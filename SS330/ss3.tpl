DATA_SECTION
!! // Stock Synthesis
!! // Developed by Richard Methot, NOAA Fisheries

!! //  SS_Label_Section_1.0 #DATA_SECTION

!! //  SS_Label_Info_1.1.1  #Create string with version info
!!version_info += "#V3.30.xx.yy;_safe;_compile_date:_";
!!version_info += __DATE__;
!!version_info += ";_Stock_Synthesis_by_Richard_Methot_(NOAA)_using_ADMB_13.2";
!!version_info2 += "#_Stock_Synthesis_is_a_work_of_the_U.S._Government_and_is_not_subject_to_copyright_protection_in_the_United_States.";
!!version_info2 += "#_Foreign_copyrights_may_apply._See_copyright.txt_for_more_information.";
!!version_info2 += "#_User_support_available_at:_https://groups.google.com/g/ss3-forum_and_NMFS.Stock.Synthesis@noaa.gov";
!!version_info2 += "#_User_info_available_at:_https://nmfs-ost.github.io/ss3-website/";
!!version_info2 += "#_Source_code_at:_https://github.com/nmfs-ost/ss3-source-code";
!!version_info2 += "";
!!#define DO_ONCE
// clang-format off
// SS_Label_file  #1. **SS_readstarter.tpl**
// SS_Label_file  #  * define many global constants, also see GLOBALS_SECTION
// SS_Label_file  #  * create list of pick_report_name values
// SS_Label_file  #  * read and process *starter.ss*
// SS_Label_file  #  * read *runnumber.ss*
// SS_Label_file  #  * read *profilevalues.ss*
// SS_Label_file  #

//*********COUNTERS*************************
  int z;  // counters for size (length)
  int z1; // min for z counter
  int z2; // max for z counter
  int L1; //  for selecting sex specific length data
  int L2; //  used for l+nlength to get length bin for males
  int A2; //  used for a+nages+1 to get true age bin for males
  int a1; // use to track a subset of ages
  int f;  // counter for fleets and surveys.  total is Ntypes
  int f1; // another fleet counter
  int fs; //  counter for fleets when looping across size and ageselex; so = f-Ntypes

  int gmorph; // number of biological entities:  gender*GP*BirthEvent*Platoon
  int g;  // counter for biological entity
  int GPat; //  counter for Gpattern (morph)
  int gg; // counter for sex
  int gp; //  counter for sex*GPat  or for Gpat
  int gp2; //  used to loop platoons within Gpattern

  int a;  // counter for ages
  int b;  // counter for age bins
  int p;  // counter for area
  int p1;
  int p2; // counter for destination area in migration
  int i;  // counter for observations
  int y;  // counter for year
  int yz; // year, but not allowed to extend past endyr
  int s;  // counter for seasons
  int s2; // destination season
  int mid_subseas; //  index of the subseas that corresponds to the middle of the season
  int subseas; //  subseas, mostly used to calc ALK_idx
  int ALK_idx; //  index to which subseas within current year to use for the ALK  ALK_idx=(s-1)*N_subseas+subseas
  int ALK_time; //  continuous index to subseas =(y-styr)*nseas*N_subseas+ALK_idx
  int ALK_idx_mid; //  index of subseason at middle of season
  int t;  // counter for time, combining year and season
  int mo; //  month (1-12), not (0-11)
  int j;
  int j1;
  int j2;
  int k;
  int k1;
  int k2;
  int k3;
  int special_flag; //  reserved for ephemeral use while developing code
  int s_off; // offset for male section of vectors
  int Fishon; // whether or not to do fishery catch in equil_calc
  int NP; // number of parameters
  int Ip; // parameter counter
  int firstseas; // used to start season loops at the birthseason
  int t_base;  //
  int niter; // iteration count
  int loop;
  int TG_t;  // time counter (in seasons) for tag groups

  int Fcast_catch_start;
//  int ParCount;
  int retParCount;
  int N_SC; // counter for starter comments
  int N_DC;
  int N_CC;
  int N_FC;

  int catch_mult_pointer;

  int frac_female_pointer;
  int finished_minimize;
  int icycle;
  int No_Report; // flag to skip output reports after MCMC and MCeval
  int mcmcFlag;
  int noest_flag;
  number temp;
  number temp1;
  int save_for_report;
  int bigsaver; // (save_for_report>0) || ((sd_phase() || mceval_phase()) && (initial_params::mc_phase==0))
  int write_bodywt;
  int write_bodywt_save;
  int save_gparm;
  int save_gparm_print;
!! save_for_report = 0;
!! bigsaver = 0;
!! write_bodywt = 0;
!! write_bodywt_save = 0;
!! special_flag = 0;

  int Nparm_on_bound;
  int on;
  int SDmode;
  int maxI;

 LOCAL_CALCS
  // clang-format on
  maxI = 999;
  on = 0;
  No_Report = 0;
  Ncycle = 3;
  z = 0;
  z1 = 0;
  z2 = 0;
  L1 = 0;
  L2 = 0;
  A2 = 0;
  a1 = 0;
  f = 0;
  f1 = 0;
  fs = 0;
  gmorph = 0;
  g = 0;
  GPat = 0;
  gg = 0;
  gp = 0;
  gp2 = 0;
  a = 0;
  b = 0;
  p = 0;
  p1 = 0;
  p2 = 0;
  i = 0;
  y = 0;
  yz = 0;
  s = 0;
  s2 = 0;
  mid_subseas = 0;
  subseas = 0;
  ALK_idx = 0;
  ALK_time = 0;
  ALK_idx_mid = 0;
  t = 0;
  mo = 0;
  j = 0;
  j1 = 0;
  j2 = 0;
  k = 0;
  k1 = 0;
  k2 = 0;
  k3 = 0;
  s_off = 0;
  Fishon = 0;
  NP = 0;
  Ip = 0;
  firstseas = 0;
  t_base = 0;
  niter = 0;
  loop = 0;
  TG_t = 0;
  Fcast_catch_start = 0;
  retParCount = 0;
  N_SC = 0;
  N_DC = 0;
  N_CC = 0;
  N_FC = 0;
  catch_mult_pointer = 0;
  frac_female_pointer = 0;
  icycle = 0;
  No_Report = 0;
  mcmcFlag = 0;
  noest_flag = 0;
  temp = 0;
  temp1 = 0;
  save_gparm_print = 0;
  finished_minimize = 0;
  // SS_Label_Info_1.1.2 #arrays for parameter labels are created in GLOBAL
  // adstring_array NumLbl;
  // adstring_array GenderLbl;   // gender label
  // adstring_array CRLF;   // blank to terminate lines

  MessageIntro += " Information: "; // information that could be useful
  MessageIntro += " Suggestion: ";  // a possible better way
  MessageIntro += " Performance: "; // can help performance
  MessageIntro += " : ";            // might be a problem, execution continues anyway
  MessageIntro += " Adjustment: ";  // adjustment has been made, execution continues
  MessageIntro += " Fatal Error! "; // major problem, program will exit

  CRLF += "";
  GenderLbl += "Fem";
  GenderLbl += "Mal";
  GP_Lbl += "_GP_1";
  GP_Lbl += "_GP_2";
  GP_Lbl += "_GP_3";
  GP_Lbl += "_GP_4";
  GP_Lbl += "_GP_5";
  GP_Lbl += "_GP_6";
  onenum = "    ";
  for (i = 1; i <= 199; i++) /* SS_loop: fill string NumLbl with numbers (start at 1) */
  {
    sprintf(onenum, "%d", i);
    NumLbl += onenum + CRLF(1);
  }
  for (i = 0; i <= 198; i++) /* SS_loop: fill string NumLbl0 with numbers (start at 0) */
  {
    sprintf(onenum, "%d", i);
    NumLbl0 += onenum + CRLF(1);
  }
  pick_report_name += "DEFINITIONS report:1";
  pick_report_use += "N";
  pick_report_name += "LIKELIHOOD report:2";
  pick_report_use += "N";
  pick_report_name += "Input_Variance_Adjustment report:3";
  pick_report_use += "N";
  pick_report_name += "Parm_devs_detail report:4";
  pick_report_use += "N";
  pick_report_name += "PARAMETERS report:5";
  pick_report_use += "N";
  pick_report_name += "DERIVED_QUANTITIES report:6";
  pick_report_use += "N";
  pick_report_name += "MGparm_By_Year_after_adjustments report:7";
  pick_report_use += "N";
  pick_report_name += "selparm(Size)_By_Year_after_adjustments report:8";
  pick_report_use += "N";
  pick_report_name += "selparm(Age)_By_Year_after_adjustments report:9";
  pick_report_use += "N";
  pick_report_name += "RECRUITMENT_DIST report:10";
  pick_report_use += "N";
  pick_report_name += "MORPH_INDEXING report:11";
  pick_report_use += "N";
  pick_report_name += "SIZEFREQ_TRANSLATION report:12";
  pick_report_use += "N";
  pick_report_name += "MOVEMENT report:13";
  pick_report_use += "N";
  pick_report_name += "EXPLOITATION report:14";
  pick_report_use += "N";
  pick_report_name += "CATCH report:15";
  pick_report_use += "N";
  pick_report_name += "TIME_SERIES report:16";
  pick_report_use += "N";
  pick_report_name += "SPR_SERIES report:17";
  pick_report_use += "N";
  pick_report_name += "Kobe_Plot report:18";
  pick_report_use += "N";
  pick_report_name += "SPAWN_RECRUIT report:19";
  pick_report_use += "N";
  pick_report_name += "SPAWN_RECR_CURVE report:20";
  pick_report_use += "N";
  pick_report_name += "INDEX_1 report:21 summary";
  pick_report_use += "N";
  pick_report_name += "INDEX_2 report:22 annual";
  pick_report_use += "N";
  pick_report_name += "INDEX_3 report:23 Qparms";
  pick_report_use += "N";
  pick_report_name += "DISCARD_SPECIFICATION report:24";
  pick_report_use += "N";
  pick_report_name += "DISCARD_OUTPUT report:25";
  pick_report_use += "N";
  pick_report_name += "MEAN_BODY_WT_OUTPUT report:26";
  pick_report_use += "N";
  pick_report_name += "FIT_LEN_COMPS report:27";
  pick_report_use += "N";
  pick_report_name += "FIT_AGE_COMPS report:28";
  pick_report_use += "N";
  pick_report_name += "FIT_SIZE_COMPS report:29";
  pick_report_use += "N";
  pick_report_name += "OVERALL_COMPS report:30";
  pick_report_use += "N";
  pick_report_name += "LEN_SELEX report:31";
  pick_report_use += "N";
  pick_report_name += "AGE_SELEX report:32";
  pick_report_use += "N";
  pick_report_name += "ENVIRONMENTAL_DATA report:33";
  pick_report_use += "N";
  pick_report_name += "TAG_Recapture report:34";
  pick_report_use += "N";
  pick_report_name += "NUMBERS_AT_AGE report:35";
  pick_report_use += "N";
  pick_report_name += "BIOMASS_AT_AGE report:36";
  pick_report_use += "N";
  pick_report_name += "NUMBERS_AT_LENGTH report:37";
  pick_report_use += "N";
  pick_report_name += "BIOMASS_AT_LENGTH report:38";
  pick_report_use += "N";
  pick_report_name += "F_AT_AGE report:39";
  pick_report_use += "N";
  pick_report_name += "CATCH_AT_AGE report:40";
  pick_report_use += "N";
  pick_report_name += "DISCARD_AT_AGE report:41";
  pick_report_use += "N";
  pick_report_name += "BIOLOGY report:42";
  pick_report_use += "N";
  pick_report_name += "Natural_Mortality report:43";
  pick_report_use += "N";
  pick_report_name += "AGE_SPECIFIC_K report:44";
  pick_report_use += "N";
  pick_report_name += "Growth_Parameters report:45";
  pick_report_use += "N";
  pick_report_name += "Seas_Effects report:46";
  pick_report_use += "N";
  pick_report_name += "Biology_at_age_in_endyr report:47";
  pick_report_use += "N";
  pick_report_name += "MEAN_BODY_WT(Begin) report:48";
  pick_report_use += "N";
  pick_report_name += "MEAN_SIZE_TIMESERIES report:49";
  pick_report_use += "N";
  pick_report_name += "AGE_LENGTH_KEY report:50";
  pick_report_use += "N";
  pick_report_name += "AGE_AGE_KEY report:51";
  pick_report_use += "N";
  pick_report_name += "COMPOSITION_DATABASE report:52";
  pick_report_use += "N";
  pick_report_name += "SELEX_database report:53";
  pick_report_use += "N";
  pick_report_name += "SPR/YPR_Profile report:54";
  pick_report_use += "N";
  pick_report_name += "GLOBAL_MSY report:55";
  pick_report_use += "N";
  pick_report_name += "SS_summary.sso report:56";
  pick_report_use += "N";
  pick_report_name += "rebuilder.sso report:57";
  pick_report_use += "N";
  pick_report_name += "SIStable.sso report:58";
  pick_report_use += "N";
  pick_report_name += "Dynamic_Bzero report:59";
  pick_report_use += "N";
  pick_report_name += "wtatage.ss_new report:60";
  pick_report_use += "N";
  pick_report_name += "ANNUAL_TIME_SERIES report:61";
  pick_report_use += "N";

  // check command line inputs

  if ((on = option_match(argc, argv, "-noest")) > -1)
  {
    warnstream << "SS3 is not configured to work with -noest; use -stopph <maxphase> instead which overrides maxphase in starter.ss";
    write_message(FATAL, 0);
  }

  if ((on = option_match(argc, argv, "-maxI")) > -1 || (on = option_match(argc, argv, "-stopph")) > -1)
  {
    // if maxI > 999, maxphase will reset to maxI
    maxI = atoi(ad_comm::argv[on + 1]);
    echoinput << "read max phase to override starter file's maxphase " << maxI << endl;
  }

  if ((on = option_match(argc, argv, "modelname")) > -1 )
  {
    base_modelname = ad_comm::argv[on + 1];
    echoinput << "read basemodel name to use instead of ss3 " << base_modelname << endl;
  cout << " base name " << base_modelname << endl;
  }

  SDmode = 1;
  if ((on = option_match(argc, argv, "-nohess")) > -1)
  {
    SDmode = 0;
  }
  echoinput << " -nohess flag (1 means do Hessian): " << SDmode << endl;
  adstring sw; //  used for reading of ADMB switches from command line
  mcmcFlag = 0;
  noest_flag = 0;
  for (i = 0; i < argc; i++) /* SS_loop: check command line arguments for mcmc commands */
  {
    sw = argv[i];
    j = strcmp(sw, "-mcmc");
    if (j == 0)
    {
      mcmcFlag = 1;
    }
    j = strcmp(sw, "-mceval");
    if (j == 0)
    {
      mcmcFlag = 1;
    }
  }
  // clang-format off

  // SS_Label_Info_1.2  #Read the starter.ss file
  // SS_Label_Flow  read starter.ss
  ad_comm::change_datafile_name("starter.ss"); //  get filenames
  cout << " reading from starter.ss" << endl;
  adstring checkchar;
  line_adstring readline;
  checkchar = "";
  ifstream Starter_Stream("starter.ss");
  //  this opens a different logical file with a separate pointer from the pointer that ADMB uses when reading using init command to read from global_datafile
  k = 0;
  N_SC = 0;
  while (k == 0)
  {
    Starter_Stream >> readline; // reads a single line from input stream
    if (length(readline) > 2)
    {
      checkchar = readline(1);
      k = strcmp(checkchar, "#");
      checkchar = readline(1, 2);
      j = strcmp(checkchar, "#C");
      if (j == 0)
      {
        N_SC++;
        Starter_Comments += readline;
      }
    }
  }
  echoinput << version_info(1) << version_info(2) << version_info(3) << endl
            << version_info2 << endl;
  warning << version_info(1) << version_info(2) << version_info(3) << endl
          << version_info2 << endl;
  warning << "This file contains warnings, suggestions and notes generated as files are read and processed" << endl
          << endl;
 END_CALCS


  init_adstring datfilename
!!echoinput << datfilename << "  datfilename" << endl;
  init_adstring ctlfilename
!!echoinput << ctlfilename << "  ctlfilename" << endl;
  init_int readparfile
!!echoinput << readparfile << "  readparfile" << endl;
  init_int rundetail
!!echoinput << rundetail << "  rundetail" << endl;
  init_int reportdetail
  int rd_background

 LOCAL_CALCS
      // clang-format on
      struct stat pathinfo;
  if (stat("./ssnew", &pathinfo) != 0)
  {
    ssnew_pathname = "";
  }
  else
  {
    ssnew_pathname = "./ssnew/";
  }

  if (stat("./sso", &pathinfo) != 0)
  {
    sso_pathname = "";
  }
  else
  {
    sso_pathname = "./sso/";
  }

  warning.open(sso_pathname + "warning.sso");
  echoinput.open(sso_pathname + "echoinput.sso");
  ParmTrace.open(sso_pathname + "ParmTrace.sso");
  report5.open(sso_pathname + "Forecast-report.sso");
  report2.open(sso_pathname + "CumReport.sso", ios::app);
  bodywtout.open(ssnew_pathname + "wtatage.ss_new");
  // clang-format off
 END_CALCS


 LOCAL_CALCS
  // clang-format on
  if (reportdetail < 0 || reportdetail > 3)
    reportdetail = 0;
  echoinput << reportdetail << "  reportdetail 0=minimal for data-limited, 1=all, 2=no growth, 3=custom" << endl;
  if (reportdetail == 3)
  {
    // -101 means to select all
    // -100 means to select data-limited
    // -102 means to select no growth or length
    // positive integer means to add that item to selected list
    // negative integer means to remove selected item from list
    // -999 means to stop reading items for the list
    ender = 0;
    do
    {
      ivector tempin(1, 1);
      *(ad_comm::global_datafile) >> tempin(1, 1);
      if (tempin(1) == -999)
        ender = 1;
      reportdetail_list.push_back(tempin(1, 1));
    } while (ender == 0);
    int Nrec = reportdetail_list.size() - 2;
    for (int j = 0; j <= Nrec; j++)
    {
      if (reportdetail_list[j](1) == -100) rd_background = 0;
      if (reportdetail_list[j](1) == -101) rd_background = 1;
      if (reportdetail_list[j](1) == -102) rd_background = 2;
    }
  }
  else
  {
    rd_background = reportdetail; // 0=limited; 2=brief; 1=all
  }

  // set background set of picked reports; then set custom if reportdetail==3
  for (k = 1; k <= 60; k++)
  {
    pick_report_use(k) = "N"; // all off
  }
  if (rd_background == 0) // limited
  {
    pick_report_use(1) = "Y";
    pick_report_use(2) = "Y";
    pick_report_use(5) = "Y";
    pick_report_use(6) = "Y";
    pick_report_use(14) = "Y";
    pick_report_use(15) = "Y";
    pick_report_use(16) = "Y";
    pick_report_use(61) = "Y";
  }
  else if (rd_background == 2) // brief, no growth or length
  {
    for (k = 1; k <= 61; k++)
    {
      pick_report_use(k) = "Y"; // start with all on
    }
    pick_report_use(7) = "N";
    pick_report_use(8) = "N";
    pick_report_use(11) = "N";
    pick_report_use(12) = "N";
    pick_report_use(13) = "Y";
    pick_report_use(17) = "N";
    pick_report_use(18) = "N";
    pick_report_use(24) = "N";
    pick_report_use(25) = "N";
    pick_report_use(26) = "N";
    pick_report_use(27) = "N";
    pick_report_use(29) = "N";
    pick_report_use(31) = "N";
    pick_report_use(33) = "N";
    pick_report_use(34) = "N";
    pick_report_use(37) = "N";
    pick_report_use(38) = "N";
    pick_report_use(44) = "N";
    pick_report_use(45) = "N";
    pick_report_use(46) = "N";
    pick_report_use(47) = "N";
    pick_report_use(48) = "N";
    pick_report_use(49) = "N";
    pick_report_use(50) = "N";
    pick_report_use(53) = "N";
    pick_report_use(55) = "N";
    pick_report_use(57) = "N";
    pick_report_use(58) = "N";
    pick_report_use(59) = "N";
  }
  else // all on
  {
    for (k = 1; k <= 61; k++)
    {
      pick_report_use(k) = "Y";
    }
  }
  if (reportdetail == 3)
  {
    for (unsigned j = 0; j <= reportdetail_list.size() - 2; j++)
    {
      if (reportdetail_list[j](1) > 0 && reportdetail_list[j](1) <= 60)
      {
        pick_report_use(reportdetail_list[j](1)) = "Y";
      }
      else if (reportdetail_list[j](1) >= -60)
      {
        pick_report_use(-reportdetail_list[j](1)) = "N";
      }
      else if (reportdetail_list[j](1) > -100)
      {
        warnstream << "custom report number: " << reportdetail_list[j](1) << " is out of range and ignored";
        write_message(WARN, 0);
      }
    }
  }

  for (k = 1; k <= 60; k++)
    echoinput << k << " " << pick_report_use(k) << " " << pick_report_name(k) << endl;
  // clang-format off
 END_CALCS

  init_int docheckup;           // flag for ending dump to "checkup.SS"
!!echoinput<<docheckup<<"  docheckup"<<endl;
  init_int Do_ParmTrace;
!!echoinput<<Do_ParmTrace<<"  Do_ParmTrace"<<endl;
  init_int Do_CumReport;
!!echoinput<<Do_CumReport<<"  Do_CumReport"<<endl;
  init_int Do_all_priors;
!!echoinput<<Do_all_priors<<"  Do_all_priors"<<endl;
  int prior_ignore_warning;
!!prior_ignore_warning=0;
  init_int SoftBound;
!!echoinput<<SoftBound<<"  SoftBound"<<endl;
  init_int N_nudata_read;
  int N_nudata;
!! N_nudata=N_nudata_read;
!!echoinput<<N_nudata<<"  N_nudata"<<endl;
  int Turn_off_phase;
  init_int Turn_off_phase_rd;
   !!echoinput<<Turn_off_phase_rd<<"  Turn_off_phase"<<endl;
   !!if(maxI<999) { Turn_off_phase=maxI; echoinput<<"-stopph resets it to: "<<Turn_off_phase<<endl;} else {Turn_off_phase=Turn_off_phase_rd;}

// read in burn and thinning intervals
  init_int burn_intvl;
!!echoinput<<burn_intvl<<"  MCeval burn_intvl"<<endl;
  init_int thin_intvl;
!!echoinput<<thin_intvl<<"  MCeval thin_intvl"<<endl;

  init_number jitter;
!!echoinput<<jitter<<"  jitter fraction for initial parm values"<<endl;

  int STD_Yr_min;
  int STD_Yr_max;
  init_int STD_Yr_min_rd; // min yr for sdreport
!!echoinput<<STD_Yr_min_rd<<"  STD_Yr_min"<<endl;
!!STD_Yr_min=STD_Yr_min_rd;
  init_int STD_Yr_max_rd; // max yr for sdreport
!!echoinput<<STD_Yr_max_rd<<"  STD_Yr_max (-1 for endyr; -2 for YrMax)"<<endl;
  init_int N_STD_Yr_RD ; // N extra years to read
!!echoinput<<N_STD_Yr_RD<<"  N extra STD years to read"<<endl;
!!STD_Yr_max=STD_Yr_max_rd;
  int N_STD_Yr;
  init_ivector STD_Yr_RD(1,N_STD_Yr_RD);
!!if(N_STD_Yr_RD>0) echoinput<<STD_Yr_RD<<"  vector of extra STD years"<<endl;
  // wait to process the above until after styr, endyr, N-forecast_yrs are read in data and forecast sections below

// set up the mcmc chain counter
  int mceval_counter;
  int mceval_header;
!! mceval_counter = 0;
!! mceval_header = 0;
  int mcmc_counter;
!! mcmc_counter = 0;
  int done_run;
!! done_run=0;

// set up the convergence criteria
  vector func_eval(1,50);
  vector func_conv(1,50);
//  number final_conv;
  init_number final_conv;
!!echoinput<<final_conv<<"  final_conv"<<endl;

!! func_eval.fill_seqadd(100,0);
!! func_conv.fill_seqadd(1,0);
!! func_conv(1)=10.;
!! func_conv(2)=10.;

  init_int retro_yr;             //  introduce year for retrospective analysis
!!echoinput << retro_yr << "  retro_yr" << endl;
  int fishery_on_off;
!! fishery_on_off = 1;

  init_int Smry_Age;
!!echoinput << Smry_Age << "  Smry_Age" << endl;
  int depletion_basis;
  int depletion_multi;
  int depletion_log;
  init_number depletion_basis_rd; // 0=skip; 1=B0; 2=Bmsy; 3=B_styr; 4=B_endyr; 5=dynamic_Bzero; 6=Bmark_SSB_unf;  values >=11 invoke multiyr with 10's digit; append .1 to invoke log(ratio) with hundreds digit
 LOCAL_CALCS
  // clang-format on
  echoinput << depletion_basis_rd << "  depletion_basis as read; this is also known as Bratio and is a std quantity; has multi-yr and log(ratio) options" << endl;
  depletion_multi = 0;
  depletion_log = 0;
  depletion_basis = int( depletion_basis_rd ); // discard decimal
  k = depletion_basis;

  if (depletion_basis_rd > float( depletion_basis) ) // invokes log(ratio) if decimal value exists
  {
    depletion_log = 1;
  }

  if (k > 10) //  invokes multiyr
  {
    depletion_multi = int(k / 10);
    depletion_basis = k - 10 * depletion_multi;
  }

  echoinput << "Parse into: depletion_log(ratio): " << depletion_log << " depletion_multi-yr: " << depletion_multi << " depletion_basis: " << depletion_basis << endl;
  // clang-format off
 END_CALCS

  init_number depletion_level;
!!echoinput << depletion_level << "  depletion_level" << endl;
  init_int SPR_reporting; // 0=skip; 1=SPR; 2=SPR_MSY; 3=SPR_Btarget; 4=(1-SPR); 5=SPR
!!echoinput << SPR_reporting << "  SPR_reporting" << endl;
  init_int F_reporting; // 0=skip; 1=exploit(Bio); 2=exploit(Num); 3=sum(frates); 4=true F for range of ages; 5=unweighted avg F for range of ages
 LOCAL_CALCS
  // clang-format on
  echoinput << F_reporting << "  F_reporting quantity, e.g. 3=sum(apical Fs)" << endl;
  if (F_reporting == 4 || F_reporting == 5) {
    k = 2;
  }
  else
  {
    k = 0;
  }
  // clang-format off
 END_CALCS
  init_ivector F_reporting_ages_R(1,k);
  //  convert to F_reporting_ages later after nages is read.
 LOCAL_CALCS
  // clang-format on
  if (k > 0)
  {
    echoinput << F_reporting_ages_R << "  F_reporting_ages_R" << endl;
    echoinput << "Will be checked against maxage later " << endl;
  }
  // clang-format off
 END_CALCS

  init_number F_std_basis_rd; // 0=raw; 1=rel Fspr; 2=rel Fmsy ; 3=rel Fbtgt; values >=11 invoke multiyr with 10's digit; >=100 invoke log(ratio) with hundreds digit
  number finish_starter;
  int mcmc_output_detail;
  number MCMC_bump; // value read and added to ln(R0) when starting into MCMC
  number ALK_tolerance;
  number tempin;
  int ender;
  int irand_seed;
  int irand_seed_rd;
  int timevary_bio_4SRR;  // flag in 3.30.24 for impact of timevary biology on benchmark SRR calculations
  int timevary_bio_4SRR_rd;  // flag in 3.30.24 for impact of timevary biology on benchmark SRR calculations
  int F_std_multi; // for multi-year averaging of F_std
  int F_std_log; // for log(ratio) of F_std
  int F_std_basis;

 LOCAL_CALCS
  // clang-format on
  {
    F_std_multi = 0;
    F_std_log = 0;
    echoinput << F_std_basis_rd << "  F_std basis as read" << endl;
    F_std_basis = int(F_std_basis_rd);  // discards the decimal
    k = F_std_basis;  // temp value

    if (F_std_basis_rd > float( F_std_basis) ) // invokes log(ratio) if decimal value exists
    {
      F_std_log = 1;
    }

    if (k > 10) //  invokes multiyr
    {
      F_std_multi = int(k / 10);
      F_std_basis = k - 10 * F_std_multi;
    }

    echoinput << "Parse into: F_std_log(ratio): " << F_std_log << " F_std_multi: " << F_std_multi << " F_std_basis: " << F_std_basis << endl;
    if (F_std_multi > 1)
    {
      warnstream << "new feature for multiyr F_std reporting, be sure STD reporting covers all years from styr to endyr";
      write_message(NOTE, 0);
    }
    echoinput << "For Kobe plot, set depletion_basis=2; depletion_level=1.0; F_reporting=your choice; F_std_basis=2" << endl;

    mcmc_output_detail = 0;
    MCMC_bump = 0.;
    ALK_tolerance = 0.0;
    irand_seed_rd = -1;
    irand_seed = -1;
    ender = 0;
    //embed following reads in a do-while such that additional reads can be added while retaining backward compatibility with files that do not have the added elements
    //  element list:
    //  1.  MCMC_output_detail.MCMC_bump
    //  2.  ALK_tolerance
    //  3.  irand_seed;  added for 3.30.15
    //  xx.  finish_starter
    do
    {
      *(ad_comm::global_datafile) >> tempin;
      finish_starter = tempin;
      if (tempin == 3.30 || tempin == 999)
        ender = 1;

      if (tempin == 999.) // finish read in 3.24 format for ss_trans
      {
        echoinput << "SS read 999 from starter.ss, so will read files in 3.24 format" << endl
                  << endl;
        if (readparfile > 0)
        {
          warnstream << " ss_trans does not read the PAR file; readparfile set to 0" << endl;
          write_message(WARN, 0);
          readparfile = 0;
        }
      }
      else // reading in 3.30 format
      {
        finish_starter = 3.30;
        echoinput << "Read files in 3.30 format" << endl;
        echoinput << "SS will continue reading from starter.ss until it reads 3.30" << endl;

        echoinput << "read MCMC_output_detail.MCMC_bump as a single real number;  separate values will be parsed from integer and fraction" << endl;
        mcmc_output_detail = int(tempin);
        MCMC_bump = tempin - mcmc_output_detail;
        if (mcmc_output_detail < 0 || mcmc_output_detail > 2)
          mcmc_output_detail = 0;
        echoinput << "MCMC output detail(1=more_detail_to_posts; 2=write_report_for_each_mceval):  " << mcmc_output_detail << endl;
        echoinput << "MCMC bump to R0:  " << MCMC_bump << endl;

        echoinput << "Now read ALK tolerance which is deprecated. If not 0, it will be reset to 0." << endl;
        *(ad_comm::global_datafile) >> ALK_tolerance;
        if (ALK_tolerance > 0.0 || ALK_tolerance < 0.0)
        {
          warnstream << "ALK tolerance is now deprecated and is set to 0" ;
          write_message(ADJUST, 1);
          ALK_tolerance = 0;
        }
        echoinput << "ALK tolerance:  " << ALK_tolerance << endl;

        echoinput << "Now get random number seed; enter -1 to use long(time) as the seed" << endl;
        *(ad_comm::global_datafile) >> tempin;
        if (tempin == 3.30)
        {
          ender = 1;
          irand_seed_rd = -1;
          irand_seed = -1;
        }
        else
        {
          irand_seed_rd = int(tempin);
          irand_seed = irand_seed_rd;
          echoinput << "random number seed:  " << irand_seed << endl;
          tempin = 0;
        }

        echoinput << "now read flag for dealing with impact of time-varying biology on benchmark SRR calculations" << endl;
        timevary_bio_4SRR = 0;
        timevary_bio_4SRR_rd = -1;
        *(ad_comm::global_datafile) >> tempin;
        if (tempin == 3.30)  // starter file does not contain the new line for timevary_bio_4SRR, so assign default
        {
          ender = 1;
          timevary_bio_4SRR = 0;
        }
        else  // new input line beginning 3.30.24
        {
          timevary_bio_4SRR = int(tempin);
          timevary_bio_4SRR_rd = 0;  //  indicates that line was read
          echoinput << "Compatibility flag for legacy (0) vs improved (1) impact of timevary biology on benchmark SRR calcs:  " << timevary_bio_4SRR << endl;
          tempin = 0;
        }

        if (ender == 0)
        {
          *(ad_comm::global_datafile) >> tempin;
          if (tempin == 3.30)
          {
            ender = 1;
          }
          else
          {
            echoinput << endl
                      << "starter.ss should have read 3.30 here; it read: " << tempin << endl;
            warnstream << "starter.ss has extra input lines; check echoinput to verify read";
            write_message(FATAL, 0);
          }
        }
      }
    } while (ender == 0);
    echoinput << "  finish reading starter.ss" << endl
              << endl;
  }
  // clang-format off
 END_CALCS

  //  end reading  from Starter file

  number pi
!! pi = 3.14159265358979;

  number neglog19
!! neglog19 = -log(19.);

  number NilNumbers           //  used as the minimum for posfun and similar checks
!! NilNumbers = 0.0000001;
// !!   NilNumbers = 0.000;

!!//  SS_Label_Info_1.2.1 #Set up a dummy datum for use when max phase = 0
  number dummy_datum;
  int dummy_phase;
!! dummy_datum = 1.;
!! if (Turn_off_phase <= 0) {dummy_phase = 0;} else {dummy_phase = -6;}

  int runnumber;
  int N_prof_var;
  int prof_var_cnt;
  int prof_junk;

 LOCAL_CALCS
  // clang-format on
  // SS_Label_Info_1.3 #Read runnumber.ss
  ifstream fin1("runnumber.ss", ios::in);
  if (fin1)
  {
    fin1 >> runnumber;
    runnumber++;
    fin1.close();
  }
  else
  {
    runnumber = 1;
  }
  // SS_Label_Info_1.3.1 #Increment runnumber and write to file
  ofstream fin2("runnumber.ss", ios::out);
  fin2 << runnumber;
  fin2.close();

  // SS_Label_Info_1.4 #Read Profilevalues.ss file
  N_prof_var = 998;
  ifstream fin3("profilevalues.ss", ios::in);
  fin3 >> N_prof_var; // if file is null this will not return anything
  if (N_prof_var == 998)
  {
    N_prof_var = 0;
    prof_junk = 0;
  }
  else
  {
    prof_junk = 1;
  }
  fin3.close();
  if (N_prof_var > 0)
  {
    ad_comm::change_datafile_name("profilevalues.ss");
  }
  else // just to have something in scope
  {
    ad_comm::change_datafile_name("runnumber.ss");
  }
  prof_var_cnt = (runnumber - 1) * N_prof_var + 2;
  // clang-format off
 END_CALCS
  init_vector prof_var(1,prof_junk+runnumber*N_prof_var);
// SS_Label_file  #3. **SS_readdata.tpl**
// SS_Label_file  # * read *data_file* named in starter.ss
// SS_Label_file  #     * create arrays for data with dimensioning defined dynamically
// SS_Label_file  #     * creates link from each data element to area/time/fleet that datum occur, and other arrays with specification of which data types occur in each area/time
// SS_Label_file  #     * uses function found in SS_global:  <u>get_data_timing()</u>
// SS_Label_file  # * read *forecast.ss*
// SS_Label_file  #     * note that this extends the time dimension of some arrays, so is read before readcontrol

//  SS_Label_Flow  read data file named in starter.ss file
//  SS_Label_Info_2.0 #READ DATA FILE
//  SS_Label_Info_2.1 #Read comments and dimension info
//  SS_Label_Info_2.1.1 #Read and save comments at top of data file
  number fif //  end of file marker

 LOCAL_CALCS
  // clang-format on
  //
  ad_comm::change_datafile_name(datfilename);

  if (finish_starter == 999)
  {
    warnstream << "finish_starter=999, so probably used a 3.24 starter.ss; please update";
    write_message(WARN, 0);
    finish_starter = 3.30;
  }
  cout << " reading from data file" << endl;
  ifstream Data_Stream(datfilename); // even if the global_datafile name is used, there still is a different logical device created
  k = 0;
  N_DC = 0;
  while (k == 0)
  {
    Data_Stream >> readline; // reads the line from input stream
    if (length(readline) > 2)
    {
      checkchar = readline(1);
      k = strcmp(checkchar, "#");
      checkchar = readline(1, 2);
      j = strcmp(checkchar, "#C");
      if (j == 0)
      {
        N_DC++;
        Data_Comments += readline;
      }
    }
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_2.1.2 #Read model time dimensions
  int read_seas_mo;    //  1=read integer season; 2=read real months
 LOCAL_CALCS
  // clang-format on
  read_seas_mo = 2;
  // clang-format off
 END_CALCS


  int N_subseas;  //  number of subseasons within season; must be even number to get one to be mid_season
  ivector timing_constants(1,6);
 LOCAL_CALCS
  // clang-format on
  *(ad_comm::global_datafile) >> styr; //start year of the model
  echoinput << styr << " start year " << endl;

  *(ad_comm::global_datafile) >> endyr; // end year of the model
  echoinput << endyr << " end year " << endl;

  *(ad_comm::global_datafile) >> nseas; //  number of seasons
  echoinput << nseas << " N seasons " << endl;
  // clang-format off
 END_CALCS
  init_vector seasdur(1,nseas);  // season duration; enter in units of months, fractions OK; will be rescaled to sum to 1.0 if total is greater than 11.9

 LOCAL_CALCS
  // clang-format on
  echoinput << seasdur << " months/seas (fractions OK) " << endl;
  *(ad_comm::global_datafile) >> N_subseas;
  echoinput << N_subseas << " Number of subseasons (even number only; min 2) for calculation of ALK " << endl;
  mid_subseas = N_subseas / 2 + 1;
  timing_constants(1) = read_seas_mo;
  timing_constants(2) = nseas;
  timing_constants(3) = N_subseas;
  timing_constants(4) = mid_subseas;
  timing_constants(5) = styr;
  timing_constants(6) = endyr;
  // clang-format off
 END_CALCS

  int TimeMax;
  int TimeMax_Fcast_std;
  int ALK_time_max;
  int eq_yr;
  int bio_yr;
  number sumseas;

  //  SS_Label_Info_2.1.3 #Set up seasons
  vector seasdur_half(1,nseas);   // half a season
  matrix subseasdur(1,nseas,1,N_subseas);   // cumulative time, within season, for each subseas
  vector subseasdur_delta(1,nseas);  //  length of each subseason
  vector azero_seas(1,nseas);   // cumulative time, within year, up until begin of this season

 LOCAL_CALCS
  // clang-format on
  sumseas = sum(seasdur);
  if (sumseas >= 11.9)
  {
    seasdur /= sumseas;
    seas_as_year = 0;
    sumseas = 12.0; // to be sure it is exactly 12.
  }
  else
  {
    seasdur /= 12.;
    seas_as_year = 1;
    // sumseas will now be used as the duration of the pseudo-year, rather than assuming year has 12 months;
    if (nseas > 1)
    {
      warnstream << "Error.  Can only have 1 season when during seasons as psuedo-years.";
      write_message (FATAL, 0);
    }
  }
  seasdur_half = seasdur * 0.5; // half a season
  subseasdur_delta = seasdur / double(N_subseas);
  TimeMax = styr + (endyr + 50 - styr) * nseas + nseas - 1;
  retro_yr = endyr + retro_yr;
  ALK_time_max = (endyr - styr + 51) * nseas * N_subseas; // sets maximum size for data array indexing 50 years into forecast
  //  ALK_time_max will be redefined after reading forecast's YrMax to accomodate forecasts longer than the 50 year data limit

  azero_seas(1) = 0.;
  if (nseas > 1)
  {
    for (s = 2; s <= nseas; s++) /* SS_loop: calculate azero_seas from cumulative sum of seasdur(s) */
    {
      azero_seas(s) = sum(seasdur(1, s - 1));
    }
  }
  subseasdur.initialize();
  for (s = 1; s <= nseas; s++) /* SS_loop: for each season */
  {
    for (subseas = 2; subseas <= N_subseas; subseas++) /* SS_loop: calculate cumulative time within season to start of each subseas */
    {
      subseasdur(s, subseas) = subseasdur(s, subseas - 1) + seasdur(s) / double(N_subseas);
    }
  }
  echoinput << seasdur << " processed season duration (frac. of year) " << endl;
  echoinput << subseasdur_delta << " processed subseason duration (frac. of year) " << endl;
  echoinput << " processed subseason cumulative annual time within season " << endl
            << subseasdur << endl;
  if (seas_as_year == 1)
  {
    warnstream << "Season durations sum to <11.9, so SS3 assumes you are doing years as pseudo-seasons." << endl
               << "There can be only 1 season in this timestep and SS3 will ignore month input and assume all observation occur at middle of this pseudo-year" << endl
               << "mortality, growth and movement rates are per annum, so will get multiplied by the duration of this timestep as they are used." << endl
               << "What gets reported as age is now age in timesteps; and input of age-specific M or K requires one entry per timestep" << endl
               << "Similarly, output of age-specific quantities is in terms of number of timesteps, not real years" << endl
               << "spawn_month and settlement_month in control file are best set to 1.0 when doing years as pseudo-seasons" << endl;
    write_message(WARN, 1);
  }
  // clang-format off
 END_CALCS

//  SPAWN-RECR:   define spawning season
  init_number spawn_rd;
   number spawn_month;  //  month that spawning occurs
   int spawn_seas;    //  spawning occurs in this season
   int spawn_subseas;  //
   number spawn_time_seas;  //  real time within season for mortality calculation
 LOCAL_CALCS
  // clang-format on
  if (read_seas_mo == 1) //  so reading values of integer season
  {
    spawn_seas = spawn_rd;
    spawn_month = 1.0 + azero_seas(spawn_seas) / sumseas;
    spawn_subseas = 1;
    spawn_time_seas = 0.0;
  }
  else //  reading values of month
  {
    spawn_month = spawn_rd;
    temp1 = (spawn_month - 1.0) / sumseas; //  spawn_month as fraction of year
    if (spawn_month >= 13.0)
    {
      warnstream << "Fatal error. spawn_month must be <13.0, end of year is 12.99, value read is: " << spawn_month;
      write_message (FATAL, 0);
    }
    spawn_seas = 1; // earlist possible spawn_seas;
    spawn_subseas = 1; //  earliest possible subseas in spawn_seas
    temp = azero_seas(spawn_seas) + subseasdur_delta(spawn_seas); //  starting value
    while (temp <= temp1 + 1.0e-9)
    {
      if (spawn_subseas == N_subseas)
      {
        spawn_seas++;
        spawn_subseas = 1;
      }
      else
      {
        spawn_subseas++;
      }
      temp += subseasdur_delta(spawn_seas);
    }
//    spawn_time_seas = (temp1 - azero_seas(spawn_seas)) / seasdur(spawn_seas); //  incorrect:   remaining fraction of year converted to fraction of season
    spawn_time_seas = (temp1 - azero_seas(spawn_seas)); //  timing in units of fraction of year such that exp(-Z*spawn_time_seas) will be correct
  }
  echoinput << "SPAWN month: " << spawn_month << "; seas: " << spawn_seas << "; subseas_for_ALK: " << spawn_subseas << "; spawntiming as frac. of year: " << spawn_time_seas << endl;
  if (spawn_seas > nseas)
  {
    warnstream << " spawn_seas index must be <= nseas ";
    write_message(WARN, 0);
  }
  // clang-format off
 END_CALCS
  int pop;     // number of areas
  int gender_rd;
  int gender;  //  number of sexes
  int nages;   //  maxage as accumulator
  int nages2;  //  doubled vector to store males after females = gender*nages+gender-1
  int Nsurvey;
  int Nfleet;
  int Nfleet1; // used with 3.24 for number of fishing fleets

 LOCAL_CALCS
  // clang-format on
  {
    *(ad_comm::global_datafile) >> gender_rd;
    gender = abs(gender_rd);
    if (gender_rd < 0)
      echoinput << "gender read is negative, so total spawnbiomass will be multiplied by frac_female parameter" << endl;
    *(ad_comm::global_datafile) >> nages;
    echoinput << gender << " N sexes " << endl
              << "Accumulator age " << nages << endl;
    *(ad_comm::global_datafile) >> pop;
    echoinput << pop << " N_areas " << endl;
    *(ad_comm::global_datafile) >> Nfleet;
    Nfleet1 = 0;
    Nsurvey = 0;
    nages2 = gender * nages + gender - 1;
    echoinput << Nfleet << " total number of fishing fleets and surveys " << endl;

  //  define some useful labels
    MGtype_Lbl += "natmort";
    MGtype_Lbl += "growth";
    MGtype_Lbl += "wtlen";
    MGtype_Lbl += "recr_dist";
    MGtype_Lbl += "migration";
    MGtype_Lbl += "ageerror";
    MGtype_Lbl += "catchmult";
    MGtype_Lbl += "hermaphro";
    MGtype_Lbl += "null9";
    MGtype_Lbl += "selectivity";
    MGtype_Lbl += "rel_F";
    MGtype_Lbl += "recruitment";
    echoinput << "MGtype labels: "<< MGtype_Lbl << endl;
  }
  // clang-format off
 END_CALCS

//  SS_Label_Info_2.1.5  #Define fleets, surveys, predators and areas
  imatrix pfleetname(1,Nfleet,1,2);
  ivector fleet_type(1,Nfleet);   // 1=fleet with catch; 2=discard only fleet with F; 3=survey(ignore catch); 4=M2=predator
  int N_bycatch;  //  number of bycatch only fleets
  int N_pred;  //  number of predator fleets
  ivector N_catchfleets(0,pop); //  number of bycatch plus landed catch fleets by area
  imatrix fish_fleet_area(0,pop,0,Nfleet);   // list of catch_fleets that are type 1 or 2, so have a F
  ivector predator(1,Nfleet);   // list of "fleets" that are type 4
  ivector predator_rev(1,Nfleet);   // predator ID given f
  imatrix predator_area(0,pop,0,Nfleet);   // list of predators by area
  ivector need_catch_mult(1,Nfleet);  // 0=no, 1=need catch_multiplier parameter
  vector surveytime(1,Nfleet);   // (-1, 1) code for fisheries to indicate use of season-wide observations, or specifically timed observations
  ivector fleet_area(1,Nfleet);    // areas in which each fleet/survey/predator operates
  vector catchunits1(1,Nfleet);  // 1=biomass; 2=numbers
//  vector catch_se_rd1(1,Nfleet)  // units are se of log(catch); use -1 to ignore input catch values for discard only fleets
  vector catchunits(1,Nfleet);
//  vector catch_se_rd(1,Nfleet)
  matrix catch_se(styr-nseas,TimeMax,1,Nfleet);
  matrix fleet_setup(1,Nfleet,1,5);  // type, timing, area, units, need_catch_mult
  matrix bycatch_setup(1,Nfleet,1,6);
    // 1:  fleet number; must match fleet definitions"<<endl;
    // 2:  1=include dead bycatch in total dead catch for F0.1 and MSY optimizations and forecast ABC; 2=omit from total catch for these purposes (but still include the mortality)"<<endl;
    // 3:  1=Fmult scales with other fleets; 2=bycatch F constant at input value; 3=mean bycatch F from range of years"<<endl;
    // 4:  F or first year of range"<<endl;
    // 5:  last year of range"<<endl;
    // 6:  not used"<<endl;

  ivector YPR_mask(1,Nfleet);
  ivector retParmLoc(1,1);
  int N_retParm;

 LOCAL_CALCS
  // clang-format on
  bycatch_setup.initialize();
  YPR_mask.initialize();
  catch_se = 0.01; //  initialize to a small value
  {
    N_bycatch = 0;
    N_catchfleets.initialize();
    fish_fleet_area.initialize();
    predator_area.initialize();
    N_pred = 0;
    predator.initialize();
    echoinput << "rows are fleets; columns are: Fleet_#, fleet_type, timing, area, units, need_catch_mult" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      *(ad_comm::global_datafile) >> fleet_setup(f)(1, 5);
      *(ad_comm::global_datafile) >> anystring;
      fleetname += anystring;
      fleet_type(f) = int(fleet_setup(f, 1));
      if (fleet_type(f) == 2)
        N_bycatch++;
      surveytime(f) = fleet_setup(f, 2) / fabs(fleet_setup(f, 2));
      fleet_setup(f, 2) = surveytime(f);
      p = int(fleet_setup(f, 3)); //area
      fleet_area(f) = p;
      catchunits(f) = int(fleet_setup(f, 4));
      need_catch_mult(f) = int(fleet_setup(f, 5));
      if (fleet_type(f) <= 2)
      {
        N_catchfleets(0)++; // overall N
        N_catchfleets(p)++; // count by area
        fish_fleet_area(0, N_catchfleets(0)) = f; // to find the "f" index for a catchfleet when not within an area loop
        fish_fleet_area(p, N_catchfleets(p)) = f; // to find the index when in an area loop
     
        YPR_mask(f) = 1;
        if (surveytime(f) != -1.)
        {
          warnstream << "fishing fleet: " << f << " surveytime read as: " << surveytime(f) << " normally is -1 for fishing fleet; can override for indiv. obs. using 1000+month";
          write_message(WARN, 0);
        }
      }
      else if (fleet_type(f) == 3)
      {
        if (surveytime(f) == -1.)
        {
          warnstream << "survey fleet: " << f << " surveytime read as: " << surveytime(f) << " SS3 resets to 1 for all survey fleets, and always overridden by indiv. obs. month";
          write_message (FATAL, 0);
          surveytime(f) = 1.;
        }
      }
      else if (fleet_type(f) == 4) //  predator, e.g. red tide
      {
        N_pred++;
        predator(N_pred) = f;
        predator_rev(f) = N_pred;
        predator_area(0, N_pred) = f; // to find the "f" index for a predator when not within an area loop
        predator_area(p, N_pred) = f; //  to find the index when in an area loop
        surveytime(f) = -1.;
      }
      if (fleet_type(f) > 1 && need_catch_mult(f) > 0)
      {
        warnstream << "Need_catch_mult can be used only for fleet_type=1 fleet= " << f;
        write_message (FATAL, 0);
      }
      echoinput << f << " # " << fleet_setup(f) << " # " << fleetname(f) << endl;
      if (f > 1) { // check for duplicate fleet names, which will break r4ss
        for (int f1 = 1; f1 < f; f1++)
        {
          if (fleetname(f1) == fleetname(f))
          {
            warnstream << "duplicate fleet names for fleets: " << f1 << " and " << f << "; " << fleetname(f) << "; SS3 will exit";
            write_message (FATAL, 0);
          }
        }
      }
    }

    if (N_bycatch > 0)
    {
      echoinput << "Now read bycatch fleet characteristics for " << N_bycatch << " fleets" << endl;
      echoinput << "1:  fleet number; must match fleet definitions" << endl;
      echoinput << "2:  1=include dead bycatch in total dead catch for F0.1 and MSY optimizations and forecast ABC; 2=omit from total catch for these purposes (but still include the mortality)" << endl;
      echoinput << "3:  1=Fmult scales with other fleets; 2=bycatch F constant at input value; 3=mean bycatch F from range of years" << endl;
      echoinput << "4:  F or first year of range" << endl;
      echoinput << "5:  last year of range" << endl;
      echoinput << "6:  not used" << endl;
      for (j = 1; j <= N_bycatch; j++)
      {
        *(ad_comm::global_datafile) >> f;
        bycatch_setup(f, 1) = f;
        *(ad_comm::global_datafile) >> bycatch_setup(f)(2, 6);
        if (fleet_type(f) == 2)
        {
          echoinput << f << " " << fleetname(f) << " bycatch_setup: " << bycatch_setup(f) << endl;
          if (bycatch_setup(f, 2) == 2) //  omit bycatch fleet catch from YPR optimize
          {
            YPR_mask(f) = 0;
          }
          if (bycatch_setup(f, 3) == 3) //  check year range
          {
            if (bycatch_setup(f, 4) < styr)
              bycatch_setup(f, 4) = styr;
            if (bycatch_setup(f, 5) > retro_yr)
              bycatch_setup(f, 5) = retro_yr;
          }
        }
        else
        {
          warnstream << "fleet " << f << " is in bycatch list but not designated as bycatch fleet";
          write_message (FATAL, 0);
        }
      }
    }
    echoinput << "YPR_optimize_mask: " << YPR_mask << endl;
    Nfleet1 = N_catchfleets(0);
    N_retParm = 0;
  }
  // clang-format off
 END_CALCS

//  ProgLabel_2.1.5  define genders and max age

  ivector age_vector(0,nages);
  vector  r_ages(0,nages);
  vector  frac_ages(0,nages);
  ivector years(styr,endyr); // vector of the years of the model
  vector  r_years(styr,endyr);
  ivector ALK_subseas_update(1,nseas*N_subseas);  //  0 means ALK is OK for this subseas, 1 means that recalc is needed

  ivector F_reporting_ages(1,2);

 LOCAL_CALCS
  // clang-format on
  for (a = 0; a <= nages; a++) // SS_loop: fill ivector age vector
    age_vector(a) = a;
  for (a = 0; a <= nages; a++) // SS_loop: fill real vector r_ages
    r_ages(a) = double(a);
  frac_ages = r_ages / r_ages(nages);
  for (y = styr; y <= endyr; y++)
  { //year vector
    years(y) = y;
    r_years(y) = y;
  }
  if (F_reporting == 4 || F_reporting == 5)
  {
    F_reporting_ages = F_reporting_ages_R;
    if (F_reporting_ages(1) > (nages - 2) || F_reporting_ages(1) < 0)
    {
      warnstream << "reset lower end of F_reporting_ages to be nages-2  ";
      write_message(ADJUST, 0);
      F_reporting_ages(1) = nages - 2;
    }
    if (F_reporting_ages(2) > (nages - 2) || F_reporting_ages(2) < 0)
    {
      warnstream << "reset upper end of F_reporting_ages to be nages-2  ";
      write_message(ADJUST, 0);
      F_reporting_ages(2) = nages - 2;
    }
  }
  else
  {
    F_reporting_ages(1) = nages / 2;
    F_reporting_ages(2) = F_reporting_ages(1);
  }
  // clang-format off
 END_CALCS

//  SS_Label_Info_2.1.6  #Indexes for data timing.  "have_data" and "data_time" hold pointers for data occurrence, timing, and ALK need
  int data_type;
  number data_timing;
  4iarray have_data(1,ALK_time_max,0,Nfleet,0,9,0,150);
  imatrix have_data_yr(styr,endyr+50,0,Nfleet);

//  have_data stores the data index of each datum occurring at time ALK_time, for fleet f of observation type k.  Up to 150 data are allowed due to CAAL data
//  have_data(ALK_idx,0,0,0) is overall indicator that some datum requires ALK update in this ALK_time
//  have_data() 3rd element:  0=any; 1=survey/CPUE/effort; 2=discard; 3=mnwt; 4=length; 5=age; 6=SizeFreq; 7=sizeage; 8=morphcomp; 9=tags
//  have_data() 4th element;  zero'th element contains N obs for this subseas; allows for 150 observations per datatype per fleet per subseason

  3darray data_time(1,ALK_time_max,1,Nfleet,1,3);
//  data_time():  first value will hold real month; 2nd is timing within season; 3rd is year.fraction
//  for a given fleet x subseas, all observations must have the same specific timing (month.fraction)
//  a warning will be given if subsequent observations have a different month.fraction
//  an observation's real_month is used to assign it to a season and a subseas within that seas, and it is used to calculate the data_timing within the season for mortality

//  where ALK_idx=(y-styr)*nseas*N_subseas+(s-1)*N_subseas+subseas   This is index to subseas and used to indicate which ALK is being referenced

//  ProgLabel_2.2  Read CATCH amount by fleet
  matrix obs_equ_catch(1,nseas,1,Nfleet);    //  initial, equilibrium catch.  now seasonal
 LOCAL_CALCS
  // clang-format on
  have_data.initialize();
  have_data_yr.initialize();
  obs_equ_catch.initialize();

  for (y = 1; y <= ALK_time_max; y++)
    for (f = 1; f <= Nfleet; f++)
    {
      data_time(y, f, 1) = -1.0; // set to illegal value since 0.0 is valid
    }
  // clang-format off
 END_CALCS
!!//  SS_Label_Info_2.2 #Read CATCH amount by fleet

  int N_ReadCatch;
//  int Catch_read;
  vector tempvec(1,6); // vector used for temporary reads
 LOCAL_CALCS
  // clang-format on
  ender = 0;
  do
  {
    dvector tempvec(1, 5);
    *(ad_comm::global_datafile) >> tempvec(1, 5);
    if (tempvec(1) == -9999.)
      ender = 1;
    catch_read.push_back(tempvec(1, 5));
  } while (ender == 0);
  N_ReadCatch = catch_read.size() - 1;
  echoinput << N_ReadCatch << " records" << endl;
  // clang-format off
 END_CALCS

  matrix catch_ret_obs(1,Nfleet,styr-nseas,TimeMax+nseas);
  imatrix catch_record_count(1,Nfleet,styr-nseas,TimeMax+nseas);
  3iarray catch_seas_area(styr,TimeMax,1,pop,0,Nfleet);
  matrix totcatch_byarea(styr,TimeMax,1,pop);
  vector totcat(styr-1,endyr); // by year, not by t
  int first_catch_yr;
  vector catch_by_fleet(1,Nfleet);

  ivector disc_fleet_list(1,Nfleet);
  int N_retain_fleets;
  int catch_warn;

 LOCAL_CALCS
  // clang-format on
  catch_ret_obs.initialize();
  catch_record_count.initialize();
  catch_warn = 0;
  tempvec.initialize();
  for (k = 0; k <= N_ReadCatch - 1; k++)
  {
    // do read in list format  y, s, f, catch, catch_se
    tempvec(1, 5) = catch_read[k];
    g = tempvec(1);
    s = tempvec(2);
    f = tempvec(3);
    if (g == -999)
    { // designates initial equilibrium
      y = styr - 1;
    }
    else
    {
      y = g;
    }
    if (k == 0)
      echoinput << "first catch record: " << tempvec(1, 5) << endl;
    if (k == (N_ReadCatch - 1))
      echoinput << "last catch record: " << tempvec(1, 5) << endl;
    if (y >= (styr - 1) && y <= endyr && (g == -999 || g >= styr)) //  observation is in date range
    {
      if (s > nseas)
      {
        catch_warn++;
        s = nseas;
        // allows for collapsing multiple season catch data down into fewer seasons
        // typically to collapse to annual because accumulation will all be in the index "nseas"
      }
      if (s > 0)
      {
        t = styr + (y - styr) * nseas + s - 1;
        {
          catch_ret_obs(f, t) += tempvec(4);
          catch_record_count(f, t)++;
          catch_se(t, f) = tempvec(5);
        }
      }
      else // distribute catch equally across seasons
      {
        for (s = 1; s <= nseas; s++)
        {
          t = styr + (y - styr) * nseas + s - 1;
          {
            catch_ret_obs(f, t) += tempvec(4) / nseas;
            catch_record_count(f, t)++;
          }
        }
      }
    }
  }
  if (catch_warn > 0) {
    if (catch_warn > 1)
      warnstream << catch_warn << " catch records have ";
    else
      warnstream << "one catch record has ";
    warnstream << "seas>nseas; perhaps erroneous entry of month rather than season; changed to nseas";
    write_message(ADJUST, 0);
  }
  //  warn on duplicate catch records
  for (y = styr - 1; y <= endyr; y++)
    for (s = 1; s <= nseas; s++)
      for (f = 1; f <= Nfleet; f++) {
        t = styr + (y - styr) * nseas + s - 1;
        if (catch_record_count(f, t) > 1)
        {
          warnstream << catch_record_count(f, t) << " catch records have been accumulated into year, seas, fleet " << y << " " << s << " " << f << "; total catch= " << catch_ret_obs(f, t);
          write_message(WARN, 0);
        }
      }

  obs_equ_catch.initialize();
  for (s = 1; s <= nseas; s++)
  {
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        obs_equ_catch(s, f) = catch_ret_obs(f, styr - nseas - 1 + s);
      }
    echoinput << " equ, seas:   -1 " << s << " catches: " << obs_equ_catch(s) << endl;
  }
  for (y = styr; y <= endyr; y++)
    for (s = 1; s <= nseas; s++)
    {
      t = styr + (y - styr) * nseas + s - 1;
      echoinput << "year, seas: " << y << " " << s << " catches: " << trans(catch_ret_obs)(t) << endl;
    }

  //  calc total catch by year so can calculate the first year with catch and to omit zero catch years from sdreport
  totcat.initialize();
  catch_seas_area.initialize();
  totcatch_byarea.initialize();
  totcat(styr - 1) = sum(obs_equ_catch); //  sums over all seasons and fleets
  first_catch_yr = 0;
  if (totcat(styr - 1) > 0.0)
    first_catch_yr = styr - 1;

  for (y = styr; y <= endyr; y++)
  {
    for (s = 1; s <= nseas; s++)
    {
      t = styr + (y - styr) * nseas + s - 1;
      for (p = 1; p <= pop; p++)
        for (f = 1; f <= Nfleet; f++)
          if (fleet_area(f) == p && catch_ret_obs(f, t) > 0.0 && fleet_type(f) <= 2) //  excludes survey and predator fleets
          {
            catch_seas_area(t, p, f) = 1;
            catch_seas_area(t, p, 0) = 1;
            if (fleet_type(f) == 1)
              totcat(y) += catch_ret_obs(f, t);
            if (fleet_type(f) == 1)
              totcatch_byarea(t, p) += catch_ret_obs(f, t);
          }
    }
    if (totcat(y) > 0.0 && first_catch_yr == 0)
      first_catch_yr = y;
    if (y == endyr && totcat(y) == 0.0)
    {
      warnstream << "catch is 0.0 in endyr; this can cause problem in the benchmark and forecast calculations. ";
      write_message(WARN, 0);
    }
  }
  echoinput << endl
            << "#_show_total_catch_by_fleet" << endl;
  catch_by_fleet = rowsum(catch_ret_obs);
  for (f = 1; f <= Nfleet; f++)
  {
    echoinput << f << " type: " << fleet_type(f) << " " << fleetname(f) << " catch: " << catch_by_fleet(f);
    if (fleet_type(f) == 3 && catch_by_fleet(f) > 0.0)
    {
      warnstream << " Catch by survey fleet will be ignored " << fleet_type(f);
      write_message(WARN, 1);
    }
    echoinput << endl;
  }
  // clang-format off
 END_CALCS

  //  SS_Label_Info_2.3 #Read fishery CPUE, effort, and Survey index or abundance
!!echoinput<<endl<<"#_  now read survey characteristics:  fleet_#, svyunits, svyerrtype for each fleet "<<endl;
  int Svy_N_rd;
  int Svy_N;
  init_imatrix Svy_units_rd(1,Nfleet,1,4);
  ivector Svy_units(1,Nfleet);   // 0=num; 1=bio; 2=F; >=30 for special patterns
  ivector Svy_errtype(1,Nfleet);  // -2=gamma(Cole); -1=normal; 0=lognormal ; 1=lognormal w/ biascorr; >1=T-dist
  ivector Svy_sdreport(1,Nfleet);  // 0=no sdreport; 1=enable sdreport
  int Svy_N_sdreport;

 LOCAL_CALCS
  // clang-format on

  data_type = 1; //  for surveys
  echoinput << "Units:  0=numbers; 1=biomass; 2=F; >=30 for special patterns" << endl;
  echoinput << "Errtype:  -2=gamma(future); -1=normal; 0=lognormal ; 1=lognormal w/ biascorr; >1=T-dist with DF=XXX" << endl;
  echoinput << "SD_Report: 0=no sdreport; 1=enable sdreport" << endl;
  echoinput << "Fleet Units Err_Type SD_Report" << endl;
  echoinput << Svy_units_rd << endl;
  Svy_units = column(Svy_units_rd, 2);
  Svy_errtype = column(Svy_units_rd, 3);
  Svy_sdreport = column(Svy_units_rd, 4);

  for (f = 1; f<=Nfleet; f++)
  {
    if (Svy_units(f) >= 35 && Svy_errtype(f) >= 0)
    {
      warnstream << " survey error type must not be lognormal for surveys of deviations for fleet: " << f << fleetname(f) << endl;
      write_message(FATAL, 1);
    }

    if (Svy_errtype(f) < -2 )
    {
      warnstream << " survey error type = " << Svy_errtype(f) << " is illegal for fleet: " << f << fleetname(f) << endl;
      write_message(FATAL, 1);
    }
  }

  // read survey data
  ender = 0;
  do
  {
    dvector tempvec(1, 5);
    *(ad_comm::global_datafile) >> tempvec(1, 5);
    if (tempvec(1) == -9999.)
      ender = 1;
    Svy_data.push_back(tempvec(1, 5));
  } while (ender == 0);
  Svy_N_rd = Svy_data.size() - 1;
  echoinput << Svy_N_rd << " nobs_survey " << endl;
  // clang-format off
 END_CALCS

//   init_matrix Svy_data(1,Svy_N_rd,1,5)
//  !!if(Svy_N_rd>0) echoinput<<" Svy_data "<<endl<<Svy_data<<endl;
  ivector Svy_N_fleet(1,Nfleet); // total N
  ivector Svy_N_fleet_use(1,Nfleet); // N in likelihood
  int in_superperiod;
  ivector Svy_super_N(1,Nfleet); // N super_yrs per fleet

 LOCAL_CALCS
  // clang-format on
  //  count the number of observations, exclude those outside the specified year range, count the number of superperiods
  Svy_N = 0;
  Svy_N_fleet = 0;
  Svy_N_fleet_use = 0;
  Svy_super_N = 0;
  if (Svy_N_rd > 0)
  {
    for (i = 0; i <= Svy_N_rd - 1; i++)
    {
      echoinput << Svy_data[i] << endl;
      y = Svy_data[i](1);
      if (y >= styr)
      {
        f = abs(Svy_data[i](3)); //  negative f turns off observation
        Svy_N_fleet(f)++;
        if (Svy_data[i](5) < 0)
        {
          warnstream << "cannot use negative se to indicate superperiods in survey data";
          write_message (FATAL, 0);
        }
        if (Svy_data[i](2) < 0)
          Svy_super_N(f)++; // count the super-periods if seas<0
      }
    }
    Svy_N = sum(Svy_N_fleet);
    for (f = 1; f <= Nfleet; f++)
      if (Svy_super_N(f) > 0)
      {
        j = Svy_super_N(f) / 2; // because we counted the begin and end
        if (2 * j != Svy_super_N(f))
        {
          warnstream << "unequal number of starts and ends of survey superperiods ";
          write_message (FATAL, 0);
        }
        else
        {
          Svy_super_N(f) = j;
        }
      }
  }

  // check if there are observations for the index before enabling sdreport
  for (f = 1; f <= Nfleet; ++f)
  {
    if (Svy_N_fleet(f) == 0) Svy_sdreport(f) = 0;
  }
  // clang-format off
 END_CALCS

  imatrix Svy_time_t(1,Nfleet,1,Svy_N_fleet); // stores the continuous season index (t) for each obs
  imatrix Svy_ALK_time(1,Nfleet,1,Svy_N_fleet); // stores the continuous subseas index (ALK_time) for each obs
  imatrix Svy_use(1,Nfleet,1,Svy_N_fleet);
  matrix  Svy_obs(1,Nfleet,1,Svy_N_fleet);
  matrix  Svy_obs_log(1,Nfleet,1,Svy_N_fleet);
  matrix  Svy_se_rd(1,Nfleet,1,Svy_N_fleet);
  matrix  Svy_se(1,Nfleet,1,Svy_N_fleet);
// arrays for Super-years
  imatrix Svy_super(1,Nfleet,1,Svy_N_fleet); // indicator used to display start/stop in reports
  imatrix Svy_super_start(1,Nfleet,1,Svy_super_N); // where Svy_super_N is a vector
  imatrix Svy_super_end(1,Nfleet,1,Svy_super_N);
  matrix Svy_super_weight(1,Nfleet,1,Svy_N_fleet);
  ivector Svy_styr(1,Nfleet);
  ivector Svy_endyr(1,Nfleet);
  imatrix Svy_yr(1,Nfleet,1,Svy_N_fleet);
  number  real_month;
  vector timing_input(1,3);
  vector timing_r_result(1,3);
  vector Svy_minval(1,Nfleet);
  vector Svy_maxval(1,Nfleet);
  ivector timing_i_result(1,6);
    // r_result(1,3) will contain: real_month, data_timing_seas, data_timing_yr,
    // i_result(1,6) will contain y, t, s, f, ALK_time, use_midseas

 LOCAL_CALCS
  // clang-format on
  //  SS_Label_Info_2.3.1  #Process survey observations, move info into working arrays,create super-periods as needed
  Svy_super_N.initialize();
  Svy_N_fleet.initialize();
  Svy_styr.initialize();
  Svy_endyr.initialize();
  Svy_yr.initialize();
  Svy_minval.initialize();
  Svy_minval = 999999999.;
  Svy_maxval.initialize();
  Svy_maxval = -999999999.;
  in_superperiod = 0;
  if (Svy_N > 0)
  {
    for (i = 0; i <= Svy_N_rd - 1; i++) // loop all, including those out of yr range
    {
      y = Svy_data[i](1);
      if (y > endyr + 50)
      {
        warnstream << "forecast observations cannot be beyond endyr +50";
        write_message (FATAL, 0);
      }
      if (y >= styr)
      {
        //  call a global function to calculate data timing and create various indexes
        //  function will return: data_timing, ALK_time, real_month, use_midseas
        timing_input(1, 3) = Svy_data[i](1, 3);
        get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);
        f = abs(Svy_data[i](3));
        if (y > retro_yr)
          Svy_data[i](3) = -f;
        Svy_N_fleet(f)++; //  count obs by fleet again
        j = Svy_N_fleet(f); //  index of observation as stored in working array
        t = timing_i_result(2);
        ALK_time = timing_i_result(5);
        //  some fleet specific indexes and working versions of the data and se
        Svy_time_t(f, j) = t;
        Svy_ALK_time(f, j) = ALK_time; //  continuous subseas counter in which jth obs from fleet f occurs
        Svy_se_rd(f, j) = Svy_data[i](5); // later adjust with varadjust, copy to se_cr_use, then adjust with extra se parameter
        if (Svy_data[i](3) < 0)
        {
          Svy_use(f, j) = -1;
        }
        else
        {
          Svy_use(f, j) = 1;
          Svy_N_fleet_use(f)++;
        }
        Svy_obs(f, j) = Svy_data[i](4);
        Svy_yr(f, j) = y;
        if (Svy_styr(f) == 0 || (y >= styr && y < Svy_styr(f)))
          Svy_styr(f) = y; // for dimensioning survey q devs
        if (Svy_endyr(f) == 0 || (y <= endyr && y > Svy_endyr(f)))
          Svy_endyr(f) = y; //  for dimensioning survey q devs

        //  Svy_styr and Svy_endyr for recruitment surveys will be checked against recdev start and end in readcontrol
        if (y >= styr && Svy_data[i](3) > 0)
        {
          Svy_minval(f) = min(Svy_minval(f), Svy_obs(f, j));
          Svy_maxval(f) = max(Svy_maxval(f), Svy_obs(f, j));
        }
        //  some all fleet indexes
        if (data_time(ALK_time, f, 1) < 0.0) //  so first occurrence of data at ALK_time,f
        { // real_month,fraction of season, year.fraction
          data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
        }
        else if (timing_r_result(1) == data_time(ALK_time, f, 1))
        {
          warnstream << "SURVEY: duplicate survey obs for this time-fleet: y,s,f: " << y << " " << s << " " << f << " SS3 will exit ";
          write_message (FATAL, 0);
        }

        have_data(ALK_time, 0, 0, 0) = 1;
        have_data(ALK_time, f, 0, 0) = 1; //  so have data of some type in this subseas, for this fleet
        have_data(ALK_time, f, data_type, 0)++; //  count the number of observations in this subseas
        p = have_data(ALK_time, f, data_type, 0); //  current number of observations
        have_data(ALK_time, f, data_type, p) = j; //  store data index for the p'th observation in this subseas
        have_data_yr(y, f) = 1; //  survey or comp data exist this year
        have_data_yr(y, 0) = 1;
        //  create super_year indexes
        if (Svy_data[i](2) < 0) // start or stop a super-period;  ALL observations must be continguous in the file
        {
          Svy_super(f, j) = -1;
          if (in_superperiod == 0) // start superperiod
          {
            Svy_super_N(f)++;
            Svy_super_start(f, Svy_super_N(f)) = j;
            in_superperiod = 1;
          }
          else
          {
            if (in_superperiod == 1) // end superperiod
            {
              Svy_super_end(f, Svy_super_N(f)) = j;
              in_superperiod = 0;
            }
            else
            {
            }
          }
        }
        else
        {
          Svy_super(f, j) = 1;
        }
      }
    }

    echoinput << "Successful read of survey data; total N:  " << Svy_N << endl;
    echoinput << "Index Survey_name       N   Super_Per    Min_val   max_val  //  Observations:" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (Svy_N_fleet(f) > 0)
      {
        echoinput << f << "    " << fleetname(f) << "   " << Svy_N_fleet(f) << "     " << Svy_super_N(f) << "      " << Svy_minval(f) << " " << Svy_maxval(f) << " // " << Svy_obs(f) << endl;
        if (Svy_errtype(f) >= 0 && Svy_minval(f) <= 0.)
        {
          warnstream << "error, SS3 has exited. A fleet uses lognormal error and has an observation <=0.0; fleet: " << f;
          write_message (FATAL, 0);
        }
      }
    }
  }
  Svy_N_sdreport = 0;
  for (f = 1; f <= Nfleet; ++f)
  {
    if (Svy_sdreport(f) > 0)
    {
      Svy_N_sdreport += Svy_N_fleet(f);
    }
  }
  if (Svy_N_sdreport < 0)
    Svy_N_sdreport = 0;
  echoinput << "Number of sdreport index values: " << Svy_N_sdreport << endl;
  // clang-format off
 END_CALCS

  init_int Ndisc_fleets;
   int nobs_disc;  //  number of discard records kept in active array
   int disc_N_read;  //  number of records read
   ivector disc_N_fleet(1,Nfleet);  //  kept obs per fleet
   ivector disc_N_fleet_use(1,Nfleet);  //  kept obs per fleet
   ivector N_suprper_disc(1,Nfleet);      // N super_yrs per obs

 LOCAL_CALCS
  // clang-format on
  //  SS_Label_Info_2.4 #read Discard data
  echoinput << " note order of discard read is now: N fleets with disc, then if Ndisc_fleets>0 read:  fleet, disc_units, disc_error(for 1,Ndisc_fleets), then read obs " << endl;
  echoinput << Ndisc_fleets << " N fleets with discard " << endl;

  if (Ndisc_fleets > 0)
  {
    j = Nfleet;
  }
  else
  {
    j = 0;
  }
  data_type = 2; //  for discard
  // clang-format off
 END_CALCS
  init_imatrix disc_units_rd(1,Ndisc_fleets,1,3);
  ivector disc_units(1,j);  //  formerly scalar disc_type
  ivector disc_errtype(1,j);  // formerly scalar DF_disc
  vector disc_errtype_r(1,j);  // real version for T-dist
  vector disc_minval(1,j);
  vector disc_maxval(1,j);

 LOCAL_CALCS
  // clang-format on
  disc_units.initialize();
  disc_errtype.initialize();
  disc_minval.initialize();
  disc_minval = 999999999.;
  disc_maxval.initialize();
  disc_maxval = -999999999.;
  nobs_disc = 0;
  disc_N_fleet = 0;
  disc_N_fleet_use = 0;
  N_suprper_disc = 0;
  if (Ndisc_fleets > 0)
  {
    echoinput << "#_discard_units (1=same_as_catchunits(bio/num);2=fraction; 3=numbers)" << endl;
    echoinput << "#_discard_error:  >0 for DF of T-dist(read CV below); 0 for normal with CV; -1 for normal with se; -2 for lognormal; -3 for trunc normal with CV" << endl;
    echoinput << "#_fleet units errtype" << endl;
    echoinput << disc_units_rd << endl;
    for (j = 1; j <= Ndisc_fleets; j++)
    {
      f = disc_units_rd(j, 1);
      disc_units(f) = disc_units_rd(j, 2);
      disc_errtype(f) = disc_units_rd(j, 3);
      disc_errtype_r(f) = float(disc_errtype(f));
    }

    ender = 0;
    do
    {
      dvector tempvec(1, 5);
      *(ad_comm::global_datafile) >> tempvec(1, 5);
      if (tempvec(1) == -9999.)
        ender = 1;
      discdata.push_back(tempvec(1, 5));
    } while (ender == 0);
    disc_N_read = discdata.size() - 1;
    echoinput << disc_N_read << " N discard obs " << endl;

    if (disc_N_read > 0)
    {
      for (i = 0; i <= disc_N_read - 1; i++) // get count of observations in date range
      {
        echoinput << discdata[i] << endl;
        y = discdata[i](1);
        if (y >= styr)
        {
          f = abs(discdata[i](3));
          disc_N_fleet(f)++;
          if (discdata[i](5) < 0)
          {
            warnstream << "Cannot use negative se as indicator of superperiod in discard data";
            write_message (FATAL, 0);
          }
          if (discdata[i](2) < 0)
            N_suprper_disc(f)++; // count the super-periods if seas<0 or se<0
        }
      }
      nobs_disc = sum(disc_N_fleet); // sum of obs in the date range
      for (f = 1; f <= Nfleet; f++)
        if (N_suprper_disc(f) > 0)
        {
          j = N_suprper_disc(f) / 2; // because we counted the begin and end
          if (2 * j != N_suprper_disc(f))
          {
            warnstream << "unequal number of starts and ends of discard superperiods ";
            write_message (FATAL, 0);
          }
          else
          {
            N_suprper_disc(f) = j;
          }
        }
    }
  }
  // clang-format off
 END_CALCS

  imatrix disc_time_t(1,Nfleet,1,disc_N_fleet);
  imatrix disc_time_ALK(1,Nfleet,1,disc_N_fleet);  // stores the continuous subseas index (ALK_time) for each obs
  imatrix yr_disc_use(1,Nfleet,1,disc_N_fleet);
  matrix  obs_disc(1,Nfleet,1,disc_N_fleet);
  matrix  cv_disc(1,Nfleet,1,disc_N_fleet);
  matrix  sd_disc(1,Nfleet,1,disc_N_fleet);
// arrays for Super-years
  imatrix yr_disc_super(1,Nfleet,1,disc_N_fleet);
  imatrix suprper_disc1(1,Nfleet,1,N_suprper_disc);
  imatrix suprper_disc2(1,Nfleet,1,N_suprper_disc);
  matrix suprper_disc_sampwt(1,Nfleet,1,disc_N_fleet);
 LOCAL_CALCS
  // clang-format on
  //  SS_Label_Info_2.4.1 #Process discard data and create super periods as needed
  disc_N_fleet.initialize(); // redo the counter to provide pointer for below
  N_suprper_disc.initialize();
  in_superperiod = 0;
  if (nobs_disc > 0)
  {
    for (i = 0; i <= disc_N_read - 1; i++)
    {
      y = discdata[i](1);
      if (y > endyr + 50)
      {
        warnstream << "forecast observations cannot be beyond endyr +50";
        write_message (FATAL, 0);
      }
      if (y >= styr)
      {
        timing_input(1, 3) = discdata[i](1, 3);
        get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);

        f = abs(discdata[i](3));
        if (y > retro_yr)
          discdata[i](3) = -f;
        disc_N_fleet(f)++;
        j = disc_N_fleet(f); // index number for data that are in date range
        t = timing_i_result(2);
        ALK_time = timing_i_result(5);
        disc_time_t(f, j) = t;
        disc_time_ALK(f, j) = ALK_time; // subseas that this observation is in

        if (data_time(ALK_time, f, 1) < 0.0) // so first occurrence of data at ALK_time,f
        { // real_month,fraction of season, year.fraction
          data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
        }
        else if (timing_r_result(1) != data_time(ALK_time, f, 1))
        {
          warnstream << "DISCARD: data_month already set for y,s,f: " << y << " " << s << " " << f << " to real month: " << data_time(ALK_time, f, 1) << "  but read value is: " << timing_r_result(1);
          write_message(WARN, 0);
        }

        have_data(ALK_time, 0, 0, 0) = 1;
        have_data(ALK_time, f, 0, 0) = 1; // so have data of some type
        have_data(ALK_time, f, data_type, 0)++; // count the number of observations in this subseas
        p = have_data(ALK_time, f, data_type, 0);
        have_data(ALK_time, f, data_type, p) = j; // store data index for the p'th observation in this subseas

        cv_disc(f, j) = discdata[i](5);
        obs_disc(f, j) = fabs(discdata[i](4));
        disc_minval(f) = min(disc_minval(f), obs_disc(f, j));
        disc_maxval(f) = max(disc_maxval(f), obs_disc(f, j));
        if (discdata[i](4) < 0.0)
          discdata[i](3) = -fabs(discdata[i](3)); //  convert to new format using negative fleet
        if (discdata[i](3) < 0)
        {
          yr_disc_use(f, j) = -1;
        }
        else
        {
          yr_disc_use(f, j) = 1;
          disc_N_fleet_use(f)++;
        }
        if (fleet_type(f) < 3 && catch_ret_obs(f, t) <= 0.0)
        {
          warnstream << "discard observation: " << i << " has no corresponding catch " << discdata[i];
          write_message(WARN, 0);
        }

        // create super_year indexes
        if (discdata[i](2) < 0) // start/stop a super-year  ALL observations must be continguous in the file
        {
          yr_disc_super(f, j) = -1;
          if (in_superperiod == 0) // start a super-year
          {
            N_suprper_disc(f)++;
            suprper_disc1(f, N_suprper_disc(f)) = j;
            in_superperiod = 1;
          }
          else if (in_superperiod == 1) // end a super-year
          {
            suprper_disc2(f, N_suprper_disc(f)) = j;
            in_superperiod = 0;
          }
        }
        else
        {
          yr_disc_super(f, j) = 1;
        }
      }
    }
  }
  echoinput << "Successful read of discard data " << endl;
  echoinput << "Index Survey_name       N   Super_Per    Min_val   max_val  //  Observations:" << endl;
  for (f = 1; f <= Nfleet; f++)
  {
    if (disc_N_fleet(f) > 0)
    {
      echoinput << f << "    " << fleetname(f) << "   " << disc_N_fleet(f) << "     " << N_suprper_disc(f);
      echoinput << "      " << disc_minval(f) << " " << disc_maxval(f) << " // " << obs_disc(f) << endl;
      if (disc_minval(f) < 0.)
      {
        warnstream << "error, SS3 has exited. A discard observation is <0.0; fleet: " << f;
        write_message (FATAL, 0);
      }
    }
  }
  // clang-format off
 END_CALCS


!!//  SS_Label_Info_2.5 #Read Mean Body Weight data
//  note that syntax for storing this info internally is done differently than for surveys and discard
  init_int do_meanbodywt;
  int nobs_mnwt_rd;
  int nobs_mnwt;
  ivector mnwt_N_fleet(1,Nfleet);
  ivector mnwt_N_fleet_use(1,Nfleet);
  number DF_bodywt;  // DF For meanbodywt T-distribution
!!echoinput<<do_meanbodywt<<" Use mean body size (weight or length); If 0, then no additional input in 3.30 "<<endl;

 LOCAL_CALCS
  // clang-format on
  nobs_mnwt = 0;
  mnwt_N_fleet.initialize();
  mnwt_N_fleet_use.initialize();
  if (do_meanbodywt > 0)
  {
    *(ad_comm::global_datafile) >> DF_bodywt;
    echoinput << DF_bodywt << " degrees of freedom for bodywt T-distribution " << endl;
    echoinput << "#_yr month fleet part type obs stderr" << endl;
    echoinput << "# type is a required new input with 3.30.12" << endl;
    echoinput << "# type makes explicit the infor previously contained in the sign of partition, e.g. " << endl;
    echoinput << "# type=1 is for mean length, type=2 is for mean weight, (future, type=3 is for mean true age)" << endl;
    ender = 0;
    z = 0;
    do
    {
      dvector tempvec(1, 7);
      *(ad_comm::global_datafile) >> tempvec(1, 7);
      if (tempvec(1) == -9999.)
        ender = 1;
      z++;
      if (z <= 2)
      {
        echoinput << "meansize_obs_#:" << z << " # " << tempvec << endl;
      }
      mnwtdata1.push_back(tempvec(1, 7));
      if (tempvec(1) >= styr)
      {
        nobs_mnwt++;
      }
    } while (ender == 0);
    nobs_mnwt_rd = mnwtdata1.size() - 1;
    echoinput << nobs_mnwt_rd << " nobs for mean body size" << endl;
    if (nobs_mnwt_rd > 0)
    {
      echoinput << "meansize_obs_#:" << nobs_mnwt_rd << " # " << mnwtdata1[nobs_mnwt_rd - 1] << endl;
    }
  }
  // clang-format off
 END_CALCS
  matrix mnwtdata(1,11,1,nobs_mnwt);  //  working matrix for the mean size data
//  10 items are:  1yr, 2seas, 3fleet, 4part, 5type, 6obs, 7se, then three intermediate variance quantities, then ALKtime

 LOCAL_CALCS
  // clang-format on
  mnwtdata.initialize();
  j = 0;
  data_type = 3;
  if (nobs_mnwt > 0)
    for (i = 0; i <= nobs_mnwt_rd - 1; i++) //   loop all obs
    {
      y = mnwtdata1[i](1);
      if (y > endyr + 50)
      {
        warnstream << "mnwt forecast observations cannot be beyond endyr +50";
        write_message (FATAL, 0);
      }
      if (y >= styr)
      {
        if (mnwtdata1[i](2) < 0.0)
        {
          warnstream << "negative season not allowed for mnwtdata because superperiods not implemented ";
          write_message(WARN, 0);
        }
        timing_input(1, 3) = mnwtdata1[i](1, 3);
        get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);
        j++;
        f = abs(mnwtdata1[i](3));
        if (y > retro_yr)
        {
          mnwtdata1[i](3) = -f;
        }
        mnwt_N_fleet(f)++;
        if (mnwtdata1[i](3) > 0)
        {
          mnwt_N_fleet_use(f)++;
        }
        t = timing_i_result(2);
        ALK_time = timing_i_result(5);
        //      disc_time_ALK(f,j) = ALK_time;  //  subseas that this observation is in

        if (data_time(ALK_time, f, 1) < 0.0) //  so first occurrence of data at ALK_time,f
        { // real_month,fraction of season, year.fraction
          data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
        }
        else if (timing_r_result(1) != data_time(ALK_time, f, 1))
        {
          warnstream << "MEAN_WEIGHT: data_month already set for y,s,f: " << y << " " << s << " " << f << " to real month: " << data_time(ALK_time, f, 1) << "  but read value is: " << timing_r_result(1);
          write_message(WARN, 0);
        }
        have_data(ALK_time, 0, 0, 0) = 1;
        have_data(ALK_time, f, 0, 0) = 1; //  so have data of some type
        have_data(ALK_time, f, data_type, 0)++; //  count the number of observations in this subseas
        p = have_data(ALK_time, f, data_type, 0);
        have_data(ALK_time, f, data_type, p) = j; //  store data index for the p'th observation in this subseas

        z = mnwtdata1[i](4); // z is partition (0, 1, 2)

        for (k = 1; k <= 7; k++)
        {
          mnwtdata(k, j) = mnwtdata1[i](k);
        }
        mnwtdata(1, j) = t; //  note:  saving t, not y so have direct access to t later
        mnwtdata(11, j) = ALK_time;
      }
    }
  echoinput << "Successful pre-processing of mean-bodysize data" << endl;
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_2.6 #Setup population Length bins
  number binwidth2;  //  width of length bins in population
  number minLread;  // input minimum size in population; this is used as the mean size at age 0.00
  number maxLread;  //  input maximum size to be considered; should be divisible by binwidth2
  int nlen_bin2;  //number of length bins in length comp data doubled for males
  int nlen_binP;   //number of length bins in length comp data +1 as needed
  number minL;               // minL and maxL store ends of the sizevector and are used as bounds later
  number minL_m;  // mean size in first pop bin
  number maxL;  // set to the midsize of last population bin for selex calc
  int nlength;  // N pop lenbins
  int nlength1;  //  +1 as needed
  int nlength2;  // doubled for males
  number startbin;  // population length bin that matches first data length bin

  init_int LenBin_option;  // 1=set to data bins; 2 generate uniform; 3 = read custom
!!echoinput<<LenBin_option<<" LenBin_option:  1=set to data bins; 2 generate uniform; 3 = read custom"<<endl;
 LOCAL_CALCS
  // clang-format on
  if (LenBin_option == 1)
  {
    k = 0;
  }
  else if (LenBin_option == 2)
  {
    k = 3;
  }
  else if (LenBin_option == 3)
  {
    k = 1;
  }
  else
  {
    warnstream << "LenBin_option must be 1, 2 or 3" << LenBin_option;
    write_message(WARN, 0);
  }
  // clang-format off
 END_CALCS

  init_vector PopBin_Read(1,k);
!!if( k>0) echoinput<<PopBin_Read<<" input for setup of pop length bins "<<endl;
 LOCAL_CALCS
  // clang-format on
  nlength = 0; // later will be read or calculated
  if (LenBin_option == 2)
  {
    binwidth2 = PopBin_Read(1);
    minLread = PopBin_Read(2);
    maxLread = PopBin_Read(3);
  }
  else if (LenBin_option == 3)
  { // number of bins to read
    nlength = PopBin_Read(1);
  }
  // clang-format off
 END_CALCS
  init_vector len_bins_rd(1,nlength);
!!if(nlength>0) echoinput<<len_bins_rd<<" population length bins as read "<<endl;

!!//  SS_Label_Info_2.7 #Start length data section
  init_int use_length_data;  //  0/1/2 to indicate whether there is any reading of length data
!!echoinput<<use_length_data<<" indicator for length data  "<<endl;

  number min_tail;  //min_proportion_for_compressing_tails_of_observed_composition
  number min_comp;  //  small value added to each composition bins
  int CombGender_l;  //  combine genders through this length bin
!!//  SS_Label_Info_2.7.1 #Read and process data length bins
  int nlen_bin //number of length bins in length comp data
  matrix min_tail_L(0,2,1,Nfleet);  //min_proportion_for_compressing_tails_of_observed_composition; by partition type and fleet
  matrix min_comp_L(0,2,1,Nfleet);  //  small value added to each composition bins
  imatrix CombGender_L(0,2,1,Nfleet);  //  combine genders through this length bin (0 or -1 for no combine)
  imatrix AccumBin_L(0,2,1,Nfleet);  //  collapse bins down to this bin number (0 for no collapse; positive value for number to accumulate)
  imatrix Comp_Err_L(0,2,1,Nfleet);  //  composition error type
  imatrix Comp_Err_L2(0,2,1,Nfleet);  //  composition error type index
  matrix min_sample_size_L(0,2,1,Nfleet);  // minimum sample size
  int Comp_Err_ParmCount;  // counts number of comp_err definitions that are created
  int comp_control_L_count;
  imatrix DM_parmlist(0,2,1,3*Nfleet);  // flag for creating a new comperr definition; 3*Nfleet creates dim for length, age, size comps
 LOCAL_CALCS
  // clang-format on
  Comp_Err_ParmCount = 0;
  min_tail_L.initialize();
  CombGender_L.initialize();
  AccumBin_L.initialize();
  Comp_Err_L.initialize();
  Comp_Err_L2.initialize();
  Comp_Err_parmloc.initialize();
  min_sample_size_L = 0.001; // default sample size avoids warnings for partition/fleet combinations which aren't read
  DM_parmlist.initialize();
  comp_control_L_count = -1;
  if (use_length_data > 0)
  {
    echoinput << "#_now read controls for processing the length comps:" << endl;
    echoinput << "Use_length_data == 1: invokes original input format starting with mintailcomp, one row for each fleet" << endl;
    echoinput << "Use_length_data == 2: invokes list format with fleet and partition preceding controls" << endl;
    if (use_length_data == 2)
    {
      echoinput << "#_fleet: fleet number, or -9999 for terminator row, or negative fleet to use input row as filler for all fleets and partitions" << endl;
      echoinput << "#_partition: 0=all, 1=discard, 2=retained" << endl;
    }
    echoinput << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
    echoinput << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
    echoinput << "#_males and females treated as combined gender below this bin number " << endl;
    echoinput << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
    echoinput << "#_Comp_Error:  0=multinomial, 1=dirichlet using theta * n, 2=dirichlet using beta, 3=MV_Tweedie with phi and power"<<endl;
    echoinput << "#_Comp_ERR-2:  consecutive index of error def to use"<<endl;
    echoinput << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;

    if (use_length_data == 1)
    {
  //  read input into partition 0, then copy to partition 1 and 2
      for (f = 1; f <= Nfleet; f++)
      {
        *(ad_comm::global_datafile) >> min_tail_L(0, f);
        min_tail_L(1, f) = min_tail_L(0, f);
        min_tail_L(2, f) = min_tail_L(0, f);
        *(ad_comm::global_datafile) >> min_comp_L(0, f);
        if (min_comp_L(0, f) <= 0) {
          warnstream << "addtocomp input for length comps fleet " << f << 
          " is " << min_comp_L(0, f) << " but should be > 0 to avoid log(0) in likelihood";
          write_message(WARN, 0);      
        }
        min_comp_L(1, f) = min_comp_L(0, f);
        min_comp_L(2, f) = min_comp_L(0, f);
        *(ad_comm::global_datafile) >> CombGender_L(0, f);
        CombGender_L(1, f) = CombGender_L(0, f);
        CombGender_L(2, f) = CombGender_L(0, f);
        *(ad_comm::global_datafile) >> AccumBin_L(0, f);
        AccumBin_L(1, f) = AccumBin_L(0, f);
        AccumBin_L(2, f) = AccumBin_L(0, f);
        *(ad_comm::global_datafile) >> Comp_Err_L(0, f);
        Comp_Err_L(1, f) = Comp_Err_L(0, f);
        Comp_Err_L(2, f) = Comp_Err_L(0, f);
        *(ad_comm::global_datafile) >> Comp_Err_L2(0, f);
        Comp_Err_L2(1, f) = Comp_Err_L2(0, f);
        Comp_Err_L2(2, f) = Comp_Err_L2(0, f);
        *(ad_comm::global_datafile) >> min_sample_size_L(0, f);
        min_sample_size_L(1, f) = min_sample_size_L(0, f);
        min_sample_size_L(2, f) = min_sample_size_L(0, f);
      }
    }
    else
    {
      ender = 0;
      int parti;
      int parti_lo;
      int parti_hi;
      int f_lo;
      int f_hi;
      do
      {
        dvector tempvec(1,9);
        *(ad_comm::global_datafile) >> tempvec(1,9);  //  read vector
        f = int(tempvec(1));
        parti = int(tempvec(2));
        comp_control_L.push_back(tempvec(1,9));  //  save for write back in ss_new
        comp_control_L_count++;
        if (f == -9999.)
          {
            ender = 1;
          }
          else
          {
            if (f < 0)  //  fill all higher fleets to create default that is overwritten by later reads
            {
              f_lo = abs(f);
              f_hi = Nfleet;
              parti_lo = 0;
              parti_hi = 2;
            }
            else  //  specific input
            {
              f_lo = f;
              f_hi = f;
              parti_lo = parti;
              parti_hi = parti;
            }
            //  else  other codes could do other types of specialized fills

            for (f = f_lo; f <= f_hi; f++)
            for (parti = parti_lo; parti <= parti_hi; parti++)
            {
              min_tail_L(parti, f) = tempvec(3);
              min_comp_L(parti, f) = tempvec(4);
              CombGender_L(parti, f) = int(tempvec(5));
              AccumBin_L(parti, f) = int(tempvec(6));
              Comp_Err_L(parti, f) = int(tempvec(7));
              Comp_Err_L2(parti, f) = int(tempvec(8));
              min_sample_size_L(parti, f) = tempvec(9);
            }
          }
        } while (ender == 0);
    }
    echoinput << "fleet partition mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
    for (f = 1; f <= Nfleet; f++)
    for (int parti = 0; parti <= 2; parti++)
    {
      echoinput << f << " " << parti << " " << min_tail_L(parti, f) << " " << min_comp_L(parti, f) << " " << CombGender_L(parti, f) << " " << AccumBin_L(parti, f) << " " << Comp_Err_L(parti, f) << " " << Comp_Err_L2(parti, f) << " " << min_sample_size_L(parti, f) << "  #_fleet: " << f << " " << fleetname(f) << endl;

      if (min_sample_size_L(parti, f) < 0.001)
      {
        warnstream << " minimum sample size for length comps must be > 0; minimum sample size set to 0.001 ";
        write_message(WARN, 1);
        min_sample_size_L(parti, f) = 0.001;
      }
  
      if (Comp_Err_L2(parti, f) > Comp_Err_ParmCount + 1)
      {
        warnstream << "; length D-M must refer to existing Comp_err definition, or increment by 1:  " << Comp_Err_L2(parti, f);
        write_message(FATAL, 1);
      }
      else if (Comp_Err_L2(parti, f) > Comp_Err_ParmCount)
      {
        Comp_Err_ParmCount++;
        DM_parmlist(parti, f) = 1;  // flag for creating new definition because Comp_Err_L2 can point to existing definition
      }
      //  else OK because refers to existing definition
    }
    //  the count for age data will be added after reading the age data setup
    echoinput << "number of D-M definitions needed for length comp data: " << Comp_Err_ParmCount << endl
              << endl;

    *(ad_comm::global_datafile) >> nlen_bin;
    echoinput << nlen_bin << " nlen_bin_for_data " << endl;
  }
  else
  {
    nlen_bin = 2;
    nlen_bin2 = 2 * gender;
  }
  // clang-format off
 END_CALCS
  vector len_bins_dat(1,nlen_bin); // length bin lower boundaries
 LOCAL_CALCS
  // clang-format on
  if (use_length_data > 0)
  {
    *(ad_comm::global_datafile) >> len_bins_dat;
    echoinput << " len_bins_dat " << endl
              << len_bins_dat << endl;

    for (f = 1; f <= Nfleet; f++)
    {
      if (CombGender_L(0, f) > nlen_bin)
      {
        warnstream << "Combgender_L(part,f) cannot be greater than nlen_bin; resetting for fleet: " << f;
        write_message(WARN, 0);
        CombGender_L(0, f) = nlen_bin;
      }
    }
    nlen_binP = nlen_bin + 1;
    nlen_bin2 = gender * nlen_bin;
  }
  else
  {
  }
  // clang-format off
 END_CALCS

  vector len_bins_dat2(1,nlen_bin2);  // doubled for males; for output only
  vector len_bins_dat_m(1,nlen_bin);  // midbin; for output only
  vector len_bins_dat_m2(1,nlen_bin2);  // doubled for males; for output only

 LOCAL_CALCS
  // clang-format on
  //  SS_Label_Info_2.7.2 #Process population length bins, create mean length per bin, etc.
  //  note this is after reading the len_bin_for data in case population is mirrored to data
  if (LenBin_option == 1)
  {
    nlength = nlen_bin; // set N pop bins same as data bins
  }
  else if (LenBin_option == 2)
  {
    nlength = (maxLread - minLread) / binwidth2 + 1; // number of population length bins
  }
  else if (LenBin_option == 3)
  {
    // nlength was read
  }
  nlength1 = nlength + 1; //  +1 when needed
  nlength2 = gender * nlength; // doubled for males
  // clang-format off
 END_CALCS

  vector len_bins(1,nlength);   //vector with lower edge of population length bins
  vector log_len_bins(1,nlength);  //vector with log of lower edge of population length bins
  vector len_bins2(1,nlength2);  //vector with lower edge of population length bins
  vector binwidth(1,nlength2);  //ve
  vector len_bins_m(1,nlength);  //vector with mean size in bin
  vector len_bins_m2(1,nlength2);  //vector with all length bins; doubled for males
  vector len_bins_sq(1,nlength2);  //vector with all length bins; doubled for males
  vector male_offset(1,nlength2);  // used to calculate retained@length as population quantity

 LOCAL_CALCS
  // clang-format on
  male_offset.initialize(); //  initialize
  if (LenBin_option == 1)
  {
    len_bins = len_bins_dat;
  }
  else if (LenBin_option == 2)
  {
    len_bins(1) = minLread;
    for (z = 2; z <= nlength; z++)
    {
      len_bins(z) = len_bins(z - 1) + binwidth2;
    }
  }
  else
  {
    len_bins = len_bins_rd;
  }

  if (len_bins(1) == 0.0)
  {
    len_bins(1) = 0.001;
  }
  for (z = 1; z <= nlength; z++)
  {
    len_bins2(z) = len_bins(z);
    log_len_bins(z) = log(len_bins(z));
    if (z < nlength)
    {
      len_bins_m(z) = (len_bins(z + 1) + len_bins(z)) / 2.;
      binwidth(z) = len_bins(z + 1) - len_bins(z);
    }
    else
    {
      len_bins_m(z) = len_bins(z) + binwidth(z - 1) / 2.;
      binwidth(z) = binwidth(z - 1);
    }

    len_bins_m2(z) = len_bins_m(z); // for use in calc mean size at binned age
    len_bins_sq(z) = len_bins_m2(z) * len_bins_m2(z); //  for use in calc std dev of size at binned age
    if (gender == 2)
    {
      len_bins2(z + nlength) = len_bins(z);
      male_offset(z + nlength) = 1.;
      binwidth(z + nlength) = binwidth(z);
      len_bins_m2(z + nlength) = len_bins_m2(z);
      len_bins_sq(z + nlength) = len_bins_sq(z);
    }
  }
  echoinput << endl
            << "Processed Population length bin info " << endl
            << len_bins << endl;

  maxL = len_bins_m(nlength);
  minL = len_bins(1);
  minL_m = len_bins_m(1);
  if (LenBin_option != 2)
  {
    binwidth2 = binwidth(nlength / 2); // set a reasonable value in case LenBin_option !=2
  }
  startbin = 1;

  if (use_length_data > 0)
  {
    while (len_bins(startbin) < len_bins_dat(1))
    {
      startbin++;
    }

    for (z = 1; z <= nlen_bin; z++)
    {
      len_bins_dat2(z) = len_bins_dat(z);
      if (gender == 2)
      {
        len_bins_dat2(z + nlen_bin) = len_bins_dat(z);
      }
      if (z < nlen_bin)
      {
        len_bins_dat_m(z) = 0.5 * (len_bins_dat(z) + len_bins_dat(z + 1)); //  this is not gender specific
      }
      else
      {
        len_bins_dat_m(z) = len_bins_dat_m(z - 1) + (len_bins_dat(z) - len_bins_dat(z - 1));
      }
      len_bins_dat_m2(z) = len_bins_dat_m(z);
      if (gender == 2)
      {
        len_bins_dat_m2(z + nlen_bin) = len_bins_dat_m(z);
      }
    }
    if (len_bins_dat(nlen_bin) > len_bins(nlength))
    {
      warnstream << "Data length bins extend beyond pop len bins " << len_bins_dat(nlen_bin) << " " << len_bins(nlength);
      write_message(FATAL, 0);
    }
    if (len_bins_dat(nlen_bin) < len_bins(nlength))
    {
      warnstream << "Max data length bin: " << len_bins_dat(nlen_bin) << "  < max pop len bins: " << len_bins(nlength) << "; so will accumulate larger pop len bins";
      write_message(NOTE, 1);
    }
    echoinput << endl
              << "Processed Data length bin info " << endl
              << len_bins_dat << endl;
  }
  // clang-format off
 END_CALCS

  matrix make_len_bin(1,nlen_bin2,1,nlength2);

  int ibin;
  int ibinsave;
  int fini;
  number topbin;
  number botbin;

 LOCAL_CALCS
  // clang-format on
  //  SS_Label_Info_2.7.3 #Create conversion of pop length bins to data length bins
  make_len_bin.initialize();
  ibin = 0;
  topbin = 0.;
  botbin = 0.;
  if (use_length_data > 0)
  {
    for (z = 1; z <= nlength; z++)
    {
      if (ibin == nlen_bin)
      { //checkup<<" got to last ibin, so put rest of popbins here"<<endl;
        make_len_bin(ibin, z) = 1.;
      }
      else
      {
        if (len_bins(z) >= topbin)
        { //checkup<<" incr ibin ";
          ibin++;
        }

        if (ibin > 1)
        {
          botbin = len_bins_dat(ibin);
        }
        if (ibin < nlen_bin)
        {
          topbin = len_bins_dat(ibin + 1);
        }
        else
        {
          topbin = 99999.;
        }

        if (ibin == nlen_bin) // checkup<<" got to last ibin, so put rest of popbins here"<<endl;
        {
          make_len_bin(ibin, z) = 1.;
        }
        else if (len_bins(z) >= botbin && len_bins(z + 1) <= topbin) //checkup<<" pop inside dat, put here"<<endl;
        {
          make_len_bin(ibin, z) = 1.;
        }
        else
        {
          make_len_bin(ibin + 1, z) = (len_bins(z + 1) - topbin) / (len_bins(z + 1) - len_bins(z));
          if (ibin != 1)
          {
            make_len_bin(ibin, z) = 1. - make_len_bin(ibin + 1, z);
          }
        }
      }
    }
    if (gender == 2)
    {
      for (i = 1; i <= nlen_bin; i++)
        for (j = 1; j <= nlength; j++)
          make_len_bin(i + nlen_bin, j + nlength) = make_len_bin(i, j);
    }
    if (docheckup == 1)
    {
      echoinput << "pop_len_bin: " << len_bins << endl;
      for (ibin = 1; ibin <= nlen_bin; ibin++)
      {
        echoinput << len_bins_dat(ibin) << make_len_bin(ibin)(1, nlength) << endl;
      }
    }
    echoinput << endl
              << "Processed Population to Data length bin conversion matrix" << endl;
  }
  // clang-format off
 END_CALCS


!!//  SS_Label_Info_2.7.4 #Read Length composition data
   int nobsl_rd;
   int Nobs_l_tot;
  ivector Nobs_l(1,Nfleet);
  ivector Nobs_l_use(1,Nfleet);
  ivector N_suprper_l(1,Nfleet);  // N super_yrs per obs

//   vector tempvec_lenread(1,6+nlen_bin2);

 LOCAL_CALCS
  // clang-format on
  k = 6 + nlen_bin2;
  Nobs_l.initialize();
  Nobs_l_use.initialize();
  N_suprper_l.initialize();
  if (use_length_data > 0)
  {
    ender = 0;
    z = 0;
    do
    {
      dvector tempvec(1, k);
      *(ad_comm::global_datafile) >> tempvec(1, k);
      if (sum(tempvec) == 0.0)
      {
        warnstream << "reading past end of file for length data; exit ";
        write_message(FATAL, 0);
      }
      if (tempvec(1) == -9999.)
        ender = 1;
      z++;
      if (z <= 2)
      {
        echoinput << "len_obs_#:" << z << " # " << tempvec(1, k) << endl;
      }
      lendata.push_back(tempvec(1, k));
    } while (ender == 0);
    nobsl_rd = lendata.size() - 1;
    echoinput << nobsl_rd << " N length comp observations " << endl;
    if (nobsl_rd > 0)
      echoinput << "len_obs_#:" << nobsl_rd << " # " << lendata[nobsl_rd - 1] << endl;

    data_type = 4;
    if (nobsl_rd > 0)
      for (i = 0; i <= nobsl_rd - 1; i++)
      {
        y = lendata[i](1);
        if (y >= styr)
        {
          f = abs(lendata[i](3));
          if (lendata[i](6) < 0)
          {
            warnstream << "Error in length data: negative sample size no longer valid as indicator of skip data or superperiods ";
            write_message(FATAL, 0);
          }
          if (lendata[i](2) < 0)
            N_suprper_l(f)++; // count the number of starts and ends of super-periods if seas<0
          Nobs_l(f)++;
        }
      }
    Nobs_l_tot = sum(Nobs_l);
    for (f = 1; f <= Nfleet; f++)
    {
      s = N_suprper_l(f) / 2.;
      if (s * 2 != N_suprper_l(f))
      {
        warnstream << "Error: unequal number of length superperiod starts and stops ";
        write_message(FATAL, 0);
      }
      else
      { // to get the number of superperiods
        N_suprper_l(f) = s;
      }
    }

    echoinput << "Lendata Nobs by fleet " << Nobs_l << endl;
    echoinput << "Lendata superperiods by fleet " << N_suprper_l << endl;
  }
  else
  {
    nobsl_rd = 0;
    Nobs_l = 0;
    Nobs_l_tot = 0;
    N_suprper_l = 0;
  }
  // clang-format off
 END_CALCS

  imatrix Len_time_t(1,Nfleet,1,Nobs_l);
  imatrix Len_time_ALK(1,Nfleet,1,Nobs_l);
  3darray obs_l(1,Nfleet,1,Nobs_l,1,nlen_bin2);
  4darray obs_l_all(1,4,0,nseas,1,Nfleet,1,nlen_bin); // for the sum of all length comp data
  matrix offset_l(1,Nfleet,1,Nobs_l); // Compute OFFSET for multinomial (i.e, value for the multinonial function
  matrix  nsamp_l(1,Nfleet,1,Nobs_l);
  matrix  nsamp_l_read(1,Nfleet,1,Nobs_l);
  imatrix  gen_l(1,Nfleet,1,Nobs_l);
  imatrix  mkt_l(1,Nfleet,1,Nobs_l);
  3darray header_l_rd(1,Nfleet,1,Nobs_l,0,5);
  3darray header_l(1,Nfleet,1,Nobs_l,0,3);
  3darray tails_l(1,Nfleet,1,Nobs_l,1,4); // min-max bin for females; min-max bin for males
  ivector tails_w(1,4);

// arrays for Super-years
  imatrix suprper_l1(1,Nfleet,1,N_suprper_l);
  imatrix suprper_l2(1,Nfleet,1,N_suprper_l);
  matrix  suprper_l_sampwt(1,Nfleet,1,Nobs_l); // will contain calculated weights for obs within super periods
  int floop;
  int tloop;

 LOCAL_CALCS
  // clang-format on
  //  SS_Label_Info_2.7.5 #Process length comps, compress tails, add constant, scale to 1.0
  N_suprper_l = 0;
  Nobs_l = 0;
  in_superperiod = 0;
  suprper_l1.initialize();
  suprper_l2.initialize();
  obs_l_all.initialize();

  if (Nobs_l_tot > 0)
  {
    echoinput << "process length comps " << endl;
    for (floop = 1; floop <= Nfleet; floop++) // loop fleets
      for (i = 0; i <= nobsl_rd - 1; i++) // loop all observations to find those for this fleet/time
      {
        y = lendata[i](1);
        if (y > endyr + 50)
        {
          warnstream << "forecast length obs cannot be beyond endyr +50;";
          write_message(FATAL, 0);
        }
        if (y >= styr)
        {
          f = abs(lendata[i](3));
          if (f == floop)
          {
            timing_input(1, 3) = lendata[i](1, 3);
            get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);

            Nobs_l(f)++;
            j = Nobs_l(f);
            f = abs(lendata[i](3));
            t = timing_i_result(2);
            s = timing_i_result(3);
            ALK_time = timing_i_result(5);

            Len_time_t(f, j) = t; // sequential time = year+season
            Len_time_ALK(f, j) = ALK_time;
            if (data_time(ALK_time, f, 1) < 0.0) // so first occurrence of data at ALK_time,f
            { // real_month,fraction of season, year.fraction
              data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
            }
            else if (timing_r_result(1) != data_time(ALK_time, f, 1))
            {
              warnstream << "LENGTH: data_month already set for y,m,f: " << y << " " << timing_r_result(1) << " " << f << " to real month: " << data_time(ALK_time, f, 1) << "  so treat as replicate";
              write_message(WARN, 0);
            }

            have_data(ALK_time, 0, 0, 0) = 1;
            have_data(ALK_time, f, 0, 0) = 1; //  so have data of some type
            have_data(ALK_time, f, data_type, 0)++; //  count the number of observations in this subseas
            p = have_data(ALK_time, f, data_type, 0);
            have_data(ALK_time, f, data_type, p) = j; //  store data index for the p'th observation in this subseas
            have_data_yr(y, f) = 1; //  survey or comp data exist this year
            have_data_yr(y, 0) = 1;

            if (s > nseas)
            {
              warnstream << " Critical error, season for length obs " << i << " is > nseas";
              write_message(FATAL, 0);
            }

            if (lendata[i](6) < 0.0)
            {
              warnstream << "negative values not allowed for lengthcomp sample size, use -fleet to omit from -logL";
              write_message(FATAL, 0);
            }
            header_l(f, j, 1) = y;
            if (lendata[i](2) < 0)
            {
              header_l(f, j, 2) = -timing_r_result(1); // month with sign to indicate super period
            }
            else
            {
              header_l(f, j, 2) = timing_r_result(1); // month
            }

            header_l_rd(f, j)(1, 5) = lendata[i](1, 5); // values as in input file
            header_l(f, j, 3) = lendata[i](3);
//            header_l(f, j)(3, 5) = lendata[i](3, 5);
            if (y > retro_yr)
              header_l(f, j, 3) = -f;
            if (header_l(f, j, 3) > 0)
              Nobs_l_use(f)++;
            // note that following storage is redundant with Show_Time(t,3) calculated later
            header_l(f, j, 0) = float(y) + 0.01 * int(100. * (azero_seas(s) + seasdur_half(s))); //
            gen_l(f, j) = lendata[i](4); // gender 0=combined, 1=female, 2=male, 3=both
            mkt_l(f, j) = lendata[i](5); // partition: 0=all, 1=discard, 2=retained
            nsamp_l_read(f, j) = lendata[i](6); // assigned sample size for observation
            nsamp_l(f, j) = nsamp_l_read(f, j);
            //  SS_Label_Info_2.7.6 #Create super-periods for length compositions
            if (lendata[i](2) < 0) // start/stop a super-period  ALL observations must be continguous in the file
            {
              if (in_superperiod == 0) // start a super-period  ALL observations must be continguous in the file
              {
                N_suprper_l(f)++;
                suprper_l1(f, N_suprper_l(f)) = j;
                in_superperiod = 1;
              }
              else if (in_superperiod == 1) // end a super-year
              {
                suprper_l2(f, N_suprper_l(f)) = j;
                in_superperiod = 0;
              }
            }

            for (z = 1; z <= nlen_bin2; z++) // get the composition vector
            {
              obs_l(f, j, z) = lendata[i](6 + z);
            }

            if (sum(obs_l(f, j)) <= 0.0)
            {
              warnstream << "zero fish in size comp (fleet, year) " << f << " " << y;
              write_message(FATAL, 0);
            }
            if (nsamp_l_read(f, j) <= 0.0)
            {
              warnstream << "Input N is <=0.0 in length comp " << header_l_rd(f, j);
              write_message(FATAL, 0);
            }
            tails_l(f, j, 1) = 1;
            tails_l(f, j, 2) = nlen_bin;
            tails_l(f, j, 3) = nlen_binP;
            tails_l(f, j, 4) = nlen_bin2;
            if (gen_l(f, j) == 3 && gender == 2 && CombGender_L(mkt_l(f, j), f) > 0)
            {
              for (z = 1; z <= CombGender_L(mkt_l(f, j), f); z++)
              {
                obs_l(f, j, z) += obs_l(f, j, z + nlen_bin);
                obs_l(f, j, z + nlen_bin) = 0.0;
              }
              tails_l(f, j, 3) = nlen_binP + CombGender_L(mkt_l(f, j), f);
            }
            if (gen_l(f, j) == 2) // zero out females for male-only obs
              obs_l(f, j)(1, nlen_bin) = 0.;
            if (gen_l(f, j) <= 1 && gender == 2) // zero out males for female-only or combined gender obs
              obs_l(f, j)(nlen_binP, nlen_bin2) = 0.;
            obs_l(f, j) /= sum(obs_l(f, j)); // make sum to 1.00

            if (gen_l(f, j) != 2) // do females, unless Male-only observation
            {
              k = 0;
              temp = sum(obs_l(f, j)(1, nlen_bin)); // sum of females proportions
              for (z = 1; z <= nlen_bin; z++)
                if (obs_l(f, j, z) > 0.) // find Number of bins with data
                {
                  k++;
                }
              if (temp > 0.0 && k > 1) // only compress tail if obs exist for this gender and there is more than 1 bin with data
              {
                k = 0;
                for (z = 1; z <= nlen_bin - 1; z++) // compress Female lower tail until exceeds min_tail
                {
                  if (obs_l(f, j, z) <= min_tail_L(mkt_l(f, j), f) && k == 0)
                  {
                    obs_l(f, j, z + 1) += obs_l(f, j, z);
                    obs_l(f, j, z) = 0.00;
                    tails_l(f, j, 1) = z + 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }

                k = 0;
                for (z = nlen_bin; z >= tails_l(f, j, 1); z--) // compress Female upper tail until exceeds min_tail
                {
                  if ((obs_l(f, j, z) <= min_tail_L(mkt_l(f, j), f) && k == 0) || z > (nlen_bin - AccumBin_L(mkt_l(f, j), f)))
                  {
                    obs_l(f, j, z - 1) += obs_l(f, j, z);
                    obs_l(f, j, z) = 0.00;
                    tails_l(f, j, 2) = z - 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }
              }
              obs_l(f, j)(tails_l(f, j, 1), tails_l(f, j, 2)) += min_comp_L(mkt_l(f, j), f); // add min_comp to bins in range
            }

            if (gen_l(f, j) >= 2 && gender == 2) // process males
            {
              k = 0;
              temp = sum(obs_l(f, j)(nlen_binP, nlen_bin2));
              for (z = nlen_binP; z <= nlen_bin2; z++)
                if (obs_l(f, j, z) > 0.)
                {
                  k++;
                }
              if (temp > 0.0 && k > 1) // only compress tail if obs exist for this gender and there is more than 1 bin with data
              {
                k = 0;
                k1 = tails_l(f, j, 3);
                for (z = k1; z <= nlen_bin2 - 1; z++)
                {
                  if (obs_l(f, j, z) <= min_tail_L(mkt_l(f, j), f) && k == 0)
                  {
                    obs_l(f, j, z + 1) += obs_l(f, j, z);
                    obs_l(f, j, z) = 0.00;
                    tails_l(f, j, 3) = z + 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }

                k = 0;
                for (z = nlen_bin2; z >= tails_l(f, j, 3); z--) // compress Male upper tail until exceeds min_tail
                {
                  if ((obs_l(f, j, z) <= min_tail_L(mkt_l(f, j), f) && k == 0) || z > (nlen_bin2 - AccumBin_L(mkt_l(f, j), f)))
                  {
                    obs_l(f, j, z - 1) += obs_l(f, j, z);
                    obs_l(f, j, z) = 0.00;
                    tails_l(f, j, 4) = z - 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }
              }
              obs_l(f, j)(tails_l(f, j, 3), tails_l(f, j, 4)) += min_comp_L(mkt_l(f, j), f); // add min_comp to bins in range
            } // end doing males
            obs_l(f, j) /= sum(obs_l(f, j)); // make sum to 1.00 again after adding min_comp
            if (gender == 1 || gen_l(f, j) != 2)
            { //  females or combined
              obs_l_all(1, s, f)(1, nlen_bin) += obs_l(f, j)(1, nlen_bin);
            }
            if (gender == 2)
            {
              if (gen_l(f, j) == 1 || gen_l(f, j) == 3) // put females into female only
              {
                obs_l_all(3, s, f)(1, nlen_bin) += obs_l(f, j)(1, nlen_bin);
              }
              if (gen_l(f, j) >= 2) // put males into combined and into male only
              {
                for (z = 1; z <= nlen_bin; z++)
                {
                  obs_l_all(1, s, f, z) += obs_l(f, j, nlen_bin + z);
                  obs_l_all(4, s, f, z) += obs_l(f, j, nlen_bin + z);
                }
              }
            }
          }
        }
      }
  }

  echoinput << "Overall_Compositions" << endl
            << "seas fleet len_bins " << len_bins_dat << endl;
  for (f = 1; f <= Nfleet; f++)
  {
    for (s = 1; s <= nseas; s++)
    {
      for (j = 1; j <= 4; j++)
      {
        if (j != 2)
        {
          temp = sum(obs_l_all(j, s, f));
          if (temp > 0.0)
          {
            obs_l_all(j, s, f) /= temp;
          }
          else
          {
            obs_l_all(j, s, f) = float(1. / nlen_bin);
          }
        }
      }
      obs_l_all(2, s, f, 1) = obs_l_all(1, s, f, 1); // first bin
      for (z = 2; z <= nlen_bin; z++)
      {
        obs_l_all(2, s, f, z) = obs_l_all(2, s, f, z - 1) + obs_l_all(1, s, f, z);
      }
      if (Nobs_l(f) > 0)
      {
        echoinput << s << " " << f << " freq" << obs_l_all(1, s, f) << endl;
        echoinput << s << " " << f << " cuml" << obs_l_all(2, s, f) << endl;
        echoinput << s << " " << f << " female" << obs_l_all(3, s, f) << endl;
        echoinput << s << " " << f << " male" << obs_l_all(4, s, f) << endl;
      }
    }
  }
  echoinput << "Successful processing of length data" << endl
            << endl;
  // clang-format off
 END_CALCS


!!//  SS_Label_Info_2.8 #Start age composition data section
!!//  SS_Label_Info_2.8.1 #Read Age bin and ageing error vectors
  int n_abins; // age classes for data
  int n_abins1;
  int n_abins2;
  int Use_AgeKeyZero;  //  set to ageerr_type for the age data that use parameter approach
  int AgeKeyParm;  //  holds starting parm number for age error parameters
  int store_agekey_add;  //  when parameter based key uses blocks, this stores dimension
  int save_agekey_count;  //  counter for storing those keys
  int AgeKey_StartAge;
  int AgeKey_Linear1;
  int AgeKey_Linear2;
  int N_ageerr ;  // number of ageing error matrices to be calculated
  vector min_tail_A(1,Nfleet);  //min_proportion_for_compressing_tails_of_observed_composition
  vector min_comp_A(1,Nfleet);  //  small value added to each composition bins
  ivector CombGender_A(1,Nfleet);  //  combine genders through this age bin (0 or -1 for no combine)
  ivector AccumBin_A(1,Nfleet);  //  collapse bins down to this bin number (0 for no collapse; positive value for N to accumulate)
  ivector Comp_Err_A(1,Nfleet);  //  composition error type
  ivector Comp_Err_A2(1,Nfleet);  //  composition error definition used
  vector min_sample_size_A(1,Nfleet);  // minimum sample size
  int Nobs_a_tot;
  int nobsa_rd;
  int Lbin_method;  //#_Lbin_method: 1=poplenbins; 2=datalenbins; 3=lengths
  int CombGender_a;  //  combine genders through this age bin
  ivector Nobs_a(1,Nfleet);
  ivector Nobs_a_use(1,Nfleet);
  ivector N_suprper_a(1,Nfleet);      // N super_yrs per obs

 LOCAL_CALCS
    // clang-format o
    Use_AgeKeyZero = 0;
    N_ageerr = 0;
    n_abins1 = 0;
    n_abins2 = 0;
    nobsa_rd = 0;
    store_agekey_add = 0;
    Nobs_a.initialize();
    Nobs_a_use.initialize();
    N_suprper_a.initialize();
    Comp_Err_A.initialize();
    Comp_Err_A2.initialize();
    echoinput << "Enter the number of agebins, or 0 if no age data" << endl;
    *(ad_comm::global_datafile) >> n_abins;
    echoinput << n_abins << " N age bins " << endl;
    n_abins1 = n_abins + 1;
    n_abins2 = gender * n_abins;
    // clang-format off
 END_CALCS

  vector age_bins1(1,n_abins); // age classes for data
  vector age_bins(1,n_abins2); // age classes for data  female then male end-to-end
  vector age_bins_mean(1,n_abins2);  //  holds mean age for each data age bin
  3darray age_err_rd(1,1,1,1,0,0);

 LOCAL_CALCS
  // clang-format on
  age_bins1.initialize();
  age_bins.initialize();
  age_bins_mean.initialize();

  if (n_abins > 0)
  {
    *(ad_comm::global_datafile) >> age_bins1;
    echoinput << age_bins1 << " agebins " << endl;

    *(ad_comm::global_datafile) >> N_ageerr; // number of ageing error matrices to be calculated
    echoinput << N_ageerr << " N age error defs " << endl;

    age_err_rd.deallocate();
    age_err_rd.allocate(1, N_ageerr, 1, 2, 0, nages);
    age_err_rd.initialize();
    for (j = 1; j <= N_ageerr; j++)
    {
      *(ad_comm::global_datafile) >> age_err_rd(j, 1)(0, nages);
      *(ad_comm::global_datafile) >> age_err_rd(j, 2)(0, nages);
    }
    Nobs_a = 0;
    N_suprper_a = 0;
    if (n_abins > 0)
    {
      echoinput << "ageerror_definitions_as_read" << endl
                << age_err_rd << endl;
      Use_AgeKeyZero = 0;
      if (N_ageerr > 0)
      {
        for (i = 1; i <= N_ageerr; i++)
        {
          if (age_err_rd(i, 2, 0) < 0.)
          { //  set flag for setup of age error parameters
            if (Use_AgeKeyZero > 0)
            {
              warnstream << "Error: There are > 1 negative sd values for age 0 in age error definitions." << endl;
              warnstream << "       but SS3 can only create 1 age error definition from parameters, ";
              write_message(FATAL, 1);
            }
            Use_AgeKeyZero = i;
          }
        }
      }

      echoinput << "#_now read for each fleet info for processing the age comps:" << endl;
      echoinput << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
      echoinput << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
      echoinput << "#_males and females treated as combined gender below this bin number " << endl;
      echoinput << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
      echoinput << "#_Comp_Error:  0=multinomial, 1=dirichlet using theta * n, 2=dirichlet using beta, 3=MV_Tweedie with phi and power"<<endl;
      echoinput << "#_Comp_ERR-2:  index of parameter (pair for Tweedie) to use, cumulative count after DM parms for length comp"<<endl;
      echoinput << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;

      for (f = 1; f <= Nfleet; f++)
      {
        *(ad_comm::global_datafile) >> min_tail_A(f);
        *(ad_comm::global_datafile) >> min_comp_A(f);
        if (min_comp_A(f) <= 0) {
          warnstream << "addtocomp input for age comps fleet " << f << 
          " is " << min_comp_A(f) << " but should be > 0 to avoid log(0) in likelihood";
          write_message(WARN, 0);      
        }
        *(ad_comm::global_datafile) >> CombGender_A(f);
        *(ad_comm::global_datafile) >> AccumBin_A(f);
        *(ad_comm::global_datafile) >> Comp_Err_A(f);
        *(ad_comm::global_datafile) >> Comp_Err_A2(f);
        *(ad_comm::global_datafile) >> min_sample_size_A(f);
        echoinput << min_tail_A(f) << " " << min_comp_A(f) << " " << CombGender_A(f) << " " << AccumBin_A(f) << " " << Comp_Err_A(f) << " " << Comp_Err_A2(f) << " " << min_sample_size_A(f) << "  #_fleet: " << f << " " << fleetname(f) << endl;

        if (min_sample_size_A(f) < 0.001)
        {
          warnstream << "minimum sample size for age comps must be > 0; minimum sample size set to 0.001 ";
          write_message(WARN, 0);
          min_sample_size_A(f) = 0.001;
        }
        if (Comp_Err_A2(f) > Comp_Err_ParmCount + 1)
        {
          warnstream << "Age D-M must refer to existing comp_err definition, or increment by 1:  " << Comp_Err_A2(f);
          write_message(FATAL, 0);
        }
        else if (Comp_Err_A2(f) > Comp_Err_ParmCount)
        {
          Comp_Err_ParmCount++;
          int parti = 0;
          DM_parmlist(parti, f + Nfleet) = 1;  // flag for creating new definition because Comp_Err_L2 can point to existing parameter
        }
        //  else OK because refers to existing definition
      }
      echoinput << "number of D-M definitions needed for both length and age comp data: " << Comp_Err_ParmCount << endl;
  
      *(ad_comm::global_datafile) >> Lbin_method;
      echoinput << Lbin_method << " Lbin method for defined size ranges " << endl;

      if (nobsa_rd > 0 && N_ageerr == 0)
      {
        warnstream << "must define ageerror vectors because age data exist";
        write_message(FATAL, 0);
      }
      for (f = 1; f <= Nfleet; f++)
      {
        if (CombGender_A(f) > n_abins2)
        {
          warnstream << "Combgender_A(f) cannot be greater than n_abins for fleet:_" << f << "; resetting";
          write_message(WARN, 0);
          CombGender_A(f) = n_abins2;
        }
      }
      for (b = 1; b <= n_abins; b++)
      {
        age_bins(b) = age_bins1(b);

        if (b < n_abins)
        {
          age_bins_mean(b) = (age_bins1(b) + age_bins1(b + 1)) * 0.5;
        }
        else if (b > 1)
        {
          age_bins_mean(b) = age_bins1(b) + 0.5 * (age_bins1(b) - age_bins1(b - 1));
        }
        else
        {
          age_bins_mean(b) = age_bins1(b) + 0.5;
        }

        if (gender == 2)
        {
          age_bins(b + n_abins) = age_bins1(b);
          age_bins_mean(b + n_abins) = age_bins_mean(b);
        }
      }
      //  SS_Label_Info_2.8.2 #Read Age data
      k = 9 + n_abins2;
      ender = 0;
      z = 0;
      do
      {
        dvector tempvec(1, k);
        *(ad_comm::global_datafile) >> tempvec(1, k);
        if (sum(tempvec) == 0.0)
        {
          warnstream << "reading past end of file for age data; exit ";
          write_message(FATAL, 0);
        }
        if (tempvec(1) == -9999.)
          ender = 1;
        z++;
        if (z <= 2)
          echoinput << "age_obs_#:" << z << " # " << tempvec(1, k) << endl;
        Age_Data.push_back(tempvec(1, k));
      } while (ender == 0);
      nobsa_rd = Age_Data.size() - 1;
      echoinput << nobsa_rd << " N age comp observations " << endl;
      if (nobsa_rd > 0)
        echoinput << "age_obs_#:" << nobsa_rd << " # " << Age_Data[nobsa_rd - 1] << endl;

      data_type = 5; // for age data

      for (i = 0; i <= nobsa_rd - 1; i++)
      {
        y = Age_Data[i](1);
        if (y >= styr)
        {
          f = abs(Age_Data[i](3));
          if (Age_Data[i](9) < 0)
          {
            warnstream << "Error: negative sample size in age data no longer valid as indicator of skip data or superperiods ";
            write_message(FATAL, 0);
          }
          if (Age_Data[i](6) == 0 || Age_Data[i](6) > N_ageerr)
          {
            warnstream << "Error: undefined age_error type: " << Age_Data[i](6) << "  in obs: " << i;
            write_message(FATAL, 0);
          }
          if (Age_Data[i](2) < 0)
            N_suprper_a(f)++; // count the number of starts and ends of super-periods if seas<0 or sampsize<0

          Nobs_a(f)++;
        }
      }
      for (f = 1; f <= Nfleet; f++)
      {
        s = N_suprper_a(f) / 2.;
        if (s * 2 != N_suprper_a(f))
        {
          warnstream << "Error: unequal number of age superperiod starts and stops ";
          write_message(FATAL, 0);
        }
        else
        {
          N_suprper_a(f) /= 2;
        }
      }
      echoinput << endl
                << "Age_Data Nobs by fleet " << Nobs_a << endl;
      echoinput << "Age_Data superperiods by fleet " << N_suprper_a << endl;
      Nobs_a_tot = sum(Nobs_a);
    }
  }
  else
  {
    echoinput << "N bins set to zero, so no more reading of age data inputs" << endl;
  }
  // clang-format off
 END_CALCS

  matrix offset_a(1,Nfleet,1,Nobs_a); // Compute OFFSET for multinomial (i.e, value for the multinonial function
  imatrix Age_time_t(1,Nfleet,1,Nobs_a);
  imatrix Age_time_ALK(1,Nfleet,1,Nobs_a);
  3darray obs_a(1,Nfleet,1,Nobs_a,1,gender*n_abins);
  4darray obs_a_all(1,4,0,nseas,1,Nfleet,1,n_abins);  //  for the sum of all age comp data
  matrix  nsamp_a(1,Nfleet,1,Nobs_a);
  matrix  nsamp_a_read(1,Nfleet,1,Nobs_a);
  imatrix  ageerr_type_a(1,Nfleet,1,Nobs_a);
  imatrix  gen_a(1,Nfleet,1,Nobs_a);
  imatrix  mkt_a(1,Nfleet,1,Nobs_a);
  3darray  Lbin_filter(1,Nfleet,1,Nobs_a,1,nlength2);
  imatrix  use_Lbin_filter(1,Nfleet,1,Nobs_a);
  imatrix  Lbin_lo(1,Nfleet,1,Nobs_a);
  imatrix  Lbin_hi(1,Nfleet,1,Nobs_a);
  3darray tails_a(1,Nfleet,1,Nobs_a,1,4);   // min-max bin for females; min-max bin for males
  3darray header_a(1,Nfleet,1,Nobs_a,1,9);
  3darray header_a_rd(1,Nfleet,1,Nobs_a,2,3);

// arrays for Super-years
  matrix  suprper_a_sampwt(1,Nfleet,1,Nobs_a);  //  will contain calculated weights for obs within super periods
  imatrix suprper_a1(1,Nfleet,1,N_suprper_a);
  imatrix suprper_a2(1,Nfleet,1,N_suprper_a);

  //  SS_Label_Info_2.8.3 #Pre-process age comps, compress tails, define length bin filters
 LOCAL_CALCS
  // clang-format on
  Lbin_filter = 1.;
  use_Lbin_filter.initialize(); // have to use initialize; imatrix cannot be set to a constant
  suprper_a1.initialize();
  suprper_a2.initialize();
  obs_a_all.initialize();
  N_suprper_a = 0;
  Nobs_a = 0;
  in_superperiod = 0;

  if (Nobs_a_tot > 0)
  {
    echoinput << "process age comps " << endl;
    for (floop = 1; floop <= Nfleet; floop++)
      for (i = 0; i <= nobsa_rd - 1; i++)
      {
        y = Age_Data[i](1);
        if (y > endyr + 50)
        {
          warnstream << "forecast age obs cannot be beyond endyr +50; SS3 will exit";
          write_message(FATAL, 0);
        }
        if (y >= styr)
        {
          f = abs(Age_Data[i](3));
          if (f == floop)
          {
            timing_input(1, 3) = Age_Data[i](1, 3);
            get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);
            Nobs_a(f)++; //  redoing this pointer just to create index j used below
            j = Nobs_a(f);

            f = abs(Age_Data[i](3));
            t = timing_i_result(2);
            s = timing_i_result(3);
            ALK_time = timing_i_result(5);
            Age_time_t(f, j) = t; // sequential time = year+season
            Age_time_ALK(f, j) = ALK_time;
            if (data_time(ALK_time, f, 1) < 0.0) // so first occurrence of data at ALK_time,f
            { // real_month,fraction of season, year.fraction
              data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
            }
            else if (timing_r_result(1) != data_time(ALK_time, f, 1))
            {
              warnstream << "AGE: data_month already set for y,m,f: " << y << " " << timing_r_result(1) << " " << f << " to real month: " << data_time(ALK_time, f, 1) << "  so treat as replicate";
              write_message(WARN, 0);
            }
            have_data(ALK_time, 0, 0, 0) = 1;
            have_data(ALK_time, f, 0, 0) = 1; //  so have data of some type
            have_data(ALK_time, f, data_type, 0)++; //  count the number of observations in this subseas
            p = have_data(ALK_time, f, data_type, 0);
            if (p > 150)
            {
              warnstream << "fatal:  max agecomp obs per fleet*time is 150; you requested " << p << " for fleet x year " << f << " " << y;
              write_message(FATAL, 0);
            }
            have_data(ALK_time, f, data_type, p) = j; // store data index for the p'th observation in this subseas
            have_data_yr(y, f) = 1;
            have_data_yr(y, 0) = 1; //  survey or comp data exist this year

            if (s > nseas)
            {
              warnstream << "Critical error, season for age obs " << i << " is > nseas";
              write_message(FATAL, 0);
            }

            if (Age_Data[i](6) < 0.0)
            {
              warnstream << "negative values not allowed for age comp sample size, use -fleet to omit from -logL";
              write_message(WARN, 0);
            }
            header_a(f, j)(1, 9) = Age_Data[i](1, 9);
            header_a_rd(f, j)(2, 3) = Age_Data[i](2, 3);
            if (Age_Data[i](2) < 0)
            {
              header_a(f, j, 2) = -timing_r_result(1); //  month with sign for super periods
            }
            else
            {
              header_a(f, j, 2) = timing_r_result(1); // month
            }
            if (y > retro_yr)
              header_a(f, j, 3) = -f;
            if (header_a(f, j, 3) > 0)
              Nobs_a_use(f)++;
            gen_a(f, j) = Age_Data[i](4); // gender 0=combined, 1=female, 2=male, 3=both
            mkt_a(f, j) = Age_Data[i](5); // partition: 0=all, 1=discard, 2=retained
            nsamp_a_read(f, j) = Age_Data[i](9); // assigned sample size for observation
            nsamp_a(f, j) = nsamp_a_read(f, j);

            if (Age_Data[i](6) > N_ageerr)
            {
              warnstream << " ageerror type must be <= " << N_ageerr;
              write_message(FATAL, 0);
            }
            ageerr_type_a(f, j) = Age_Data[i](6);

            //  SS_Label_Info_2.8.4 #Create super-periods for age compositions
            if (in_superperiod == 0 && Age_Data[i](2) < 0) // start a super-year  ALL observations must be continguous in the file
            {
              N_suprper_a(f)++;
              suprper_a1(f, N_suprper_a(f)) = j;
              in_superperiod = 1;
            }
            else if (in_superperiod == 1 && Age_Data[i](2) < 0) // end a super-year
            {
              suprper_a2(f, N_suprper_a(f)) = j;
              in_superperiod = 0;
            }

            for (b = 1; b <= gender * n_abins; b++) // get the composition vector
            {
              obs_a(f, j, b) = Age_Data[i](9 + b);
            }
            if (sum(obs_a(f, j)) <= 0.0)
            {
              warnstream << " zero fish in age comp " << header_a(f, j);
              write_message(FATAL, 0);
            }
            if (nsamp_a_read(f, j) <= 0.0)
            {
              warnstream << "Input N is <=0.0 in age comp " << header_a_rd(f, j);
              write_message(FATAL, 0);
            }

            Lbin_lo(f, j) = Age_Data[i](7);
            Lbin_hi(f, j) = Age_Data[i](8);
            switch (Lbin_method) //  here all 3 methods are converted to poplenbins for use internally
            {
              case 1: // values are population length bin numbers
              {
                if (Lbin_lo(f, j) <= 0)
                  Lbin_lo(f, j) = 1;
                if (Lbin_hi(f, j) <= 0 || Lbin_hi(f, j) > nlength)
                  Lbin_hi(f, j) = nlength;
                break;
              }
              case 2: // values are data length bin numbers
              {
                if (Lbin_lo(f, j) <= 0)
                  Lbin_lo(f, j) = 1;
                if (Lbin_hi(f, j) <= 0 || Lbin_hi(f, j) > nlen_bin)
                  Lbin_hi(f, j) = nlen_bin;
                s = 0;
                for (k = 1; k <= nlength; k++)
                { //  find poplen bin that matches data len bin
                  if (len_bins(k) == len_bins_dat(Lbin_lo(f, j)))
                    s = k;
                }
                if (s == 0)
                {
                  warnstream << "L_bin_lo no match to poplenbins in age comp " << header_a(f, j);
                  write_message(FATAL, 0);
                }
                Lbin_lo(f, j) = s;

                s = 0;
                for (k = 1; k <= nlength; k++)
                {
                  if (len_bins(k) == len_bins_dat(Lbin_hi(f, j)))
                    s = k; //  find poplen bin that matches data len bin
                }
                if (s == 0)
                {
                  warnstream << "L_bin_hi no match to poplenbins in age comp " << header_a(f, j);
                  write_message(FATAL, 0);
                }
                Lbin_hi(f, j) = s;
                break;
              }
              case 3: // values are lengths
              {
                if (Lbin_lo(f, j) <= 0)
                  Lbin_lo(f, j) = len_bins(1);
                if (Lbin_hi(f, j) <= 0 || Lbin_hi(f, j) > len_bins(nlength))
                  Lbin_hi(f, j) = len_bins(nlength);
                s = 0;
                for (k = 1; k <= nlength; k++)
                {
                  if (len_bins(k) == Lbin_lo(f, j))
                    s = k; //  find poplen bin that matches input length for lbin_lo
                }
                if (s == 0)
                {
                  warnstream << "L_bin_lo no match to poplenbins in age comp " << header_a(f, j);
                  write_message(FATAL, 0);
                }
                Lbin_lo(f, j) = s;

                s = 0;
                for (k = 1; k <= nlength; k++)
                {
                  if (len_bins(k) == Lbin_hi(f, j))
                    s = k;
                }
                if (s == 0)
                {
                  warnstream << "L_bin_hi no match to poplenbins in age comp " << header_a(f, j);
                  write_message(FATAL, 0);
                }
                Lbin_hi(f, j) = s;
                break;
              }
            }

            //  lbin_lo and lbin_hi are now in terms of poplenbins; their original values are retained in header_a
            if (Lbin_lo(f, j) > nlength || Lbin_lo(f, j) > Lbin_hi(f, j))
            {
              warnstream << "L_bin_lo is too high in age comp.  Are you using lengths or bin numbers? " << header_a(f, j);
              write_message(FATAL, 0);
            }
            if (Lbin_lo(f, j) == 1 && Lbin_hi(f, j) == nlength)
            {
              use_Lbin_filter(f, j) = 0;
            }
            else
            {
              use_Lbin_filter(f, j) = 1;
            }

            if (use_Lbin_filter(f, j) == 1)
            { // use Lbin_filter for this obs
              Lbin_filter(f, j) = 0.;
              Lbin_filter(f, j)(Lbin_lo(f, j), Lbin_hi(f, j)) = 1;
              if (gender == 2)
              {
                k = int(Lbin_lo(f, j)) + nlength;
                z = int(Lbin_hi(f, j)) + nlength;
                Lbin_filter(f, j)(k, z) = 1.;
              }
            }

            if (gen_a(f, j) == 2)
              obs_a(f, j)(1, n_abins) = 0.; //  zero out females for male-only obs
            if (gen_a(f, j) <= 1 && gender == 2)
              obs_a(f, j)(n_abins1, gender * n_abins) = 0.; //  zero out males for female-only or combined gender obs
            tails_a(f, j, 1) = 1;
            tails_a(f, j, 2) = n_abins;
            tails_a(f, j, 3) = 1 + (gender - 1) * n_abins;
            tails_a(f, j, 4) = gender * n_abins;
            if (gender == 2)
            {
              if (gen_a(f, j) == 3 && CombGender_A(f) > 0)
              {
                for (z = 1; z <= CombGender_A(f); z++)
                {
                  obs_a(f, j, z) += obs_a(f, j, z + n_abins);
                  obs_a(f, j, z + n_abins) = 0.0;
                }
                tails_a(f, j, 3) = n_abins + 1 + CombGender_A(f);
              }
            }

            obs_a(f, j) /= sum(obs_a(f, j));

            if (gen_a(f, j) != 2) // do females, unless Male-only observation
            {
              k = 0;
              temp = sum(obs_a(f, j)(1, n_abins));
              for (z = 1; z <= n_abins; z++)
                if (obs_a(f, j, z) > 0.)
                {
                  k++;
                }
              if (temp > 0.0 && k > 1) // only compress tail if obs exist for this gender and there is more than 1 bin with data
              {
                k = 0;
                for (z = 1; z <= n_abins - 1; z++) // compress Female lower tail until exceeds min_tail
                {
                  if (obs_a(f, j, z) <= min_tail_A(f) && k == 0)
                  {
                    obs_a(f, j, z + 1) += obs_a(f, j, z);
                    obs_a(f, j, z) = 0.00;
                    tails_a(f, j, 1) = z + 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }

                k = 0;
                for (z = n_abins; z >= tails_a(f, j, 1); z--) // compress Female upper tail until exceeds min_tail
                {
                  if ((obs_a(f, j, z) <= min_tail_A(f) && k == 0) || (z > (n_abins - AccumBin_A(f))))
                  {
                    obs_a(f, j, z - 1) += obs_a(f, j, z);
                    obs_a(f, j, z) = 0.00;
                    tails_a(f, j, 2) = z - 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }
              }
              obs_a(f, j)(tails_a(f, j, 1), tails_a(f, j, 2)) += min_comp_A(f); // add min_comp to bins in range
            } // done with females

            if (gen_a(f, j) >= 2 && gender == 2) // compress Male tails until exceeds min_tail
            {
              k = 0;
              temp = sum(obs_a(f, j)(n_abins1, n_abins2));
              for (z = n_abins1; z <= n_abins2; z++)
                if (obs_a(f, j, z) > 0.)
                {
                  k++;
                }
              if (temp > 0.0 && k > 1) // only compress tail if obs exist for this gender and there is more than 1 bin with data
              {
                k = 0;

                for (z = n_abins1; z <= n_abins2 - 1; z++)
                {
                  if (obs_a(f, j, z) <= min_tail_A(f) && k == 0)
                  {
                    obs_a(f, j, z + 1) += obs_a(f, j, z);
                    obs_a(f, j, z) = 0.00;
                    tails_a(f, j, 3) = z + 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }

                k = 0;
                for (z = n_abins2; z >= tails_a(f, j, 3); z--) // compress Male upper tail until exceeds min_tail
                {
                  if ((obs_a(f, j, z) <= min_tail_A(f) && k == 0) || (z > (n_abins2 - AccumBin_A(f))))
                  {
                    obs_a(f, j, z - 1) += obs_a(f, j, z);
                    obs_a(f, j, z) = 0.00;
                    tails_a(f, j, 4) = z - 1;
                  }
                  else
                  {
                    k = 1;
                  }
                }
              }
              obs_a(f, j)(tails_a(f, j, 3), tails_a(f, j, 4)) += min_comp_A(f); // add min_comp to bins in range
            }
            if (sum(obs_a(f, j)) > 0.)
              obs_a(f, j) /= sum(obs_a(f, j)); // make sum to 1.00 again after adding min_comp
            s = timing_i_result(3);
            if (gender == 1 || gen_a(f, j) != 2)
              obs_a_all(1, s, f)(1, n_abins) += obs_a(f, j)(1, n_abins); //  females or combined
            if (gender == 2)
            {
              if (gen_a(f, j) == 1 || gen_a(f, j) == 3) // put females into female only
              {
                obs_a_all(3, s, f)(1, n_abins) += obs_a(f, j)(1, n_abins);
              }
              if (gen_a(f, j) >= 2) //  put males into combined and into male only
              {
                for (a = 1; a <= n_abins; a++)
                {
                  obs_a_all(1, s, f, a) += obs_a(f, j, n_abins + a); //  males into combined
                  obs_a_all(4, s, f, a) += obs_a(f, j, n_abins + a); //  males
                }
              }
            }
          }
        }
      }

    echoinput << "area seas fleet age_bins " << age_bins << endl;
    for (s = 1; s <= nseas; s++)
      for (f = 1; f <= Nfleet; f++)
      {
        if (Nobs_a(f) > 0)
        {
          obs_a_all(1, s, f) /= sum(obs_a_all(1, s, f));
        }
        else
        {
          obs_a_all(1, s, f) = 0.0;
        }
        obs_a_all(2, s, f, 1) = obs_a_all(1, s, f, 1); // first bin
        for (a = 2; a <= n_abins; a++)
        {
          obs_a_all(2, s, f, a) = obs_a_all(2, s, f, a - 1) + obs_a_all(1, s, f, a);
        }
        echoinput << fleet_area(f) << " " << s << " " << f << " freq " << obs_a_all(1, s, f) << endl;
        echoinput << fleet_area(f) << " " << s << " " << f << " cuml " << obs_a_all(2, s, f) << endl;
      }
    echoinput << endl
              << "Successful processing of age data " << endl;
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_2.9 #Read mean Size_at_Age data
  init_int use_meansizedata;
  int nobs_ms_tot;
  int nobs_ms_rd;
!!echoinput<<use_meansizedata<<" (0/1) use mean size-at-age data "<<endl;
//  init_matrix sizeAge_Data(1,nobs_ms_rd,1,7+2*n_abins2);
  ivector Nobs_ms(1,Nfleet);
  ivector Nobs_ms_use(1,Nfleet);
  ivector N_suprper_ms(1,Nfleet);      // N super_yrs per obs

 LOCAL_CALCS
  // clang-format on
  Nobs_ms.initialize();
  Nobs_ms_use.initialize();
  N_suprper_ms.initialize();
  if (use_meansizedata > 0)
  {
    k = 7 + 2 * n_abins2;
    ender = 0;
    z = 0;
    do
    {
      dvector tempvec(1, k);
      *(ad_comm::global_datafile) >> tempvec(1, k);
      if (sum(tempvec) == 0.0)
      {
        warnstream << "reading past end of file for size-at-age data; exit ";
        write_message(FATAL, 0);
      }
      if (tempvec(1) == -9999.)
        ender = 1;
      z++;
      if (z <= 2)
        echoinput << "meansize@age_obs_#:" << z << " # " << tempvec(1, k) << endl;
      sizeAge_Data.push_back(tempvec(1, k));
    } while (ender == 0);
    nobs_ms_rd = sizeAge_Data.size() - 1;
    echoinput << nobs_ms_rd << " N size@age obs read " << endl;
    if (nobs_ms_rd > 0)
      echoinput << "meansize@age_obs_#:" << nobs_ms_rd << " # " << sizeAge_Data[nobs_ms_rd - 1] << endl;

    data_type = 7; // for size (length or weight)-at-age data
    Nobs_ms = 0;
    N_suprper_ms = 0;
    if (nobs_ms_rd > 0)
      for (i = 0; i <= nobs_ms_rd - 1; i++)
      {
        y = sizeAge_Data[i](1);
        if (y >= styr)
        {
          f = abs(sizeAge_Data[i](3));
          if (sizeAge_Data[i](7) < 0)
          {
            warnstream << "error.  cannot use negative sampsize for meansize data ";
            write_message(FATAL, 0);
          }
          if (sizeAge_Data[i](2) < 0)
          {
            N_suprper_ms(f)++; // count the number of starts and ends of super-periods if seas<0 or sampsize<0
          }
          Nobs_ms(f)++;
        }
      }
    for (f = 1; f <= Nfleet; f++)
    {
      s = N_suprper_ms(f) / 2.;
      if (s * 2 != N_suprper_ms(f))
      {
        warnstream << "Error: unequal number of meansize superperiod starts and stops ";
        write_message(FATAL, 0);
      }
      else
      {
        N_suprper_ms(f) /= 2;
      }
    }
    echoinput << endl
              << "meansize data Nobs by fleet " << Nobs_ms << endl;
    echoinput << "meansize superperiods by fleet " << N_suprper_ms << endl;

    nobs_ms_tot = sum(Nobs_ms);
  }
  else
  {
    Nobs_ms = 0;
    N_suprper_ms = 0;
    nobs_ms_tot = 0;
  }
  // clang-format off
 END_CALCS

  imatrix msz_time_t(1,Nfleet,1,Nobs_ms);
  imatrix msz_time_ALK(1,Nfleet,1,Nobs_ms);
  3darray obs_ms(1,Nfleet,1,Nobs_ms,1,n_abins2);
  3darray obs_ms_n(1,Nfleet,1,Nobs_ms,1,n_abins2);
  3darray obs_ms_n_read(1,Nfleet,1,Nobs_ms,1,n_abins2);
  imatrix  ageerr_type_ms(1,Nfleet,1,Nobs_ms);
  imatrix  gen_ms(1,Nfleet,1,Nobs_ms);
  imatrix  mkt_ms(1,Nfleet,1,Nobs_ms);
  3darray header_ms(1,Nfleet,1,Nobs_ms,0,7);
  3darray header_ms_rd(1,Nfleet,1,Nobs_ms,2,3);
  matrix suprper_ms_sampwt(1,Nfleet,1,Nobs_ms);
  imatrix suprper_ms1(1,Nfleet,1,N_suprper_ms);
  imatrix suprper_ms2(1,Nfleet,1,N_suprper_ms);

//  note:  sizeAge_Data[i](6) has age error method used; sign is positive to indicate mean length-at-age; negative for mean weight-at-age
 LOCAL_CALCS
  // clang-format on
  Nobs_ms = 0;
  suprper_ms1.initialize();
  suprper_ms2.initialize();
  N_suprper_ms.initialize();
  if (nobs_ms_tot > 0)
  {
    in_superperiod = 0;
    for (floop = 1; floop <= Nfleet; floop++)
      for (i = 0; i <= nobs_ms_rd - 1; i++)
      {
        y = sizeAge_Data[i](1);
        if (y > endyr + 50)
        {
          warnstream << "forecast meansize obs cannot be beyond endyr +50";
          write_message(FATAL, 0);
        }
        if (y >= styr)
        {
          f = abs(sizeAge_Data[i](3));
          if (f == floop)
          {
            timing_input(1, 3) = sizeAge_Data[i](1, 3);
            get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);
            Nobs_ms(f)++;
            j = Nobs_ms(f); // observation counter
            t = timing_i_result(2);
            s = timing_i_result(3);
            real_month = timing_r_result(1);
            ALK_time = timing_i_result(5);
            msz_time_t(f, j) = t;
            msz_time_ALK(f, j) = ALK_time;
            if (data_time(ALK_time, f, 1) < 0.0) // so first occurrence of data at ALK_time,f
            { // real_month,fraction of season, year.fraction
              data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
            }
            else if (timing_r_result(1) != data_time(ALK_time, f, 1))
            {
              warnstream << "LEN@AGE: data_month already set for y,m,f: " << y << " " << timing_r_result(1) << " " << f << " to real month: " << data_time(ALK_time, f, 1) << "  so treat as replicate";
              write_message(WARN, 0);
            }
            have_data(ALK_time, 0, 0, 0) = 1;
            have_data(ALK_time, f, 0, 0) = 1; // so have data of some type
            have_data(ALK_time, f, data_type, 0)++; // count the number of observations in this subseas
            p = have_data(ALK_time, f, data_type, 0);
            have_data(ALK_time, f, data_type, p) = j; // store data index for the p'th observation in this subseas

            if (s > nseas)
            {
              warnstream << " Critical error, season for size-age obs " << i << " is > nseas";
              write_message(FATAL, 0);
            }

            header_ms(f, j)(1, 7) = sizeAge_Data[i](1, 7);
            header_ms_rd(f, j)(2, 3) = sizeAge_Data[i](2, 3);

            //  note that following storage is redundant with Show_Time(t,3) calculated later
            if (y > retro_yr)
              header_ms(f, j, 3) = -f;
            if (sizeAge_Data[i](3) < 0)
              header_ms(f, j, 3) = -f;
            if (header_ms(f, j, 3) > 0)
              Nobs_ms_use(f)++;
            header_ms(f, j, 0) = float(y) + 0.01 * int(100. * (azero_seas(s) + seasdur_half(s))); //

            gen_ms(f, j) = sizeAge_Data[i](4);
            mkt_ms(f, j) = sizeAge_Data[i](5);
            if (abs(sizeAge_Data[i](6)) > N_ageerr)
            {
              warnstream << "in meansize-at-age, ageerror type must be <= " << N_ageerr;
              write_message(FATAL, 0);
            }
            ageerr_type_ms(f, j) = sizeAge_Data[i](6);

            // SS_Label_Info_2.9.1 #Create super-periods for meansize data
            if (sizeAge_Data[i](2) < 0) // start/stop a super-period  ALL observations must be continguous in the file
            {
              header_ms(f, j, 2) = -real_month; //month
              if (in_superperiod == 0) // start superperiod
              {
                N_suprper_ms(f)++;
                suprper_ms1(f, N_suprper_ms(f)) = j;
                in_superperiod = 1;
              }
              else if (in_superperiod == 1) // end a super-period
              {
                suprper_ms2(f, N_suprper_ms(f)) = j;
                in_superperiod = 0;
              }
            }
            else
            {
              header_ms(f, j, 2) = real_month; //month
            }

            for (b = 1; b <= n_abins2; b++)
            {
              obs_ms(f, j, b) = sizeAge_Data[i](7 + b);
            }
            for (b = 1; b <= n_abins2; b++)
            {
              obs_ms_n(f, j, b) = sizeAge_Data[i](7 + b + n_abins2);
              obs_ms_n_read(f, j, b) = sizeAge_Data[i](7 + b + n_abins2);
            }
          }
        }
      }
    echoinput << "Successful read of size-at-age data; N kept = " << Nobs_ms << endl;
  }
  // clang-format off
 END_CALCS


//  SS_Label_Info_2.10 #Read environmental data that will be used to modify processes and expected values
  init_int N_envvar;
  int N_envdata;
 LOCAL_CALCS
  // clang-format on
  echoinput << N_envvar << " N_envvar " << endl;

  ender = 0;
  N_envdata = 0;
  if (N_envvar > 0)
  {
    do
    {
      dvector tempvec(1, 3);
      *(ad_comm::global_datafile) >> tempvec(1, 3);
      if (tempvec(1) == -9999.)
        ender = 1;
      if (sum(tempvec) == 0.0)
      {
        warnstream << "reading past end of file for env data; exit ";
        write_message(FATAL, 0);
      }
      env_temp.push_back(tempvec(1, 3));
    } while (ender == 0);
    N_envdata = env_temp.size() - 1;
    echoinput << " successful read of " << N_envdata << " environmental observations " << endl;
  }
  // clang-format off
 END_CALCS

//  SS_Label_Info_2.11 #Start generalized size composition section
//  SS_Label_Info_2.11.1 #Read generalized size frequency data (aka wt frequency)
  int SzFreqMethod;
  int iobs;
  int SzFreq_Nmeth_rd;                                   // number of sizefreq methods to be read
  int SzFreq_Nmeth;
 LOCAL_CALCS
  *(ad_comm::global_datafile) >> SzFreq_Nmeth_rd;
  if (SzFreq_Nmeth_rd > 0)
  {
      SzFreq_Nmeth = SzFreq_Nmeth_rd; 
  }
  else if  (SzFreq_Nmeth_rd < 0)
  {
    *(ad_comm::global_datafile) >> SzFreq_Nmeth;
  }
  echoinput << SzFreq_Nmeth << " N sizefreq methods to read " << endl;
 END_CALCS

  imatrix SzFreq_HaveObs2(1,SzFreq_Nmeth,1,ALK_time_max);
  init_ivector SzFreq_Nbins(1,SzFreq_Nmeth);               //  number of bins for each method
!!if (SzFreq_Nmeth > 0) echoinput << SzFreq_Nbins << " Sizefreq N bins per method" << endl;
  init_ivector SzFreq_units(1,SzFreq_Nmeth);               //  units for proportions (1 = biomass; 2=numbers ) for each method
!!if (SzFreq_Nmeth > 0) echoinput << SzFreq_units << " Sizetfreq units(1=bio/2=num) per method" << endl;
  init_ivector SzFreq_scale(1,SzFreq_Nmeth);               //  bin scale (1=kg; 2=lbs; 3=cm; 4=in) for each method
!!if (SzFreq_Nmeth > 0) echoinput << SzFreq_scale << " Sizefreq scale(1=kg/2=lbs/3=cm/4=inches) per method" << endl;
  init_vector SzFreq_mincomp(1,SzFreq_Nmeth);         //  mincomp to add for each method
!!if (SzFreq_Nmeth > 0) echoinput << SzFreq_mincomp << " Sizefreq:  add small constant to comps, per method " << endl;
  init_ivector SzFreq_nobs(1,SzFreq_Nmeth);
!!if (SzFreq_Nmeth > 0) echoinput << SzFreq_nobs << " Sizefreq N obs per method" << endl;
  ivector SzFreq_Nbins_seas_g(1,SzFreq_Nmeth*nseas);   //  array dimensioner used only for the SzFreqTrans array
  ivector SzFreq_Nbins3(1,SzFreq_Nmeth);      // doubles the Nbins if gender==2
  int SzFreqMethod_seas;
  ivector Comp_Err_Sz(1,SzFreq_Nmeth);
  ivector Comp_Err_Sz2(1,SzFreq_Nmeth);
  
 LOCAL_CALCS
  // clang-format on
  Comp_Err_Sz.initialize();
  Comp_Err_Sz2.initialize();
  if (SzFreq_Nmeth_rd == -1)
  {
    *(ad_comm::global_datafile) >> Comp_Err_Sz(1,SzFreq_Nmeth);
    echoinput << Comp_Err_Sz << " Sizefreq:  Comp_Err_method " << endl;
    *(ad_comm::global_datafile) >> Comp_Err_Sz2(1,SzFreq_Nmeth);
    echoinput << Comp_Err_Sz2 << " Sizefreq:  Comp_Err_index " << endl;
    for (f = 1; f <= SzFreq_Nmeth; f ++)
    {
      if (Comp_Err_Sz2(f) > Comp_Err_ParmCount + 1)
      {
        warnstream << "Sz D-M must refer to existing index, or increment by 1 to add new definition:  " << Comp_Err_Sz2(f);
        write_message(FATAL, 0);
      }
      else if (Comp_Err_Sz2(f) > Comp_Err_ParmCount)
      {
        Comp_Err_ParmCount++;
        int parti = 0;
        DM_parmlist(parti, f + 2*Nfleet) = 1;  // flag for creating new definition because Comp_Err_Sz2 can point to existing parameter
      }
      //  else OK because refers to existing definition
    }
  }

  SzFreq_units_label += "bio";
  SzFreq_units_label += "numbers";
  SzFreq_scale_label += "kg";
  SzFreq_scale_label += "lbs";
  SzFreq_scale_label += "cm";
  SzFreq_scale_label += "inches";
  g = 0;
  data_type = 6; // for generalized size composition data

  if (SzFreq_Nmeth > 0)
  {
    SzFreq_HaveObs2.initialize();
    for (k = 1; k <= SzFreq_Nmeth; k++)
    {
      if (SzFreq_units(k) == 1 && SzFreq_scale(k) > 2)
      {
        warnstream << "error:  cannot accumulate biomass into length-based szfreq scale for method: " << k;
        write_message(FATAL, 0);
      }
      SzFreq_Nbins3(k) = gender * SzFreq_Nbins(k);
      for (s = 1; s <= nseas; s++)
      {
        g++;
        SzFreq_Nbins_seas_g(g) = SzFreq_Nbins(k) * gender;
      }
    }
  }
  // clang-format off
  echoinput<<"here"<<endl;
 END_CALCS

 !!echoinput<<"bins "<<SzFreq_Nbins<<endl;
  init_matrix SzFreq_bins1(1,SzFreq_Nmeth,1,SzFreq_Nbins);    // lower edge of wt bins
!!if(SzFreq_Nmeth>0) echoinput << " SizeFreq bins-raw " << endl << SzFreq_bins1 << endl;
  matrix SzFreq_bins(1,SzFreq_Nmeth,1,SzFreq_Nbins3);    // szfreq bins as processed and doubled for the males if necessary
  matrix SzFreq_bins2(1,SzFreq_Nmeth,0,SzFreq_Nbins3+1); // as above, but one more bin to aid in the search for bin boundaries
  ivector SzFreq_Omit_Small(1,SzFreq_Nmeth);
  int SzFreq_totobs;
  int SzFreq_N_Like;
  matrix SzFreq_means(1,SzFreq_Nmeth,1,SzFreq_Nbins3);   // szfreq mean size in bins as processed and doubled for the males if necessary

 LOCAL_CALCS
  // clang-format on
  SzFreq_totobs = 0;
  //  SS_Label_Info_2.11.1 #Size comp bins according to scaling method
  if (SzFreq_Nmeth > 0)
  {
    for (k = 1; k <= SzFreq_Nmeth; k++)
    {
      // set flag for accumulating, or not, fish from small pop len bins up into first SzFreq data bin
      // if first bin is positive, then fish smaller than that bin are ignored (omitsmall set =1)
      // if first bin is negative, then smaller fish are accumulated up into that first bin

      SzFreq_Omit_Small(k) = 1;
      if (SzFreq_bins1(k, 1) < 0)
      {
        SzFreq_Omit_Small(k) = -1;
        SzFreq_bins1(k, 1) *= -1; // make this positive for use in model, then write out as negative in data_echo.ss_new
      }

      SzFreq_bins(k)(1, SzFreq_Nbins(k)) = SzFreq_bins1(k)(1, SzFreq_Nbins(k));
      if (gender == 2)
      {
        for (j = 1; j <= SzFreq_Nbins(k); j++)
        {
          SzFreq_bins(k, j + SzFreq_Nbins(k)) = SzFreq_bins1(k, j);
        }
      }
      if (SzFreq_scale(k) == 2) // convert from lbs to kg
      {
        SzFreq_bins(k) *= 0.4536;
      }
      else if (SzFreq_scale(k) == 4) // convert from inches to cm
      {
        SzFreq_bins(k) *= 2.54;
      }
      SzFreq_bins2(k, 0) = 0.;
      SzFreq_bins2(k)(1, SzFreq_Nbins(k)) = SzFreq_bins(k)(1, SzFreq_Nbins(k));
      if (gender == 2)
      {
        SzFreq_bins2(k, SzFreq_Nbins(k) + 1) = 0.;
        for (j = 1; j <= SzFreq_Nbins(k); j++)
        {
          SzFreq_bins2(k, j + SzFreq_Nbins(k) + 1) = SzFreq_bins2(k, j);
        }
      }

      for (z = 1; z <= SzFreq_Nbins(k); z++)
      {
        if (z < SzFreq_Nbins(k))
        {
          SzFreq_means(k, z) = 0.5 * (SzFreq_bins2(k, z) + SzFreq_bins2(k, z + 1)); // this is not gender specific
        }
        else
        {
          SzFreq_means(k, z) = SzFreq_means(k, z - 1) + (SzFreq_bins2(k, z) - SzFreq_bins2(k, z - 1));
        }
        if (gender == 2)
          SzFreq_means(k, z + SzFreq_Nbins(k)) = SzFreq_means(k, z);
      }
      echoinput << "Processed_SizeFreqMethod_bins for method: " << k << endl
                << "low: " << SzFreq_bins(k) << endl
                << "mean: " << SzFreq_means(k) << endl;
    }
    SzFreq_totobs = sum(SzFreq_nobs);
  }
  // clang-format off
 END_CALCS

//  NOTE:  for the szfreq data, which are stored in one list and not by fleet, it is not possible to exclude from the working array on basis of before styr or after retroyr
  ivector SzFreq_Setup(1,SzFreq_totobs);  //  stores the number of bins plus header info to read into ragged array
  ivector SzFreq_Setup2(1,SzFreq_totobs);   //  stores the number of bins for each obs to create the ragged array
  ivector SzFreq_time_t(1,SzFreq_totobs);
  ivector SzFreq_time_ALK(1,SzFreq_totobs);

 LOCAL_CALCS
  // clang-format on
  if (SzFreq_Nmeth > 0)
  {
    g = 0;
    for (k = 1; k <= SzFreq_Nmeth; k++)
      for (j = 1; j <= SzFreq_nobs(k); j++)
      {
        g++;
        SzFreq_Setup(g) = 7 + gender * SzFreq_Nbins(k);
        SzFreq_Setup2(g) = gender * SzFreq_Nbins(k);
      }
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_2.11.2 #Read size comp observations into a ragged array
!!// , with the number of elements for each obs stored in sizefreq_setup
!!//   unlike the size and agecomp, obs from all fleets are in one dimension, rather than having a dimension for fleet
!!//  to do super-period, obs must be sorted by fleet and time within each method
  init_matrix SzFreq_obs1(1,SzFreq_totobs,1,SzFreq_Setup);
!!if(SzFreq_totobs>0) echoinput<<" first sizefreq obs "<<endl<<SzFreq_obs1(1)<<endl<<" last obs"<<endl<<SzFreq_obs1(SzFreq_totobs)<<endl;;
  imatrix SzFreq_obs_hdr(1,SzFreq_totobs,1,9);
  // SzFreq_obs1:     Method, Year, season, Fleet, Gender, Partition, SampleSize, <data>
  // SzFreq_obs_hdr:     1=y; 2=month; 3=f; 4=gender; 5=partition; 6=method&skip flag; 7=first bin to use; 8=last bin(e.g. to include males or not); 9=flag to indicate transition matrix needs calculation
  vector SzFreq_sampleN(1,SzFreq_totobs);
  vector SzFreq_effN(1,SzFreq_totobs);
  vector SzFreq_eachlike(1,SzFreq_totobs);
  vector SzFreq_each_offset(1,SzFreq_totobs);
  matrix SzFreq_obs(1,SzFreq_totobs,1,SzFreq_Setup2);
  imatrix SzFreq_LikeComponent(1,Nfleet,1,SzFreq_Nmeth);
  number N_suprper_SzFreq; // no real need to keep track of these by method, so just use a number
 LOCAL_CALCS
  // clang-format on
  SzFreq_N_Like = 0;
  N_suprper_SzFreq = 0;
  if (SzFreq_Nmeth > 0)
  {
    SzFreq_LikeComponent.initialize();
    SzFreq_obs.initialize();
    SzFreq_eachlike.initialize();
    SzFreq_each_offset.initialize();
    iobs = 0;
    for (k = 1; k <= SzFreq_Nmeth; k++)
    {
      for (j = 1; j <= SzFreq_nobs(k); j++)
      {
        //       if(y>=styr && y<=retro_yr)  // not used because all obs in one list
        iobs++;
        for (z = 1; z <= 5; z++)
        {
          SzFreq_obs_hdr(iobs, z) = SzFreq_obs1(iobs, z + 1);
        }
        SzFreq_sampleN(iobs) = SzFreq_obs1(iobs, 7);
        if (SzFreq_obs1(iobs, 3) < 0)
          N_suprper_SzFreq++; //  count the number of superperiod start/stops
        if (SzFreq_obs_hdr(iobs, 4) == 3) // both genders
        {
          for (z = 1; z <= SzFreq_Setup2(iobs); z++)
          {
            SzFreq_obs(iobs, z) = SzFreq_obs1(iobs, 7 + z);
          }
        }
        else if (SzFreq_obs_hdr(iobs, 4) <= 1) // combined gender or female only
        {
          for (z = 1; z <= SzFreq_Nbins(k); z++)
          {
            SzFreq_obs(iobs, z) = SzFreq_obs1(iobs, 7 + z);
          }
        }
        else // male only
        {
          for (z = SzFreq_Nbins(k) + 1; z <= SzFreq_Setup2(iobs); z++)
          {
            SzFreq_obs(iobs, z) = SzFreq_obs1(iobs, 7 + z);
          }
        }
        if (gender == 1)
          SzFreq_obs_hdr(iobs, 4) = 1; // just in case
        if (sum(SzFreq_obs(iobs)) <= 0.0)
        {
          warnstream << "zero fish in size comp " << SzFreq_obs_hdr(iobs);
          write_message(FATAL, 0);
        }
        if (SzFreq_sampleN(iobs) <= 0.0)
        {
          warnstream << " Input N is <=0.0 in size comp " << SzFreq_obs_hdr(iobs);
          write_message(FATAL, 0);
        }

        f = abs(SzFreq_obs_hdr(iobs, 3));
        SzFreq_obs(iobs) /= sum(SzFreq_obs(iobs));
        SzFreq_obs(iobs) += SzFreq_mincomp(k);
        SzFreq_obs(iobs) /= sum(SzFreq_obs(iobs));
        y = SzFreq_obs_hdr(iobs, 1);
        if (y > endyr + 50)
        {
          warnstream << "forecast sizefreq obs cannot be beyond endyr +50";
          write_message(FATAL, 0);
        }

        timing_input(1, 3) = SzFreq_obs_hdr(iobs)(1, 3);
        timing_input(2) = SzFreq_obs1(iobs, 3);
        get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);

        f = abs(SzFreq_obs_hdr(iobs, 3));
        if (y > retro_yr)
          SzFreq_obs_hdr(iobs, 3) = -f;
        t = timing_i_result(2);
        if (gender == 1)
        {
          SzFreq_obs_hdr(iobs, 4) = 0;
        }
        z = SzFreq_obs_hdr(iobs, 4); // gender
        // get min and max index according to use of 0, 1, 2, 3 gender index
        if (z != 2)
        {
          SzFreq_obs_hdr(iobs, 7) = 1;
        }
        else
        {
          SzFreq_obs_hdr(iobs, 7) = SzFreq_Nbins(k) + 1;
        }
        if (z <= 1)
        {
          SzFreq_obs_hdr(iobs, 8) = SzFreq_Nbins(k);
        }
        else
        {
          SzFreq_obs_hdr(iobs, 8) = 2 * SzFreq_Nbins(k);
        }
        //      SzFreq_obs_hdr(iobs,5);  // partition
        SzFreq_obs_hdr(iobs, 6) = k;
        if (k != SzFreq_obs1(iobs, 1))
        { // save method code for later use
          warnstream << "sizefreq ID # doesn't match ";
          write_message(WARN, 0);
        }
        if (y >= styr)
        {
          ALK_time = timing_i_result(5);
          real_month = timing_r_result(1);

          SzFreq_time_t(iobs) = t;
          SzFreq_time_ALK(iobs) = ALK_time;
          SzFreq_LikeComponent(f, k) = 1; // indicates that this combination is being used
          if (SzFreq_HaveObs2(k, ALK_time) == 0) //  transition matrix needs calculation
          {
            SzFreq_HaveObs2(k, ALK_time) = 1; // flad showing condition met
            SzFreq_obs_hdr(iobs, 9) = 1; //  flag that will be ehecked in ss_expval
          }

          if (data_time(ALK_time, f, 1) < 0.0) //  so first occurrence of data at ALK_time,f
          { // real_month,fraction of season, year.fraction
            data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
          }
          else if (timing_r_result(1) != data_time(ALK_time, f, 1))
          {
            warnstream << "SIZE: data_month already set for y,m,f: " << y << " " << timing_r_result(1) << " " << f << " to real month: " << data_time(ALK_time, f, 1) << "  so treat as replicate";
            write_message(WARN, 0);
          }
          have_data(ALK_time, 0, 0, 0) = 1;
          have_data(ALK_time, f, 0, 0) = 1; //  so have data of some type
          have_data(ALK_time, f, data_type, 0)++; //  count the number of observations in this subseas
          p = have_data(ALK_time, f, data_type, 0);
          have_data(ALK_time, f, data_type, p) = iobs; //  store data index for the p'th observation in this subseas
          have_data_yr(y, f) = 1;
          have_data_yr(y, 0) = 1; //  survey or comp data exist this year

          if (SzFreq_obs_hdr(iobs, 7) < 0)
            SzFreq_obs_hdr(iobs, 3) = -abs(SzFreq_obs_hdr(iobs, 3)); //  old method for excluding from logL
        }
        else
        {
          SzFreq_obs_hdr(iobs, 3) = -abs(SzFreq_obs_hdr(iobs, 3)); //  flag for skipping this obs
          SzFreq_time_t(iobs) = styr;
          SzFreq_time_ALK(iobs) = 1;
        }
      }
    }
    SzFreq_N_Like = sum(SzFreq_LikeComponent);
    if (N_suprper_SzFreq > 0)
    {
      j = N_suprper_SzFreq / 2; // because we counted the begin and end
      if (2 * j != N_suprper_SzFreq)
      {
        warnstream << "unequal number of starts and ends of sizefreq superperiods ";
        write_message(FATAL, 0);
      }
      else
      {
        N_suprper_SzFreq = j;
      }
      echoinput << "N superperiods for sizecomp " << N_suprper_SzFreq << endl;
    }
  }
  // clang-format off
 END_CALCS

// SS_Label_Info_2.11.3 #Calc logL for a perfect fit to the sizefreq data as an offset
    vector offset_Sz_tot(1,SzFreq_N_Like); // this is a constant offset, so can be declared in data section
    ivector suprper_SzFreq_start(1,N_suprper_SzFreq);
    ivector suprper_SzFreq_end(1,N_suprper_SzFreq);
    vector suprper_SzFreq_sampwt(1,SzFreq_totobs); // will contain calculated weights for obs within super periods

 LOCAL_CALCS
  // clang-format on
  if (SzFreq_Nmeth > 0)
  {
    offset_Sz_tot.initialize();
    suprper_SzFreq_start.initialize();
    suprper_SzFreq_end.initialize();
    suprper_SzFreq_sampwt.initialize();
    //     N_suprper_SzFreq=0;  // redo this counter so can use the counter
    //  count the number of type x methods being used to create vector length for the likelihoods
    g = 0;
    for (f = 1; f <= Nfleet; f++)
      for (k = 1; k <= SzFreq_Nmeth; k++)
      {
        if (SzFreq_LikeComponent(f, k) > 0)
        { //  so stored value g gives index in list of logL elements
          g++;
          SzFreq_LikeComponent(f, k) = g;
        }
      }
    //     in_superperiod=0;
    //     for (iobs=1;iobs<=SzFreq_totobs;iobs++)
    //     {
    //       k=SzFreq_obs_hdr(iobs,6);  //  get the method
    //       f=abs(SzFreq_obs_hdr(iobs,3));
    //       s=SzFreq_obs_hdr(iobs,2);  // sign used to indicate start/stop of super period
    //       if(SzFreq_obs_hdr(iobs,3)>0)  // negative for out of range or skip
    //       {
    //         z1=SzFreq_obs_hdr(iobs,7);
    //         z2=SzFreq_obs_hdr(iobs,8);
    //         g=SzFreq_LikeComponent(f,k);
    //         offset_Sz_tot(g)-=SzFreq_sampleN(iobs)*SzFreq_obs(iobs)(z1,z2)*log(SzFreq_obs(iobs)(z1,z2));
    //       }

    // identify super-period starts and stops
    //       if(s<0) // start/stop a super-period  ALL observations must be continguous in the file
    //       {
    //         if(in_superperiod==0)
    //         {
    //           N_suprper_SzFreq++;
    //           suprper_SzFreq_start(N_suprper_SzFreq)=iobs;
    //           in_superperiod=1;
    //         }
    //         else if(in_superperiod==1)  // end a super-period
    //         {
    //           suprper_SzFreq_end(N_suprper_SzFreq)=iobs;
    //           in_superperiod=0;
    //         }
    //       }
    //     }
  }
  echoinput << " finished processing sizefreq data " << endl;
  //  if(N_suprper_SzFreq>0) echoinput<<"sizefreq superperiod start obs: "<<suprper_SzFreq_start<<endl<<"sizefreq superperiod end obs:   "<<suprper_SzFreq_end<<endl;
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_2.12 #Read tag release and recapture data
  int Do_TG_rd;
  int Do_TG;
  int TG;
  int N_TG; // N tag groups
  int N_TG2;
  int TG_timestart;
  int N_TG_recap;   // N recapture events
  int TG_mixperiod; // First period (seasons) to start comparing obs to expected recoveries; period=0 is the release period
  int TG_maxperiods; // max number of periods (seasons) to track recoveries; period=0 is the release period
  int TG_min_recap; // minimum number of tags recaptured to include this TG in the logL
 LOCAL_CALCS
  // clang-format on
  Do_TG = 0;
  *(ad_comm::global_datafile) >> Do_TG_rd;
  echoinput << Do_TG_rd << " Do_TagData(0/1/2) " << endl
            << "#  where 2 indicates additional read of TG_min_recap" << endl;
  if (Do_TG_rd > 0)
  {
    Do_TG = 1;
    *(ad_comm::global_datafile) >> N_TG;
    *(ad_comm::global_datafile) >> N_TG_recap;
    *(ad_comm::global_datafile) >> TG_mixperiod;
    *(ad_comm::global_datafile) >> TG_maxperiods;
    TG_min_recap = 0;
    N_TG2 = N_TG;
    TG_timestart = 9999;
    echoinput << N_TG << " N tag groups " << endl
              << N_TG_recap << " N recapture events" << endl
              << TG_mixperiod << "  Latency period for mixing" << endl
              << TG_maxperiods << " N periods to track recoveries" << endl;
    if (Do_TG_rd == 2)
    {
      *(ad_comm::global_datafile) >> TG_min_recap;
      echoinput << TG_min_recap << " min recaps >= mixperiod for inclusion in logL" << endl;
    }
  }
  else
  {
    N_TG = 0;
    N_TG_recap = 0;
    TG_mixperiod = 0;
    TG_maxperiods = 0;
    TG_min_recap = 0;
    N_TG2 = 1;
    TG_timestart = 1;
  }
  // clang-format off
 END_CALCS

  ivector TG_endtime(1,N_TG2)
  ivector TG_use(1,N_TG2)  //  0/1 flag to indicate N recaptures >= TG_min_recap
  init_matrix TG_release(1,N_TG,1,8)
  // TG area year seas tfill sex age Nrelease
 LOCAL_CALCS
  // clang-format on
  TG_endtime(1) = 0;
  TG_use = 0; // initialize
  if (N_TG > 0)
  {
    echoinput << " Tag Releases " << endl
              << "TG area year seas tfill sex age Nrelease " << endl
              << TG_release << endl;
    for (TG = 1; TG <= N_TG; TG++)
    {
      t = styr + int((TG_release(TG, 3) - styr) * nseas + TG_release(TG, 4) - 1);
      TG_release(TG, 5) = t;
      if (t < TG_timestart)
        TG_timestart = t;
      k = TG_maxperiods;
      if ((t + TG_maxperiods) > TimeMax)
        k -= (t + TG_maxperiods - TimeMax);
      TG_endtime(TG) = k;
    }
  }
  // clang-format off
 END_CALCS

// SS_Label_Info_2.12.1 #Store recapture info by TG group and time to follow it as a cohort
  init_matrix TG_recap_data(1,N_TG_recap,1,5)
  // TG, year, seas, fleet, sex, Nrecap
  3darray TG_recap_obs(1,N_TG2,0,TG_endtime,0,Nfleet);   //  no area index because each fleet is in just one area
 LOCAL_CALCS
  // clang-format on
  if (N_TG > 0)
  {
    echoinput << "First row of tag-recapture data " << TG_recap_data(1) << endl;
    echoinput << "Last  row of tag-recapture data " << TG_recap_data(N_TG_recap) << endl;
    TG_recap_obs.initialize();
    for (j = 1; j <= N_TG_recap; j++)
    {
      TG = TG_recap_data(j, 1); // TG is the tag group
      t = styr + int((TG_recap_data(j, 2) - styr) * nseas + TG_recap_data(j, 3) - 1) - TG_release(TG, 5); // find elapsed time in terms of number of seasons
      if (t > TG_maxperiods)
        t = TG_maxperiods;
      if (t < 0)
      {
        warnstream << " recapture is before tag release for recap: " << j;
        write_message(FATAL, 0);
      }
      TG_recap_obs(TG, t, TG_recap_data(j, 4)) += TG_recap_data(j, 5); // save N recaptures by TG, fleet of recapture, elapsed time
      if (t >= TG_mixperiod)
        TG_use(TG) += TG_recap_data(j, 5); // count total recaptures from this TG
    }
    echoinput << "# total recaptures >= mixperiod by tag group" << endl;
    for (TG = 1; TG <= N_TG; TG++)
    {
      echoinput << TG << " " << TG_use(TG) << endl;
      for (TG_t = 0; TG_t <= TG_endtime(TG); TG_t++)
      {
        TG_recap_obs(TG, TG_t, 0) = sum(TG_recap_obs(TG, TG_t)(1, Nfleet));
        if (TG_recap_obs(TG, TG_t, 0) > 0.) TG_recap_obs(TG, TG_t)(1, Nfleet) /= TG_recap_obs(TG, TG_t, 0);
      }
    }
  }
  // clang-format off
 END_CALCS

// SS_Label_Info_2.13 #Morph composition data
  init_int Do_Morphcomp;
!!echoinput << Do_Morphcomp << " Do_Morphcomp(0/1) " << endl;
   int Morphcomp_nobs;
   int Morphcomp_nobs_rd;
   int Morphcomp_nmorph;
   number Morphcomp_mincomp;
   matrix Morphcomp_obs_rd(1,1,1,1); // reallocate if needed
   matrix Morphcomp_obs(1,1,1,1); // reallocate if needed
 LOCAL_CALCS
  // clang-format on
  if (Do_Morphcomp == 0)
  {
    Morphcomp_nobs = 0;
    Morphcomp_nobs_rd = 0;
    Morphcomp_nmorph = 0;
    Morphcomp_mincomp = 0.00001;
  }
  else
  {
    *(ad_comm::global_datafile) >> Morphcomp_nobs_rd;
    *(ad_comm::global_datafile) >> Morphcomp_nmorph; // later compare this value to the n morphs in the control file and exit if different
    *(ad_comm::global_datafile) >> Morphcomp_mincomp;
    echoinput << Morphcomp_nobs_rd << " Morphcomp_nobs " << endl;
    echoinput << Morphcomp_nmorph << " Morphcomp_nmorph " << endl;
    echoinput << Morphcomp_mincomp << " Morphcomp_mincomp " << endl;

    Morphcomp_obs.deallocate();
    Morphcomp_obs.allocate(1, Morphcomp_nobs_rd, 1, 5 + Morphcomp_nmorph + 1); // terminal +1 will contain computed value of ALK_time
    Morphcomp_obs.initialize();
    Morphcomp_obs_rd.deallocate();
    Morphcomp_obs_rd.allocate(1, Morphcomp_nobs_rd, 1, 5 + Morphcomp_nmorph); //  but will only get filled with the used obs
    Morphcomp_obs_rd.initialize();
    //    yr, seas, fleet, partition, Nsamp, datavector
    data_type = 8; // for morphcomp

    echoinput << " morph composition data" << endl
              << "year month fleet null Nsamp datavector" << endl;
    Morphcomp_nobs = 0;
    for (i = 1; i <= Morphcomp_nobs_rd; i++)
    {
      *(ad_comm::global_datafile) >> Morphcomp_obs_rd(i);
      echoinput << Morphcomp_obs_rd(i) << endl;
      timing_input(1, 3) = Morphcomp_obs_rd(i)(1, 3);
      y = timing_input(1);
      if (y >= styr && y <= endyr + 50) // obs is in year range
      {
        if (timing_input(2) < 0.0)
        {
          warnstream << "negative month not allowed for morphcomp because superperiods not implemented ";
          write_message(FATAL, 0);
        }
        get_data_timing(timing_input, timing_constants, timing_i_result, timing_r_result, seasdur, subseasdur_delta, azero_seas, surveytime);

        s = timing_input(2);
        f = abs(timing_input(3));
        t = timing_i_result(2);
        ALK_time = timing_i_result(5);

        Morphcomp_nobs++;
        Morphcomp_obs(Morphcomp_nobs)(1, 5 + Morphcomp_nmorph) = Morphcomp_obs_rd(i)(1, 5 + Morphcomp_nmorph); //  save observations to be used
        Morphcomp_obs(Morphcomp_nobs, 5 + Morphcomp_nmorph + 1) = ALK_time; //  for reporting
        if (y > retro_yr)
          Morphcomp_obs(Morphcomp_nobs, 3) = -f; //  set to dummy observation
        if (data_time(ALK_time, f, 1) < 0.0) //  so first occurrence of data at ALK_time,f
        { // real_month,fraction of season, year.fraction
          data_time(ALK_time, f)(1, 3) = timing_r_result(1, 3);
        }
        else if (timing_r_result(1) != data_time(ALK_time, f, 1))
        {
          warnstream << "morph_comp: data_month already set for y,s,f: " << y << " " << s << " " << f << " to real month: " << data_time(ALK_time, f, 1) << "  but read value is: " << timing_r_result(1);
          write_message(WARN, 0);
        }
        have_data(ALK_time, 0, 0, 0) = 1;
        have_data(ALK_time, f, 0, 0) = 1; //  so have data of some type
        have_data(ALK_time, f, data_type, 0)++; //  count the number of observations in this subseas
        p = have_data(ALK_time, f, data_type, 0);
        have_data(ALK_time, f, data_type, p) = Morphcomp_nobs; //  store data index for the p'th observation in this subseas

        Morphcomp_obs(Morphcomp_nobs)(6, 5 + Morphcomp_nmorph) /= sum(Morphcomp_obs(Morphcomp_nobs)(6, 5 + Morphcomp_nmorph));
        Morphcomp_obs(Morphcomp_nobs)(6, 5 + Morphcomp_nmorph) += Morphcomp_mincomp;
        Morphcomp_obs(Morphcomp_nobs)(6, 5 + Morphcomp_nmorph) /= sum(Morphcomp_obs(Morphcomp_nobs)(6, 5 + Morphcomp_nmorph));
      }
    }
    echoinput << "processed morphcomp: Nread:" << Morphcomp_nobs_rd << " N save: " << Morphcomp_nobs << endl
              << Morphcomp_obs << endl;
  }
  // clang-format off
 END_CALCS

  int Do_SelexData;
 LOCAL_CALCS
  // clang-format on
  *(ad_comm::global_datafile) >> Do_SelexData;
  echoinput << "Do dataread for selectivity priors(0/1):  " << Do_SelexData << endl;
  echoinput << "year seas fleet age/size bin selex_prior prior_sd" << endl;
  echoinput << "feature not yet implemented" << endl;
  // clang-format off
 END_CALCS

//  SS_Label_Info_2.14 #End of datafile indicator
  init_int fid;

 LOCAL_CALCS
  // clang-format on
  if (fid != 999)
  {
    warnstream << " final value in data file is an error " << fid;
    write_message(FATAL, 0);
  }
  cout << "Data read successful " << fid << endl
       << endl;
  echoinput << " data read successful" << endl
            << endl;

  //  SS_Label_Info_3.0 #Read forecast.ss
  //   SS_Label_Flow  #read forecast.ss
  //  note that forecast.ss is read before control file in order to st up length of some time dimension arrays
  ad_comm::change_datafile_name("forecast.ss");
  cout << " reading forecast file " << endl;
  ifstream Forecast_Stream("forecast.ss"); // even if the global_datafile name is used, there still is a different logical device created
  k = 0;
  N_FC = 0;
  while (k == 0)
  {
    Forecast_Stream >> readline; // reads the line from input stream
    if (length(readline) > 2)
    {
      checkchar = readline(1);
      k = strcmp(checkchar, "#");
      checkchar = readline(1, 2);
      j = strcmp(checkchar, "#C");
      if (j == 0)
      {
        N_FC++;
        Forecast_Comments += readline;
      }
    }
  }
  // clang-format off
 END_CALCS
  int Do_Benchmark; // 0=skip; 1= do Fspr, Fbtgt, Fmsy; 2=do Fspr, F0.1, Fmsy
  int Do_MSY; // 1= set to F(SPR); 2=calc F(MSY); 3=set to F(Btgt) or F0.1; 4=set to F(endyr)
  int did_MSY;
  int show_MSY;
  int wrote_bigreport;
  ivector Bmark_Yr_rd(1,10);
  ivector Bmark_Yr(1,10);
  ivector Bmark_t(1,2); // for range of time values for averaging body size
  number SPR_target;
  number BTGT_frac;
  number Blim_frac;
  int MSY_units; // 1=dead catch, 2=retained catch, 3=retained catch profits
  vector CostPerF(1,Nfleet);
  vector PricePerF(1,Nfleet);
  ivector AdjustBenchF(1,Nfleet);

 LOCAL_CALCS
  // clang-format on
  echoinput << "read Do_Benchmark(0=skip; 1= do Fspr, Fbtgt, Fmsy; 2=do Fspr, F0.1, Fmsy;  3=Fspr, Fbtgt, Fmsy, F_Blimit)" << endl;
  *(ad_comm::global_datafile) >> Do_Benchmark;
  echoinput << Do_Benchmark << " echoed Do_Benchmark " << endl;
  echoinput << "read Do_MSY basis (1=F_SPR,2=calcMSY,3=F_Btarget,4=mult*F_endyr (disabled);5=calcMEY with MSY_unit options" << endl;
  *(ad_comm::global_datafile) >> Do_MSY;
  echoinput << Do_MSY << " echoed Do_MSY basis" << endl;
  if (Do_MSY == 2)
  {
    echoinput << "Note that Do_MSY=5 is more flexible than Do_MSY=2 by providing control of MSY_units" << endl;
  }

  CostPerF = 0.0;
  PricePerF = 1.0; // default value per mt
  MSY_units = 2; //  default to YPR_opt = dead catch without excluded bycatch fleets, but with size/age discard included
  AdjustBenchF = 1;
  if (Do_MSY == 5) //  doing advanced MSY options, including MEY
  {
    warnstream << "F(mey) is a research feature in 3.30.19; use cautiously and report any issues";
    write_message(WARN, 0);
    echoinput << "enter quantity to be maximized: (1) dead catch biomass; (2) dead catch biomass w/o excluded bycatch fleet "
              << "(3) retained catch; (4) retained catch profits" << endl;
    *(ad_comm::global_datafile) >> MSY_units;
    echoinput << MSY_units << " # MSY_units as entered" << endl;

    CostPerF.initialize();
    PricePerF.initialize();
    echoinput << "enter fleet ID and cost per fleet, price per fleet, and 1 to indicate FMEY applies to this fleet (0) otherwise; negative fleet ID fills for all higher fleet IDs, -9999 exits list" << endl;
    int fleet_ID = 100;
    double tempcost;
    double tempprice;
    int tempAdjust;
    while (fleet_ID > -9999)
    {
      *(ad_comm::global_datafile) >> fleet_ID;
      *(ad_comm::global_datafile) >> tempcost;
      *(ad_comm::global_datafile) >> tempprice;
      *(ad_comm::global_datafile) >> tempAdjust;
      echoinput << fleet_ID << " " << tempcost << " " << tempprice << " " << tempAdjust << endl;
      if (fleet_ID > Nfleet)
      {
        warnstream << "fleetID > Nfleet";
        write_message(WARN, 0);
      }
      else if (fleet_ID > 0)
      {
        CostPerF(fleet_ID) = tempcost;
        PricePerF(fleet_ID) = tempprice;
        AdjustBenchF(fleet_ID) = tempAdjust;
      }
      else if (fleet_ID > -999)
      {
        for (f = -fleet_ID; f <= Nfleet; f++)
        {
          if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
          {
            CostPerF(f) = tempcost;
            PricePerF(f) = tempprice;
            AdjustBenchF(f) = tempAdjust;
          }
        }
      }
    }
    echoinput << "# Cost-per-unit fishing mortality: " << CostPerF << endl
              << "Price per kg: " << PricePerF << endl;
  }

  switch (Do_MSY)
  {
    case 1: // set Fmsy=Fspr
    {
      MSY_name = "set_Fmsy=Fspr";
      break;
    }
    case 3: // set Fmsy=Fbtgt or F0.1
    {
      if (Do_Benchmark == 1) MSY_name = "set_Fmsy=Fbtgt";
      if (Do_Benchmark == 2) MSY_name = "set_Fmsy=F0.1";
      break;
    }
    case 4: //  set fmult for Fmsy to 1
    {
      MSY_name = "set_Fmsy_using_input_Fmult";
      break;
    }
    case 2: // calc Fmsy
    {
      MSY_name = "find_Fmsy_to_maximize_dead_catch";
      break;
    }
    case 5: // calc Fmey
    {
      switch (MSY_units)
      {
        case 1:
        {
          MSY_name = "find_Fmsy_to_maximize_dead_catch";
          break;
        }
        case 2:
        {
          MSY_name = "find_Fmsy_to_maximize_retained_catch";
          break;
        }
        case 3:
        {
          MSY_name = "find_Fmey_to_maximize_profits_(retained_catch_revenue_-_fleet_cost";
          break;
        }
      }
      break;
    }
  }

  show_MSY = 0;
  did_MSY = 0;
  wrote_bigreport = 0;
  Blim_frac = 0.5; // default
  echoinput << "next read SPR target and Biomass target as fractions" << endl;
  *(ad_comm::global_datafile) >> SPR_target;
  echoinput << SPR_target << " echoed SPR_target " << endl;
  *(ad_comm::global_datafile) >> BTGT_frac;
  echoinput << BTGT_frac << " echoed BTGT_frac " << endl;

  if (Do_Benchmark == 3)
  {
    echoinput << "if Do_Benchmark==3, read Blimit as fraction of Bmsy (neg value to use as frac of Bzero)" << endl;
    *(ad_comm::global_datafile) >> Blim_frac;
    echoinput << Blim_frac << " echoed Blim_frac " << endl;
  }

  echoinput << "next read 10 Benchmark years for:  beg-end bio; beg-end selex; beg-end relF; beg-end recr_dist; beg-end SRparm" << endl;
  echoinput << "codes: -999 means start year; >0 is an actual year; <=0 is relative to endyr" << endl;
  *(ad_comm::global_datafile) >> Bmark_Yr_rd(1, 10);

  Bmark_Yr = 0;
  if (Do_Benchmark == 2 && N_bycatch > 0)
  {
    warnstream << "F0.1 does not work well with bycatch fleets; check output carefully";
    write_message(WARN, 0);
  }
  echoinput << Bmark_Yr_rd << " echoed Benchmark years" << endl;
  for (i = 1; i <= 10; i++) //  beg-end bio; beg-end selex; beg-end relF
  {
    if (Bmark_Yr_rd(i) == -999)
    {
      Bmark_Yr(i) = styr;
    }
    else if (Bmark_Yr_rd(i) <= 0)
    {
      Bmark_Yr(i) = Bmark_Yr_rd(i) + endyr;
    }
    else if (Bmark_Yr_rd(i) < styr)
    {
      warnstream << "benchmark year (" << Bmark_Yr_rd(i) << ") < styr (" << styr << "); change to styr";
      write_message(WARN, 0);
      Bmark_Yr(i) = styr;
    }
    else if (Bmark_Yr_rd(i) > endyr)
    {
      warnstream << "benchmark year (" << Bmark_Yr_rd(i) << ") > endyr (" << endyr << "); change to endyr";
      write_message(WARN, 0);
      Bmark_Yr(i) = endyr;
    }
    else
    {
      Bmark_Yr(i) = Bmark_Yr_rd(i);
    }
  }
  Bmark_t(1) = styr + (Bmark_Yr(1) - styr) * nseas;
  Bmark_t(2) = styr + (Bmark_Yr(2) - styr) * nseas;

  echoinput << Bmark_Yr << " Benchmark years as processed" << endl;
  echoinput << "next read:  1=use range of years as read for relF; 2 = set same as forecast relF below" << endl;
  // clang-format off
 END_CALCS
  init_int Bmark_RelF_Basis;

 LOCAL_CALCS
  // clang-format on
  echoinput << Bmark_RelF_Basis << "  echoed Bmark_RelF_year basis" << endl;
  if (Do_MSY == 5 && Bmark_RelF_Basis == 2)
  {
    warnstream << "Do_MSY=5, so must use Bmark_RelF_Basis=1";
    write_message(FATAL, 0);
  }
  echoinput << endl
            << "next read forecast basis: 0=none; 1=F(SPR); 2=F(MSY) 3=F(Btgt); 4=Ave F (enter yrs); 5=read Fmult" << endl;
  // clang-format off
 END_CALCS
  init_int Do_Forecast_rd;
  int Do_Forecast;
!! Do_Forecast = Do_Forecast_rd;
!!echoinput << Do_Forecast << " echoed Forecast basis" << endl;

  vector Fcast_Input(1,24);

  int N_Fcast_Yrs;
  ivector Fcast_yr(1,6); // yr range for selex, then yr range for either allocation or for mean F
  ivector Fcast_yr_rd(1,6);
  int Fcast_Sel_yr1;
  int Fcast_Sel_yr2;
  int Fcast_RelF_yr1;
  int Fcast_RelF_yr2;
  int Fcast_Rec_yr1;
  int Fcast_Rec_yr2;
  int Fcast_RelF_Basis; // 1=use year range; 2=read below
  number Fcast_Flevel;
  int Do_Rebuilder;
  int Rebuild_Ydecl;
  int Rebuild_Yinit;
  int HarvestPolicy; // 0=none; 1=west coast adjust catch; 2=AK to adjust F
  number H4010_top_rd;
  number H4010_bot;
  number H4010_scale;
  number H4010_scale_rd;
  int Do_Impl_Error;
  number Impl_Error_Std;
  vector Fcast_Loop_Control(1,5);
  int N_Fcast_Input_Catches;
  int Fcast_InputCatch_Basis; // 2=dead catch; 3=retained catch;  99=F; -1=read fleet/time specific  (biomass vs numbers will match catchunits(fleet)
  int Fcast_Catch_Basis; // 2=dead catch bio, 3=retained catch bio, 5= dead catch numbers 6=retained catch numbers;   Same for all fleets

  int Fcast_Catch_Allocation_Groups;
  int Fcast_Do_Fleet_Cap;
  int Fcast_Do_Area_Cap;
  int Fcast_Cap_FirstYear;
  vector Fcast_MaxFleetCatch(1,Nfleet);
  vector Fcast_MaxAreaCatch(1,pop);
  ivector Allocation_Fleet_Assignments(1,Nfleet);
  matrix Fcast_RelF_Input(1,nseas,1,Nfleet);
  int Fcast_timevary_Selex_rd;   // old logic: 0 = fcast selectivity is mean over range of years; 1=use time-varying parameters to control selectivity in forecast
  int Fcast_timevary_Selex;   // new logic: 1 = fcast selectivity is mean over range of years; 0=use time-varying parameters to control selectivity in forecast
  int N_Fcast_parm_aves;

 LOCAL_CALCS
  // clang-format on
  Fcast_MaxFleetCatch.initialize();
  Fcast_MaxAreaCatch.initialize();
  Allocation_Fleet_Assignments.initialize();
  Fcast_Catch_Allocation.initialize();
  Fcast_RelF_Input.initialize();
  Fcast_yr.initialize();
  Do_Impl_Error = 0;
  Do_Rebuilder = 0;
  // clang-format off
 END_CALCS
    matrix Fcast_MGparm_ave_rd(1,12,1,4)  //  for the 8 MGtypes plus, method, st_year, end_year
    matrix Fcast_MGparm_ave(1,12,1,4)  //  for the 8 MGtypes plus, method, st_year, end_year (real years)
    // lables for the MGtypes found in string array:  MGtype_Lbl

 LOCAL_CALCS
  // clang-format on
  Fcast_timevary_Selex_rd = 0; // default; do mean
  Fcast_MGparm_ave.initialize();
  Fcast_MGparm_ave_rd.initialize();
  if (Do_Forecast_rd > 0)
  {
    //    Fcast_Input(1,k)=Fcast_Input_rd(1,k);
    //  k=0;
    //  k++;
    echoinput << endl
              << "#next read N forecast years" << endl;
    *(ad_comm::global_datafile) >> N_Fcast_Yrs;
    echoinput << N_Fcast_Yrs << " #echoed N_Fcast_Yrs " << endl;
    if (Do_Forecast_rd > 0 && N_Fcast_Yrs <= 0)
    {
      warnstream << "ERROR: cannot do a forecast of zero years: " << N_Fcast_Yrs;
      write_message(FATAL, 0);
    }
    if (Do_Forecast_rd > 0 && STD_Yr_max == -1)
    {
      warnstream << "Std_yrmax=-1 in starter, so no variance output for forecast quantities after endyr+1 ";
      write_message(NOTE, 0);
    }

    YrMax = endyr + N_Fcast_Yrs;

    echoinput << endl
              << "# next read Fmult value to be used only if Forecast basis==5" << endl;
    //  k++; Fcast_Flevel=Fcast_Input(k);
    *(ad_comm::global_datafile) >> Fcast_Flevel;
    echoinput << Fcast_Flevel << " # echoed Fmult value" << endl;

    N_Fcast_parm_aves = 0;
    echoinput << endl
              << "# next enter year ranges for averaging forecast quantities that otherwise will follow time-vary parameter controls" << endl
              << "# enter single value of -12345 to invoke recommended generic approach" << endl
              << "# or enter six Fcast_year values:  beg_selex, end_selex, beg_relF, end_relF, beg_recruits, end_recruits" << endl
              << "# year values are actual year, or values <= 0 to be relative to endyr" << endl
              << "# use of some of these year ranges is conditional on settings later in the forecast.ss file" << endl;
    *(ad_comm::global_datafile) >> Fcast_yr_rd(1);
    
    if(Fcast_yr_rd(1) != -12345)  //  continue with old approach
    {
    *(ad_comm::global_datafile) >> Fcast_yr_rd(2,6);
    echoinput << Fcast_yr_rd << " # echoed Fcast years as read" << endl;
    Fcast_yr = Fcast_yr_rd;
    for (i = 1; i <= 6; i++)  // tagcode
    {
      if (Fcast_yr(i) == -999)
      {
        Fcast_yr(i) = styr;
      }
      else if (Fcast_yr(i) <= 0)
      {
        Fcast_yr(i) += endyr;
      }
      else if (Fcast_yr(i) < styr)
      {
        Fcast_yr(i) = styr;
      }
      else if (Fcast_yr(i) > endyr)
      {
        Fcast_yr(i) = endyr;
      }
      else
      {
      } //  OK in range
    }
    Fcast_Sel_yr1 = Fcast_yr(1);
    Fcast_Sel_yr2 = Fcast_yr(2);
    Fcast_RelF_yr1 = Fcast_yr(3);
    Fcast_RelF_yr2 = Fcast_yr(4);
    Fcast_Rec_yr1 = Fcast_yr(5);
    Fcast_Rec_yr2 = Fcast_yr(6);
    echoinput << Fcast_yr << "  # After Transformation" << endl;

    echoinput << endl
              << "# read flag for selectivity used in forecasts; 0 creates mean to use for all years; 1 implements time-varying selectivity per parameters" << endl;
    *(ad_comm::global_datafile) >> Fcast_timevary_Selex_rd;
    //  change polarity to match new code logic
    if(Fcast_timevary_Selex_rd == 0) 
    {Fcast_timevary_Selex = 1;}  //  do means
    else
    {Fcast_timevary_Selex = 0;}
    
    echoinput << Fcast_timevary_Selex_rd << " # echoed Fcast_timevary_Selex value" << endl;
    //  set equivalent values using new approach
    Fcast_MGparm_ave(10,1) = 10;
    Fcast_MGparm_ave(10,2) = 1;
    Fcast_MGparm_ave(10,3) = Fcast_yr_rd(1);  // for selectivity
    Fcast_MGparm_ave(10,4) = Fcast_yr_rd(2);
    Fcast_MGparm_ave(11,1) = 11;
    Fcast_MGparm_ave(11,2) = 1;
    Fcast_MGparm_ave(11,3) = Fcast_yr_rd(3);  // for rel F
    Fcast_MGparm_ave(11,4) = Fcast_yr_rd(4);
    Fcast_MGparm_ave(12,1) = 12;
    Fcast_MGparm_ave(12,2) = 1;
    Fcast_MGparm_ave(12,3) = Fcast_yr_rd(5);  // for recruitment
    Fcast_MGparm_ave(12,4) = Fcast_yr_rd(6);
    Fcast_MGparm_ave_rd = Fcast_MGparm_ave;
    }  //  end old approach for Fcast years
    else
    
    {  //  read fcast year ranges in new list-based format
// set defaults, but each can be overridden
    Fcast_yr(1,6) = endyr;
    Fcast_Sel_yr1 = Fcast_yr(1);
    Fcast_Sel_yr2 = Fcast_yr(2);
    Fcast_RelF_yr1 = Fcast_yr(3);
    Fcast_RelF_yr2 = Fcast_yr(4);
    Fcast_Rec_yr1 = Fcast_yr(5);
    Fcast_Rec_yr2 = Fcast_yr(6);
    Fcast_timevary_Selex = 0;

    echoinput << " #_Read year ranges for forecast factors that will use means" << endl
    << "#_ range will be endyr to endyr unless explicitly set below" << endl;
  //  Fcast_MGparm_ave_rd: read MGtype, method, start year, end year
  //  terminate with Factor = -9999
      echoinput << "read list of factor, method (0,1), start year, end year" << endl
                << "Terminate with -9999 for factor" << endl
                << "Factors: 1=M, 2=growth, 3=wtlen, 4=recr_dist&femfrac, 5=migration, 6=ageerror, 7=catchmult, 8=hermaphroditism" << endl
                << "10=selectivity, 11=rel.F, 12=recruitment"
                << "Method = 0 to use parameters (with time_vary); 1 to use mean of derived factor over year range"<<endl;
      ender = 0;
      do
      {
        dvector tempvec(1, 4);
        *(ad_comm::global_datafile) >> tempvec(1, 4);
        echoinput << tempvec << endl;
        if (tempvec(1) == -9999. || tempvec(1) > 12)  
          ender = 1;
        else
          {
            int f1 = tempvec(1);
            Fcast_MGparm_ave_rd(f1) = tempvec; 
            Fcast_MGparm_ave(f1) = tempvec;
          }
      } while (ender == 0);

      //  Adjusting Fcast_MGparm_ave_rd minyear and maxyear values
      //  for Fcast_MGparm_ave
      for (i = 1; i <= 12; i++)
      {
        if (Fcast_MGparm_ave_rd(i,1) > 0)
        {
          echoinput<<Fcast_MGparm_ave(i)<<endl;
          // Adjust start year
          if (Fcast_MGparm_ave(i,3) == -999)
          {
            Fcast_MGparm_ave(i,3) = styr;
          }
          else if (Fcast_MGparm_ave(i,3) <= 0)
          {
            Fcast_MGparm_ave(i,3) += endyr;
          }
          if (Fcast_MGparm_ave(i,3) < styr)
          {
            Fcast_MGparm_ave(i,3) = styr;
          }
          else if (Fcast_MGparm_ave(i,3) > endyr)
          {
            Fcast_MGparm_ave(i,3) = endyr;
          }
          // Adjust end year
          if (Fcast_MGparm_ave(i,4) == -999)
          {
            Fcast_MGparm_ave(i,4) = endyr;
          }
          else if (Fcast_MGparm_ave(i,4) <= 0)
          {
            Fcast_MGparm_ave(i,4) += endyr;
          }
          if (Fcast_MGparm_ave(i,4) < Fcast_MGparm_ave(i,3))
          {
            Fcast_MGparm_ave(i,4) = Fcast_MGparm_ave(i,3);
            warnstream << "Fcast_MGparm_ave maxyear before minyear, setting to: " << Fcast_MGparm_ave(i,4);
            write_message(ADJUST, 0);
          }
          if (Fcast_MGparm_ave(i,4) > endyr)
          {
            Fcast_MGparm_ave(i,4) = endyr;
          }
          switch (i) 
          {
          case 10:  // 10=selectivity
          Fcast_Sel_yr1 = Fcast_MGparm_ave(i,3);
          Fcast_Sel_yr2 = Fcast_MGparm_ave(i,4);
          Fcast_timevary_Selex = Fcast_MGparm_ave(i,2);  //  tells SS3 to use mean (1) vs. time-vary parms (0)
          break;
          case 11:  // 11=relative F
          Fcast_RelF_yr1 = Fcast_MGparm_ave(i,3);
          Fcast_RelF_yr2 = Fcast_MGparm_ave(i,4);
          //  only year range read here; invocation will be read later:  Fcast_RelF_Basis;  //  tells SS3 to use mean, not time-vary parms
          break;
          case 12:  // 12=recruitment
          Fcast_Rec_yr1 = Fcast_MGparm_ave(i,3);
          Fcast_Rec_yr2 = Fcast_MGparm_ave(i,4);
          //  only year range read here; invocation will be read later
          break;
          }
        }
      }
      echoinput << "Forecast factor averaging: " << endl << Fcast_MGparm_ave << endl;
      echoinput << "operational values may be calculated or assigned in benchmark_forecast setup" << endl;
    }

    echoinput << endl
              << "next read 4 values for:  control rule shape(0, 1, 2, 3 or 4), inflection (like 0.40), cutoff(like 0.10), scale(like 0.75)" << endl;
    *(ad_comm::global_datafile) >> HarvestPolicy;
    if (HarvestPolicy == 0)
      echoinput << "HarvestPolicy=0, so values for top, bottom, buffer will be ignored" << endl;

    echoinput << HarvestPolicy << "  # echoed HarvestPolicy " << endl;
    *(ad_comm::global_datafile) >> H4010_top_rd; //  as fraction of HCR_anchor; use -1 as legacy approach to set H4010_top to Bmsy/SSB_unf
    echoinput << H4010_top_rd << "   # echoed control rule inflection" << endl;
    *(ad_comm::global_datafile) >> H4010_bot;
    echoinput << H4010_bot << "   # echoed control rule cutoff " << endl;
    *(ad_comm::global_datafile) >> H4010_scale_rd;
    H4010_scale = H4010_scale_rd;
    echoinput << H4010_scale << "   # echoed control rule scalar " << endl;
    if (H4010_top_rd > 0.0 && H4010_top_rd <= H4010_bot)
    {
      warnstream << "control rule inflection: " << H4010_top_rd << " must be > control rule cutoff " << H4010_bot;
      write_message(FATAL, 0);
    }
    if (H4010_scale > 1.0)
    {
      warnstream << "Sure you want control rule scalar > 1.0? " << H4010_scale;
      write_message(WARN, 0);
    }

    if (H4010_scale < 0.0)
    {
      echoinput << "# now read pairs of year,H4010scale; each read fills from that year to YrMax; end with year<0.0 " << endl;
      ender = 0;
      do
      {
        dvector tempvec(1, 2);
        *(ad_comm::global_datafile) >> tempvec(1, 2);
        if (tempvec(1) < 0.0)
          ender = 1;
        H4010_scale_vec_rd.push_back(tempvec(1, 2));
        echoinput << " H4010 read: " << tempvec(1, 2) << endl;
      } while (ender == 0);
    }

    echoinput << endl
              << "# next enter 2 values that control looping through the forecast (see manual), then 3 additional controls" << endl;
    echoinput << "# first does F_msy or proxy; 2nd applies control rule; 3rd applies caps and allocations" << endl;
    *(ad_comm::global_datafile) >> Fcast_Loop_Control(1, 5);
    echoinput << Fcast_Loop_Control(1) << " #echo: N forecast loops (1-3) (recommend 3 to get full variance for short-term forecasts)" << endl;
    echoinput << Fcast_Loop_Control(2) << " #echo: First forecast loop with stochastic recruitment (recommend 3)" << endl;
    echoinput << Fcast_Loop_Control(3) << " #echo: Forecast base recruitment:  0=spawn_recr; 1=mult*spawn_recr; 2=mult*VirginRecr; 3=deprecated; 4=mult*mean from yr range" << endl;
    if (Fcast_Loop_Control(3) == 3)
    {
      echoinput << "Option 3 deprecated, converting to option 4 for mean recruitment. Use mean over year range controls for recrdist" << endl;
      warnstream << "Option 3 for mean forecast recruitment is deprecated. Changing to option 4. User can do recrdist with new fcast year controls";
      write_message(ADJUST, 0);
      Fcast_Loop_Control(3) = 4;
      Fcast_Loop_Control(4) = 1.0;  //  safeguard in case user had value here
    }
    if (Fcast_Loop_Control(3) == 4)
    {
      echoinput << "Forecast base recruitment is mean from years: " << Fcast_Rec_yr1 << " to " << Fcast_Rec_yr2 << " recrdist from parameters, or mean fcast year controls" << endl;
    }
    else if (Fcast_Loop_Control(3) < 0) //  input probably was a -1 from pre 3.30.15, so convert to 0
    {
      Fcast_Loop_Control(3) = 0;
      Fcast_Loop_Control(4) = 1.0;
    }
    if (Fcast_Loop_Control(3) > 0)
    {
      echoinput << Fcast_Loop_Control(4) << "#echo:  multiplier on forecast base recruitment" << endl;
      echoinput << "forecast devs will be applied after the multiplier," << endl <<
      "even when the base is set to the mean of earlier recruitments" << endl;
    }

    if (Fcast_Loop_Control(5) <= 0)  //  default before 3.30.24
    {
      echoinput << "basis for HCR anchor was not set; setting to 2 to match default before 3.30.24" << endl;
      warnstream << "basis for HCR anchor was not set; setting to 2 to match default before 3.30.24";
      write_message(ADJUST, 0);
      Fcast_Loop_Control(5) = 2;
    }
    if (H4010_top_rd < 0)  // convert old legacy approach to new approach for using Bmsy
    {
      Fcast_Loop_Control(5) = 3;
      H4010_top_rd = 1.0;
    }
    echoinput << Fcast_Loop_Control(5) << " #control rule anchor: 1=virgin_SSB; 2=unfished_benchmark_SSB(old_approach); 3=Bmsy" << endl;
    if (depletion_basis == 1 && Fcast_Loop_Control(5) == 2)
    {
      warnstream << "depletion_basis is using virgin but HCR anchor is using SSB_unf from benchmark. Are you sure?";
      write_message(WARN, 0);
    }
    
    echoinput << "#next enter year in which Fcast loop 3 caps and allocations begin to be applied" << endl;
    *(ad_comm::global_datafile) >> Fcast_Cap_FirstYear;
    echoinput << Fcast_Cap_FirstYear << " # echoed value" << endl;

    echoinput << endl
              << "#next enter 0, or stddev of implementation error" << endl;
    *(ad_comm::global_datafile) >> Impl_Error_Std;
    echoinput << Impl_Error_Std << " # echoed value" << endl;
    if (Impl_Error_Std > 0.0) {
      if (Do_Forecast_rd > 0) {
        Do_Impl_Error = 1; // OK to do impl error because forecast occurs
      }
      else
      {
        warnstream << "changing Imple_Error to 0 because no forecast ";
        write_message(WARN, 1);
        Impl_Error_Std = 0.0;
        Do_Impl_Error = 0;
      }
    }

    echoinput << endl
              << "#next select rebuilding program output: 0=no; 1=yes" << endl;
    *(ad_comm::global_datafile) >> Do_Rebuilder;
    echoinput << Do_Rebuilder << " # echoed value" << endl;

    echoinput << endl
              << "#next select rebuilding program:  year declared overfished" << endl;
    *(ad_comm::global_datafile) >> Rebuild_Ydecl;
    echoinput << Rebuild_Ydecl << " # echoed value" << endl;

    echoinput << endl
              << "#next select rebuilding program:  year rebuilding plan started" << endl;
    *(ad_comm::global_datafile) >> Rebuild_Yinit;
    echoinput << Rebuild_Yinit << " # echoed value" << endl;

    echoinput << endl
              << "#next select fleet relative F:  1=mean over year range read above; 2=read list of seas, fleet, relF below" << endl;
    echoinput << "# Note that fleet allocation is used directly as F if Do_Forecast=4 " << endl;
    *(ad_comm::global_datafile) >> Fcast_RelF_Basis;
    echoinput << Fcast_RelF_Basis << " # echoed value" << endl;
    if (Fcast_RelF_Basis < 1 || Fcast_RelF_Basis > 2) {
      warnstream << "Fcast_relF_Basis value must be 1 or 2" << endl;
      write_message(FATAL, 1);
    }
    if (Fcast_RelF_Basis == 1 && Fcast_MGparm_ave(11,2) == 0) {
      echoinput << "Fcast_relF_Basis = 1 requires that year range is set above" << endl;
      warnstream << "Fcast_relF_Basis = 1 requires that year range is set above" << endl;
      write_message(FATAL, 1);

    }

    if (Do_Forecast_rd == 4 && Fcast_RelF_Basis == 2) {
      warnstream << "Cannot specify forecast fleet relative F because Do_Forecast==4 specifies relative F directly as F;" << endl
                 << "  need to align choice of forecast basis and forecast relative F basis";
      write_message(FATAL, 1);
    }

    echoinput << endl
              << "#next read Catch Basis for caps and allocations;  Same for all fleets" << endl;
    echoinput << "2=dead catch bio, 3=retained catch bio, 5= dead catch numbers 6=retained catch numbers" << endl;
    *(ad_comm::global_datafile) >> Fcast_Catch_Basis;
    echoinput << Fcast_Catch_Basis << " # echoed value" << endl;
    if (Fcast_Catch_Basis < 2 || Fcast_Catch_Basis > 6) {
      warnstream << "illegal value for Fcast_Catch_Basis";
      write_message(FATAL, 1);
    }

    if (Fcast_RelF_Basis == 2)
    {
      ivector checkfleet(1, Nfleet);
      checkfleet.initialize();
      echoinput << endl
                << "Fcast_RelF_Basis==2, so now read list of seas, fleet#, relF_value" << endl
                << "Terminate with -9999 for season" << endl
                << "Will be re-scaled to sum to 1.0" << endl;
      ender = 0;
      do
      {
        dvector tempvec(1, 3);
        *(ad_comm::global_datafile) >> tempvec(1, 3);
        echoinput << tempvec << endl;
        if (tempvec(1) == -9999.)
        {
          ender = 1;
        }
        else
        {
          s = int(tempvec(1));
          f = int(tempvec(2));
          if (fleet_type(f) <= 2)
          {
            Fcast_RelF_Input(s, f) = tempvec(3);
            checkfleet(f) = 1;
          }
          else
          {
            warnstream << "forecast exit for fleet " << f << "  ;cannot set fcast relF for survey fleets";
            write_message(FATAL, 0);
          }
        }
      } while (ender == 0);
      echoinput << " fleet relative F by season and fleet as read" << endl
                << Fcast_RelF_Input << endl;
      for (f = 1; f <= Nfleet; f++)
      {
        if (fleet_type(f) == 1 && checkfleet(f) == 0)
        {
          warnstream << "fleet: " << f << " " << fleetname(f) << "  is a fishing fleet but forecast relF not read";
          write_message(WARN, 0);
        }
      }
    }
    else
    {
    }
  }

  else // set forecast defaults
  {
    warnstream << "Forecast=0 or -1, so rest of forecast file will not be read and can be omitted;";
    write_message(WARN, 0);
    if (Bmark_RelF_Basis == 2)
    {
      warnstream << "Fatal stop:  no forecast, but bmark set to use fcast";
      write_message(FATAL, 0);
    }
    if (Do_Forecast == 0)
    {
      warnstream << "A one year forecast using recent F will be done automatically";
      write_message(WARN, 0);
      Do_Forecast = 4; // sets simple forecast; else Do_Forecast==-1 causes no forecast
      N_Fcast_Yrs = 1;
      YrMax = endyr + 1;
    }
    else
    {
      Do_Forecast = -1; //  no forecast
      N_Fcast_Yrs = 0;
      YrMax = endyr;
    }

    Fcast_Flevel = 1.;
    Fcast_yr = 0;
    Fcast_yr_rd = 0;
    Fcast_RelF_Basis = 1;
    Fcast_Sel_yr1 = endyr;
    Fcast_Sel_yr2 = endyr;
    Fcast_RelF_yr1 = endyr;
    Fcast_RelF_yr2 = endyr;
    Fcast_Rec_yr1 = styr;
    Fcast_Rec_yr2 = endyr;
    HarvestPolicy = 0;
    H4010_top_rd = 0.001;
    H4010_bot = 0.0001;
    H4010_scale_rd = 1.0;
    H4010_scale = 1.0;
    Fcast_Loop_Control.fill("{2,1,0,0,0}");
    Fcast_Cap_FirstYear = endyr + 1;
    Impl_Error_Std = 0.0;
    Do_Impl_Error = 0;
    Do_Rebuilder = 0;
    Rebuild_Ydecl = endyr;
    Rebuild_Yinit = endyr;
    Fcast_RelF_Basis = 1;
    Fcast_Catch_Basis = 2;
  } //  end of defaults for do_forecast = 0
  // clang-format off
 END_CALCS

  matrix Fcast_Catch_Allocation(1,N_Fcast_Yrs,1,Nfleet);  //   dimension to Nfleet but use only to N alloc groups
  vector H4010_scale_vec(endyr+1,YrMax);

 LOCAL_CALCS
  // clang-format on
  if (Do_Forecast_rd > 0)
  {
    echoinput << endl
              << "# next read list of fleet ID and max annual catch;  end with fleet=-9999" << endl;
    for (f = 1; f <= Nfleet; f++)
      Fcast_MaxFleetCatch(f) = -1;
    Fcast_Do_Fleet_Cap = 0;
    ender = 0;
    do
    {
      dvector tempvec(1, 2);
      *(ad_comm::global_datafile) >> tempvec(1, 2);
      echoinput << tempvec << endl;
      if (tempvec(1) == -9999.)
      {
        ender = 1;
      }
      else
      {
        f = int(tempvec(1));
        if (fleet_type(f) <= 2)
        {
          Fcast_MaxFleetCatch(f) = tempvec(2);
        }
        else
        {
          warnstream << "exit for fleet " << f << "  ;  can only set max catch for retained or discard catch fleets";
          write_message(FATAL, 0);
          //          cout<<" EXIT - see warning "<<endl; warning<<"exit for fleet "<<f<<"  ;  can only set max catch for retained or discard catch fleets"<<endl; exit(1);
        }
        Fcast_Do_Fleet_Cap = 1;
      }
    } while (ender == 0);
    echoinput << " Processed Max totalcatch by fleet " << endl
              << Fcast_MaxFleetCatch << endl;

    echoinput << endl
              << "Read list of area ID and max annual catch;  end with area=-9999" << endl;
    for (p = 1; p <= pop; p++)
      Fcast_MaxAreaCatch(p) = -1;
    Fcast_Do_Area_Cap = 0;
    ender = 0;
    do
    {
      dvector tempvec(1, 2);
      *(ad_comm::global_datafile) >> tempvec(1, 2);
      echoinput << tempvec << endl;
      if (tempvec(1) == -9999.)
      {
        ender = 1;
      }
      else
      {
        p = int(tempvec(1));
        Fcast_MaxAreaCatch(p) = tempvec(2);
        Fcast_Do_Area_Cap = 1;
      }
    } while (ender == 0);
    echoinput << " processed Max totalcatch by area " << endl
              << Fcast_MaxAreaCatch << endl;

    echoinput << endl
              << "Read list of fleet ID and assignment to allocation group;  end with fleet ID=-9999" << endl;
    echoinput << "fishing fleets not assigned to allocation group are processed normally" << endl;
    Allocation_Fleet_Assignments.initialize();
    Fcast_Catch_Allocation_Groups = 0;
    ender = 0;
    do
    {
      dvector tempvec(1, 2);
      *(ad_comm::global_datafile) >> tempvec(1, 2);
      echoinput << tempvec << endl;
      if (tempvec(1) == -9999.)
      {
        ender = 1;
      }
      else
      {
        f = int(tempvec(1));
        if (fleet_type(f) == 1)
        {
          Allocation_Fleet_Assignments(f) = tempvec(2);
        }
        else
        {
          warnstream << "exit for fleet " << f << "  ;  can only put retained catch fleets in allocation groups";
          write_message(FATAL, 0);
        }
      }
    } while (ender == 0);

    Fcast_Catch_Allocation_Groups = max(Allocation_Fleet_Assignments);
    echoinput << " Processed Fleet allocation group assignments " << endl
              << Allocation_Fleet_Assignments << endl;

    Fcast_Catch_Allocation.initialize();
    if (Fcast_Catch_Allocation_Groups > 0)
    {
      echoinput << "# now read fraction of catch for each identified allocation group " << endl;
      ender = 0;
      k = Fcast_Catch_Allocation_Groups + 1;
      do
      {
        dvector tempvec(1, k);
        *(ad_comm::global_datafile) >> tempvec(1, k);
        if (tempvec(1) == -9999.)
          ender = 1;
        Fcast_Catch_Allocation_list.push_back(tempvec(1, k));
        echoinput << " allocation assignment: " << tempvec(1, k) << endl;
      } while (ender == 0);
      j = Fcast_Catch_Allocation_list.size() - 1;

      if (j == 0)
      {
        warnstream << "Error: there are no allocation fractions specified and there are " << Fcast_Catch_Allocation_Groups << " allocation groups";
        write_message(FATAL, 1);
      }

      for (k = 0; k <= j - 1; k++)
      {
        for (y = Fcast_Catch_Allocation_list[k](1) - endyr; y <= N_Fcast_Yrs; y++) // assign input from the input year through last forecast year
        {
          for (a = 1; a <= Fcast_Catch_Allocation_Groups; a++)
          {
            Fcast_Catch_Allocation(y, a) = Fcast_Catch_Allocation_list[k](a + 1);
          }
        }
      }
      echoinput << "processed allocation groups by year" << endl;
      for (y = 1; y <= N_Fcast_Yrs; y++)
      {
        if (sum(Fcast_Catch_Allocation(y)) == 0.0)
        {
          warnstream << "Fcast_Catch_allocation is blank for year: " << y + endyr << "; SS3 assigning uniform; can override with input catches";
          write_message(WARN, 0);
        }
        else
        {
          Fcast_Catch_Allocation(y) /= sum(Fcast_Catch_Allocation(y)(1, Fcast_Catch_Allocation_Groups));
        }
        echoinput << y + endyr << " " << Fcast_Catch_Allocation(y)(1, Fcast_Catch_Allocation_Groups) << endl;
      }
    }

    *(ad_comm::global_datafile) >> Fcast_InputCatch_Basis;
    echoinput << Fcast_InputCatch_Basis << " # basis for input Fcast catch:  -1= read with each obs; 2=dead catch; 3=retained catch; 99=input Hrate(F); -1=read fleet/time specific (bio/num units are from fleetunits; note new codes in SSV3.20)" << endl;
    k1 = styr + (endyr - styr) * nseas - 1 + nseas + 1;
    y = k1 + (N_Fcast_Yrs)*nseas - 1;
    if (Fcast_InputCatch_Basis == -1)
    {
      j = 5;
      echoinput << "# year seas fleet catch basis" << endl;
    }
    else
    {
      j = 4;
      echoinput << "# year seas fleet catch" << endl;
    }

    ender = 0;
    do
    {
      dvector tempvec(1, j);
      *(ad_comm::global_datafile) >> tempvec(1, j);
      if (tempvec(1) == -9999.)
        ender = 1;
      Fcast_InputCatch_list.push_back(tempvec(1, j));
      echoinput << tempvec << endl;
    } while (ender == 0);
    N_Fcast_Input_Catches = Fcast_InputCatch_list.size() - 1;
  }
  else
  {
    N_Fcast_Input_Catches = 0;
    Fcast_InputCatch_Basis = 2;
    k1 = 1;
    y = 0;
    j = 0;
    fif = 999;
  }
  // clang-format off
 END_CALCS

  3darray Fcast_InputCatch(k1,y,1,Nfleet,1,2); // values and basis to be used
  matrix Fcast_InputCatch_rd(1,N_Fcast_Input_Catches,1,j);
  imatrix Fcast_RelF_special(1,nseas,1,Nfleet); // records whether an input catch or F occurs

 LOCAL_CALCS
  // clang-format on
  Fcast_InputCatch.initialize();
  Fcast_InputCatch_rd.initialize();
  Fcast_RelF_special.initialize();
  if (Do_Forecast_rd > 0)
  {
    if (N_Fcast_Input_Catches > 0)
    {
      for (t = k1; t <= y; t++)
        for (f = 1; f <= Nfleet; f++)
        {
          Fcast_InputCatch(t, f, 1) = -1;
        }

      for (i = 0; i <= N_Fcast_Input_Catches - 1; i++)
      {
        echoinput << i << " " << Fcast_InputCatch_list[i] << endl;
        Fcast_InputCatch_rd(i + 1) = Fcast_InputCatch_list[i];
        y = Fcast_InputCatch_rd(i + 1, 1);
        s = Fcast_InputCatch_rd(i + 1, 2);
        f = Fcast_InputCatch_rd(i + 1, 3);
        if (y > endyr && y <= YrMax && fleet_type(f) <= 2)
        {
          Fcast_RelF_special(s, f) = 1;
          t = styr + (y - styr) * nseas + s - 1;
          Fcast_InputCatch(t, f, 1) = Fcast_InputCatch_rd(i + 1, 4);
          if (y >= Fcast_Cap_FirstYear)
          {
            warnstream << "Input catches in " << y << " can be overridden by caps or allocations";
            write_message(WARN, 0);
          }
          if (Fcast_InputCatch_Basis == -1)
          {
            Fcast_InputCatch(t, f, 2) = Fcast_InputCatch_rd(i + 1, 5); // new method
          }
          else
          {
            Fcast_InputCatch(t, f, 2) = Fcast_InputCatch_Basis; // method before 3.24P
          }
        }
      }
    }
  }

  H4010_scale_vec.initialize();
  if (H4010_scale_rd >= 0.0)
  {
    echoinput << "fill H4010_scale_vec with single input" << endl;
    H4010_scale_vec = H4010_scale_rd;
  }
  else
  {
    echoinput << "fill H4010_scale_vec from input list; filling from read year to YrMax for each input" << endl;
    j = H4010_scale_vec_rd.size() - 1;
    int last_rd_yr;
    last_rd_yr = endyr;
    for (int s = 0; s <= j - 1; s++) // loop input
    {
      y = H4010_scale_vec_rd[s](1);
      echoinput << H4010_scale_vec_rd[s] << endl;
      if (y <= endyr)
      {
        warnstream << "; " << y << " is <= endyr; set to endyr+1 ";
        write_message(WARN, 1);
        y = endyr + 1;
      }
      if (y <= last_rd_yr)
      {
        warnstream << "; " << y << " is <= last_rd_yr; overwrite will occur ";
        write_message(WARN, 1);
      }
      last_rd_yr = y;
      if (y > YrMax)
      {
        warnstream << "; " << y << " is > YrMax; set to YrMax ";
        write_message(WARN, 0);
        y = YrMax;
      }
      for (k = y; k <= YrMax; k++)
      {
        H4010_scale_vec(k) = H4010_scale_vec_rd[s](2);
      }
    }
  }
  echoinput << "H4010_scale: " << H4010_scale_vec << endl;

  if (Do_Rebuilder == 1 && Do_Forecast_rd <= 0)
  {
    warnstream << "Error: Rebuilder output selected without requesting forecast";
    write_message(FATAL, 0);
  }
  if (Do_Benchmark == 0)
  {
    if (Do_Forecast_rd >= 1 && Do_Forecast_rd <= 3) {
      Do_Benchmark = 1;
      warnstream << "Turn Benchmark on because Forecast needs it";
      write_message(WARN, 0);
    }
    if (Do_Forecast == 0 && F_std_basis > 0)
    {
      F_std_basis = 0;
      warnstream << "Set F_std_basis=0 because no benchmark or forecast";
      write_message(WARN, 0);
    }
    if (depletion_basis == 2 || depletion_basis == 6 )
    {
      depletion_basis = 1;
      warnstream << "Change depletion basis to 1 because benchmarks were not requested";
      write_message(WARN, 0);
    }
    if (SPR_reporting >= 1 && SPR_reporting <= 3)
    {
      SPR_reporting = 5;
      warnstream << "Change SPR_reporting to 5 (raw %SPR) because benchmarks were not requested";
      write_message(WARN, 0);
    }
  }
  else
  {
    if (Do_MSY == 0)
    {
      warnstream << "Setting Do_MSY=1 because benchmarks are on";
      write_message(WARN, 0);
      Do_MSY = 1;
    }
  }

  if (Fcast_Sel_yr1 > Fcast_Sel_yr2)  // tagcode  these checks seem unnecessary because of checks already done upon reading values
  {
    warnstream << " Error, Fcast_Sel_Yr1 must be at or before Fcast_Sel_Yr2";
    write_message(FATAL, 1);
  }
  if (Fcast_Sel_yr1 > endyr || Fcast_Sel_yr1 < styr)
  {
    warnstream << " Error, Fcast_Sel_Yr1 must be between styr and endyr";
    write_message(FATAL, 1);
  }
  if (Fcast_Sel_yr2 > endyr || Fcast_Sel_yr2 < styr)
  {
    warnstream << " Error, Fcast_Sel_Yr2 must be between styr and endyr";
    write_message(FATAL, 1);
  }
  if (Fcast_Rec_yr1 > Fcast_Rec_yr2)
  {
    warnstream << " Error, Fcast_Rec_Yr1 must be at or before Fcast_Rec_Yr2";
    write_message(FATAL, 1);
  }
  if (Fcast_Rec_yr1 > endyr || Fcast_Rec_yr1 < styr)
  {
    warnstream << " Error, Fcast_Rec_Yr1 must be between styr and endyr";
    write_message(FATAL, 1);
  }
  if (Fcast_Rec_yr2 > endyr || Fcast_Rec_yr2 < styr)
  {
    warnstream << " Error, Fcast_Rec_Yr2 must be between styr and endyr";
    write_message(FATAL, 1);
  }

  did_MSY = 0;
  if (Do_Forecast > 0)
    *(ad_comm::global_datafile) >> fif;

  if (Do_Forecast_rd > 0 && fif != 999)
  {
    warnstream << " Error, must have 999 to verify end of forecast inputs. value: " << fif;
    write_message(FATAL, 1);
  }
  echoinput << " done reading forecast " << endl
            << endl;
  //  if (Do_Forecast == 0) Do_Forecast = 4;
  TimeMax_Fcast_std = styr + (max(YrMax, endyr + 50) - styr) * nseas + nseas - 1;

  // redefine ALK_time_max for forecast years longer than 50, but no data past 50 years
  j = max(YrMax, endyr + 50);
  ALK_time_max = (j - styr + 1) * nseas * N_subseas; // sets maximum size for data array indexing 50 years into forecast
  // clang-format off
 END_CALCS

  imatrix Show_Time(styr,TimeMax_Fcast_std,1,2) // for each t:  shows year, season
  imatrix Show_Time2(1,ALK_time_max,1,3) // for each ALK_time:  shows year, season, subseas
 LOCAL_CALCS
  // clang-format on
  t = styr - 1;
  for (y = styr; y <= max(YrMax, endyr + 50); y++) /* SS_loop:  fill Show_Time(t,1) with year value */
    for (s = 1; s <= nseas; s++) /* SS_loop:  fill Show_Time(t,2) with season value */
    {
      t++;
      Show_Time(t, 1) = y;
      Show_Time(t, 2) = s;
    }
  ALK_idx = 0;
  for (y = styr; y <= max(YrMax, endyr + 50); y++)
    for (s = 1; s <= nseas; s++)
      for (subseas = 1; subseas <= N_subseas; subseas++)
      {
        ALK_idx++;
        Show_Time2(ALK_idx, 1) = y;
        Show_Time2(ALK_idx, 2) = s;
        Show_Time2(ALK_idx, 3) = subseas;
      }
  // clang-format off
 END_CALCS

//  matrix env_data_RD(styr-1,YrMax,1,N_envvar)
  vector env_data_mean(1,N_envvar);
  vector env_data_stdev(1,N_envvar);
  vector env_data_N(1,N_envvar);
  ivector env_data_minyr(1,N_envvar);
  ivector env_data_maxyr(1,N_envvar);
  ivector env_data_do_mean(1,N_envvar);
  ivector env_data_do_stdev(1,N_envvar);

 LOCAL_CALCS
  // clang-format on
  {
    env_data_mean.initialize();
    env_data_stdev.initialize();
    env_data_N.initialize();
    env_data_minyr.initialize();
    env_data_maxyr.initialize();
    env_data_do_mean.initialize();
    env_data_do_stdev.initialize();

    if (N_envdata > 0)
    {
      env_data_minyr = 9876;
      for (i = 0; i <= N_envdata - 1; i++)
      {
        y = env_temp[i](1);
        k = env_temp[i](2);
        if (y <= -1) //  flag to do_mean  so use -2 to get mean but not stdev
        {
          env_data_do_mean(k) = 1;
        }
        if (y == -1) //  flag to do_stdev
        {
          env_data_do_stdev(k) = 1;
        }
        if (y >= (styr - 1) && y <= YrMax)
        {
          env_data_mean(k) += env_temp[i](3);
          env_data_stdev(k) += env_temp[i](3) * env_temp[i](3);
          env_data_N(k)++;
          env_data_minyr(k) = min(env_data_minyr(k), y);
          env_data_maxyr(k) = max(env_data_maxyr(k), y);
        }
      }
      echoinput << " process environmental input data" << endl;
      for (k = 1; k <= N_envvar; k++)
      {
        if (env_data_N(k) > 0)
        {
          env_data_mean(k) /= env_data_N(k);
        }
        else
        { //  no data
        }
        if (env_data_N(k) > 1)
        {
          temp = env_data_stdev(k) / (env_data_N(k) - 1.);
          env_data_stdev(k) = sqrt(temp - env_data_mean(k) * env_data_mean(k));
        }
        else
        { //  no data
        }
        echoinput << k << " N " << env_data_N(k) << " min-max year " << env_data_minyr(k) << " " << env_data_maxyr(k) << " mean " << env_data_mean(k) << " stdev " << env_data_stdev(k) << " subtract mean " << env_data_do_mean(k) << " divide stddev " << env_data_do_stdev(k) << endl;
      }
    }
  }
  // clang-format off
 END_CALCS


!!// SS_Label_Info_3.2 #Create complete list of years for STD reporting
  ivector STD_Yr_Reverse(styr-2,YrMax);   //  contains 0/1 for each year to indicate std reporting
  ivector STD_Yr_Reverse_Dep(styr-2,YrMax);  //  contains index number to i'th depletion (e.g. Bratio) std
  ivector STD_Yr_Reverse_Ofish(styr-2,YrMax);  //  ditto
  ivector STD_Yr_Reverse_F(styr-2,YrMax);  //  ditto
  int N_STD_Yr_Dep;
  int N_STD_Yr_Ofish;
  int N_STD_Yr_F;
  int N_STD_Mgmt_Quant;

 LOCAL_CALCS
  // clang-format on
  if (STD_Yr_min < 0 || STD_Yr_min < (styr - 2))
    STD_Yr_min = styr - 2;
  if (STD_Yr_max == -1)
    STD_Yr_max = endyr + 1;
  if (STD_Yr_max == -2)
    STD_Yr_max = YrMax;
  if (STD_Yr_max > YrMax)
    STD_Yr_max = YrMax;
  STD_Yr_Reverse.initialize();
  for (y = STD_Yr_min; y <= STD_Yr_max; y++)
  {
    STD_Yr_Reverse(y) = 1;
  }
  STD_Yr_Reverse(styr - 2) = 1;
  STD_Yr_Reverse(styr - 1) = 1;
  STD_Yr_Reverse(styr) = 1;
  for (i = 1; i <= N_STD_Yr_RD; i++)
  {
    if (STD_Yr_RD(i) >= styr && STD_Yr_RD(i) <= YrMax)
    {
      STD_Yr_Reverse(STD_Yr_RD(i)) = 1;
    }
  }
  N_STD_Yr = sum(STD_Yr_Reverse);  //  count number of years for which std is requested

  STD_Yr_Reverse_Dep.initialize();
  STD_Yr_Reverse_Ofish.initialize();
  STD_Yr_Reverse_F.initialize();
  j = 0;
  N_STD_Yr_Dep = 0;
  N_STD_Yr_Ofish = 0;
  N_STD_Yr_F = 0;

  echoinput << "SPR_reporting " << SPR_reporting << endl;
  echoinput << "F_reporting " << F_reporting << endl;
  for (y = styr - 2; y <= YrMax; y++)
  {
    if (STD_Yr_Reverse(y) > 0)
    {
      j++;
      STD_Yr_Reverse(y) = j; // use for SSB and recruitment
      if (y >= styr)
      {
        // depletion must start in year AFTER first catch.  It could vary earlier if recdevs happened enough earlier to change SSBio, but this is not included
        if ((depletion_basis > 0 && y > first_catch_yr) || y == endyr)
        {
          N_STD_Yr_Dep++;
          STD_Yr_Reverse_Dep(y) = N_STD_Yr_Dep;
        }
        if (y <= endyr)
        {
          if ((SPR_reporting > 0 && totcat(y) > 0.0) || y == endyr)
          {
            N_STD_Yr_Ofish++;
            STD_Yr_Reverse_Ofish(y) = N_STD_Yr_Ofish;
          }
          if ((F_reporting > 0 && totcat(y) > 0.0) || y == endyr)
          {
            N_STD_Yr_F++;
            STD_Yr_Reverse_F(y) = N_STD_Yr_F;
          }
        }
        else
        {
          if (SPR_reporting > 0)
          {
            N_STD_Yr_Ofish++;
            STD_Yr_Reverse_Ofish(y) = N_STD_Yr_Ofish;
          }
          if (F_reporting > 0)
          {
            N_STD_Yr_F++;
            STD_Yr_Reverse_F(y) = N_STD_Yr_F;
          }
        }
      }
    }
  }
  echoinput << "Finished creating STD containers and indexes " << endl
            << " STD_SSB_Recr " << STD_Yr_Reverse << endl
            << " STD_deplet " << STD_Yr_Reverse_Dep << endl
            << " STD_SPR " << STD_Yr_Reverse_Ofish << endl
            << " STD_F " << STD_Yr_Reverse_F << endl;
  // clang-format off
 END_CALCS
// SS_Label_file  #4. **SS_readcontrol.tpl**
// SS_Label_file  # * read *control_file* named in starter.ss
// SS_Label_file  #     * define and read needed parameters from model options selected
// SS_Label_file  #     * creates labels for those parameters
// SS_Label_file  #     * uses a function found in SS_global, <u>create_timevary()</u>, to create, index and label time-varying parameters; including autogeneration option
// SS_Label_file  #     * creates and labels derived quantities
// SS_Label_file  #     * creates covariance matrix
// SS_Label_file  #     * reads *wt_at_age.ss* if requested
// SS_Label_file  # * finish DATA_SECTION

 LOCAL_CALCS
  // clang-format on
  //********CONTROLS********************************
  //  SS_Label_Info_4.0 #Begin Reading from Control File
  // /*  SS_Label_Flow  begin reading from control file */
  ad_comm::change_datafile_name(ctlfilename);
  echoinput << endl
            << " Begin reading control file " << endl;
  cout << " reading from control file" << endl;
  ifstream Control_Stream(ctlfilename); // even if the global_datafile name is used, there still is a different logical device created
  
  //  SS_Label_Info_4.1 #Read and store comments at top of control file
  k = 0;
  N_CC = 0;
  while (k == 0)
  {
    Control_Stream >> readline; // reads the line from input stream
    if (length(readline) > 2)
    {
      checkchar = readline(1);
      k = strcmp(checkchar, "#");
      checkchar = readline(1, 2);
      j = strcmp(checkchar, "#C");
      if (j == 0) {
        N_CC++;
        Control_Comments += readline;
      }
    }
  }
  // clang-format off
 END_CALCS

//  when a parameter is defined and its label (hence usage) is created,
//  the value of its min, max, init, prior have not yet been read
//  so when it gets created, need to pushback a code to indicate what special conditions affect it
//  also may want to save indicator of whether the parameter is multiplier, logit, etc.
//  so push_back a code to the ivector Parm_minmax
//  and add a string to the adstring_array Parm_info
  ivector minmax_types(1,10)  //  set of canned min-max types

!!//  SS_Label_Info_4.2 #Read info for growth patterns, gender, settlement events, platoons
  init_int WTage_rd  // 0 means do not read wtatage.ss; 1 means read and use wtatage.ss and also read and use growth parameters
                     //  future option 2 will suppress reading and use of growth
!!echoinput<<WTage_rd<<" wtatage switch "<<endl;
!!if (WTage_rd > 0) timevary_MG_firstyr = styr;
  init_int N_GP  // number of growth patterns (morphs)
!!echoinput<<N_GP<<" N growth patterns "<<endl;
  init_int N_platoon  //  number of platoons  1, 3, 5 are best values to use
!!echoinput<<N_platoon<<"  N platoons (1, 3 or 5)"<<endl;

  number sd_ratio_rd;  // ratio of stddev within platoon to between morphs from file
  number platoon_sd_ratio;  // ratio of stddev within platoon to between morphs
  number sd_within_platoon;
  number sd_between_platoon;

  ivector ishadow(1,N_platoon);
  vector shadow(1,N_platoon);
  vector platoon_distr(1,N_platoon);

 LOCAL_CALCS
  // clang-format on
  if (WTage_rd > 0)
  {
    // Remove unnecessary or confusing reports (issue #383)
    pick_report_use(8) = "N";
    pick_report_use(27) = "N";
    pick_report_use(31) = "N";
    pick_report_use(38) = "N";
    pick_report_use(42) = "N";
    // Incompatible option, fatal condition 
    if (nobs_mnwt > 0)
    {
	  warnstream << "expected value for mean body-wt will be from the growth curve, not from empirical wtatage.ss";
      write_message (WARN, 1);
    }
  }
  
  if (N_platoon > 1)
  {
    *(ad_comm::global_datafile) >> sd_ratio_rd;
    *(ad_comm::global_datafile) >> platoon_distr;
    echoinput << sd_ratio_rd << "  sd_ratio_rd" << endl;
    echoinput << platoon_distr << "  platoon_distr" << endl;
  }
  else
  {
    sd_ratio_rd = 1.;
    platoon_distr(1) = 1.;
    echoinput << "  do not read sd_ratio or platoon_distr" << endl;
  }
  //  SS_Label_Info_4.2.1 #Assign distribution among growth platoons if needed
  if (platoon_distr(1) < 0.)
  {
    if (N_platoon == 1)
    {
      platoon_distr(1) = 1.;
    }
    else if (N_platoon == 3)
    {
      platoon_distr.fill("{0.15,0.70,0.15}");
    }
    else if (N_platoon == 5)
    {
      platoon_distr.fill("{0.031, 0.237, 0.464, 0.237, 0.031}");
    }
  }
  platoon_distr /= sum(platoon_distr);
  // calculate stdev values
  if (sd_ratio_rd < 0)
  {
    platoon_sd_ratio = -sd_ratio_rd;
    warnstream << "sd_ratio read is < 0, so expecting sd parameter after movement params.";
    write_message (NOTE, 1);
  }
  else
  {
    platoon_sd_ratio = sd_ratio_rd;
  }
  if (N_platoon > 1)
  {
    sd_between_platoon = sqrt(1. / (1. + platoon_sd_ratio * platoon_sd_ratio));
    sd_within_platoon = platoon_sd_ratio * sd_between_platoon;
  }
  else
  {
    sd_between_platoon = 0.000001;
    sd_within_platoon = 1;
  }
  
  if (N_platoon == 1)
  {
    ishadow(1) = 0;
    shadow(1) = 0.;
  }
  else if (N_platoon == 3)
  {
    ishadow.fill_seqadd(-1, 1);
    shadow.fill_seqadd(-1., 1.);
  }
  else if (N_platoon == 5)
  {
    ishadow.fill_seqadd(-2, 1);
    shadow.fill_seqadd(-2., 1.);
  }
  else
  {
    warnstream << "illegal N platoons: " << N_platoon << "; must be 1, 3 or 5 " ;
    write_message (FATAL, 1); // EXIT!
  }
  // clang-format off
          
 END_CALCS

!!//  SS_Label_Info_4.2.2  #Define distribution of recruitment(settlement) among growth patterns, areas, months

  int recr_dist_method  //  1=like 3.24 (not used); 2=main effects for GP, Settle timing, Area; 3=each Settle entity; 4=no parms (only if GPXsettleXarea=1)
  int recr_dist_area  //  1=global SRR; 2=area-specific SRR
  int N_settle_assignments  //  number of assigned settlements for GP, Settle_month, Area (>=0)
  int N_settle_assignments_rd  //  number read, needed to distinguish between ss3.24 and SS3.30 setup
  int N_settle_timings  //  number of recruitment settlement timings per spawning (>=1) - important for number of morphs calculation
                         //  will be calculated from the number of unique settle_months among the settle_assignments
  int settle  //  index to settle_assignments
  int settle_time  //  index to setting timings
  int Comp_Err_Parm_Start
  int recr_dist_inx
 LOCAL_CALCS
  // clang-format on
  * (ad_comm::global_datafile) >> recr_dist_method;
  echoinput << recr_dist_method << "  # Recruitment distribution method; where: 2=parms for main effects for GP, Area, Settle timing; 3=one parm for each Settle event" << endl;
  *(ad_comm::global_datafile) >> recr_dist_area;
  echoinput << recr_dist_area << "  # future option for recr_dist_area: 1 is hardwired to do global SRR; 2 in future will do area-specific SRR" << endl;
  recr_dist_area = 1; //hardwire for testing
  N_settle_assignments_rd = 0;
  N_settle_assignments = 1; // default
  
  switch (recr_dist_method)
  {
    case 1:
    {
      *(ad_comm::global_datafile) >> N_settle_assignments_rd;
      *(ad_comm::global_datafile) >> recr_dist_inx;
      N_settle_assignments = N_settle_assignments_rd;
      break;
    }
    case 2:
    {
      *(ad_comm::global_datafile) >> N_settle_assignments;
      *(ad_comm::global_datafile) >> recr_dist_inx;
      break;
    }
    case 3:
    {
      *(ad_comm::global_datafile) >> N_settle_assignments;
      *(ad_comm::global_datafile) >> recr_dist_inx;
      break;
    }
    case 4:
    {
      *(ad_comm::global_datafile) >> N_settle_assignments;
      *(ad_comm::global_datafile) >> recr_dist_inx;
      if (N_settle_assignments > 1)
      {
        warnstream << "Need to change to recr_dist_method=3 because >1 settle assignments requested";
        write_message (FATAL, 0); // EXIT!
      }
      break;
    }
  }
  echoinput << N_settle_assignments << " Number of settlement events: GP/area/month to read (>=0) " << endl;
  if (recr_dist_method == 1)
  {
    warnstream << "recr_dist_method cannot be 1 in SS3.30 ";
    write_message (FATAL, 0); // EXIT!
  }
  else if (N_settle_assignments == 1 && recr_dist_method != 4)
  {
    warnstream << "This model has just one settlement event. Changing to recr_dist_method 4 and removing the recruitment distribution parameters at the end of the MG parms section (below growth parameters) will produce identical results and simplify the model.";
    write_message (SUGGEST, 0);
  }
  else if (recr_dist_method == 2)
  {
    warnstream << " recr_dist_method 3 is simpler and takes 1 parm for each settlement";
    write_message (SUGGEST, 0);
  }
  echoinput << recr_dist_inx << "  # unused option " << endl;
  // clang-format off
 END_CALCS

  int birthseas;  //  is this still needed??

  matrix settlement_pattern_rd(1,N_settle_assignments,1,4);   //  for each settlement event:  GPat, Month, area, age
  ivector settle_assignments_timing(1,N_settle_assignments);  //  stores the settle_timing index for each assignment
  matrix settle_timings_tempvec(1,N_settle_assignments,1,2)  //  temporary storage for real_month and age of each settlement_timing
                                                        //  dimensioned by assignments, but only uses N_settle_timings of these
 LOCAL_CALCS
          // clang-format on
          *(ad_comm::global_datafile) >>
      settlement_pattern_rd;
  echoinput << " settlement pattern as read " << endl
            << "GPat  Month  Area Age" << endl
            << "*" << settlement_pattern_rd << "*" << endl;
  echoinput << "Now calculate the number of unique settle timings, which will dictate the number of recr_dist_timing parameters " << endl;
  N_settle_timings = 0;
  settle_timings_tempvec.initialize();
  if (N_settle_assignments == 0)
  {
    N_settle_timings = 1;
    settle_timings_tempvec(1, 1) = 1.0;
    settle_timings_tempvec(1, 2) = 0;
  }
  else
  {
    for (settle = 1; settle <= N_settle_assignments; settle++)
    {
      real_month = settlement_pattern_rd(settle, 2);
      int settle_age_here = settlement_pattern_rd(settle, 4);
      if (N_settle_timings == 0)
      {
        N_settle_timings++;
        settle_timings_tempvec(N_settle_timings, 1) = real_month;
        settle_timings_tempvec(N_settle_timings, 2) = settle_age_here;
        settle_assignments_timing(settle) = N_settle_timings;
      }
      else
      {
        k = 0;
        for (j = 1; j <= N_settle_timings; j++)
        {
          if (settle_timings_tempvec(j, 1) == real_month && settle_timings_tempvec(j, 2) == settle_age_here) // found matching settle_time
          {
            settle_assignments_timing(settle) = j;
            k = 1;
          }
        }
        if (k == 0)
        {
          N_settle_timings++;
          settle_timings_tempvec(N_settle_timings, 1) = real_month;
          settle_timings_tempvec(N_settle_timings, 2) = settle_age_here;
          settle_assignments_timing(settle) = N_settle_timings;
        }
      }
    }
  }
  echoinput << "N settle timings: " << N_settle_timings << endl
            << " unique_settle_times: " << endl
            << settle_timings_tempvec << endl;
  echoinput << "settle events use these settle_times: " << settle_assignments_timing << endl;
  
  if (recr_dist_method == 2)
  {
    echoinput << " Need to read N_GP * Narea * N_settletimings=" << N_GP * pop * N_settle_timings << "  recruitment distribution parameters " << endl;
  }
  else if (recr_dist_method == 3)
  {
    echoinput << " Need to read N_settle_assignments=" << N_settle_assignments << "  recruitment distribution parameters " << endl;
  }
  
  //  SS_Label_Info_4.2.3 #Set-up arrays and indexing for growth patterns, gender, settlements, platoons
  // clang-format off
 END_CALCS
   int g3i;
//  SPAWN-RECR:   define settlement timings
  ivector Settle_seas(1,N_settle_timings)  //  calculated season in which settlement occurs
  ivector Settle_seas_offset(1,N_settle_timings)  //  calculated number of seasons between spawning and the season in which settlement occurs
  vector  Settle_timing_seas(1,N_settle_timings)  //  calculated elapsed time (frac of year) between settlement and the begin of season in which it occurs
  vector  Settle_month(1,N_settle_timings)  //  month (real)in which settlement occurs
  ivector Settle_age(1,N_settle_timings)  //  calculated age at which settlement occurs, with age 0 being the year in which spawning occurs
  3iarray recr_dist_pattern(1,N_GP,1,N_settle_timings,0,pop);  //  has flag to indicate each settlement events

 LOCAL_CALCS
  // clang-format on
  Settle_seas_offset.initialize();
  Settle_timing_seas.initialize();
  Settle_age.initialize();
  Settle_seas.initialize();
  recr_dist_pattern.initialize();
  
  echoinput << "Calculated assignments in which settlement occurs " << endl
            << "Settle_event / Month / Seas / Seas_from_spawn / time_from_seas_start / age_at_settle" << endl;
  if (N_settle_assignments > 0)
  {
    for (settle = 1; settle <= N_settle_assignments; settle++)
    {
      gp = settlement_pattern_rd(settle, 1); //  growth patterns
      p = settlement_pattern_rd(settle, 3); //  settlement area
      settle_time = settle_assignments_timing(settle);
      Settle_age(settle_time) = settlement_pattern_rd(settle, 4); //  settlement age as read
      recr_dist_pattern(gp, settle_time, p) = 1; //  indicates that settlement will occur here
      recr_dist_pattern(gp, settle_time, 0) = 1; //  for growth updating
      Settle_month(settle_time) = settle_timings_tempvec(settle_time, 1);
    }
    for (settle_time = 1; settle_time <= N_settle_timings; settle_time++)
    {
      j = 0; //  temp value for calculated settlement age
      if (spawn_month > Settle_month(settle_time))
      {
        k = 1;
        j++; //  so sets season 1 as earliest possible settlement at age 1
      }
      else
      {
        k = spawn_seas; //  earliest possible season for settlement at age 0
      }
      temp = azero_seas(k); //  annual elapsed time fraction at begin of this season
      Settle_timing_seas(settle_time) = (Settle_month(settle_time) - 1.0) / sumseas; //  fraction of year at settlement month
  
      while ((temp + seasdur(k)) <= Settle_timing_seas(settle_time))
      {
        temp += seasdur(k);
        if (k == nseas)
        {
          k = 1;
          j++;
        }
        else
        {
          k++;
        }
      }
      if (j != Settle_age(settle_time))
      {
        warnstream << "settle_month is less than spawn_month, so logical age at settlement calculated to be: " << j
                   << "  for settle_time " << settle_time << ".  Does not match read value of " << Settle_age(settle_time) << " are you sure? ";
        write_message (NOTE, 0);
      }
      Settle_seas(settle_time) = k;
      Settle_seas_offset(settle_time) = Settle_seas(settle_time) - spawn_seas + j * nseas; //  number of seasons between spawning and the season in which settlement occurs
      Settle_timing_seas(settle_time) -= temp; //  timing from beginning of this season; needed for mortality calculation
      echoinput << settle_time << " / " << Settle_month(settle_time);
      echoinput << "  /  " << Settle_seas(settle_time) << " / " << Settle_seas_offset(settle_time) << " / "
                << Settle_timing_seas(settle_time) << "  / " << Settle_age(settle_time) << endl;
      if (Settle_seas_offset(settle_time) == 0 && spawn_time_seas > 0.0)
      {
        warnstream << "Cannot have spawn_time_seas after beginning of a season and settlements in the same season" << endl
                   << "++ put spawning at beginning of the season, or move settlements to next season";
        write_message (FATAL, 0); // EXIT!
      }
    }
  }
  else
  {
    recr_dist_pattern(1, 1, 1) = 1;
    recr_dist_pattern(1, 1, 0) = 1;
    Settle_month(1) = 1.;
    Settle_timing_seas(1) = 0.0;
    Settle_seas(1) = 1;
    Settle_seas_offset(1) = 0;
    Settle_age(1) = 0;
  }
  
  gmorph = gender * N_GP * N_settle_timings * N_platoon; //  total potential number of biological entities, some may not get used so see use_morph(g)
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.2.1.1 #Define indexing vectors to keep track of characteristics of each morph
  ivector sx(1,gmorph) //  define sex for each growth morph
  ivector GP4(1,gmorph)   // index to GPat
  ivector GP(1,gmorph)    //  index for gender*GPat;  note that gp is nested inside gender
  ivector GP3(1,gmorph)   // index for main gender*GPat*settlement
  ivector GP2(1,gmorph)  // reverse pointer for platoon
  imatrix g_finder(1,N_GP,1,gender)  //  reverse pointer to middle "g" for each main morph (used only with Growth_Std
  ivector g_Start(1,N_GP*gender)  //  base "g" for this growth pattern
  ivector Bseas(1,gmorph)  // birth season
//  following two containers are used to track which morphs are being used
  ivector use_morph(1,gmorph)
  imatrix TG_use_morph(1,N_TG2,1,gmorph)
  imatrix ALK_range_g_lo(1,N_subseas*nseas*gmorph,0,nages)
  imatrix ALK_range_g_hi(1,N_subseas*nseas*gmorph,0,nages)

  vector azero_G(1,gmorph);  //  time since Jan 1 at beginning of settlement in which "g" was born
  3darray real_age(1,gmorph,1,nseas*N_subseas,0,nages);  // real age since settlement
  3darray keep_age(1,gmorph,1,nseas*N_subseas,0,nages);  // set to 0.0 if real_age<0.  this allows omitting virtual young fish to be excluded from expected values
  3darray calen_age(1,gmorph,1,nseas*N_subseas,0,nages);  // real age since Jan 1 of spawn year

  3darray lin_grow(1,gmorph,1,nseas*N_subseas,0,nages)  //  during linear phase has fraction of Size at Afix
  ivector settle_g(1,gmorph)   //  settlement pattern for each platoon
  int ALK_count;

 LOCAL_CALCS
  // clang-format on
  ALK_count = 0;
  
  use_morph.initialize();
  TG_use_morph.initialize();
  keep_age.initialize();
  keep_age = 1.0;
  
  for (gp = 1; gp <= N_GP * gender; gp++)
  {
    g_Start(gp) = (gp - 1) * N_settle_timings * N_platoon + int(N_platoon / 2) + 1 - N_platoon; // find the mid-morph being processed
  }
  
  g = 0;
  g3i = 0;
  echoinput << endl
            << "MORPH_INDEXING" << endl;
  echoinput << "g Sex GP Settlement Birth_Seas Platoon Platoon% Sex*GP Sex*GP*settle_time Used(0/1) SettleTime_frac_yr" << endl;
  for (gg = 1; gg <= gender; gg++)
    for (gp = 1; gp <= N_GP; gp++)
      for (settle = 1; settle <= N_settle_timings; settle++)
      {
        g3i++;
        {
          for (gp2 = 1; gp2 <= N_platoon; gp2++)
          {
            g++;
            GP3(g) = g3i; // track counter for main morphs (gender x pattern x settlement)
            Bseas(g) = Settle_seas(settle);
            sx(g) = gg;
            GP(g) = gp + (gg - 1) * N_GP; // counter for pattern x gender so gp is nested inside gender
            GP2(g) = gp2; //   reverse pointer to platoon counter
            GP4(g) = gp; //  counter for growth pattern
            settle_g(g) = settle; //  to find the settlement timing for this platoon
            azero_G(g) = (Settle_month(settle) - 1.0) / sumseas; //  settlement month converted to fraction of year; could be > one year
            for (p = 1; p <= pop; p++)
            {
              if (recr_dist_pattern(gp, settle, p) == 1)
              {
                use_morph(g) = 1;
              }
            }
            if (use_morph(g) == 1)
            {
              if ((N_platoon == 1) || (N_platoon == 3 && gp2 == 2) || (N_platoon == 5 && gp2 == 3)) g_finder(gp, gg) = g; // finds g for a given GP and gender and last birstseason
            }
            echoinput << g << "   " << sx(g) << "  " << GP4(g) << "       " << settle << "       " << Bseas(g) << "       "
                      << GP2(g) << "       " << 100. * platoon_distr(GP2(g)) << "       " << GP(g) << "        " << GP3(g) << "               " << use_morph(g) << "       " << azero_G(g) << endl;
          }
        }
      }
  echoinput << "calen_age is elapsed years since beginning of year in which spawning occurred" << endl;
  echoinput << "real_age is elapsed years since settlement" << endl;
  echoinput << "g  s  subseas  ALK_idx settle_time age@settle age real_age calen_age" << endl;
  calen_age.initialize();
  real_age.initialize();
  keep_age.initialize();
  for (g = 1; g <= gmorph; g++)
    if (use_morph(g) == 1)
      for (s = 1; s <= nseas; s++)
        for (subseas = 1; subseas <= N_subseas; subseas++)
        {
          ALK_idx = (s - 1) * N_subseas + subseas;
          settle_time = settle_g(g);
          //   real_age is real age since settlement and is used in growth calculations
          //   calen_age is real age since the beginning of the year in which spawning occurred
          for (a = 0; a <= nages; a++)
          {
            calen_age(g, ALK_idx, a) = r_ages(a) + azero_seas(s) + double(subseas - 1) / double(N_subseas) * seasdur(s);
            if (a < Settle_age(settle_time))
            {
              real_age(g, ALK_idx, a) = 0.;
              keep_age(g, ALK_idx, a) = 0.;
            }
            else if (a == Settle_age(settle_time))
            {
              if (calen_age(g, ALK_idx, a) >= (azero_G(g) + Settle_age(settle_time)))
              {
                real_age(g, ALK_idx, a) = calen_age(g, ALK_idx, a) - azero_G(g) - Settle_age(settle_time);
                keep_age(g, ALK_idx, a) = 1.;
              }
              else
              {
                real_age(g, ALK_idx, a) = 0.;
                keep_age(g, ALK_idx, a) = 0.;
              }
            }
            else
            {
              real_age(g, ALK_idx, a) = calen_age(g, ALK_idx, a) - azero_G(g) - Settle_age(settle_time);
              keep_age(g, ALK_idx, a) = 1.;
            }
            if (a < 4) echoinput << g << " " << s << " " << subseas << " " << ALK_idx << " " << settle_time << " " << Settle_age(settle_time)
                                 << " " << a << " " << real_age(g, ALK_idx, a) << " " << calen_age(g, ALK_idx, a) << endl;
          }
        }
  
  if (N_TG > 0)
  {
    for (TG = 1; TG <= N_TG; TG++)
    {
      for (g = 1; g <= gmorph; g++)
      {
        if (TG_release(TG, 6) > 2)
        {
          warnstream << "Gender for tag groups must be 0, 1 or 2 ";
          write_message (WARN, 0);
        }
        if (use_morph(g) > 0 && (TG_release(TG, 6) == 0 || TG_release(TG, 6) == sx(g))) TG_use_morph(TG, g) = 1;
      }
    }
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.3  #Define movement between areas
   int do_migration  //  number of explicit movements to define
   number migr_firstage
   matrix migr_start(1,nseas,1,N_GP)
 LOCAL_CALCS
   // clang-format on
   migr_firstage = 0.0;
  do_migration = 0;
  if (pop > 1)
  {
    *(ad_comm::global_datafile) >> do_migration;
    echoinput << do_migration << " N_migration definitions to read" << endl;
    if (do_migration > 0)
    {
      *(ad_comm::global_datafile) >> migr_firstage;
      echoinput << migr_firstage << " migr_firstage" << endl;
    }
  }
  else
  {
    echoinput << " only 1 area, so no read of do_migration or migr_firstage " << endl;
  }
  // clang-format off
 END_CALCS
  init_matrix move_def(1,do_migration,1,6)   // seas morph source dest minage maxage
//  ivector GP3(1,gmorph)   // index for main gender*GPat*settlement in that order
//  plan to revise such that movement is by GP3, not GP
   4iarray move_pattern(1,nseas,1,N_GP,1,pop,1,pop)
   int do_migr2
   ivector firstBseas(1,N_GP)

 LOCAL_CALCS
      // clang-format on
      move_pattern.initialize();
  do_migr2 = 0;
  if (do_migration > 0)
  {
    echoinput << " migration setup " << endl
              << move_def << endl;
    for (k = 1; k <= do_migration; k++)
    {
      s = move_def(k, 1);
      gp = move_def(k, 2);
      p = move_def(k, 3);
      p2 = move_def(k, 4);
      move_pattern(s, gp, p, p2) = k; // save index for definition of this pattern to find the right parameters
    }
    k = do_migration;
    for (s = 1; s <= nseas; s++)
      for (gp = 1; gp <= N_GP; gp++)
        for (p = 1; p <= pop; p++)
        {
          if (move_pattern(s, gp, p, p) == 0) {
            k++;
            move_pattern(s, gp, p, p) = k;
          } //  no explicit migration for staying in this area, so create implicit
        }
  
    do_migr2 = k; //  number of explicit plus implicit movement rates
    migr_start.initialize();
    // need to modify so it only does the calc for the first settlement used for each GP???
    for (gp = 1; gp <= N_GP; gp++)
    {
      //  use firstBseas so that the start age of migration is calculated only for the first birthseason used for each GP
      firstBseas(gp) = 0;
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          if (GP4(g) == gp && firstBseas(gp) == 0) firstBseas(gp) = Bseas(g);
        }
    }
    for (g = 1; g <= gmorph; g++)
      if (use_morph(g) > 0 && firstBseas(GP4(g)) == Bseas(g))
      {
        for (s = 1; s <= nseas; s++)
          for (subseas = 1; subseas <= N_subseas; subseas++)
          {
            a = 0;
            ALK_idx = (s - 1) * N_subseas + subseas;
            while (real_age(g, ALK_idx, a) < migr_firstage) {
              a++;
            }
            migr_start(s, GP4(g)) = a;
          }
      }
  }
  // clang-format off
 END_CALCS
   matrix move_def2(1,do_migr2,1,6)    //  movement definitions.  First Do_Migration of these are explicit; rest are implicit

 LOCAL_CALCS
      // clang-format on
      if (do_migration > 0)
  {
    for (k = 1; k <= do_migration; k++) {
      move_def2(k) = move_def(k);
    }
    k = do_migration;
    for (s = 1; s <= nseas; s++)
      for (gp = 1; gp <= N_GP; gp++)
        for (p = 1; p <= pop; p++)
        {
          if (move_pattern(s, gp, p, p) > do_migration)
          {
            k++;
            move_def2(k, 1) = s;
            move_def2(k, 2) = gp;
            move_def2(k, 3) = p;
            move_def2(k, 4) = p;
            move_def2(k, 5) = 0;
            move_def2(k, 6) = nages;
          }
        }
    echoinput << "move_def " << endl
              << move_def2 << endl;
  }
  // clang-format off
 END_CALCS


!!//  SS_Label_Info_4.4 #Define the time blocks for time-varying parameters
  int N_Block_Designs                      // read N block designs
  ivector Nblk(1,1)
  imatrix Block_Design(1,1,1,1)
 LOCAL_CALCS
          // clang-format on
          * (ad_comm::global_datafile) >>
      N_Block_Designs;
  echoinput << N_Block_Designs << " N_Block_Designs" << endl;
  if (N_Block_Designs > 0)
  {
    Nblk.deallocate();
    Nblk.allocate(1, N_Block_Designs);
    *(ad_comm::global_datafile) >> Nblk(1, N_Block_Designs);
    echoinput << Nblk << " N_Blocks_per design" << endl;
  
    ivector Nblk2; //  temporary vector to create ragged array of dimensions for block matrix
    Nblk2.allocate(1, N_Block_Designs);
    Nblk2 = Nblk + Nblk;
    Block_Design.deallocate();
    Block_Design.allocate(1, N_Block_Designs, 1, Nblk2);
    bool endyrChk = false;
    for (j = 1; j <= N_Block_Designs; j++)
    {
      *(ad_comm::global_datafile) >> Block_Design(j)(1, Nblk2(j));
      a = -1;
      for (k = 1; k <= Nblk(j); k++)
      {
        a += 2;
        b = a + 1;
        if (Block_Design(j, b) == -1)
        {
          Block_Design(j, b) = endyr;
        }
        else if (Block_Design(j, b) == -2)
        {
          Block_Design(j, b) = YrMax;
        }
        // check block year values
        if (Block_Design(j, b) > YrMax)
        {
          if (Block_Design(j, b) < 999)  // manual suggests use of 9999, so 999 is safe choice here
          {
            warnstream << "Block_design:" << j << ", block: " << k << ", ends in: " << Block_Design(j, a + 1) << " reset to YrMax:  " << YrMax;
            write_message (ADJUST, 0);
          }
          Block_Design(j, b) = YrMax;
        }
        if (Block_Design(j, a) < styr - 1)
        {
          warnstream << "Block:" << j << " " << k << " starts before styr; resetting";
          write_message (ADJUST, 0);
          Block_Design(j, a) = styr;
        }
        if (Block_Design(j, b) < Block_Design(j, a))
        {
          warnstream << "Block:" << j << " " << k << " ends before it starts; fatal error";
          write_message (FATAL, 0); // EXIT!
        }
        if (Block_Design(j, b) < styr - 1)
        {
          warnstream << "Block:" << j << " " << k << " ends before styr; fatal error";
          write_message (FATAL, 1); // EXIT!
        }
        if (Block_Design(j, a) > retro_yr + 1)
        {
          warnstream << "Block:" << j << " " << k << " starts after retroyr+1; should not estimate ";
          write_message (WARN, 0);
        }
        if (Block_Design(j, b) > retro_yr + 1)
        {
          warnstream << "Block:" << j << " " << k << " ends in: " << Block_Design(j, a + 1) << " after retroyr+1:  " << retro_yr + 1;
          write_message (WARN, 0);
        }
        if (Block_Design(j, a) > YrMax)
        {
          warnstream << "Block:" << j << " " << k << " starts in: " << Block_Design(j, a + 1) << " which is > YrMax:  " << YrMax << " fatal error";
          write_message (FATAL, 0); // EXIT!
        }
        if (Block_Design(j, b) == endyr)
        {
          endyrChk = true;
        }
      }
      echoinput << " block design #: " << j << "  read year pairs: " << Block_Design(j) << endl;
    }
    if (endyrChk == true)
    {
      warnstream << "At least one block pattern ends in endyr. Check the output parameter value time series to see if the values in forecast years are as intended.";
      write_message (WARN, 0);
    }
  }
  else
  {
    Nblk.allocate(1, 1);
    Block_Design.allocate(1, 1, 1, 1);
  }
  // clang-format off
 END_CALCS

  init_int parm_adjust_method
!! echoinput<<parm_adjust_method<<"  timevarying parameter constraint method"<<endl;
  init_ivector autogen_timevary(1,5);  //  0 means to autogenerate time-vary parameters; 1 means to read; (2) read then autogen if parm min==-12345
                                       //  first element for biology, 2nd for SRR; 3rd for Q; 4th for tag; 5th for selex
!! echoinput<<autogen_timevary<<"  timevarying parameter autogenerate (0) or read (1) for each parm type or (2) read then autogen if parm min==-12345"<<endl;
   ivector varparm_estimated(1,5)  // flag to show what types of variance parameters are estimated
   // (1) for growth
   // (2)  for recruitment sigmaR
   // (3)  for survey extraSD
!!  varparm_estimated.initialize();

!!//  SS_Label_Info_4.5 #Read setup and parameters for natmort, growth, biology, recruitment distribution, and migration
// read setup for natmort parameters:  LO, HI, INIT, PRIOR, PR_type, CV, PHASE, use_env, use_dev, dev_minyr, dev_maxyr, dev_phase, Block, Block_type
  int N_MGparm
  int N_natMparms
  int N_predparms
  ivector predparm_pointer(1,Nfleet+1)
  int N_growparms
  int N_M_Grow_parms
  int recr_dist_parms
  int natM_type
  int natM_5_opt  //  option selection for Maunder approach
  imatrix MGparm_point(1,gender,1,N_GP)
  vector NatM_break(1,1);
  matrix Age_NatMort(1,1,1,1);
  number natM_amin;
  number natM_amax;
  number fracfemale;
!!fracfemale=1.00;
  number fracfemale_mult;
!!fracfemale_mult=1.0;  //  multiplier used in female SSB calc; gets changed to femfrac(1) if gender_rd==-1

// read natmort setup
 LOCAL_CALCS
  // clang-format on
  N_natMparms = 0;
  N_predparms = N_pred;
  if (nseas > 1) N_predparms += N_pred * nseas;
  natM_5_opt = 0;
  MGparm_point.initialize();
  //  0=1Parm; 1=segmented; 2=Lorenzen; 3=agespecific; 4=agespec with seas interpolate; 5=Maunder_M; 6=Lorenzen range
  *(ad_comm::global_datafile) >> natM_type;
  echoinput << natM_type << " natM_type" << endl;
  switch (natM_type)
  {
    case 0:
    {
      N_natMparms = 1;
      break;
    }
    case 1:
    {
      *(ad_comm::global_datafile) >> N_natMparms;
      echoinput << N_natMparms << " N breakpoints " << endl;
      NatM_break.deallocate();
      NatM_break.allocate(1, N_natMparms);
      *(ad_comm::global_datafile) >> NatM_break(1, N_natMparms);
      echoinput << NatM_break << " NatM_age_segment_breaks " << endl;
      break;
    }
    case 2:
    {
      N_natMparms = 1;
      *(ad_comm::global_datafile) >> natM_amin;
      echoinput << natM_amin << " natM_A for Lorenzen" << endl;
      break;
    }
    case 3:
    {
      //  same as 4
    }
    case 4:
    {
      N_natMparms = 0;
      Age_NatMort.deallocate();
      Age_NatMort.allocate(1, N_GP * gender, 0, nages);
      for (gp = 1; gp <= N_GP * gender; gp++)
      {
        *(ad_comm::global_datafile) >> Age_NatMort(gp)(0, nages);
      }
      echoinput << " Age_NatMort empirical input: " << endl
                << Age_NatMort << endl;
      break;
    }
    case 5:
    {
      //  Maunder et al. age and sex specific M
      // A) read in an integer for the method to do maturity Maunder_MatType = 1,2,3
      *(ad_comm::global_datafile) >> natM_5_opt;
      echoinput << " Maunder_NatMort option: " << natM_5_opt << endl;
      N_natMparms = 4;
      if (natM_5_opt == 3) N_natMparms = 6;
      //            Maunder_Mjuv = natMparms(1,gp);
      //            Maunder_lambda = natMparms(2,gp);
      //            Maunder_lmat = natMparms(3,gp);
      //            Maunder_Mmat = natMparms(4,gp);
      //            if(natM_5_opt==3){	//use two parameters  mat50% and mat_slope.
      //        		Maunder_L50  = natMparms(5,gp);
      //		        Maunder_beta = natMparms(6,gp);
      break;
    }
    case 6:
    {
      N_natMparms = 1;
      *(ad_comm::global_datafile) >> natM_amin;
      echoinput << natM_amin << " natM_minage for Lorenzen" << endl;
      *(ad_comm::global_datafile) >> natM_amax;
      echoinput << natM_amax << " natM_maxage for Lorenzen" << endl;
      break;
    }
  }
  // clang-format off
 END_CALCS

// read growth setup
  init_int Grow_type  // 1=vonbert; 2=Richards; 3=age-specific K ascend;  4=age-specific K descend; 5=age-specific K; 6=read vector(not implemented); 8=growth cessation
!!echoinput<<Grow_type<<" growth model "<<endl;
!!//  SS_Label_Info_4.5.1 #Create time constants for growth
  number AFIX;
  number AFIX2;
  number AFIX2_forCV;
  number AFIX_delta;
  number AFIX_plus;
  number Linf_decay;  //  decay factor to calculate mean L at maxage from Linf and the decaying abundance above maxage
                      //  forced equal to 0.20 in 3.24 (which also assumed linear, not VBK, growth)
  int do_ageK;
  ivector first_grow_age(1,gmorph);
!! first_grow_age.initialize();
!! k=0;
!! do_ageK=0;
!! if(Grow_type<=2 || Grow_type==8) {k=4;}  //  AFIX and AFIX2
!! if (Grow_type>=3 && Grow_type<=5) {do_ageK=1; k=5;}  //  number of ages for age-specific K
  init_vector tempvec5(1,k)
  int Age_K_count;

 LOCAL_CALCS
  // clang-format on
  Age_K_count = 0;
  if (k > 0) echoinput << tempvec5 << " # growth specifications: AFIX1 AFIX2 LINF_decay placeholder  age-specific_K_ages" << endl;
  k1 = 0;
  AFIX = 0.;
  AFIX2 = 999.; // this value invokes setting Linf equal to the L2 parameter
  Linf_decay = 0.0; //  initialize
  if (Grow_type == 1)
  {
    N_growparms = 5;
    AFIX = tempvec5(1);
    AFIX2 = tempvec5(2);
    Linf_decay = tempvec5(3);
    //  tempvec(4) is a placeholder
  }
  else if (Grow_type == 2 || Grow_type == 8)
  {
    N_growparms = 6;
    AFIX = tempvec5(1);
    AFIX2 = tempvec5(2);
    Linf_decay = tempvec5(3);
    if (Grow_type == 8 && AFIX2 != 999)
    {
      warnstream << "AFIX2 set to 999 for grow_type==8 because only Linfinity allowed for growth cessation ";
      write_message (ADJUST, 0);
      AFIX2 = 999.;
    }
    if (Grow_type == 8 && AFIX != 0.0)
    {
      warnstream << "AFIX set to 0.0 for grow_type==8;  growth cessation ";
      write_message (ADJUST, 0);
      AFIX2 = 0.0;
    }
    //  tempvec(4) is a placeholder
  }
  else if (do_ageK == 1)
  {
    AFIX = tempvec5(1);
    AFIX2 = tempvec5(2);
    Linf_decay = tempvec5(3);
    //  tempvec(4) is a placeholder
    Age_K_count = tempvec5(5);
    echoinput << " read this number of ages for age-specific K " << Age_K_count << endl;
    N_growparms = 5 + Age_K_count;
  }
  else if (Grow_type == 6) //  not implemented
  {
    N_growparms = 2; // for the two CV parameters
    k1 = N_GP * gender; // for reading empirical length_at_age
  }
  
  echoinput << " N_growparms  " << N_growparms << endl;
  AFIX2_forCV = AFIX2;
  if (AFIX2_forCV > nages) AFIX2_forCV = nages;
  
  AFIX_delta = AFIX2 - AFIX;
  if (AFIX != 0.0)
  {
    AFIX_plus = AFIX;
  }
  else
  {
    AFIX_plus = 1.0e-06;
  }
  N_M_Grow_parms = N_natMparms + N_growparms;
  lin_grow.initialize();
  
  echoinput << "g a seas subseas ALK_idx real_age calen_age lin_grow first_grow_age" << endl;
  for (g = 1; g <= gmorph; g++)
    if (use_morph(g) > 0)
    {
      for (a = 0; a <= nages; a++)
      {
        for (s = 1; s <= nseas; s++)
          for (subseas = 1; subseas <= N_subseas; subseas++)
          {
            ALK_idx = (s - 1) * N_subseas + subseas;
            //        if(a==0 && s<Bseas(g))
            //          {lin_grow(g,ALK_idx,a)=0.0;}  //  so fish are not yet born so will get zero length
            if (real_age(g, ALK_idx, a) < AFIX)
            {
              lin_grow(g, ALK_idx, a) = real_age(g, ALK_idx, a) / AFIX_plus;
            } //  on linear portion of the growth
            else if (real_age(g, ALK_idx, a) == AFIX)
            {
              lin_grow(g, ALK_idx, a) = 1.0; //  at the transition from linear to VBK growth
            }
            else if (first_grow_age(g) == 0)
            {
              lin_grow(g, ALK_idx, a) = -1.0; //  flag for first age on growth curve beyond AFIX
              if (subseas == N_subseas) {
                first_grow_age(g) = a;
              } //  so that lingrow will be -1 for rest of this season
            }
            else
            {
              lin_grow(g, ALK_idx, a) = -2.0;
            } //  flag for being in growth curve
  
            if (a < 4) echoinput << g << " " << a << " " << s << " " << subseas << " " << ALK_idx << " " << real_age(g, ALK_idx, a)
                                 << " " << calen_age(g, ALK_idx, a) << " " << lin_grow(g, ALK_idx, a) << " " << first_grow_age(g) << endl;
          }
      }
    }
  // clang-format off
 END_CALCS
  init_ivector Age_K_points(1,Age_K_count);  //  points at which age-specific multipliers to K will be applied
!!if(Age_K_count>0) echoinput<<"Age-specific_K_points"<<Age_K_points<<endl;

  init_matrix Len_At_Age_rd(1,k1,0,nages)
!!if(k1>0) echoinput<<"  Len_At_Age_rd"<<Len_At_Age_rd<<endl;

  init_number SD_add_to_LAA   // constant added to SD length-at-age (set to 0.1 for compatibility with SS2 V1.x
!!echoinput<<SD_add_to_LAA<<"  SD_add_to_LAA"<<endl;
  init_int CV_depvar     //  select CV_growth pattern; 0 CV=f(LAA); 1 CV=F(A); 2 SD=F(LAA); 3 SD=F(A); 4 logSD=f(A)   SS2 V1.x ony had CV=F(LAA)
!!echoinput<<CV_depvar<<"  CV_depvar"<<endl;
  int CV_depvar_a;
  int CV_depvar_b;
  int Grow_logN
 LOCAL_CALCS
      // clang-format on
      if (Age_K_count > 1)
  {
    if (Grow_type == 3)
    {
      for (j = 2; j <= Age_K_count; j++)
      {
        if (Age_K_points(j) <= Age_K_points(j - 1))
        {
          warnstream << "Age K points must be unique and ascending order ";
          write_message (FATAL, 0);  // EXIT!
        }
      }
    }
    else if (Grow_type == 4 || Grow_type == 5)
    {
      for (j = 2; j <= Age_K_count; j++)
      {
        if (Age_K_points(j) >= Age_K_points(j - 1))
        {
          warnstream << "Age K points must be unique and decending order ";
          write_message (FATAL, 0);  // EXIT!
        }
      }
    }
  }
  Grow_logN = 0;
  switch (CV_depvar)
  {
    case 0:
    {
      CV_depvar_a = 0;
      CV_depvar_b = 0;
      break;
    }
    case 1:
    {
      CV_depvar_a = 1;
      CV_depvar_b = 0;
      break;
    }
    case 2:
    {
      CV_depvar_a = 0;
      CV_depvar_b = 1;
      break;
    }
    case 3:
    {
      CV_depvar_a = 1;
      CV_depvar_b = 1;
      break;
    }
    case 4:
    {
      CV_depvar_a = 1;
      CV_depvar_b = 1;
      Grow_logN = 1;
      break;
    }
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.5.2 #Process biology
  int do_fec_len                 //  switch based on maturity option to trigger fecundity calcs
  init_int Maturity_Option       // 1=length logistic; 2=age logistic; 3=read age-maturity
                                  //  4=read age-fecundity;  5=read age-fec from wtatage.ss; 6=read length-maturity
                            // options 1, 2, 3, 6 can be used with fecundity options to create fecundity-at-age: fec(g)
                            // options 4 and 5 read fecundity directly, so the concept of maturity is not defined
 LOCAL_CALCS
      // clang-format on
      echoinput << Maturity_Option << "  Maturity_Option" << endl;
  if (Maturity_Option == 3 || Maturity_Option == 4)
  {
    k1 = N_GP;
  }
  else
  {
    k1 = 0;
  }
  if (Maturity_Option == 6)
  {
    k2 = N_GP;
  }
  else
  {
    k2 = 0;
  }
  if (Maturity_Option == 4 || Maturity_Option == 5) {
    do_fec_len = 0;
  }
  else {
    do_fec_len = 1;
  }
  
  if (Maturity_Option == 5)
  {
    echoinput << " fecundity and weight at age to be read from file:  wtatage.ss" << endl;
    if (WTage_rd == 0)
    {
      warnstream << "Must set WTage_rd to 1 to use wtatage.ss";
      write_message (FATAL, 0); // EXIT!
    }
  }
  // clang-format off
 END_CALCS
  init_matrix Age_Maturity(1,k1,0,nages) // for maturity option 3 or 4
  init_matrix Length_Maturity(1,k2,1,nlength)  //  for maturity option 6
!!if(k1>0) echoinput<<"  read Age_Maturity(3) or Age_Fecundity(4) for each GP"<<Age_Maturity<<endl;
!!if(k2>0) echoinput<<"  read Length_Maturity for each GP"<<Length_Maturity<<endl;

  init_int First_Mature_Age     // first age with non-zero maturity
 LOCAL_CALCS
  echoinput<<First_Mature_Age<<"  First_Mature_Age"<<endl;
  if (First_Mature_Age == 0)
  {
    warnstream<<"First_Mature_Age read as:  " << First_Mature_Age << ", which is unusual. Check logic of spawn_month and settlement time & age";
    write_message(WARN,0);
  }
 END_CALCS

  init_int Fecund_Option
//   Value=1 means interpret the 2 egg parameters as linear eggs/kg on body weight (current SS3 default),
//   so eggs = wt * (a+b*wt), so value of a=1, b=0 causes eggs to be equiv to spawning biomass
//   Value=2 sets eggs=a*L^b   so cannot make equal to biomass
//   Value=3 sets eggs=a*W^b, so values of a=1, b=1 causes eggs to be equiv to spawning biomass
//   Value=4 sets eggs=a+b*L
//   Value=5 sets eggs=a+b*W
!! echoinput<<Fecund_Option<<"  Fecundity option"<<endl;
!! if(Fecund_Option>5) {warnstream<<"Illegal fecundity option:  "<<Fecund_Option;write_message(FATAL,0);} // EXIT!

  int Hermaphro_Option;
  int MGparm_Hermaphro;
  int Hermaphro_seas;
  int Hermaphro_firstage;
  number Hermaphro_seas_rd;
  number Hermaphro_maleSSB;
 LOCAL_CALCS
  // clang-format on
  Hermaphro_seas = 0;
  Hermaphro_maleSSB = 0.0;
  Hermaphro_firstage = 0;
  MGparm_Hermaphro = 0;
  
  *(ad_comm::global_datafile) >> Hermaphro_Option;
  echoinput << Hermaphro_Option << "  Hermaphro_Option: 0 means No; 1 for F to M; -1 for M to F" << endl;
  if (Hermaphro_Option != 0)
  {
    *(ad_comm::global_datafile) >> Hermaphro_seas_rd; //  -1 for all seasons, or integer for particular season <=nseas
    echoinput << Hermaphro_seas_rd << endl;
    Hermaphro_seas = int(Hermaphro_seas_rd);
  
    // fractional part of Hermaphro_seas will be converted to the first age that switches
    if (Hermaphro_seas_rd > 0) {
      Hermaphro_firstage = int((Hermaphro_seas_rd - Hermaphro_seas) * 10.0 + 1.0e-6);
    }
    else
    {
      Hermaphro_firstage = int((abs(Hermaphro_seas_rd) - 1) * 10.0 + 1.0e-6);
    }
    //  so  2.3 will do switch in season 2 beginning with age 3.
    echoinput << Hermaphro_seas << "  Hermaphro_season (-1 means all seasons)" << endl;
    echoinput << Hermaphro_firstage << "  Hermaphro_firstage (from decimal part of seas input; note that firstage can only be a single digit, so 9 is max" << endl;
    *(ad_comm::global_datafile) >> Hermaphro_maleSSB; // read as a fraction (0.0 to 1.0) of the male SSB added into the total SSB
    echoinput << Hermaphro_maleSSB << "  Hermaphro_maleSSB " << endl;
  }
  // clang-format off
 END_CALCS
// if Hermaphro_Option=1, then read 3 parameters for switch from female to male by age
// if Hermaphro_Option=-1, then read 3 parameters for switch from male to female by age
// FUTURE if Hermaphro_Option=2, then read 3 parameters for switch from female to male by age for each GrowPattern
// FUTURE if Hermaphro_Option=3, then read 3 parameters for switch from female to male by length
// FUTURE if Hermaphro_Option=4, then read 3 parameters for switch from female to male by length for each GrowPattern

  init_int MGparm_def       //  offset approach (1=none, 2= M, G, CV_G as offset from female-GP1, 3=like SS2 V1.x)
!! echoinput<<MGparm_def<<"  MGparm_def"<<endl;

  int do_once;
  int doit;

  int MGP_CGD;
  int sd_ratio_param_ptr;
  int CGD_onoff;  //  switch for cohort growth dev

 LOCAL_CALCS
  // clang-format on
  if (parm_adjust_method < 1 || parm_adjust_method > 3)
  {
    warnstream << "Illegal parm_adjust_method; must be 1 or 2 or 3 ";
    write_message (FATAL, 0); // EXIT!
  }
  
  ParCount = 0;
  Parm_minmax.push_back(0); // to start real info at index "1" to align with ParCount
  
  //  retParCount=-1;   // for 3.24 -> 3.30 dome-shaped retention  replace with ivector N_retparm()
  
  //  SS_Label_Info_4.5.3 #Set up indexing and parameter names for MG parameters
  for (gg = 1; gg <= gender; gg++)
  {
    for (gp = 1; gp <= N_GP; gp++)
    {
      MGparm_point(gg, gp) = ParCount + 1; //  starting pointer
      switch (natM_type)
      {
        case 0:
        {
          ParCount++;
          ParmLabel += "NatM_uniform_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          break;
        }
        case 1:
        {
          for (k = 1; k <= N_natMparms; k++)
          {
            ParCount++;
            onenum = "    ";
            sprintf(onenum, "%d", k);
            ParmLabel += "NatM_break_" + onenum + "_" + GenderLbl(gg) + GP_Lbl(gp);
            Parm_info += "val";
            Parm_minmax.push_back(3);
          }
          break;
        }
        case 2:
        {
          ParCount++;
          ParmLabel += "NatM_Lorenzen_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          break;
        }
        case 5: //  new age and maturity specific by Mark Maunder
        {
          ParCount++;
          ParmLabel += "NatM_juv_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          ParCount++;
          ParmLabel += "NatM_power_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          ParCount++;
          ParmLabel += "NatM_infl_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          ParCount++;
          ParmLabel += "NatM_mature_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          if (natM_5_opt == 3)
          {
            ParCount++;
            ParmLabel += "NatM_L50_" + GenderLbl(gg) + GP_Lbl(gp);
            Parm_info += "val";
            Parm_minmax.push_back(3);
            ParCount++;
            ParmLabel += "NatM_slope_" + GenderLbl(gg) + GP_Lbl(gp);
            Parm_info += "val";
            Parm_minmax.push_back(3);
          }
          break;
        }
        case 6:
        {
          ParCount++;
          ParmLabel += "NatM_Lorenzen_average" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          break;
        }
        default:
        {
          break;
        }
      }
  
      switch (Grow_type)
      {
        case 1:
        {
          ParmLabel += "L_at_Amin_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(3);
          ParmLabel += "L_at_Amax_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(2);
          ParmLabel += "VonBert_K_" + GenderLbl(gg) + GP_Lbl(gp);
          Parm_info += "val";
          Parm_minmax.push_back(1);
          ParCount += 3;
          break;
        }
        case 2:
        {
          ParmLabel += "L_at_Amin_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "L_at_Amax_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "VonBert_K_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "Richards_" + GenderLbl(gg) + GP_Lbl(gp);
          ParCount += 4;
          break;
        }
        case 3:
        {
          ParmLabel += "L_at_Amin_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "L_at_Amax_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "VonBert_K_young_" + GenderLbl(gg) + GP_Lbl(gp);
          ParCount += 3;
          for (a = 1; a <= Age_K_count; a++)
          {
            ParmLabel += "Age_K_mult_" + GenderLbl(gg) + GP_Lbl(gp) + "_a_" + NumLbl0(Age_K_points(a) + 1);
            ParCount++;
          }
          break;
        }
        case 4:
        {
          ParmLabel += "L_at_Amin_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "L_at_Amax_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "VonBert_K_old_" + GenderLbl(gg) + GP_Lbl(gp);
          ParCount += 3;
          for (a = 1; a <= Age_K_count; a++)
          {
            ParmLabel += "Age_K_mult_" + GenderLbl(gg) + GP_Lbl(gp) + "_a_" + NumLbl0(Age_K_points(a) + 1);
            ParCount++;
          }
          break;
        }
        case 5:
        {
          ParmLabel += "L_at_Amin_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "L_at_Amax_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "VonBert_K_old_" + GenderLbl(gg) + GP_Lbl(gp);
          ParCount += 3;
          for (a = 1; a <= Age_K_count; a++)
          {
            ParmLabel += "Age_K_each_" + GenderLbl(gg) + GP_Lbl(gp) + "_a_" + NumLbl0(Age_K_points(a) + 1);
            ParCount++;
          }
          break;
        }
        case 8:
        {
          ParmLabel += "L_at_Amin_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "Linf_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "VonBert_K_" + GenderLbl(gg) + GP_Lbl(gp);
          ParmLabel += "Cessation_" + GenderLbl(gg) + GP_Lbl(gp);
          ParCount += 4;
          break;
        }
      }
      //  init_int CV_depvar     //  select CV_growth pattern; 0 CV=f(LAA); 1 CV=F(A); 2 SD=F(LAA); 3 SD=F(A); 4 logSD=f(A)
      if (CV_depvar <= 1)
      {
        ParmLabel += "CV_young_" + GenderLbl(gg) + GP_Lbl(gp);
        ParmLabel += "CV_old_" + GenderLbl(gg) + GP_Lbl(gp);
      }
      else if (CV_depvar <= 3)
      {
        ParmLabel += "SD_young_" + GenderLbl(gg) + GP_Lbl(gp);
        ParmLabel += "SD_old_" + GenderLbl(gg) + GP_Lbl(gp);
      }
      else
      {
        ParmLabel += "lnSD_young_" + GenderLbl(gg) + GP_Lbl(gp);
        ParmLabel += "LnSD_old_" + GenderLbl(gg) + GP_Lbl(gp);
      }
  
      ParCount += 2;
      ParmLabel += "Wtlen_1_" + GenderLbl(gg) + GP_Lbl(gp);
      ParmLabel += "Wtlen_2_" + GenderLbl(gg) + GP_Lbl(gp);
      ParCount += 2;
      if (gg == 1) //  add parms for maturity and fecundity for females only
      {
        ParmLabel += "Mat50%_" + GenderLbl(1) + GP_Lbl(gp);
        ParmLabel += "Mat_slope_" + GenderLbl(1) + GP_Lbl(gp);
        ParCount += 2;
        if (Fecund_Option == 1)
        {
          ParmLabel += "Eggs/kg_inter_" + GenderLbl(1) + GP_Lbl(gp);
          ParmLabel += "Eggs/kg_slope_wt_" + GenderLbl(1) + GP_Lbl(gp);
          ParCount += 2;
        }
        else if (Fecund_Option == 2)
        {
          ParmLabel += "Eggs_scalar_" + GenderLbl(1) + GP_Lbl(gp);
          ParmLabel += "Eggs_exp_len_" + GenderLbl(1) + GP_Lbl(gp);
          ParCount += 2;
        }
        else if (Fecund_Option == 3)
        {
          ParmLabel += "Eggs_scalar_" + GenderLbl(1) + GP_Lbl(gp);
          ParmLabel += "Eggs_exp_wt_" + GenderLbl(1) + GP_Lbl(gp);
          ParCount += 2;
        }
        else if (Fecund_Option == 4)
        {
          ParmLabel += "Eggs_intercept_" + GenderLbl(1) + GP_Lbl(gp);
          ParmLabel += "Eggs_slope_len_" + GenderLbl(1) + GP_Lbl(gp);
          ParCount += 2;
        }
        else if (Fecund_Option == 5)
        {
          ParmLabel += "Eggs_intercept_" + GenderLbl(1) + GP_Lbl(gp);
          ParmLabel += "Eggs_slope_Wt_" + GenderLbl(1) + GP_Lbl(gp);
          ParCount += 2;
        }
      }
    }
  }
  
  if (Hermaphro_Option == 1 || Hermaphro_Option == -1)
  {
    MGparm_Hermaphro = ParCount + 1; // pointer to first hermaphroditism parameter
    ParmLabel += "Herm_Infl_age";
    ParmLabel += "Herm_stdev";
    ParmLabel += "Herm_asymptote";
    ParCount += 3;
  }
  recr_dist_parms = ParCount + 1; // pointer to first recruitment distribution  parameter
  switch (recr_dist_method)
  {
    case 2: //  new method with main effects only
    {
      for (k = 1; k <= N_GP; k++) {
        ParCount++;
        ParmLabel += "RecrDist_GP_" + NumLbl(k);
      }
      for (k = 1; k <= pop; k++) {
        ParCount++;
        ParmLabel += "RecrDist_Area_" + NumLbl(k);
      }
      for (k = 1; k <= N_settle_timings; k++) {
        ParCount++;
        ParmLabel += "RecrDist_month_" + NumLbl(Settle_month(k));
      }
      break;
    }
    case 3: //  new method with parm for each settlement
    {
      for (s = 1; s <= N_settle_assignments; s++)
      {
        ParCount++;
        gp = settlement_pattern_rd(s, 1); //  growth patterns
        p = settlement_pattern_rd(s, 3); //  settlement area
        settle_time = settle_assignments_timing(s);
        ParmLabel += "RecrDist_GP_" + NumLbl(gp) + "_area_" + NumLbl(p) + "_month_" + NumLbl(Settle_month(settle_time));
      }
      break;
    }
    case 4: //  no distribution of recruitments
    {
      break;
    }
  }
  
  MGP_CGD = ParCount + 1; // pointer to cohort growth deviation base parameter
  ParCount++;
  ParmLabel += "CohortGrowDev";
  
  if (do_migration > 0)
  {
    for (k = 1; k <= do_migration; k++)
    {
      s = move_def(k, 1);
      gp = move_def(k, 2);
      p = move_def(k, 3);
      p2 = move_def(k, 4);
      ParCount++;
      ParmLabel += "MoveParm_A_seas_" + NumLbl(s) + GP_Lbl(gp) + "from_" + NumLbl(p) + "to_" + NumLbl(p2);
      ParCount++;
      ParmLabel += "MoveParm_B_seas_" + NumLbl(s) + GP_Lbl(gp) + "from_" + NumLbl(p) + "to_" + NumLbl(p2);
    }
  }
  
  if (N_platoon > 1 && sd_ratio_rd < 0)
  {
    ParCount ++;
    sd_ratio_param_ptr = ParCount;
    ParmLabel += "Platoon_SD_Ratio";
  }
  
  if (Use_AgeKeyZero > 0)
  {
    AgeKeyParm = ParCount + 1;
    for (k = 1; k <= 7; k++)
    {
      ParCount++;
      ParmLabel += "AgeKeyParm" + NumLbl(k);
    }
  }
  
  catch_mult_pointer = -1;
  j = sum(need_catch_mult); //  number of fleets needing a catch multiplier parameter
  if (j > 0) {
    catch_mult_pointer = ParCount + 1;
  }
  for (int ff = 1; ff <= N_catchfleets(0); ff++)
  {
    j = fish_fleet_area(0, ff);
    if (need_catch_mult(j) == 1)
    {
      ParCount++;
      ParmLabel += "Catch_Mult:_" + NumLbl(j) + "_" + fleetname(j);
    }
  }
  
  frac_female_pointer = ParCount + 1;
  for (gp = 1; gp <= N_GP; gp++)
  {
    ParCount++;
    ParmLabel += "FracFemale_GP_" + NumLbl(gp);
  }
  predparm_pointer = -1;
  for (int pc = 1; pc <= N_pred; pc++)
  {
    ParCount++;
    predparm_pointer(pc) = ParCount; //  first parm for this predator
    onenum = "    ";
    sprintf(onenum, "%d", pc);
    ParmLabel += "M2_pred" + onenum;
    Parm_info += "val";
    Parm_minmax.push_back(3);
    if (nseas > 1)
    {
      for (s = 1; s <= nseas; s++)
      {
        ParCount++;
        onenum2 = "    ";
        sprintf(onenum2, "%d", s);
        ParmLabel += "M2_pred" + onenum + "_s" + onenum2;
        Parm_info += "val";
        Parm_minmax.push_back(3);
      }
    }
  }
  predparm_pointer(Nfleet + 1) = ParCount;
  echoinput << " predparm pointer" << predparm_pointer << endl;
  N_MGparm = ParCount;
  // clang-format off
 END_CALCS

  init_matrix MGparm_1(1,N_MGparm,1,14)   // matrix with natmort and growth parms controls
  ivector MGparm_offset(1,N_MGparm)

 LOCAL_CALCS
      // clang-format on
      //set base parm for cohort growth dev to permissable values
      if (MGparm_1(MGP_CGD, 3) == 0 || (MGparm_1(MGP_CGD, 1) == MGparm_1(MGP_CGD, 2)))
  {
    MGparm_1(MGP_CGD, 1) = 0.1; //min
    MGparm_1(MGP_CGD, 2) = 10.; //max
    MGparm_1(MGP_CGD, 3) = 1.; //init
    MGparm_1(MGP_CGD, 4) = 1.; //prior
    MGparm_1(MGP_CGD, 5) = 1.; //  prior_sd
    MGparm_1(MGP_CGD, 6) = 0.; //  prior type
    MGparm_1(MGP_CGD, 7) = -1.; // phase
  }
  
  echoinput << " Biology base parameter setup " << N_MGparm << endl;
  for (i = 1; i <= N_MGparm; i++)
    echoinput << i << " " << MGparm_1(i) << " " << ParmLabel(ParCount - N_MGparm + i) << endl;
  
  //  find MGparms for which the male parameter value is set equal to the female value
  //  only applies for MGparm_def==1 which is direct estimation (no offsets)
  //  only for the natmort and growth parameters (not wtlen, fecundity, movement, recr distribution)
  MGparm_offset.initialize();
  if (MGparm_def == 1 && gender == 2)
  {
    gg = 2; // males
    for (gp = 1; gp <= N_GP; gp++)
    {
      Ip = MGparm_point(gg, gp) - 1;
      for (j = 1; j <= N_M_Grow_parms; j++)
      {
        if (MGparm_1(Ip + j, 3) == 0.0 && MGparm_1(Ip + j, 7) < 0) MGparm_offset(Ip + j) = MGparm_point(1, gp) - 1 + j; // save reference to female parm if male value is zero and not estimated
      }
    }
  }
  // clang-format off
 END_CALCS

  ivector mgp_type(1,N_MGparm)  //  contains category to parameter (1=natmort; 2=growth; 3=wtlen & fec; 4=recr_dist&femfrac; 5=movement; 6=ageerrorkey; 7=catchmult)
  //  labels for the types are found in:  MGtype_Lbl
 LOCAL_CALCS
      // clang-format on
      gp = 0;
  for (gg = 1; gg <= gender; gg++)
    for (GPat = 1; GPat <= N_GP; GPat++)
    {
      gp++;
      Ip = MGparm_point(gg, GPat);
      mgp_type(Ip, Ip + N_natMparms - 1) = 1; // natmort parms
      Ip += N_natMparms;
      mgp_type(Ip, Ip + N_growparms - 1) = 2; // growth parms
  
      //  check on estimation of variance parameters for CV_young and CV_old
      for (int kk = Ip + N_growparms - 2; kk <= Ip + N_growparms - 1; kk++)
      {
        if (MGparm_1(kk, 7) > 0) varparm_estimated(1) = 1;
        if (MGparm_1(kk, 8) != 0 || MGparm_1(kk, 9) != 0 || MGparm_1(kk, 13) != 0)
        {
          warnstream << "CV of growth parameters cannot be time-varying";
          write_message (FATAL, 0); // EXIT!
        }
      }
      //     if(MGparm_1(Ip+N_growparms-2,7)>0) varparm_estimated(1)=1;  //  for CV_young
      //     if(MGparm_1(Ip+N_growparms-1,7)>0) varparm_estimated(1)=1;  //  for CV_old
  
      Ip = Ip + N_growparms;
      mgp_type(Ip, Ip + 1) = 3; // wtlen
      Ip += 2;
      if (gg == 1) {
        mgp_type(Ip, Ip + 3) = 3;
        Ip += 4;
      } // maturity and fecundity
    }
  if (Hermaphro_Option != 0) {
    mgp_type(MGparm_Hermaphro, MGparm_Hermaphro + 2) = 3;
  } //   herma parameters done with wtlen and fecundity
  if (recr_dist_method < 4) mgp_type(Ip, MGP_CGD - 1) = 4; // recruit apportionments
  mgp_type(MGP_CGD) = 2; // cohort growth dev
  if (do_migration > 0) mgp_type(MGP_CGD + 1, N_MGparm) = 5; // note that it fills until end of MGparm list, but some get overwritten
  if (N_platoon > 1 && sd_ratio_rd < 0) mgp_type(sd_ratio_param_ptr) = 2;
  if (Use_AgeKeyZero > 0) mgp_type(AgeKeyParm, N_MGparm) = 6;
  if (catch_mult_pointer > 0) mgp_type(catch_mult_pointer, N_MGparm) = 7;
  for (f = frac_female_pointer; f <= frac_female_pointer + N_GP - 1; f++) mgp_type(f) = 4;
  if (N_pred > 0) mgp_type(predparm_pointer(1), predparm_pointer(1) + N_predparms - 1) = 1;
  echoinput << "mgparm_type for each parm:"<<endl;
  for (f = 1; f<= N_MGparm; f++) echoinput << f << " " << MGtype_Lbl(mgp_type(f)) << endl;
  // clang-format off
 END_CALCS

!!// SS_Label_Info_4... //  quantities used to track all time-varying parameters
  int timevary_cnt   //  cumulative count of timevarying parameters across MG, SRR, Q, Selex, Tag
                     //  it counts the number of times timevary_setup is created
                     //  by the function  "create_timevary"
                     //  and is pushed to the vector_vector  timevary_def
  int N_parm_dev     //  number of  all parms that use annual deviations

!!//  SS_Label_Info_4.5.4 #Set up time-varying parameters for MG parms
  int timevary_used;
  int timevary_MG_firstyr;
  int timevary_parm_cnt_MG;
  int timevary_parm_start_MG;

  ivector MGparm_timevary(1,N_MGparm)  //  holds index in timevary_def used by this base parameter
  imatrix timevary_MG(styr-3,YrMax+1,0,7)  // goes to yrmax+1 to allow referencing in forecast, but only endyr+1 is checked
                                            // stores years to calc non-constant MG parms (1=natmort; 2=growth; 3=wtlen & fec; 4=recr_dist&femfrac; 5=movement; 6=ageerrorkey; 7=catchmult)
  ivector timevary_pass(styr-3,YrMax+1)    //  extracted column
  ivector MG_active(0,7)  // 0=all, 1=M, 2=growth 3=wtlen, 4=recr_dist&femfrac, 5=migration, 6=ageerror, 7=catchmult
  vector env_data_pass(1,2)  //  holds min-max year with env data
  int  do_densitydependent;

//  timevary_setup(1)=baseparm type;
//  timevary_setup(2)=baseparm index;
//  timevary_setup(3)=first timevary parm
//  timevary_setup(4)=block or trend type
//  timevary_setup(5)=block pattern
//  timevary_setup(6)=env link type
//  timevary_setup(7)=env variable
//  timevary_setup(8)=dev vector used
//  timevary_setup(9)=dev link type  used in SS_timevarmparm
//  timevary_setup(10)=dev min year
//  timevary_setup(11)=dev maxyear
//  timevary_setup(12)=dev phase
//  timevary_setup(13)=all parm index of baseparm
//  timevary_setup(14)=continue_last dev

 LOCAL_CALCS
  // clang-format on
  do_densitydependent = 0;
  timevary_cnt = 0;
  N_parm_dev = 0;
  timevary_parm_cnt = 0;
  
  //  push once so 0'th row is not used
  ivector timevary_setup(1, 14);
  timevary_setup.initialize();
  timevary_def.push_back(timevary_setup(1, 14));
  dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
  timevary_parm_rd.push_back(tempvec);
  
  echoinput << "Now read env, block/trend, and dev adjustments to MGparms " << endl;
  timevary_MG.initialize(); // stores years to calc non-constant MG parms (1=natmort; 2=growth; 3=wtlen & fec; 4=recr_dist; 5=movement)
  MG_active.initialize();
  CGD_onoff = 0;
  
  timevary_parm_start_MG = 0;
  timevary_parm_cnt_MG = 0;
  timevary_used = 0;
  timevary_MG_firstyr = YrMax;
  MGparm_timevary.initialize();
  ivector block_design_null(1, 1);
  block_design_null.initialize();
  
  for (j = 1; j <= N_MGparm; j++)
  {
    k = mgp_type(j);
    timevary_pass = column(timevary_MG, k); // year vector for this type of MGparm
  
    if (MGparm_1(j, 13) == 0 && MGparm_1(j, 8) == 0 && MGparm_1(j, 9) == 0)
    {
      //  no time-vary parameter effects
    }
    else
    {
      ivector timevary_setup(1, 14); //  temporary vector for timevary specs
      timevary_setup.initialize();
      timevary_parm_start_MG = 1; //  at least one MG parm is time varying
      timevary_used = 1;
      echoinput << endl
                << " timevary for MG parameter: " << j << endl;
      timevary_cnt++; //  count parameters with time-vary effect
      MGparm_timevary(j) = timevary_cnt; //  base parameter will use this timevary specification
      timevary_setup(1) = 1; //  indicates a MG parm
      timevary_setup(2) = j; //  index of base parm within that type of parameter
      timevary_setup(13) = j; //  index of base parm relative to ParCount which is continuous across all types of parameters
      timevary_setup(3) = timevary_parm_cnt + 1; //  first parameter within total list of all timevary parms
      z = MGparm_1(j, 13); // specified block or trend definition
  
      k = int(abs(MGparm_1(j, 8)) / 100); //  find the env link code
      timevary_setup(6) = k; //  link code for env
      if (MGparm_1(j, 8) > 0) //  env variable used
      {
        timevary_setup(7) = int(abs(MGparm_1(j, 8))) - k * 100;
        k = timevary_setup(7);
        //         for(y=styr-1;y<=YrMax;y++) env_data_pass(y)=env_data_RD(y,k);
        env_data_pass(1) = env_data_minyr(k);
        env_data_pass(2) = env_data_maxyr(k);
      }
      else if (abs(MGparm_1(j, 8) > 0)) //  density-dependence
      {
        timevary_setup(7) = -int(abs(MGparm_1(j, 8)) - k * 100);
        do_densitydependent = 1;
  echoinput << "Density-dependent flag for MGparms " << do_densitydependent << " MGparm: " << j << endl;
        k = 0;
        env_data_pass.initialize();
      }
  
      if (z > 0) //  doing blocks
      {
        if (z > N_Block_Designs)
        {
          warnstream << "MG block request exceeds N_block patterns";
          write_message (FATAL, 0); // EXIT!
        }
        create_timevary(MGparm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), mgp_type(j), Block_Design(z), env_data_pass, N_parm_dev, finish_starter);
      }
      else
      {
        create_timevary(MGparm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), mgp_type(j), block_design_null, env_data_pass, N_parm_dev, finish_starter);
      }
      timevary_def.push_back(timevary_setup(1, 14));
      for (y = styr - 3; y <= YrMax + 1; y++) {
        timevary_MG(y, mgp_type(j)) = timevary_pass(y);
      } // year vector for this category of MGparm
      if (j == MGP_CGD) CGD_onoff = 1;
      if (mgp_type(j) == 6) //  doing time-vary age-age' key;  can only use blocks
      {
        store_agekey_add = Nblk(z) + 2; //  additional storage space for block-based Age error keys
      }
    }
  }
  if (timevary_used == 1) autogen_timevary(1) = 1; //  indicate that some parameter is time-varying
  timevary_parm_cnt_MG = timevary_parm_cnt;
  
  //  SS_Label_Info_4.5.9 #Set up random deviations for MG parms
  //  NOTE:  the parms for the se of the devs are part of the MGparm2 list above, not the dev list below
  
  //  SS_Label_Info_4.5.95 #Populate time_bio_category array defining when biology changes
  k = YrMax + 1;
  echoinput << "Display timevary_MG flag" << endl;
  for (y = styr + 1; y <= YrMax; y++)
  {
    if (timevary_MG(y, 2) > 0 && y < k) k = y;
  }
  if (k < YrMax + 1)
  {
    for (y = k; y <= YrMax + 1; y++)
    {
      timevary_MG(y, 2) = 1;
    }
  }
  for (y = styr - 1; y <= YrMax; y++)
  {
    for (f = 1; f <= 7; f++)
    {
      if (timevary_MG(y, f) > 0)
      {
        MG_active(f) = 1;
        timevary_MG(y, 0) = 1; // tracks active status for all MG types
        if(timevary_MG_firstyr == YrMax) timevary_MG_firstyr = y;  // save for reporting in MSY and spawn_recruit output
      }
    }

    //  timevary growth or maturity and Maunder M refers to that maturity
    if ((timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0) && natM_type == 5 && natM_5_opt < 3) timevary_MG(y, 1) = 1;
  
    echoinput << y << " timevary_MG: " << timevary_MG(y) << endl;
  }

  if( timevary_MG_firstyr < YrMax || WTage_rd == 1)  //  time-varying biology
  {
    if( timevary_bio_4SRR == 0)  // legacy approach;  this switch is read from starter.ss
    {
      warnstream << "There is timevary biology and the legacy approach to benchmark calculations is being used; user should be aware of possible impacts to benchmark results";
      write_message(WARN, 0);
        if( timevary_bio_4SRR_rd == -1)  // older starter file did not contain necessary flag
        {
          warnstream << "There is timevary biology, so the flag for timevary_bio_4SRR must be set to 0 (old default) or 1 (new improved) in starter.ss";
// make this a WARN while testing, then change to FATAL for operational code
          write_message(WARN, 0);
        }
    }
  }

  for (y = endyr + 1; y <= YrMax; y++)
  {
    for (f = 1; f <= 7; f++)
    {
      if (timevary_MG(y, f) > 0 && Fcast_MGparm_ave(f,2) > 0)
      {
          warnstream << "mean MGparm for forecast is incompatible with timevary parm in forecast yr: " << y << "; for type: " << f << " " << MGtype_Lbl(f) << "; SS3 will disable time-vary";
          write_message(WARN, 0);
          timevary_MG(y, f) = 0;
      }
    }
  }

  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.5.7 #Set up seasonal effects for MG parms
  init_ivector MGparm_seas_effects(1,10)  // femwtlen1, femwtlen2, mat1, mat2, fec1 fec2 Malewtlen1, malewtlen2 L1 K
  int MGparm_doseas
  int N_MGparm_seas                            // number of MGparms that use seasonal effects
 LOCAL_CALCS
      // clang-format on
      echoinput
      << "seasonal effects as read: " << MGparm_seas_effects << endl;
  adstring_array MGseasLbl;
  MGseasLbl += "F-WL1" + CRLF(1);
  MGseasLbl += "F-WL2" + CRLF(1);
  MGseasLbl += "F-Mat1" + CRLF(1);
  MGseasLbl += "F-Mat1" + CRLF(1);
  MGseasLbl += "F-Fec1" + CRLF(1);
  MGseasLbl += "F-Fec1" + CRLF(1);
  MGseasLbl += "M-WL1" + CRLF(1);
  MGseasLbl += "M-WL2" + CRLF(1);
  MGseasLbl += "L1" + CRLF(1);
  MGseasLbl += "VBK" + CRLF(1);
  MGparm_doseas = sum(MGparm_seas_effects);
  N_MGparm_seas = 0; // counter for assigned parms
  if (MGparm_doseas > 0)
  {
    for (j = 1; j <= 10; j++)
    {
      if (MGparm_seas_effects(j) > 0)
      {
        MGparm_seas_effects(j) = N_MGparm + timevary_parm_cnt_MG + N_MGparm_seas; // store base parameter count
        for (s = 1; s <= nseas; s++)
        {
          N_MGparm_seas++;
          ParCount++;
          ParmLabel += MGseasLbl(j) + "_seas_" + NumLbl(s);
        }
      }
    }
    echoinput << MGparm_seas_effects << " MGparm_seas_effects" << endl;
  }
  // clang-format off
 END_CALCS
  init_matrix MGparm_seas_1(1,N_MGparm_seas,1,7)  // read matrix that defines the seasonal parms
!!if(N_MGparm_seas>0) echoinput<<" MGparm_seas"<<endl<<MGparm_seas_1<<endl;

!!//  SS_Label_Info_4.5.9 #Create vectors (e.g. MGparm_PH) to be used to define the actual estimated parameter array
  int N_MGparm2
!! N_MGparm2=N_MGparm+timevary_parm_cnt_MG+N_MGparm_seas;
  vector MGparm_LO(1,N_MGparm2)
  vector MGparm_HI(1,N_MGparm2)
  vector MGparm_RD(1,N_MGparm2)
  vector MGparm_PR(1,N_MGparm2)
  ivector MGparm_PRtype(1,N_MGparm2)
  vector MGparm_CV(1,N_MGparm2)
  ivector MGparm_PH(1,N_MGparm2)

 LOCAL_CALCS
      // clang-format on
      for (f = 1; f <= N_MGparm; f++) //  loop mgparm and map setup to _LO , _HI etc.
  {
    MGparm_LO(f) = MGparm_1(f, 1);
    MGparm_HI(f) = MGparm_1(f, 2);
    MGparm_RD(f) = MGparm_1(f, 3);
    MGparm_PR(f) = MGparm_1(f, 4);
    MGparm_CV(f) = MGparm_1(f, 5);
    MGparm_PRtype(f) = MGparm_1(f, 6);
    MGparm_PH(f) = MGparm_1(f, 7);
    if (MGparm_PH(f) > 0)
    {
      MG_active(mgp_type(f)) = 1;
    }
  }
  if ((natM_type == 2 || natM_type == 6) && MG_active(2) > 0)
  {
    MG_active(1) = 1; // lorenzen M depends on growth
  }
  
  j = N_MGparm;
  if (timevary_parm_cnt_MG > 0)
    for (f = timevary_parm_start_MG; f <= timevary_parm_cnt_MG; f++)
    {
      j++;
      MGparm_LO(j) = timevary_parm_rd[f](1);
      MGparm_HI(j) = timevary_parm_rd[f](2);
      MGparm_RD(j) = timevary_parm_rd[f](3);
      MGparm_PR(j) = timevary_parm_rd[f](4);
      MGparm_CV(j) = timevary_parm_rd[f](5);
      MGparm_PRtype(j) = timevary_parm_rd[f](6);
      MGparm_PH(j) = timevary_parm_rd[f](7);
    }
  
  if (N_MGparm_seas > 0)
    for (f = 1; f <= N_MGparm_seas; f++)
    {
      j++;
      MGparm_LO(j) = MGparm_seas_1(f, 1);
      MGparm_HI(j) = MGparm_seas_1(f, 2);
      MGparm_RD(j) = MGparm_seas_1(f, 3);
      MGparm_PR(j) = MGparm_seas_1(f, 4);
      MGparm_CV(j) = MGparm_seas_1(f, 5);
      MGparm_PRtype(j) = MGparm_seas_1(f, 6);
      MGparm_PH(j) = MGparm_seas_1(f, 7);
    }
  MG_active(0) = sum(MG_active(1, 7));
  echoinput << "MG_active " << MG_active << endl;
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.6 #Read setup for Spawner-Recruitment parameters
  //  SPAWN-RECR: read setup for SR parameters:  LO, HI, INIT, PRIOR, PRtype, CV, PHASE
  init_int SR_fxn
!!echoinput<<SR_fxn<<" #_SR_function: 1=NA; 2=Ricker(2 parms); 3=BevHolt(2); 4=SCAA(2); 5=Hockey(3); 6=B-H_flattop(2); 7=Survival(3); 8=Shepherd(3); 9=Ricker_Power(3); 10=B-H_a,b(4)"<<endl;
  init_int init_equ_steepness;
!!echoinput<<init_equ_steepness<<"  # 0/1 to use steepness in initial equ recruitment calculation"<<endl;
  init_int itemp;

//   echoinput<<sigmaR_dendep<<"  #  future feature:  0/1 to make realized sigmaR a function of SR curvature"<<endl;

  ivector N_SRparm(1,10)
!!N_SRparm.fill("{0,2,2,2,3,2,3,3,3,4}");
  int N_SRparm2
  int N_SRparm3  //  with timevary links included
!!N_SRparm2=N_SRparm(SR_fxn)+3;
  init_matrix SRparm_1(1,N_SRparm2,1,14)
!!echoinput<<" SR parms "<<endl<<SRparm_1<<endl;
   int SR_env_link
//  !!echoinput<<SR_env_link<<" SR_env_link "<<endl;
    int SR_env_target_RD   // 0=none; 1=devs; 2=R0; 3=steepness
//  !!echoinput<<SR_env_target_RD<<" SR_env_target_RD "<<endl;
  int SR_env_target
  int SR_autocorr;  // will be calculated later

  int timevary_SRparm_first;  //   == 0 means that no relevant parms are timevarying
  int firstSRparm;
  int timevary_SRparm_first_yr;  //   year
  int timevary_parm_SR_last;
  ivector timevary_SRparm(styr-3,YrMax+1);
  ivector SRparm_timevary(1,N_SRparm2);

 LOCAL_CALCS
  // clang-format on
  //  SS_Label_Info_4.6.1 #Create S-R parameter labels
  firstSRparm = ParCount;
  timevary_parm_SR_last = 0;
  timevary_SRparm_first = 0;
  timevary_SRparm_first_yr = 0;
  timevary_SRparm.initialize();
  SRparm_timevary.initialize();
  SR_env_link = 0;
  SR_env_target = 0;

  //#_SR_function: 1=null; 2=Ricker; 3=std_B-H; 4=SCAA; 5=Hockey; 6=B-H_flattop; 7=Survival_3Parm; 10=B-H with a,b "<<endl;
  if (SR_fxn == 10)
  {ParmLabel += "SR_LN(R0)_derived";}
  else
  {ParmLabel += "SR_LN(R0)";}
  
  switch (SR_fxn)
  {
    case 1: // previous placement for B-H constrained
    {
      warnstream << "B-H constrained curve is now Spawn-Recr option #6";
      write_message (FATAL, 0); // EXIT!
      break;
    }
    case 2: // Ricker
    {
      ParmLabel += "SR_Ricker_beta";
      break;
    }
    case 3: // Bev-Holt
    {
      ParmLabel += "SR_BH_steep";
      break;
    }
    case 4: // SCAA
    {
      ParmLabel += "SR_SCAA_null";
      break;
    }
    case 5: // Hockey
    {
      ParmLabel += "SR_hockey_infl";
      ParmLabel += "SR_hockey_min_R";
      break;
    }
    case 6: // Bev-Holt flattop
    {
      ParmLabel += "SR_BH_flat_steep";
      break;
    }
    case 7: // survival
    {
      ParmLabel += "SR_surv_zfrac";
      ParmLabel += "SR_surv_Beta";
      break;
    }
    case 8: // Shepherd
    {
      ParmLabel += "SR_steepness";
      ParmLabel += "SR_Shepherd_c";
      break;
    }
    case 9: //  Ricker Power parameters
    {
      ParmLabel += "SR_RkrPower_steep";
      ParmLabel += "SR_RkrPower_gamma";
      break;
    }
    case 10: // Bev-Holt a,b
    {
      ParmLabel += "SR_BH_steep_derived";
      ParmLabel += "SR_BH_ln(alpha)";
      ParmLabel += "SR_BH_ln(beta)";
      break;
    }
  }
  ParmLabel += "SR_sigmaR";
  ParmLabel += "SR_regime";
  ParmLabel += "SR_autocorr";
  ParCount += N_SRparm2;
  
  if (SRparm_1(N_SRparm2 - 2, 7) > 0) varparm_estimated(2) = 1; //  sigmaR is estimated so need sd_offset=1
  
  if (SRparm_1(N_SRparm2, 3) != 0.0 || SRparm_1(N_SRparm2, 7) > 0)
  {
    SR_autocorr = 1;
  }
  else
  {
    SR_autocorr = 0;
  }
  // flag for recruitment autocorrelation
  echoinput << " Do recruitment_autocorr: " << SR_autocorr << endl;

  // note that the regime parameter seems to bypass use of timevary_SRparm, but timevary_SRparm is used for R0, h beginning 3.30.24
  timevary_used = 0;
  for (j = 1; j <= N_SRparm2 - 1; j++)  // so omits autocorr
    if (j != N_SRparm2 - 2) //  because sigmaR cannot be time-varying
    {
      if (SRparm_1(j, 13) == 0 && SRparm_1(j, 8) == 0 && SRparm_1(j, 9) == 0)
      {
        //  no time-vary parameter effects
      }
      else //  set up a timevary parameter definition
      {
        timevary_used = 1;
        ivector timevary_setup(1, 14); //  temporary vector for timevary specs
        timevary_setup.initialize();
        if (timevary_SRparm_first == 0) timevary_SRparm_first = timevary_parm_cnt + 1;  // cumulative index for first timevary SRparm
        echoinput << " timevary for SR parm: " << j << endl;
        timevary_cnt++; //  count parameters with time-vary effect
        SRparm_timevary(j) = timevary_cnt; //  base SR parameter will use this timevary specification
        timevary_setup(1) = 2; //  indicates a SR parm
        if (autogen_timevary(2) == 0)
        {
          echoinput << " timevary SR parms will be autogenerated " << endl;
        }
        else
        {
          echoinput << " timevary SR parms will be read, not autogenerated " << endl;
        }
        timevary_setup(2) = j; //  index of base parm within that type of parameter
        timevary_setup(13) = firstSRparm + j; //  index of base parm relative to ParCount which is continuous across all types of parameters
        timevary_setup(3) = timevary_parm_cnt + 1; //  first parameter within total list of all timevary parms
        timevary_pass = 0; // placeholder; not used for SR parms
        //  set up env link info
        echoinput << " check for env " << SRparm_1(j, 8) << endl;
        k = int(abs(SRparm_1(j, 8)) / 100); //  find the env link code
        timevary_setup(6) = k; //  link code for env
        if (SRparm_1(j, 8) > 0) //  env variable used
        {
          timevary_setup(7) = int(abs(SRparm_1(j, 8))) - k * 100;
          k = timevary_setup(7);
          //         for(y=styr-1;y<=YrMax;y++) env_data_pass(y)=env_data_RD(y,k);
          env_data_pass(1) = env_data_minyr(k);
          env_data_pass(2) = env_data_maxyr(k);
        }
        else if (abs(SRparm_1(j, 8) > 0)) //  density-dependence
        {
          timevary_setup(7) = -int(abs(SRparm_1(j, 8)) - k * 100);
          do_densitydependent = 1;
          k = 0;
          env_data_pass.initialize();
        }
  
        if (SRparm_1(j, 13) > 0) //  doing blocks
        {
          if (SRparm_1(j, 13) > N_Block_Designs)
          {
            warnstream << "SR block request exceeds N_block patterns";
            write_message (FATAL, 0); // EXIT!
          }
          create_timevary(SRparm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), f, Block_Design(SRparm_1(j, 13)), env_data_pass, N_parm_dev, finish_starter);
        }
        else
        {
          create_timevary(SRparm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), f, block_design_null, env_data_pass, N_parm_dev, finish_starter);
        }
        timevary_def.push_back(timevary_setup(1, 14));
        int SRflag;
        SRflag = 0;
        for (y = styr - 3; y <= YrMax + 1; y++)
        {
          if (timevary_pass(y) > 0 && j != N_SRparm2 - 1)
          {
            timevary_SRparm(y) = timevary_pass(y);  //  set timevary flag, except for regime parameter
            timevary_SRparm_first_yr = y;
            SRflag = 1; //  first change point
          }
          else if(SRflag == 1)
          {
            timevary_SRparm(y) = 2;  //  flag to carry forward current SRR info
          }
        }
      }
    }
  
  N_SRparm3 = N_SRparm2;
  if (timevary_SRparm_first > 0)
  {
    timevary_parm_SR_last = timevary_parm_cnt;
    if (timevary_used == 1) autogen_timevary(2) = 1; //  indicate that some parameter is time-varying
    N_SRparm3 += (timevary_parm_SR_last - timevary_SRparm_first + 1);
    echoinput << " SR timevary_parm_cnt start and end " << timevary_SRparm_first << " " << timevary_parm_SR_last << endl;
    echoinput << "link to timevary parms:  " << SRparm_timevary << endl;
  }
  echoinput << "SR_Npar and N_SRparm2 and N_SRparm3:  " << N_SRparm(SR_fxn) << " " << N_SRparm2 << " " << N_SRparm3 << endl;
  // clang-format off
 END_CALCS

  vector SRparm_LO(1,N_SRparm3)
  vector SRparm_HI(1,N_SRparm3)
  vector SRparm_RD(1,N_SRparm3)
  vector SRparm_PR(1,N_SRparm3)
  ivector SRparm_PRtype(1,N_SRparm3)
  vector SRparm_CV(1,N_SRparm3)
  ivector SRparm_PH(1,N_SRparm3)

 LOCAL_CALCS
      // clang-format on
      for (i = 1; i <= N_SRparm2; i++)
  {
    SRparm_LO(i) = SRparm_1(i, 1);
    SRparm_HI(i) = SRparm_1(i, 2);
    SRparm_RD(i) = SRparm_1(i, 3);
    SRparm_PR(i) = SRparm_1(i, 4);
    SRparm_CV(i) = SRparm_1(i, 5);
    SRparm_PRtype(i) = SRparm_1(i, 6);
    SRparm_PH(i) = SRparm_1(i, 7);
  }
  if (timevary_SRparm_first > 0)
  {
    j = N_SRparm2;
    for (f = timevary_SRparm_first; f <= timevary_parm_SR_last; f++)
    {
      j++;
      echoinput << f << " " << j << " " << timevary_parm_rd[f] << endl;
      SRparm_LO(j) = timevary_parm_rd[f](1);
      SRparm_HI(j) = timevary_parm_rd[f](2);
      SRparm_RD(j) = timevary_parm_rd[f](3);
      SRparm_PR(j) = timevary_parm_rd[f](4);
      SRparm_PRtype(j) = timevary_parm_rd[f](6);
      SRparm_CV(j) = timevary_parm_rd[f](5);
      SRparm_PH(j) = timevary_parm_rd[f](7);
    }
  }
  echoinput << "SRparm_RD: " << SRparm_RD << endl;
  // clang-format off
 END_CALCS

  init_int do_recdev  //  0=none; 1=devvector; 2=simple deviations; 3=dev from R0
!!echoinput<<do_recdev<<" do_recdev"<<endl;
  // check for use of devvector with MCMC
 LOCAL_CALCS
  // clang-format on
  if (do_recdev == 1 && mcmcFlag == 1)
  {
    warnstream << "do_recdev option 1=devvector should not be used with MCMC, recommend option 2=simple deviations. For more detail see https://github.com/admb-project/admb/issues/107.";
    write_message (FATAL, 0);
  }
  // clang-format off
 END_CALCS

  init_int recdev_start;
!!echoinput<<recdev_start<<" recdev_start"<<endl;
  init_int recdev_end;
!!echoinput<<recdev_end<<" recdev_end"<<endl;
  init_int recdev_PH_rd;
!!echoinput<<recdev_PH_rd<<" recdev_PH"<<endl;
  int recdev_PH;
!! recdev_PH=recdev_PH_rd;
  init_int recdev_adv
!!echoinput<<recdev_adv<<" recdev_adv"<<endl;

  init_vector recdev_options_rd(1,13*recdev_adv)
  vector recdev_options(1,13)
  int recdev_early_start_rd
  int recdev_early_start
  int recdev_early_end
  int recdev_first
  int recdev_early_PH_rd
  int Fcast_recr_PH_rd
  int recdev_early_PH
  int Fcast_recr_PH
  int Fcast_recr_PH2
  number Fcast_recr_lambda
  vector recdev_adj(1,5)
  int recdev_cycle
  int recdev_do_early
  int recdev_read
  number recdev_LO;
  number recdev_HI;
  ivector recdev_doit(styr-nages,YrMax)
  vector biasadj(styr-nages,YrMax)  // biasadj as used; depends on whether a recdev is estimated or not
  vector biasadj_full(styr-nages,YrMax)  //  full time series of biasadj values, only used in defined conditions

 LOCAL_CALCS
      // clang-format on
      //  SS_Label_Info_4.6.2 #Setup advanced recruitment options
      recdev_doit = 0;
  if (recdev_adv > 0)
  {
    recdev_options(1, 13) = recdev_options_rd(1, 13);
    recdev_early_start_rd = recdev_options(1);
    recdev_early_PH_rd = recdev_options(2);
    Fcast_recr_PH_rd = recdev_options(3);
    Fcast_recr_lambda = recdev_options(4);
    recdev_adj(1) = recdev_options(5);
    recdev_adj(2) = recdev_options(6);
    recdev_adj(3) = recdev_options(7);
    recdev_adj(4) = recdev_options(8);
    if (recdev_adj(4) > endyr + 1 && do_recdev > 0)
    {
      warnstream << "bias adjustment ramp extends into forecast; biasadj set to 0.0 internally for forecast years";
      write_message (WARN, 0);
    }
    recdev_adj(5) = recdev_options(9); // maxbias adj
  
    recdev_cycle = recdev_options(10);
    recdev_LO = recdev_options(11);
    recdev_HI = recdev_options(12);
    recdev_read = recdev_options(13);
  }
  else
  {
    recdev_early_start_rd = 0; // 0 means no early
    recdev_early_end = -1;
    recdev_early_PH_rd = -4;
    recdev_options(2) = recdev_early_PH_rd;
    Fcast_recr_PH_rd = 0; // so will be reset to maxphase+1
    recdev_options(3) = Fcast_recr_PH_rd;
    Fcast_recr_lambda = 1.;
    recdev_adj(1) = double(styr) - 1000.;
    recdev_adj(2) = styr - nages;
    recdev_adj(3) = recdev_end;
    recdev_adj(4) = double(endyr) + 1.;
    recdev_adj(5) = 1.0;
    recdev_cycle = 0;
    recdev_LO = -5;
    recdev_HI = 5;
    recdev_read = 0;
  }
  
  recdev_early_start = recdev_early_start_rd;
  
  if (do_recdev == 0)
  {
    recdev_PH_rd = -3;
    recdev_early_PH_rd = -4;
    Fcast_recr_PH_rd = -4;
  }
  if (recdev_adv > 0)
  {
    echoinput << "#_start of advanced SR options" << endl;
  }
  else
  {
    echoinput << "# advanced options not read;  defaults displayed below" << endl;
  }
  
  echoinput << recdev_early_start_rd << " #_recdev_early_start (0=none; neg value makes relative to recdev_start)" << endl;
  echoinput << recdev_early_PH_rd << " #_recdev_early_phase" << endl;
  echoinput << Fcast_recr_PH_rd << " #_forecast_recruitment phase (incl. late recr) (0 value resets to maxphase+1)" << endl;
  echoinput << Fcast_recr_lambda << " #_lambda for Fcast_recr_like occurring before endyr+1" << endl;
  if (Fcast_Loop_Control(3) >= 3 && Fcast_recr_PH_rd >= 0)
  {
    warnstream << "Forecast devs will be applied to mean base recruitment over range of historical years in forecast.ss";
    write_message (NOTE, 0);
  }
  if (Do_Impl_Error > 0 && Fcast_recr_PH_rd < 0)
  {
    warnstream << "Implementation error has null effect unless Fcast_recr_PH is >=0";
    write_message (WARN, 0);
  }
  echoinput << recdev_adj(1) << " #_last_early_yr_nobias_adj_in_MPD" << endl;
  echoinput << recdev_adj(2) << " #_first_yr_fullbias_adj_in_MPD" << endl;
  echoinput << recdev_adj(3) << " #_last_yr_fullbias_adj_in_MPD" << endl;
  echoinput << recdev_adj(4) << " #_first_recent_yr_nobias_adj_in_MPD" << endl;
  echoinput << recdev_adj(5) << " #_max_bias_adj_in_MPD" << endl;
  echoinput << " #_NOTE: biasadjustment forced to 0.0 after year recdev_end" << endl;
  echoinput << recdev_cycle << " # period of cycle in recruitment " << endl;
  echoinput << recdev_LO << " #min rec_dev" << endl;
  echoinput << recdev_HI << " #max rec_dev" << endl;
  echoinput << recdev_read << " #_read_recdevs" << endl;
  echoinput << "#_end of advanced SR options" << endl;
  
  //  SS_Label_Info_4.6.3 #Create parm labels for recruitment cycle parameters
  if (recdev_cycle > 0)
  {
    for (y = 1; y <= recdev_cycle; y++)
    {
      ParCount++;
      sprintf(onenum, "%d", y);
      ParmLabel += "RecrDev_Cycle_" + onenum + CRLF(1);
    }
  }
  
  //  SS_Label_Info_4.6.4 #Setup recruitment deviations and create parm labels for each year
  if (recdev_end > retro_yr)
  {
    warnstream << " recdev_end: " << recdev_end << " > retro_yr: " << retro_yr << " reset ";
    write_message (ADJUST, 0);
    recdev_end = retro_yr;
  }
  if (recdev_end < endyr && (Fcast_Loop_Control(3) == 3 || Fcast_Loop_Control(3) == 4))
  {
    warnstream << "Fcast recr option is 3 or 4 and recdev_end: " << recdev_end << " < endyr: " << endyr << " reset ";
    write_message (ADJUST, 0);
    recdev_end = endyr;
  }
  if (recdev_start < (styr - nages))
  {
    warnstream << " recdev_start: " << recdev_start << " < styr-nages: " << styr - nages << " reset ";
    write_message (ADJUST, 0);
    recdev_start = styr - nages;
  }
  recdev_first = recdev_start; // stores first recdev, whether from the early period or the standard dev period
  
  if (recdev_early_start >= recdev_start)
  {
    warnstream << "Cannot set recdev_early_start: " << recdev_early_start << " after main recdev start: " << recdev_start;
    write_message (FATAL, 0); // EXIT!
  }
  else if (recdev_early_start == 0) // do not do early rec devs
  {
    recdev_do_early = 0;
    recdev_early_end = -1;
    if (recdev_early_PH_rd > 0) recdev_early_PH_rd = -recdev_early_PH_rd;
  }
  else
  {
    if (recdev_early_start < 0) recdev_early_start += recdev_start; // do relative to start of recdevs
    recdev_do_early = 1;
    if (recdev_early_start < (styr - nages))
    {
      recdev_early_start = styr - nages;
      warnstream << "Adjusting recdev_early to: " << recdev_early_start;
      write_message (ADJUST, 0);
    }
    if (recdev_start - recdev_early_start < 6)
    {
      warnstream << "Are you sure you want so few early recrdevs? Better to include in range of main recdevs " << recdev_start - recdev_early_start;
      write_message (SUGGEST, 0);
    }
  
    recdev_first = recdev_early_start; // because this is before recdev_start
    recdev_early_end = recdev_start - 1;
    for (y = recdev_early_start; y <= recdev_early_end; y++)
    {
      ParCount++;
      recdev_doit(y) = 1;
      if (y >= styr)
      {
        sprintf(onenum, "%d", y);
        ParmLabel += "Early_RecrDev_" + onenum + CRLF(1);
      }
      else
      {
        onenum = "    ";
        sprintf(onenum, "%d", styr - y);
        ParmLabel += "Early_InitAge_" + onenum + CRLF(1);
      }
    }
  }
  
  if (do_recdev > 0)
  {
    for (y = recdev_start; y <= recdev_end; y++)
    {
      ParCount++;
      recdev_doit(y) = 1;
  
      if (y >= styr)
      {
        sprintf(onenum, "%d", y);
        ParmLabel += "Main_RecrDev_" + onenum + CRLF(1);
      }
      else
      {
        onenum = "    ";
        sprintf(onenum, "%d", styr - y);
        ParmLabel += "Main_InitAge_" + onenum + CRLF(1);
      }
    }
  }
  
  if (Do_Forecast > 0)
  {
    if (do_recdev != 0) {
      for (y = recdev_end + 1; y <= YrMax; y++)
      {
        recdev_doit(y) = 1;
        sprintf(onenum, "%d", y);
        ParCount++;
        if (y > endyr)
        {
          ParmLabel += "ForeRecr_" + onenum + CRLF(1);
        }
        else
        {
          ParmLabel += "Late_RecrDev_" + onenum + CRLF(1);
        }
      }
    }
  
    if (Do_Impl_Error > 0) {
      for (y = endyr + 1; y <= YrMax; y++)
      {
        sprintf(onenum, "%d", y);
        ParCount++;
        ParmLabel += "Impl_err_" + onenum + CRLF(1);
      }
    }

    // check recdev start and end against survey year start and end
    for (f = 1; f <=Nfleet; f++) {
      if (Svy_units(f) == 31 || Svy_units(f) == 32 || Svy_units(f) == 33 || Svy_units(f) == 36) { //  select just recruitment surveys
        if (Svy_styr(f) < recdev_first) {
          warnstream << "Recruitment survey: " << f << " has data in: " << Svy_styr(f) << ", which is before first early recdev: " << recdev_first << ". Suggest start recdevs earlier";
          write_message (SUGGEST, 0);
        }
        if (Svy_endyr(f) > recdev_end && Fcast_recr_PH_rd <=0 ) {
          warnstream << "Recruitment survey: " << f << " has data in: " << Svy_endyr(f) << ", which is after last main recdev: " << recdev_end << ". Suggest extend recdev_end, or use pos. phase for fore_recruitments: " << Fcast_recr_PH_rd;
          write_message (SUGGEST, 0);
        }
      }
    }

  }
  
  biasadj_full.initialize();
  if (recdev_adj(5) == -1) //  all years with estimated recruitments
  {
    biasadj_full = recdev_doit;
  }
  else if (recdev_adj(5) == -2) //  no ramp
  {
    biasadj_full(recdev_first, endyr) = recdev_doit(recdev_first, endyr);
  }
  else if (recdev_adj(5) == -3) //  all to 0.0
  {
    biasadj_full = 0.0;
  }
  else
  { //  do ramp
    for (y = styr - nages; y <= YrMax; y++)
    {
      if (y < recdev_first) // before start of recrdevs
      {
        biasadj_full(y) = 0.;
      }
      else if (y <= recdev_adj(1))
      {
        biasadj_full(y) = 0.;
      }
      else if (y <= recdev_adj(2))
      {
        biasadj_full(y) = (y - recdev_adj(1)) / (recdev_adj(2) - recdev_adj(1)) * recdev_adj(5);
      }
      else if (y <= recdev_adj(3))
      {
        biasadj_full(y) = recdev_adj(5);
      } // max bias adjustment
      else if (y <= recdev_adj(4))
      {
        biasadj_full(y) = recdev_adj(5) - (y - recdev_adj(3)) / (recdev_adj(4) - recdev_adj(3)) * recdev_adj(5);
      }
      else
      {
        biasadj_full(y) = 0.;
      }
      if (y > endyr) {
        biasadj_full(y) = 0.0;
      }
    }
  }
  echoinput << "#_recruitment bias adjustment" << endl
            << biasadj_full << endl;
  ;
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.6.5 #Read recdev_cycle parameters and input recruitment deviations if needed
  init_matrix recdev_cycle_parm_RD(1,recdev_cycle,1,14);
!!k=1;
!!if(recdev_cycle>0) k=recdev_cycle;
  vector recdev_cycle_LO(1,k);
  vector recdev_cycle_HI(1,k);
  ivector recdev_cycle_PH(1,k);
!!if(recdev_cycle>0) echoinput<<"recruitment cycle input "<<endl<<recdev_cycle_parm_RD<<endl;

  init_matrix recdev_input(1,recdev_read,1,2);
!!if(recdev_read>0) echoinput<<"recruitment deviation input "<<endl<<recdev_input<<endl;

!!//  SS_Label_Info_4.7 #Input F_method setup
  init_number F_ballpark
!! echoinput<<F_ballpark<<" F ballpark is annual F, as specified in F_reporting, for a specified year"<<endl;
  init_int F_ballpark_yr
!! echoinput<<F_ballpark_yr<<" F_ballpark_yr (<0 to ignore)  "<<endl;

  int y1;
// array definitions related to F;  F_rate; Fparm; Hrate
  vector F_parm_intval(1,Nfleet);  //  initial value for F_parm when not using hybrid for early phases
  matrix F_setup2(1,1,1,1)  // later redimensioned to contain the F_detailed setup
  int F_detail;  // number of specific initial values and phases to read
  ivector F_Method_PH(1,Nfleet);  // phase to transition from hybrid to parameter, then used to setup F_PH_time
  imatrix F_PH_time(0,Nfleet,styr,TimeMax+nseas);  // stores Phase to transition from hybrid to parameters; -1 means keep input parameter; 99 means stay as hybrid
  int F_Tune;
  int F_Method;           // 1=Pope's; 2=continuous F; 3=hybrid; 4=fleet-specific
  number max_harvest_rate
  number Equ_F_joiner

  int N_Fparm
  int Fparm_start  //  location in parameter list for first Fparm
  imatrix do_Fparm_loc(1,Nfleet,styr-nseas,TimeMax+nseas);  // location in F_rate vector of this fleet x time F; location defined even for hybrid
//  vector<ivector>Fparm_loc[]  in global: holds f,t for each element of F_rate vector
  ivector Fparm_PH_dim(1,1);  //  will be redimensioned in param section to (1,N_Fparm)
  // the ivector Fparm_PH_dim is populated from the std::vector<int> Fparm_PH defined in global;
  //  then used to set phase to each F_rate in the parameter vector
  //  defining F_rate as number_vector allows for phase of elements in F_rate parameter vector to be element specific
  // in ss_param:  init_bounded_number_vector F_rate(1,k,0.,max_harvest_rate,Fparm_PH_dim)


 LOCAL_CALCS
  // clang-format on
  Equ_F_joiner = 10; //  defaults
  F_detail = -1;
  F_Tune = 3;
  F_parm_intval = 0.05; //  fill vector

  F_Method_PH = 99; //  default is to stay in hybrid
  F_PH_time.initialize();
  F_PH_time = 99; // so hybrid unless changed
  
  *(ad_comm::global_datafile) >> F_Method;
  echoinput << F_Method << " F_Method as read" << endl;
  if (F_Method < 1 || F_Method > 5)
  {
    warnstream << "F_Method must be 1 or 2 or 3 or 4, value is: " << F_Method;
    write_message (FATAL, 0); // EXIT!
  }
  
  *(ad_comm::global_datafile) >> max_harvest_rate;
  echoinput << max_harvest_rate << " max_harvest_rate " << endl;
  if (F_Method == 1)  //  Pope's
  {
    if (max_harvest_rate > 0.999)
    {
      warnstream << "Max harvest rate must  be <1.0 for F_method 1 " << max_harvest_rate;
      write_message (FATAL, 0); // EXIT!
    }
    if (max_harvest_rate <= 0.30)
    {
      warnstream << "Unexpectedly small value for max harvest rate for F_method 1:  " << max_harvest_rate;
      write_message (NOTE, 0);
    }
    Equ_F_joiner = (log(1. / max_harvest_rate - 1.)) / (max_harvest_rate - 0.2); //  used to spline the harvest rate
  }
  else  // exponential F
  {
    if (max_harvest_rate < 1.0)
    {

      warnstream << "Max harvest rate typically is >1.0 for F_method 2, 3 or 4 " << max_harvest_rate;
      write_message (NOTE, 0);
    }
    switch (F_Method)
    {
      case 2: //  F as parameter for all fleets
      {
        *(ad_comm::global_datafile) >> F_parm_intval(1);
        *(ad_comm ::global_datafile) >> F_Method_PH(1);  // phase to switch from hybrid to parameters
        *(ad_comm::global_datafile) >> F_detail;
        F_parm_intval = F_parm_intval(1); //  copy to rest of fleets
        F_Method_PH = F_Method_PH(1); //  copy to rest of fleets
        F_Tune = 4;
        echoinput << F_parm_intval << " starting F value when not starting from hybrid " << endl;
        echoinput << F_Method_PH(1) << " Phase to switch from hybrid to parameter " << endl;
        echoinput << F_detail << " N_detailed Fsetups to read (later -1 in yr field fills remaining years for that fleet)" << endl;
        if (F_detail > 0) {
          F_setup2.deallocate();
          F_setup2.allocate(1, F_detail, 1, 6); // fleet, yr, seas, Fvalue, se, phase
          *(ad_comm::global_datafile) >> F_setup2;  // reads whole table; will be processed later
          echoinput << " detailed F_setups " << endl
                    << F_setup2 << endl;
          //  add some checks to be sure that a -year record has been read for each fleet with fleet_type<=2
        }
        break;
      }
      case 3: //  hybrid for all fleets
      {
        F_Method_PH = 99;  // never switch to parameters
        *(ad_comm::global_datafile) >> F_Tune;
        echoinput << F_Tune << " N iterations for tuning hybrid F (typically 3-5)" << endl;
        break;
      }
      case 4: //  fleet-specific choice for hybrid vs parameters
      {
        echoinput << "read list of fleet ID, starting F, and phase to transition to parameters" << endl;
        //  each fleet starts with hybrid then switches to parameter in specified phase
        //  enter PH = 99 to not create any F parms for the listed fleet (stays in hybrid)
        //  fishing fleets not listed will use hybrid for all phases
        //  except bycatch fleets always start with parm in phase 1
        //  PH = -1 will keep starting parameter value throughout run
        F_Method_PH = 99;  // default is to stay in hybrid
        ender = 0.;
        F_detail = 0;
        int byc_count;
        byc_count = 0;
        dvector tempvec(1, 3);
        tempvec.initialize();
        F_Method_4_input.push_back(tempvec(1, 3));
        while (ender >= 0.)
        {
          dvector tempvec(1, 3);
          *(ad_comm::global_datafile) >> tempvec(1, 3);
          echoinput << tempvec << endl;
          F_Method_4_input.push_back(tempvec(1, 3));
          ender = tempvec(1);
          f = int(tempvec(1)); // fleet ID
          if (f <= Nfleet && ender > 0)
          {
            if (fleet_type(f) <= 2)
            {
              F_parm_intval(f) = tempvec(2);
              F_Method_PH(f) = tempvec(3);
              if (fleet_type(f) == 2) {
                byc_count++;
              } //  count bycatch fleets listed here to check against number in data file
            }
            else
            {
              warnstream << "cannot set FMethod for survey or predator fleet: " << f << " " << fleetname(f);
              write_message (FATAL, 0); // EXIT!
            }
          }
        }
        if (byc_count != N_bycatch)
        {
          warnstream << "Not all bycatch fleets have been included in Fparm list";
          write_message (FATAL, 0); // EXIT!
        }
        echoinput << "now read N tuning loops while in hybrid phases (2 is OK if switching to parm later, 3 OK, 4 more precise with many fleets)" << endl;
        *(ad_comm::global_datafile) >> F_Tune;
        echoinput << "hybrid tuning loops as read: " << F_Tune << endl;
        if (ender == -9998)  // flag to trigger reading F_detail for f x t specific F values
        {
          echoinput << "# now read List of fleet-time specific F related values to read; enter -Yr to fill remaining years&seasons; -999 for phase or catch_se keeps base value for the run; end that list with -1 for fleet" << endl;
          echoinput << "#Fleet Yr Seas F_value catch_se phase" << endl;

          dvector tempvec(1, 6);
          tempvec.initialize();
          F_detail_input.push_back(tempvec(1, 6));  //  fill the nasty zero row
          ender = 0.;
          F_detail = -1;
          while (ender >= 0.)
          {
            dvector tempvec(1, 6);
            *(ad_comm::global_datafile) >> tempvec(1, 6);
            echoinput << tempvec << endl;
            F_detail_input.push_back(tempvec(1, 6));
            ender = tempvec(1);
            F_detail++;
          }
          F_setup2.deallocate();
          F_setup2.allocate(1, F_detail, 1, 6); // fleet, yr, seas, Fvalue, se, phase
          for (j = 1; j <= F_detail; j++)
          {
            F_setup2(j) = F_detail_input[j];
          }
          echoinput << " detailed F_setups " << endl << F_setup2 << endl;
        }
        break;
      }
    }
  }
  // note that the F_setup2 table will be processed to fill F_PH_time after reading init_F inputs
  // code flow would be cleaner if F_setup was processed before reading and processing the init_F
  // however, for backward compatibility it is necessary to create the init_F parameters before the F parameters
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.7.1 #Read setup for init_F parameters and create init_F parameter labels
//  NEW  only read for catch fleets with positive initial equ catch
  imatrix init_F_loc(1,nseas,1,Nfleet);  // pointer to init_F parameter for each fleet
  int N_init_F;
  int N_init_F2;  //  for conversion of 3.24 to 3.30
 LOCAL_CALCS
  {
  // clang-format on
  init_F_loc.initialize();
  N_init_F = 0;
  N_init_F2 = 0;
  
    for (s = 1; s <= nseas; s++)
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        if (obs_equ_catch(s, f) != 0.0)
        {
          N_init_F++;
          init_F_loc(s, f) = N_init_F;
        }
        N_init_F2 = N_init_F;
      }
  }
  // clang-format off
 END_CALCS
!! echoinput<<" ready to read init_F setup for: "<<N_init_F<<" fleet x season with initial equilibrium catch"<<endl;
  init_matrix init_F_parm_1(1,N_init_F,1,7)
!! echoinput<<" initial equil F parameter setup"<<endl<<init_F_parm_1<<endl;
  vector init_F_LO(1,N_init_F)
  vector init_F_HI(1,N_init_F)
  vector init_F_RD(1,N_init_F)
  vector init_F_PR(1,N_init_F)
  vector init_F_PRtype(1,N_init_F)
  vector init_F_CV(1,N_init_F)
  ivector init_F_PH(1,N_init_F)

 LOCAL_CALCS
  // clang-format on
  if (N_init_F > 0)
  {
    init_F_LO = column(init_F_parm_1, 1);
    init_F_HI = column(init_F_parm_1, 2);
    init_F_RD = column(init_F_parm_1, 3);
    init_F_PR = column(init_F_parm_1, 4);
    init_F_CV = column(init_F_parm_1, 5);
    init_F_PRtype = column(init_F_parm_1, 6);
    init_F_PH = ivector(column(init_F_parm_1, 7));
  
    k = nseas;
  
    for (s = 1; s <= k; s++)
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        if (init_F_loc(s, f) > 0)
        {
          ParCount++;
          ParmLabel += "InitF_seas_" + NumLbl(s) + "_flt_" + NumLbl(f) + fleetname(f);
          j = init_F_loc(s, f);
          if (obs_equ_catch(s, f) <= 0.0)
          {
            if (init_F_RD(j) > 0.0)
            {
              warnstream << f << " catch: " << obs_equ_catch(s, f) << " initF: " << init_F_RD(j) << " initF is reset to be 0.0";
              write_message (ADJUST, 0);
            }
            init_F_RD(j) = 0.0;
            init_F_PH(j) = -1;
          }
          if (obs_equ_catch(s, f) > 0.0 && init_F_RD(j) <= 0.0)
          {
            warnstream << f << " catch: " << obs_equ_catch(s, f) << " initF: " << init_F_RD(j) << " initF must be >0";
            write_message (FATAL, 0); // EXIT!
          }
        }
      }
  }  //  end processing init_F parameters

  {  //  begin processing F_setup to create the F parameters
    do_Fparm_loc.initialize();    // location in Fparm vector of this fleet x time F; location defined even for hybrid
  
    Fparm_start = ParCount;  //  beginning of Fparms in total parameter list for tracking of parameter labels
    N_Fparm = 0;
  
    ivector tempin(1, 2);
    tempin.initialize();
    Fparm_loc.push_back(tempin(1, 2));
    Fparm_PH.push_back(0);
  
    if (F_Method == 1 || F_Method == 3) //  no F parameters
    {
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        if (fleet_type(f) == 2)  //  bycatch
        {
          warnstream << " cannot use Fmethod 1 or 3 for bycatch fleet: " << f << " " << fleetname(f);
          write_message (FATAL, 0); // EXIT!
        }
        else if (fleet_type(f) >= 3) //  survey fleet or predator
        {
          // F_PH_time(f) not used;
        }
        else //  fleet_type = 1
        {
          for(t = styr; t<= TimeMax+nseas; t++)
          {
            if(catch_ret_obs(f,t) > 0) 
            {
              F_PH_time(f,t) = 99;  //  so never (e.g. PH 99) switch to parameters because Fmethod == 3
            }
            else
            {
              F_PH_time(f,t) = -1;  //  no catch, so no F needed
            }
          }
        }
      }
    }
    else //  need F parameters for Fmethod 2 and 4
    {
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        if (fleet_type(f) >= 3) //  survey fleet or predator
        {
          //  bypass because F not used for survey or predators 
        }
        else  // fleet_type is 1 or 2
        {
          echoinput << " creating parms for fleet " << f << " "<<F_Method_PH(f)<<endl;
          for (y = styr; y <= endyr; y++)
          for (s = 1; s <= nseas; s++)
          {
            t = styr + (y - styr) * nseas + s - 1;
            if (catch_ret_obs(f, t) > 0.)
            {
              if (F_Method_PH(f) < 0) F_PH_time(f, t) = -1; //  parameter will be fixed F
              if (fleet_type(f) == 2)
              {
                F_PH_time(f, t) = 1;  //  begin in phase 1 for a bycatch fleet
                // note:  catch_ret_obs for bycatch fleet is needed as a trigger to create an F, it is not used as an observation
              }
              else
              {
                if (F_Method_PH(f) > 0 && F_Method_PH(f) <= 99) F_PH_time(f, t) = F_Method_PH(f); //  for later phases
              }
              N_Fparm++;
              ivector tempin(1, 2);
              tempin(1) = f;
              tempin(2) = t;
              Fparm_loc.push_back(tempin(1, 2));  //  stores the f, t for each Fparm
              Fparm_PH.push_back(F_PH_time(f, t));  //  stores PH in vector for dimensioning Fparm later
              do_Fparm_loc(f, t) = N_Fparm;  // stores parameter count for this f, t location
              sprintf(onenum, "%d", y);
              ParCount++;
              ParmLabel += "F_fleet_" + NumLbl(f) + "_YR_" + onenum + "_s_" + NumLbl(s) + CRLF(1);
            }
            else
            {
              F_PH_time(f, t) = -1;
            }
            
          }
        }
      }
      echoinput << "N F parameters " << N_Fparm << endl;
      echoinput << "Phase for each f, t: " << endl << F_PH_time << endl;
    }
  
    if (F_detail > 0)
    {
      for (k = 1; k <= F_detail; k++)
      {
        f = F_setup2(k, 1);
        y = F_setup2(k, 2);
        s = F_setup2(k, 3);
        if (y > 0)
        {
          y1 = y;
          y2 = y;
        }
        else
        {
          y1 = -y;
          y2 = endyr;
        }
        echoinput << "detailed F setup #: " << k << ":  " << F_setup2(k) << endl;
        for (y = y1; y <= y2; y++)
        for (s = 1; s <= nseas; s++)
        {
          t = styr + (y - styr) * nseas + s - 1;
          j = do_Fparm_loc(f, t);  //  get index in the Fparm vector
          if (j > 0 && F_setup2(k, 6) != -999) {
            Fparm_PH[j] = F_setup2(k,6);    // phase for each F_rate parameter
            F_PH_time(f,t) = F_setup2(k,6);
          }
          if (j > 0 && F_setup2(k, 5) != -999) catch_se(t, f) = F_setup2(k, 5); //    reset the se for this observation
        }
        //  setup of F_rate values occurs later in the prelim calc section
      }
      echoinput << "After F_detail:  Phase for each f, t: " << endl << F_PH_time << endl;
    }
  
    //  all fleets that use parm approach will do so in PH=1
    // find whether any fleet is hybrid for each phases
    for (y = styr; y <= endyr; y++)
    for (s = 1; s <= nseas; s++)
    {
      t = styr + (y - styr) * nseas + s - 1;
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        if (F_PH_time(f, t) < 99 && readparfile == 1) //  fleet ends up using parm approach
        {
          F_PH_time(f,t) = 1; //  so start with parm in phase 1 because using parm
        }
        if (F_PH_time(f, t) == 99) F_PH_time(0, t) = 99;  //  if one fleet is hybrid in phase, then set flag for hybrid
      }
    }
    echoinput << f << "  Overall F_PH_time:  " << F_PH_time(0) << endl;
  }
  // clang-format off
 END_CALCS

//  SS_Label_Info_4.8 #Read catchability (Q) setup
  imatrix Q_setup(1,Nfleet,1,5)
  ivector Q_setup_check(1,Nfleet)
  imatrix Q_setup_parms(1,Nfleet,1,5)  //  index of first parameter for:  1=base q with link;  2=extrastd; 3=env; 4=block/trend; 5=dev;
  int parm330_cnt
  int Q_Npar2
  int Q_Npar
  int firstQparm;
  int timevary_parm_cnt_Q;
  int timevary_parm_start_Q;
  int depletion_fleet;  //  stores fleet(survey) number for the fleet that is defined as "depletion" by survey type=34
  int depletion_type;  //  entered by Q_setup(f,2) and stores additional controls for depletion fleet

 LOCAL_CALCS
  // clang-format on
  firstQparm = 0;
  timevary_parm_cnt_Q = 0;
  timevary_parm_start_Q = 0;

  depletion_fleet = 0;
  depletion_type = 0;
  
  //Q_setup for 3.30
  // 1:  link type
  // 2:  extra input for link, i.e. mirror fleet or dev_vector index associated with survey
  // 3:  0/1 to select extra sd parameter
  // 4:  0/1 for biasadj or not
  // 5:  0/1 to float
  
  //  read setup and get the parameter count
  echoinput << "# read Q setup only for fleets with survey/CPUE/effort observations, end with fleet_ID<0 " << endl
            << "#  fleet_ID link_type link_info  extra_se(0/1)   biasadj(0/1)  float(0/1)" << endl;
  firstQparm = ParCount; //  base index before adding Q parms
  Q_setup.initialize();
  Q_setup_parms.initialize();
  Q_Npar = 0;
  Q_setup_check.initialize();
  j = 1;
  do
  {
    *(ad_comm::global_datafile) >> j;
    if (j > 0)
    {
      *(ad_comm::global_datafile) >> Q_setup(j);
      Q_setup_check(j) = 1;
    }
    else
    {
      *(ad_comm::global_datafile) >> tempvec(1, 5);
    }
  } while (j > 0);
  echoinput << "Q setup " << endl
            << "Note: control file should only contain rows for fleets with index observations" << endl
            << "      but setup is reported here as one row for each fleet (with no fleet column)" << endl
            << Q_setup << endl;
  
  //  get base parameter count
  for (f = 1; f <= Nfleet; f++)
  {
    if (Svy_N_fleet(f) > 0)
    {
      if (Q_setup_check(f) == 0)
      {
        warnstream << "Q setup;  survey obs exist for fleet " << f << " but no Q setup was read ";
        write_message (FATAL, 0); // EXIT!
      }
      Q_Npar++;
      ParCount++;
      Q_setup_parms(f, 1) = Q_Npar; //  first parameter index for this fleet that has obs so needs a Q
      if (Svy_errtype(f) == -1)
      {
        ParmLabel += "Q_base_" + fleetname(f) + "(" + NumLbl(f) + ")";
        if (Q_setup(f, 5) == 1) //  float
        {
          warnstream << "Q setup:  can't use float option with normal error distribution, fleet: " << f;
          write_message (FATAL, 0); // EXIT!
        }
      }
      else if (Svy_errtype(f) >= 0)  // lognormal or T-dist
      {
        ParmLabel += "LnQ_base_" + fleetname(f) + "(" + NumLbl(f) + ")";
      }
      if (Svy_units(f) == 35)
      {
        echoinput << "fleet: " << f << "  is a survey of dev vector:  " << Q_setup(f, 2) << endl;
        if (Q_setup(f, 2) == 0)
        {
          warnstream << "Q setup:  must enter index of dev_vector surveyed by fleet:  " << f;
          write_message (FATAL, 0); // EXIT!
        }
      }

      switch (Q_setup(f, 1))
      {
        case 1: //  simple Q
        {
          break;
        }
        case 2: //  mirror
        {
          int fmirror;
          fmirror = Q_setup(f, 2);
          if (fmirror == 0 || fmirror >= f)
          {
            warnstream << "Illegal mirror for q for fleet: " << f << " trying to mirror fleet: " << Q_setup(f, 2);
            write_message (FATAL, 0); // EXIT!
          }
          if (Q_setup(fmirror, 5) == 1)
          {
            warnstream << "Fleet: " << f << "  cannot mirror fleet that has float q: " << fmirror;
            write_message (FATAL, 0); // EXIT!
          }
          break;
        }
        case 3: //  add power
        {
          Q_Npar++;
          ParCount++;
          ParmLabel += "Q_power_" + fleetname(f) + "(" + NumLbl(f) + ")";
          break;
        }
        case 4: //  mirror with offset, where offset typically is ln(area_base/area_dependent)  ln(Q2) = ln(Q1) + ln (area1 / area2)
        {
          if (Q_setup(f, 2) == 0 || Q_setup(f, 2) >= f)
          {
            warnstream << "Illegal mirror for q for fleet: " << f << " trying to mirror fleet: " << Q_setup(f, 2);
            write_message (FATAL, 0); // EXIT!
          }
          Q_Npar++;
          ParCount++;
          ParmLabel += "Q_mirror_scale_" + fleetname(f) + "(" + NumLbl(f) + ")";
          break;
        }
        case 5: //  add offset
        {
          Q_Npar++;
          ParCount++;
          ParmLabel += "Q_offset_" + fleetname(f) + "(" + NumLbl(f) + ")";
          break;
        }
        case 6: //  add offset and power
        {
          Q_Npar++;
          ParCount++;
          ParmLabel += "Q_offset_" + fleetname(f) + "(" + NumLbl(f) + ")";
          Q_Npar++;
          ParCount++;
          ParmLabel += "Q_power_" + fleetname(f) + "(" + NumLbl(f) + ")";
          break;
        }
      }
      if (Q_setup(f, 3) > 0)
      {
        Q_Npar++;
        ParCount++;
        Q_setup_parms(f, 2) = Q_Npar;
        ParmLabel += "Q_extraSD_" + fleetname(f) + "(" + NumLbl(f) + ")";
      }
      if (Svy_units(f) == 35 || Svy_units(f) == 36)  // env index of recdev or parm dev vector
      {
        if (Q_setup(f, 1) < 5)  //  so OK for 5 and 6
        {
          warnstream << "Suggest using Q option 5 to include offset parameter for an index of deviations (type 35 or 36)";
          write_message (WARN, 0);
        }
        if (Q_setup(f, 1) == 3 || Q_setup(f,1) == 6)         
        {
          warnstream << "Power function cannot be used for an index of deviations (type 35 or 36) because of negative values";
          write_message (FATAL, 0);
        }
      }
      if (Svy_units(f) == 34) //  special code for depletion, so prepare to adjust phases and lambdas
      {
        echoinput << "# survey: " << f << " " << fleetname(f) << " is a depletion fleet" << endl;
        depletion_fleet = f;
        depletion_type = Q_setup(f, 2);
        if (depletion_type == 0)
          echoinput << "link_info=0; add 1 to phases of all parms; only R0 active in new phase 1 (same as 3.24 logic)" << endl;
        if (depletion_type == 1)
          echoinput << "link_info=1  only R0 active in phase 1; then exit;  useful for data-limited draws of other fixed parameter" << endl;
        if (depletion_type == 2)
          echoinput << "link_info=2  no phase adjustments, can be used when profiling on fixed R0" << endl;
        if (Q_setup(f, 5) == 1)
        {
          warnstream << "Change to no_float for depletion fleet # " << f << endl;
          warnstream << "++ and you must set phase to negative so not estimated";
          write_message (ADJUST, 1);
          Q_setup(f, 5) = 0;
        }
      }
    }
    else
    {
      if (Q_setup_check(f) > 0)
      {
        warnstream << " Q setup error; no survey obs for fleet " << f << " but Q setup was read ";
        write_message (FATAL, 0); // EXIT!
      }
    }
  }

  echoinput << "Q_Npar (number of long parameter lines): " << Q_Npar << endl
            << endl << "Q setup parameter index " << endl
            << "column have index of first parameter for:  1=base q with link;  2=extrastd; 3=env; 4=block/trend; 5=dev;"
            << Q_setup_parms << endl;
  // clang-format off
 END_CALCS

  init_matrix Q_parm_1(1,Q_Npar,1,14)
  ivector Qparm_timevary(1,Q_Npar) //  holds index in timevary_def used by each base parameter
  //  dimensioned to hold the extra_sd parms, but these cannot be time-varying
  imatrix timevary_Qparm(styr-3,YrMax+1,0,Nfleet) // goes to yrmax+1 to allow referencing in forecast, but only endyr+1 is checked
  // stores years to calc non-constant sel parms by fleet

 LOCAL_CALCS
      // clang-format on
      //  now create time_vary parameters
      parm330_cnt = 0; //  restart the index
  Qparm_timevary.initialize();
  timevary_Qparm.initialize();
  timevary_parm_start_Q = 0;
  timevary_parm_cnt_Q = 0;
  timevary_used = 0;
  for (f = 1; f <= Nfleet; f++)
    if (Svy_N_fleet(f) > 0)
    {
      j = Q_setup_parms(f, 1);
      echoinput << "fleet " << f << " base index " << j << endl;
      if (Q_setup(f, 5) == 1) //  float
      {
        if (Q_parm_1(j, 7) >= 0)
        {
          warnstream << "Fleet: " << f << "  SS3 changed Q to not estimate because it is set to float";
          write_message (ADJUST, 0);
          Q_parm_1(j, 7) = -1;
        }
      }
  
      //  depletion fleet check
      if (Svy_units(f) == 34) //  special code for depletion
      {
        if (Q_parm_1(j, 7) >= 0)
        {
          warnstream << "Fleet: " << f << " SS3 changed Q to not estimate because it is depletion fleet";
          write_message (ADJUST, 0);
          Q_parm_1(j, 7) = -1;
        }
      }
  
      //  check for extraSD estimation
      if (Q_setup(f, 3) > 0)
      {
        if (Q_parm_1(Q_setup_parms(f, 2), 7) > 0) varparm_estimated(3) = 1; // extraSD is estimated, so need sd_offset=1
      }
  
      if (Q_parm_1(j, 13) == 0 && Q_parm_1(j, 8) == 0 && Q_parm_1(j, 9) == 0)
      {
        //  no time-vary parameter effects
      }
      else //  set up a timevary parameter definition
      {
        timevary_used = 1;
        ivector timevary_setup(1, 14); //  temporary vector for timevary specs
        timevary_setup.initialize();
        if (timevary_parm_start_Q == 0) timevary_parm_start_Q = timevary_parm_cnt + 1;
        echoinput << endl
                  << " timevary Q for fleet: " << f << endl;
        timevary_cnt++; //  count parameters with time-vary effect
        Qparm_timevary(j) = timevary_cnt; //  base Q parameter will use this timevary specification
        timevary_setup(1) = 3; //  indicates a Q parm
        timevary_setup(2) = j; //  index of base parm within that type of parameter
        timevary_setup(13) = firstQparm + j; //  index of base parm relative to ParCount which is continuous across all types of parameters
        timevary_setup(3) = timevary_parm_cnt + 1; //  first parameter within total list of all timevary parms
        timevary_pass = column(timevary_Qparm, f); // year vector for this fleet
        //  set up env link info
        echoinput << " check for env " << Q_parm_1(j, 8) << endl;
  
        k = int(abs(Q_parm_1(j, 8)) / 100); //  find the env link code
        timevary_setup(6) = k; //  link code for env
        if (Q_parm_1(j, 8) > 0) //  env variable used
        {
          timevary_setup(7) = int(abs(Q_parm_1(j, 8))) - k * 100;
          k = timevary_setup(7);
          //         for(y=styr-1;y<=YrMax;y++) env_data_pass(y)=env_data_RD(y,k);
          env_data_pass(1) = env_data_minyr(k);
          env_data_pass(2) = env_data_maxyr(k);
        }
        else if (abs(Q_parm_1(j, 8) > 0)) //  density-dependence
        {
          timevary_setup(7) = -int(abs(Q_parm_1(j, 8)) - k * 100);
          do_densitydependent = 1;
          k = 0;
          env_data_pass.initialize();
        }
  
        if (Q_parm_1(j, 13) > 0) //  doing blocks
        {
          if (Q_parm_1(j, 13) > N_Block_Designs)
          {
            warnstream << "Q block request exceeds N_block patterns" ;
            write_message (FATAL, 0); // EXIT!
          }
          create_timevary(Q_parm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), f, Block_Design(Q_parm_1(j, 13)), env_data_pass, N_parm_dev, finish_starter);
        }
        else
        {
          create_timevary(Q_parm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), f, block_design_null, env_data_pass, N_parm_dev, finish_starter);
        }
        timevary_def.push_back(timevary_setup(1, 14));
        for (y = styr - 3; y <= YrMax + 1; y++) {
          timevary_Qparm(y, f) = timevary_pass(y);
        } // year vector for this category og MGparm
      }
    }
  
  Q_Npar2 = Q_Npar;
  if (timevary_parm_start_Q > 0)
  {
    if (timevary_used == 1) autogen_timevary(3) = 1; //  indicate that some parameter is time-varying
    timevary_parm_cnt_Q = timevary_parm_cnt;
    Q_Npar2 += (timevary_parm_cnt_Q - timevary_parm_start_Q + 1);
    echoinput << "Q  uses timevary parms:  " << Qparm_timevary << endl;
    echoinput << " Q  timevary_parm_cnt start and end " << timevary_parm_start_Q << " " << timevary_parm_cnt_Q << endl;
  }
  echoinput << "Q_Npar (long lines) and Q_Npar2 (long + short lines):  " << Q_Npar << " " << Q_Npar2 << endl;
  // clang-format off
 END_CALCS

  vector Q_parm_LO(1,Q_Npar2)
  vector Q_parm_HI(1,Q_Npar2)
  vector Q_parm_RD(1,Q_Npar2)
  vector Q_parm_PR(1,Q_Npar2)
  ivector Q_parm_PRtype(1,Q_Npar2)
  vector Q_parm_CV(1,Q_Npar2)
  ivector Q_parm_PH(1,Q_Npar2)

 LOCAL_CALCS
      // clang-format on
      if (Q_Npar2 == 0)
  {
    Q_parm_LO = -1.;
    Q_parm_HI = 1.;
    Q_parm_PH = -4;
  }
  else
  {
    for (i = 1; i <= Q_Npar; i++)
    {
      Q_parm_LO(i) = Q_parm_1(i, 1);
      Q_parm_HI(i) = Q_parm_1(i, 2);
      Q_parm_RD(i) = Q_parm_1(i, 3);
      Q_parm_PR(i) = Q_parm_1(i, 4);
      Q_parm_CV(i) = Q_parm_1(i, 5);
      Q_parm_PRtype(i) = Q_parm_1(i, 6);
      Q_parm_PH(i) = Q_parm_1(i, 7);
    }
    if (timevary_parm_start_Q > 0)
    {
      j = Q_Npar;
      for (f = timevary_parm_start_Q; f <= timevary_parm_cnt_Q; f++)
      {
        j++;
        echoinput << f << " " << j << " " << timevary_parm_rd[f] << endl;
        Q_parm_LO(j) = timevary_parm_rd[f](1);
        Q_parm_HI(j) = timevary_parm_rd[f](2);
        Q_parm_RD(j) = timevary_parm_rd[f](3);
        Q_parm_PR(j) = timevary_parm_rd[f](4);
        Q_parm_PRtype(j) = timevary_parm_rd[f](6);
        Q_parm_CV(j) = timevary_parm_rd[f](5);
        Q_parm_PH(j) = timevary_parm_rd[f](7);
      }
    }
  }
  echoinput << "Q_parm_RD: " << endl;
  for (z = 1; z <= Q_Npar2; z++)
    echoinput << z << " " << Q_parm_RD(z) << " " << ParmLabel(ParCount - Q_Npar2 + z) << endl;
  echoinput << "#" << endl;
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.9 #Define Selectivity patterns and N parameters needed per pattern
  ivector seltype_Nparam(0,50)
 LOCAL_CALCS
   // clang-format on
   seltype_Nparam(0) = 0; // selex=1.0 for all sizes
  seltype_Nparam(1) = 2; // logistic; with 95% width specification
  seltype_Nparam(2) = 6; // test version of double normal (24)
  seltype_Nparam(3) = 6; // flat middle, power up, power down
  seltype_Nparam(4) = 0; // set size selex=female maturity
  seltype_Nparam(5) = 2; // mirror another selex; PARMS pick the min-max bin to mirror
  seltype_Nparam(6) = 2; // non-parm len selex, additional parm count is in seltype(f,4)
  seltype_Nparam(7) = 8; // New doublelogistic with smooth transitions and constant above Linf option
  seltype_Nparam(8) = 8; // New doublelogistic with smooth transitions and constant above Linf option
  seltype_Nparam(9) = 6; // simple 4-parm double logistic with starting length; parm 5 is first length; parm 6=1 does desc as offset
  
  seltype_Nparam(10) = 0; //  First age-selex  selex=1.0 for all ages
  seltype_Nparam(11) = 2; //  pick min-max age
  seltype_Nparam(12) = 2; //   logistic
  seltype_Nparam(13) = 8; //   double logistic
  seltype_Nparam(14) = nages + 1; //   empirical
  seltype_Nparam(15) = 0; //   mirror another selex
  seltype_Nparam(16) = 2; //   Coleraine - Gaussian
  seltype_Nparam(17) = nages + 1; //   empirical as random walk  N parameters to read can be overridden by setting special to non-zero
  seltype_Nparam(18) = 8; //   double logistic - smooth transition
  seltype_Nparam(19) = 6; //   simple 4-parm double logistic with starting age
  seltype_Nparam(20) = 6; //   double_normal,using joiners
  
  seltype_Nparam(21) = 2; // non-parm len selex, additional parm count is in seltype(f,4), read as pairs of size, then selex
  seltype_Nparam(22) = 4; //   double_normal as in CASAL
  seltype_Nparam(23) = 6; //   double_normal where final value is directly equal to sp(6) so can be >1.0
  seltype_Nparam(24) = 6; //   double_normal with sel(minL) and sel(maxL), using joiners
  seltype_Nparam(25) = 3; //   exponential-logistic in size
  seltype_Nparam(26) = 3; //   exponential-logistic in age
  seltype_Nparam(27) = 3; // cubic spline for selex at length, additional parm count is in seltype(f,4)
  //   seltype_Nparam(28)=3;   // cubic spline for selex at age, additional parm count is in seltype(f,4)
  seltype_Nparam(29) = 0; //   undefined
  
  seltype_Nparam(41) = 2 + seltype_Nparam(17); // like 17, with 2 additional parameters for scaling (average over bin range)
  seltype_Nparam(42) = 2 + seltype_Nparam(27); // like 27, with 2 additional parameters for scaling (average over bin range)
  seltype_Nparam(43) = seltype_Nparam(6); // like 6, with 2 additional parameters for scaling (average over bin range)
  seltype_Nparam(44) = 4; // like 17 for two sexes with male selectivity as separate parameters
  seltype_Nparam(45) = 4; // like 14 for two sexes with male selectivity as separate parameters
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.9.1 #Read selectivity definitions
//  do 2*Nfleet to create options for size-selex (first), then age-selex
  init_imatrix seltype_rd(1,2*Nfleet,1,4)    // read selex type for each fleet/survey, retention option, male_offset_option, special
  imatrix seltype(1,2*Nfleet,1,4)    // read selex type for each fleet/survey, retention option, male_offset_option, special

  int N_selparm   // figure out the Total number of selex parameters
  int N_selparm3                 // N selparms plus timevary parms
  int N_selparm2                 // N selparms plus timevary parms and 2D_AR1 parms
  ivector N_selparmvec(1,2*Nfleet)  //  N selparms by type, including extra parms for male selex, retention, etc.
  ivector Maleselparm(1,2*Nfleet)
  ivector RetainParm(1,Nfleet)  //  can only have length or age retention, not both for a fleet
  ivector dolen(1,Nfleet)
  int blkparm
  int firstselparm
  ivector N_ret_parm(0,6)  //  6 possible retention functions allowed
  ivector N_disc_mort_parm(0,6)  //  6 possible discard mortality functions allowed
  ivector Do_Retain(1,Nfleet)  // indicates 0=none, 1=length based, 2=age based
  ivector Min_selage(1,Nfleet) //  minimum selected age
  imatrix Comp_Err_parmloc(1,Comp_Err_ParmCount,1,2);  //  for each comp_err_index, locate starting parameter in parcount (2) and in Selparm (1).

 LOCAL_CALCS
      // clang-format on
      echoinput
      << " selex types " << endl
      << seltype_rd << endl;
  
  //  identify fleets with adjusted first_selected age
  seltype = seltype_rd; //  set matrices to be same
  Min_selage.initialize();
  for (f = 1; f <= 2 * Nfleet; f++)
  {
    echoinput << f << " " << seltype_rd(f, 1) << endl;
    if (seltype_rd(f, 1) >= 100)
    {
      if (f <= Nfleet)
      {
        warnstream << "Fleet: " << f << "  cannot use >100 code for length selectivity; SS3 will correct";
        write_message (ADJUST, 0);
        j = int(seltype(f, 1) / 100);
        k = seltype(f, 1) - 100 * j;
        seltype_rd(f, 1) = k; //  change input value so will be written correctly in ss_new
        seltype(f, 1) = seltype_rd(f, 1);
      }
      else
      {
        Min_selage(f - Nfleet) = int(seltype(f, 1) / 100);
        k = seltype(f, 1) - 100 * Min_selage(f - Nfleet);
        echoinput << seltype(f, 1) << " " << k << " " << Min_selage(f - Nfleet) << endl;
        if (k == 12 || k == 13 || k == 14 || k == 16 || k == 18 || k == 26 || k == 27)
        {
          echoinput << "OK to use min_selage for selex pattern: " << k << " for fleet: " << f - Nfleet << endl;
        }
        else if (k == 17 || k == 44 || k == 45)
        {
          warnstream << "Don't use min_selage for age selectivity: " << k << " for fleet: " << f - Nfleet << " because separate control exists; SS3 will correct";
          write_message (ADJUST, 0);
          seltype_rd(f, 1) = k;
        } //  change input value so will be written correctly in ss_new
        else if (k == 19)
        {
          warnstream << "Can't use min_selage for age selectivity: " << k << " for fleet: " << f - Nfleet << " because separate control sets sel = 1.0e-06 below a specified age SS3 will correct";
          write_message (ADJUST, 0);
          seltype_rd(f, 1) = k;
        }
        else if (k == 20)
        {
          warnstream << "OK to use min_selage for age selectivity: " << k << " for fleet: " << f - Nfleet << " but be aware that a separate control for parm 5 can set sel = 1.0e-06 below a specified age";
          write_message (WARN, 0);
        }
        else
        {
          echoinput << "Min_selage not implemented and not relevant for selex pattern: " << k << " for fleet: " << f - Nfleet << endl;
          seltype_rd(f, 1) = k;
        }
        seltype(f, 1) = k;
      }
    }
  }
  
  RetainParm.initialize();
  //  define number of parameters for each retention type
  N_ret_parm(0) = 0;
  N_ret_parm(1) = 4; // for asymptotic retention
  N_ret_parm(2) = 4; // for asymptotic retention and 4 param discard mort
  N_ret_parm(3) = 0; // all dead
  N_ret_parm(4) = 7; // for dome-shaped retention and 4 param discard mort
  
  //  define number of discard mortality parameters for each retention type
  N_disc_mort_parm(0) = 0;
  N_disc_mort_parm(1) = 0; // for asymptotic retention
  N_disc_mort_parm(2) = 4; // for asymptotic retention and 4 param discard mort
  N_disc_mort_parm(3) = 0; // all dead
  N_disc_mort_parm(4) = 4; // for dome-shaped retention and 4 param discard mort
  
  //  SS_Label_Info_4.9.2 #Process selectivity parameter count and create parameter labels
  firstselparm = ParCount;
  N_selparm = 0;
  //   N_ret_parm=7;    // to allow for dome-shaped retention
  Do_Retain.initialize();
  for (f = 1; f <= Nfleet; f++)
  {
    if (WTage_rd > 0 && seltype(f, 1) > 0)
    {
      warnstream << "Use of size selectivity not advised when reading empirical wt-at-age ";
      write_message (WARN, 0);
    }
    N_selparmvec(f) = seltype_Nparam(seltype(f, 1)); // N Length selex parms
    if (seltype(f, 1) == 6 || seltype(f, 1) == 43) N_selparmvec(f) += seltype(f, 4); // special setup of N parms
    if (seltype(f, 1) == 21) N_selparmvec(f) += 2 * (seltype(f, 4) - 1); // special setup of N parms
    if (seltype(f, 1) == 27) N_selparmvec(f) += 2 * seltype(f, 4); // special setup of N parms for cubic spline
    if (seltype(f, 1) == 42) N_selparmvec(f) += 2 * seltype(f, 4); // special setup of N parms for cubic spline
    if (seltype(f, 1) > 0 && Svy_units(f) < 30) {
      dolen(f) = 1;
    }
    else
    {
      dolen(f) = 0;
    }
    if (seltype(f, 1) == 15 || seltype(f, 1) == 5) // mirror
    {
      if (seltype(f, 4) == 0 || seltype(f, 4) >= f)
      {
        warnstream << "Illegal mirror for len selex fleet " << f << "trying to mirror fleet: " << seltype(f, 4);
        write_message (FATAL, 1); // EXIT!
      }
    }
    if (seltype(f, 1) == 43)
    {
      ParCount++;
      ParmLabel += "SizeSel_ScaleBinLo_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "SizeSel_ScaleBinHi_" + fleetname(f) + "(" + NumLbl(f) + ")";
      echoinput << "N parm " << N_selparmvec(f) << endl;
    }
  
    if (seltype(f, 1) == 27 || seltype(f, 1) == 42)
    {
      if (seltype(f, 1) == 42)
      {
        ParCount++;
        ParmLabel += "SizeSpline_ScaleBinLo_" + fleetname(f) + "(" + NumLbl(f) + ")";
        ParCount++;
        ParmLabel += "SizeSpline_ScaleBinHi_" + fleetname(f) + "(" + NumLbl(f) + ")";
      }
      ParCount++;
      ParmLabel += "SizeSpline_Code_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "SizeSpline_GradLo_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "SizeSpline_GradHi_" + fleetname(f) + "(" + NumLbl(f) + ")";
      for (s = 1; s <= seltype(f, 4); s++)
      {
        ParCount++;
        ParmLabel += "SizeSpline_Knot_" + NumLbl(s) + "_" + fleetname(f) + "(" + NumLbl(f) + ")";
      }
      for (s = 1; s <= seltype(f, 4); s++)
      {
        ParCount++;
        ParmLabel += "SizeSpline_Val_" + NumLbl(s) + "_" + fleetname(f) + "(" + NumLbl(f) + ")";
      }
    }
    else if (seltype(f, 1) == 24 || seltype(f, 1) == 2) //  double_normal
    {
      ParCount++;
      ParmLabel += "Size_DblN_peak_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "Size_DblN_top_logit_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "Size_DblN_ascend_se_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "Size_DblN_descend_se_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "Size_DblN_start_logit_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "Size_DblN_end_logit_" + fleetname(f) + "(" + NumLbl(f) + ")";
    }
    else if (seltype(f, 1) == 1) //  logistic
    {
      ParCount++;
      ParmLabel += "Size_inflection_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "Size_95%width_" + fleetname(f) + "(" + NumLbl(f) + ")";
    }
    else if (seltype(f, 1) == 11)
    {
      ParCount++;
      ParmLabel += "SizeSel=1_BinLo_" + fleetname(f) + "(" + NumLbl(f) + ")";
      ParCount++;
      ParmLabel += "SizeSel=1_BinHi_" + fleetname(f) + "(" + NumLbl(f) + ")";
    }
  
    else
    {
      for (j = 1; j <= N_selparmvec(f); j++)
      {
        ParCount++;
        ParmLabel += "SizeSel_P" + NumLbl(j) + "_" + fleetname(f) + "(" + NumLbl(f) + ")";
      }
    }
  
    // account for the low and high bin parameters
    if (seltype(f, 1) == 43) N_selparmvec(f) += 2;
  
    if (seltype(f, 2) >= 1)
    {
      if (WTage_rd > 0)
      {
        warnstream << "Length-based retention will use the same empirical wtatage for discard and retained fish for fleet: " << f;
        write_message (NOTE, 0);
      }
      Do_Retain(f) = 1;
      if (fleet_type(f) == 2 && seltype(f, 2) != 3)
      {
        warnstream << "Fleet: " << f << " is a bycatch fleet, so consider using retention option =3 so no parameters needed";
        write_message (SUGGEST, 0);
      }
      if (seltype(f, 2) == 3)
      {
        RetainParm(f) = 0;
      } //  no parameters needed
      else
      {
        RetainParm(f) = N_selparmvec(f) + 1;
        //       N_selparmvec(f) +=N_ret_parm*seltype(f,2);          // N retention parms first [N_ret_parm] for retention; next [N_ret_parm] for discard mortality
        if (N_ret_parm(seltype(f, 2)) > 0)
        {
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_L_infl_" + fleetname(f) + "(" + NumLbl(f) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_L_width_" + fleetname(f) + "(" + NumLbl(f) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_L_asymptote_logit_" + fleetname(f) + "(" + NumLbl(f) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_L_maleoffset_" + fleetname(f) + "(" + NumLbl(f) + ")";
          if (N_ret_parm(seltype(f, 2)) == 7) //  doing dome
          {
            ParCount++;
            N_selparmvec(f)++;
            ParmLabel += "Retain_L_dome_infl_" + fleetname(f) + "(" + NumLbl(f) + ")";
            ParCount++;
            N_selparmvec(f)++;
            ParmLabel += "Retain_L_dome_width_" + fleetname(f) + "(" + NumLbl(f) + ")";
            ParCount++;
            N_selparmvec(f)++;
            ParmLabel += "Retain_L_dome_maleoffset_" + fleetname(f) + "(" + NumLbl(f) + ")";
          }
        }
        if (seltype(f, 2) == 2 || seltype(f, 2) == 4)
        {
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_L_infl_" + fleetname(f) + "(" + NumLbl(f) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_L_width_" + fleetname(f) + "(" + NumLbl(f) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_L_level_old_" + fleetname(f) + "(" + NumLbl(f) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_L_male_offset_" + fleetname(f) + "(" + NumLbl(f) + ")";
        }
      }
    }
    else if (seltype(f, 2) < 0) //  mirror retention
    {
      Do_Retain(f) = 1;
      RetainParm(f) = 0;
    }
    if (seltype(f, 3) >= 1)
    {
      if (gender == 1)
      {
        warnstream << "Male selex cannot be used in one sex model; fleet: " << f ;
        write_message (FATAL, 1); // EXIT!
      }
      Maleselparm(f) = N_selparmvec(f) + 1;
      if (seltype(f, 3) == 1 || seltype(f, 3) == 2)
      {
        N_selparmvec(f) += 4; // add male parms
        ParCount += 4;
        ParmLabel += "SzSel_MaleDogleg_" + fleetname(f) + "(" + NumLbl(f) + ")";
        ParmLabel += "SzSel_MaleatZero_" + fleetname(f) + "(" + NumLbl(f) + ")";
        ParmLabel += "SzSel_MaleatDogleg_" + fleetname(f) + "(" + NumLbl(f) + ")";
        ParmLabel += "SzSel_MaleatMaxage_" + fleetname(f) + "(" + NumLbl(f) + ")";
      }
      else if (seltype(f, 3) >= 3)
      {
        if (seltype(f, 3) == 3) {
          anystring = "Male_";
        }
        else
        {
          anystring = "Fem_";
        }
        if (seltype(f, 1) == 1)
        {
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Infl_" + fleetname(f) + "(" + NumLbl(f) + ")";
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Slope_" + fleetname(f) + "(" + NumLbl(f) + ")";
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Scale_" + fleetname(f) + "(" + NumLbl(f) + ")";
        }
        else if (seltype(f, 1) == 24 || seltype(f, 1) == 2)
        {
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Peak_" + fleetname(f) + "(" + NumLbl(f) + ")";
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Ascend_" + fleetname(f) + "(" + NumLbl(f) + ")";
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Descend_" + fleetname(f) + "(" + NumLbl(f) + ")";
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Final_" + fleetname(f) + "(" + NumLbl(f) + ")";
          N_selparmvec(f)++;
          ParCount++;
          ParmLabel += "SzSel_" + anystring + "Scale_" + fleetname(f) + "(" + NumLbl(f) + ")";
        }
        else
        {
          warnstream << "Illegal male selex option selected for fleet " << f ;
          write_message (FATAL, 1); // EXIT!
        }
      }
    }
  
    if (seltype(f, 1) == 7)
    {
      warnstream << "Selectivity pattern #7 is no longer supported ";
      write_message (WARN, 0);
    }
    if (seltype(f, 1) == 23 && F_Method == 1)
    {
      warnstream << "Do not use F_Method = Pope's with selex pattern #23 ";
      write_message (WARN, 0);
    }
    N_selparm += N_selparmvec(f);
  }
  for (f = Nfleet + 1; f <= 2 * Nfleet; f++)
  {
    int f1 = f - Nfleet; // actual fleet number
    if (seltype(f, 1) == 15) // mirror
    {
      if (seltype(f, 4) == 0 || seltype(f, 4) >= f1)
      {
        warnstream << "Illegal mirror for age selex fleet " << f - Nfleet;
        write_message (FATAL, 0); // EXIT!
      }
      N_selparmvec(f) = 0; // Nunber of Age selex parms
    }
    else if (seltype(f, 1) != 17 && seltype(f, 1) != 41)
    {
      N_selparmvec(f) = seltype_Nparam(seltype(f, 1)); // Nunber of Age selex parms
    }
    else if (seltype(f, 4) == 0)
    {
      N_selparmvec(f) = seltype_Nparam(seltype(f, 1)); // this is nages+1
    }
    else
    {
      N_selparmvec(f) = abs(seltype(f, 4)) + 1; // so reads value for age 0 through this age
      if (seltype(f, 1) == 41) N_selparmvec(f) +=2;  //  for the scaling parameters
    }
  
    if (seltype(f, 1) == 41)
    {
      ParCount++;
      ParmLabel += "AgeSel_ScaleAgeLo_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "AgeSel_ScaleAgeHi_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
    }
  
    if (seltype(f, 1) == 27 || seltype(f, 1) == 42)
    {
      if (seltype(f, 1) == 42)
      {
        ParCount++;
        ParmLabel += "AgeSpline_ScaleAgeLo_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        ParCount++;
        ParmLabel += "AgeSpline_ScaleAgeHi_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      }
      N_selparmvec(f) += 2 * seltype(f, 4); // special setup of N parms for cubic spline
      ParCount++;
      ParmLabel += "AgeSpline_Code_" + fleetname(f1) + "_" + NumLbl(f1);
      ParCount++;
      ParmLabel += "AgeSpline_GradLo_" + fleetname(f1) + "_" + NumLbl(f1);
      ParCount++;
      ParmLabel += "AgeSpline_GradHi_" + fleetname(f1) + "_" + NumLbl(f1);
      for (s = 1; s <= seltype(f, 4); s++)
      {
        ParCount++;
        ParmLabel += "AgeSpline_Knot_" + NumLbl(s) + "_" + fleetname(f1) + "_" + NumLbl(f1);
      }
      for (s = 1; s <= seltype(f, 4); s++)
      {
        ParCount++;
        ParmLabel += "AgeSpline_Val_" + NumLbl(s) + "_" + fleetname(f1) + "_" + NumLbl(f1);
      }
    }
    else if (seltype(f, 1) == 44)
    {
      N_selparmvec(f) = 2 + gender + gender * seltype(f, 4);
      ParCount++;
      ParmLabel += "first_selage_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "first_age_mean_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "last_age_mean_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      if (gender == 2)
      {
        ParCount++;
        ParmLabel += "Male_ln(ratio)_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        for (int gg = 1; gg <= seltype(f, 4); gg++)
        {
          ParCount++;
          ParmLabel += "female_ln(selchange)_" + NumLbl(gg) + "_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        }
        for (int gg = 1; gg <= seltype(f, 4); gg++)
        {
          ParCount++;
          ParmLabel += "male_ln(selchange)_" + NumLbl(gg) + "_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        }
      }
      else
      {
        for (int gg = 1; gg <= seltype(f, 4); gg++)
        {
          ParCount++;
          ParmLabel += "ln(selchange)_" + NumLbl(gg) + "_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        }
      }
    }
    else if (seltype(f, 1) == 45)
    {
      N_selparmvec(f) = 2 + gender + gender * seltype(f, 4);
      ParCount++;
      ParmLabel += "first_selage_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "first_age_mean_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "last_age_mean_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      if (gender == 2)
      {
        ParCount++;
        ParmLabel += "Male_ln(ratio)_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        for (int gg = 1; gg <= seltype(f, 4); gg++)
        {
          ParCount++;
          ParmLabel += "female_sel_logit_" + NumLbl(gg) + "_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        }
        for (int gg = 1; gg <= seltype(f, 4); gg++)
        {
          ParCount++;
          ParmLabel += "male_sel_logit_" + NumLbl(gg) + "_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        }
      }
      else
      {
        for (int gg = 1; gg <= seltype(f, 4); gg++)
        {
          ParCount++;
          ParmLabel += "ln(selchange)_" + NumLbl(gg) + "_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        }
      }
    }
  
    else if (seltype(f, 1) == 20)
    {
      ParCount++;
      ParmLabel += "Age_DblN_peak_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "Age_DblN_top_logit_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "Age_DblN_ascend_se_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "Age_DblN_descend_se_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "Age_DblN_start_logit_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "Age_DblN_end_logit_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
    }
    else if (seltype(f, 1) == 12)
    {
      ParCount++;
      ParmLabel += "Age_inflection_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "Age_95%width_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
    }
    else if (seltype(f, 1) == 11)
    {
      ParCount++;
      ParmLabel += "minage@sel=1_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      ParCount++;
      ParmLabel += "maxage@sel=1_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
    }
    else
    {
      
      k = 0;
      if (seltype(f, 1) == 41) k = 2;  // reduce count for the scaling parameters
      for (j = 1; j <= N_selparmvec(f) - k; j++)
      {
        ParCount++;
        ParmLabel += "AgeSel_P" + NumLbl(j) + "_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
      }
    }
  
    //  age-specific retention function
    if (seltype(f, 2) >= 1)
    {
      Do_Retain(f1) = 2;
      if (WTage_rd > 0)
      {
        warnstream << "Age-based retention will use the same empirical wtatage for discarded and retained fish for fleet: " << f;
        write_message (NOTE, 0);
      }
      if (seltype(f1, 2) > 0)
      {
        warnstream << "cannot have both age and size retention functions " << f << "  but retention parms not setup ";
        write_message (FATAL, 0); // EXIT!
      }
      if (seltype(f, 2) == 3)
      {
        RetainParm(f1) = 0;
      } //  no parameters needed
      else
      {
        RetainParm(f1) = N_selparmvec(f) + 1;
        //         N_selparmvec(f) +=N_ret_parm*seltype(f,2);          // N retention parms first [N_ret_parm] for retention; next [N_ret_parm] for discard mortality
        //         for (j=1;j<=N_ret_parm(seltype(f,2));j++)
        //         {
        //           ParCount++; N_selparmvec(f)++; ParmLabel+="Retain_age_P"+NumLbl(j)+"_"+fleetname(f1)+"("+NumLbl(f1)+")";
        //         }
        if (N_ret_parm(seltype(f, 2)) > 0)
        {
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_A_infl_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_A_width_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_A_asymptote_logit_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "Retain_A_maleoffset_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          if (N_ret_parm(seltype(f, 2)) == 7) //  doing dome
          {
            ParCount++;
            N_selparmvec(f)++;
            ParmLabel += "Retain_A_dome_infl_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
            ParCount++;
            N_selparmvec(f)++;
            ParmLabel += "Retain_A_dome_width_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
            ParCount++;
            N_selparmvec(f)++;
            ParmLabel += "Retain_A_dome_maleoffset_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          }
        }
  
        if (seltype(f, 2) == 2 || seltype(f, 2) == 4)
        {
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_A_infl_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_A_width_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_A_level_old_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
          ParCount++;
          N_selparmvec(f)++;
          ParmLabel += "DiscMort_A_male_offset_" + fleetname(f1) + "(" + NumLbl(f1) + ")";
        }
      }
    }
    else if (seltype(f, 2) < 0) //  mirror retention
    {
      Do_Retain(f1) = 2;
      RetainParm(f1) = 0;
    }
  
    if (seltype(f, 3) >= 1)
    {
      if (gender == 1)
      {
        warnstream << "Male selex cannot be used in one sex model; fleet: " << f;
        write_message (FATAL, 0); // EXIT!
      }
      Maleselparm(f) = N_selparmvec(f) + 1;
      if (seltype(f, 3) == 1 || seltype(f, 3) == 2)
      {
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + "MaleDogleg_" + fleetname(f1);
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + "MaleatZero_" + fleetname(f1);
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + "MaleatDogleg_" + fleetname(f1);
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + "MaleatMaxage_" + fleetname(f1);
      }
      else if (seltype(f, 3) >= 3 && seltype(f, 1) == 20)
      {
        if (seltype(f, 3) == 3) {
          anystring = "Male_";
        }
        else
        {
          anystring = "Fem_";
        }
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + anystring + "Peak_" + fleetname(f1);
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + anystring + "Ascend_" + fleetname(f1);
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + anystring + "Descend_" + fleetname(f1);
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + anystring + "Final_" + fleetname(f1);
        N_selparmvec(f)++;
        ParCount++;
        ParmLabel += "AgeSel_" + NumLbl(f1) + anystring + "Scale_" + fleetname(f1);
      }
      else
      {
        warnstream << "Illegal male selex option selected for fleet " << f;
        write_message (FATAL, 1); // EXIT!
      }
    }
    N_selparm += N_selparmvec(f);
  }
  
  //  create index to fleets with discard
  disc_fleet_list.initialize();
  N_retain_fleets = 0;
  for (f = 1; f <= Nfleet; f++)
  {
    if (Do_Retain(f) > 0)
    {
      N_retain_fleets++;
      disc_fleet_list(f) = N_retain_fleets; //  for compact storage of disc_age(t,f,g)
    }
  }
  
  //  SS_Label_Info_4.097 #Read parameters needed for estimating variance of composition data
  {
    echoinput << "#Now create parameters for D-M variance of composition data; CANNOT be time-varying" << endl;
    Comp_Err_Parm_Start = 0;
    if (Comp_Err_ParmCount > 0)
    {
      echoinput << Comp_Err_ParmCount << "  #_definitions are needed: " << endl;
      Comp_Err_Parm_Start = N_selparm;
      //  create a D-M parameter or tweedie parameter pair only for the first fleet that references that parm number
      for (f = 1; f <= Nfleet; f++)
      for (int parti = 0; parti <= 2; parti++)
      {
        if (DM_parmlist(parti, f) > 0)  //  create DM parameter labels for definitions first referenced for lencomp
        {
          N_selparm ++;
          ParCount ++;
          Comp_Err_parmloc(Comp_Err_L2(parti, f),1) = N_selparm;  //  first parameter used by this method
          Comp_Err_parmloc(Comp_Err_L2(parti, f),2) = ParCount;  //  use this index in write_report to display the correct parameter label
          switch (Comp_Err_L(parti, f))
          {
            case 1:
            {
              ParmLabel += "ln(DM_theta)_Len_P" + NumLbl(Comp_Err_L2(parti, f));
              break;
            }
            case 2:
            {
              ParmLabel += "ln(DM_beta)_Len_P" + NumLbl(Comp_Err_L2(parti, f));
              break;
            }
            case 3:
            {
              ParmLabel += "ln(tweedie_Phi)_Len_P" + NumLbl(Comp_Err_L2(parti, f));
              N_selparm ++;
              ParCount ++;
              ParmLabel += "ln(tweedie_Power)_Len_P" + NumLbl(Comp_Err_L2(parti, f));
              break;
            }
          }
        }
      }

      for (f = 1; f <= Nfleet; f++) 
      {
        if (DM_parmlist(0, f + Nfleet) > 0) //  create DM parameter labels for definitions first referenced for agecomp
        {
          N_selparm ++;
          ParCount ++;
          Comp_Err_parmloc(Comp_Err_A2(f),1) = N_selparm;  //  first parameter used by this method
          Comp_Err_parmloc(Comp_Err_A2(f),2) = ParCount;  //  use this index in write_report to display the correct parameter label
          switch (Comp_Err_A(f))
          {
            case 1:
            {
              ParmLabel += "ln(DM_theta)_Age_P" + NumLbl(Comp_Err_A2(f));
              break;
            }
            case 2:
            {
              ParmLabel += "ln(DM_beta)_Age_P" + NumLbl(Comp_Err_A2(f));
              break;
            }
            case 3:
            {
              ParmLabel += "ln(tweedie_Phi)_Age_P" + NumLbl(Comp_Err_A2(f));
              N_selparm ++;
              ParCount ++;
              ParmLabel += "ln(tweedie_Power)_Age_P" + NumLbl(Comp_Err_A2(f));
              break;
            }
          }
        }
      }

      for (int f = 1; f <= SzFreq_Nmeth; f++) 
      {
        if (DM_parmlist(0, f + 2 * Nfleet) > 0) //  create DM parameter labels for definitions first referenced for sizefreq.  note that sizefreq comps are by method, not fleet
        {
          N_selparm ++;
          ParCount ++;
          Comp_Err_parmloc(Comp_Err_Sz2(f),1) = N_selparm;  //  first parameter used by this method
          Comp_Err_parmloc(Comp_Err_Sz2(f),2) = ParCount;  //  use this index in write_report to display the correct parameter label
          switch (Comp_Err_Sz(f))
          {
            case 1:
            {
              ParmLabel += "ln(DM_theta)_Sz_P" + NumLbl(Comp_Err_Sz2(f));
              break;
            }
            case 2:
            {
              ParmLabel += "ln(DM_Beta)_Sz_P" + NumLbl(Comp_Err_Sz2(f));
              break;
            }
            case 3:
            {
              ParmLabel += "ln(tweedie_Phi)_Sz_P" + NumLbl(Comp_Err_Sz2(f));
              N_selparm ++;
              ParCount ++;
              ParmLabel += "ln(tweedie_Power)_Sz_P" + NumLbl(Comp_Err_Sz2(f));
              break;
            }
          }
        }
      }
   //  note that it would take a lot more code to append labels for parameters that are used by more than one fleet or type
    }
  }

  for (f = 1; f <= Nfleet; f++)
  {
    if (disc_N_fleet(f) > 0 && seltype(f, 2) == 0 && seltype(f + Nfleet, 2) == 0)
    {
      warnstream << "discard data exists for fleet " << f << "  but retention parms not setup " ;
      write_message (FATAL, 0); // EXIT!
    }
    else if (disc_N_fleet(f) == 0 && seltype(f, 2) > 0)
    {
      warnstream << "no discard amount data for fleet " << f << "  but retention parms have been defined ";
      write_message (WARN, 0);
    }
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.9.3 #Read selex parameters
  init_matrix selparm_1(1,N_selparm,1,14)
  ivector selparm_fleet(1,N_selparm) // holds the fleet ID for each selparm
                                  //  equivalent to the mgp_type() for MGparms
  matrix mirror_mask(1,Nfleet,1,nlength)
  matrix mirror_mask_a(1,Nfleet,0,nages)
 LOCAL_CALCS
   // clang-format on
   mirror_mask.initialize();
  mirror_mask_a.initialize();
  selparm_fleet.initialize();
  echoinput << " selex and composition base parameters " << endl;
  for (g = 1; g <= N_selparm; g++)
  {
    echoinput << g << " ## " << selparm_1(g) << " ## " << ParmLabel(ParCount - N_selparm + g) << endl;
  }
  
  //  now identify the fleet associated with each parameter
  echoinput << "identify the fleet associated with each parameter" << endl;
  j = 0;
  for (f = 1; f <= 2 * Nfleet; f++)
  {
    if (N_selparmvec(f) > 0)
    {
      for (g = 1; g <= N_selparmvec(f); g++)
      {
        j++;
        selparm_fleet(j) = f;
      }
    }
  }
  if (Comp_Err_ParmCount > 0)
  {
    echoinput << "comp_error parameter selection by partition (row) and fleet" << endl
              << "L_type: " << Comp_Err_L << endl
              << "L_parm: " << Comp_Err_L2 << endl
              << "A_type: " << Comp_Err_A << endl
              << "A_parm: " << Comp_Err_A2 << endl
              << "Sz_type: " << Comp_Err_Sz << endl
              << "Sz_parm: " << Comp_Err_Sz2 << endl;
              
    for (f = 1; f <= Nfleet; f++)
    for (int parti = 0; parti <= 2; parti++)
    {
      // if Dirichlet was indicated, set fleet for this parameter
      if (Comp_Err_L2(parti, f) > 0)
      {
        j = Comp_Err_parmloc(Comp_Err_L2(parti, f),1);
        selparm_fleet(j) = f;
      }
      if (Comp_Err_A2(f) > 0)
      {
        j = Comp_Err_parmloc(Comp_Err_A2(f),1);
        selparm_fleet(j) = f;
      }
    }
  }
  echoinput<<"selparm_fleet:"<<endl<<selparm_fleet<<endl;
  //  check on conversion of retention parameter
  echoinput << "check on conversion of retention parameter" << endl;
  int parmcount;
  int new_lower_bound;
  int new_upper_bound;
  parmcount = 0;
  for (f = 1; f <= Nfleet; f++)
  {
    if (RetainParm(f) > 0) //  could point to length or age retention
    {
      k = parmcount + RetainParm(f) + 2;
      if (selparm_1(k, 1) >= 0.0) // check to see if user has bounds relevant for 3.24 format
      {
        warnstream << "Converting asymptotic retention parameter to 1/(1+e(-x)) format for fleet: " << f << " parm: " << k << endl;
        warnstream << "++      because parm min was >=0.0" << endl;
        warnstream << "++      old min, max, init, prior: " << selparm_1(k)(1, 4);
        write_message (WARN, 1);
        new_lower_bound = -10.;
        new_upper_bound = 10.;
  
        // check initial value against lower and upper bounds first
        if (selparm_1(k, 3) <= selparm_1(k, 1))
        {
          selparm_1(k, 3) = new_lower_bound;
        }
        else if (selparm_1(k, 3) >= selparm_1(k, 2))
        {
          selparm_1(k, 3) = new_upper_bound;
        }
        else if (selparm_1(k, 3) > 0.)
        {
          if (selparm_1(k, 3) < 1.0)
          {
            selparm_1(k, 3) = -log(1.0 / selparm_1(k, 3) - 1.0);
          }
          else
          {
            selparm_1(k, 3) = 999.;
          } //  hardwire to force to be 1.0
        }
        else
        {
          selparm_1(k, 3) = -999.;
        } //  hardwire to force to 0.0
  
        // check prior value against lower and upper bounds first
        if (selparm_1(k, 4) <= selparm_1(k, 1))
        {
          selparm_1(k, 4) = new_lower_bound;
        }
        else if (selparm_1(k, 4) >= selparm_1(k, 2))
        {
          selparm_1(k, 4) = new_upper_bound;
        }
        else if (selparm_1(k, 4) > 0.)
        {
          if (selparm_1(k, 4) < 1.0)
          {
            selparm_1(k, 4) = -log(1.0 / selparm_1(k, 4) - 1.0);
          }
          else
          {
            selparm_1(k, 4) = 999.;
          } //  hardwire to force to be 1.0
        }
        else
        {
          selparm_1(k, 4) = -999.;
        } //  hardwire to force to 0.0
  
        selparm_1(k, 1) = new_lower_bound;
        selparm_1(k, 2) = new_upper_bound;
  
        warnstream << "new min, max, init, prior: " << selparm_1(k)(1, 4);
        write_message (WARN, 0);
      }
    }
    parmcount += N_selparmvec(f);
  }
  
  echoinput << "check on mirror bounds" << endl;
  parmcount = 0;
  for (f = 1; f <= Nfleet; f++)
  {
    if (seltype(f, 1) == 5) //  uses mirror
    {
      i = int(selparm_1(parmcount + 1, 3));
      j = int(selparm_1(parmcount + 2, 3));
      echoinput << "check on size selex mirror bounds for fleet: " << f << " " << endl;
      if (i <= -1) {
        i = 1;
      } // legit input, use to set mirror_mask
      else if (i == 0)
      {
        echoinput << " size selex mirror, length range min bin read is (" << i << ") reset to 1 for fleet: " << f << endl;
        selparm_1(parmcount + 1, 3) = 1;
        i = 1;
      }
      if (j <= -1) {
        j = nlength;
      } // legit input, use to set mirror_mask
      else if (j == 0)
      {
        warnstream << "size selex mirror, length range max bin read is (" << j << ") reset to nlength for fleet: " << f;
        write_message (ADJUST, 1);
        selparm_1(parmcount + 2, 3) = -1;
        j = nlength;
      }
      if (j > nlength)
      {
        warnstream << "size selex mirror length is > nlength for fleet: " << f << " reset to nlength";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 2, 3) = -1;
        j = nlength;
      }
      if (i > j)
      {
        warnstream << "size selex mirror length range min (" << i << ") greater than max (" << j << ") for fleet: " << f;
        write_message (FATAL, 0); // EXIT!
      }
      if (j > nlength)
      {
        warnstream << "size selex mirror length is > nlength for fleet: " << f << " reset to nlength";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 2, 3) = nlength;
        j = nlength;
      }
      if (i > j)
      {
        warnstream << "size selex mirror length range min (" << i << ") greater than max (" << j << ") for fleet: " << f;
        write_message (FATAL, 0); // EXIT!
      }
      mirror_mask(f) = 1.0e-10;
      mirror_mask(f)(i, j) = 1.;
      echoinput << "fleet: " << f << "  set mirror for bins: " << i << " through " << j << endl;
      echoinput << "set to no prior and not estimated, just in case " << endl;
      selparm_1(parmcount + 1, 6) = 0;
      selparm_1(parmcount + 2, 6) = 0;
      selparm_1(parmcount + 1, 7) = -99;
      selparm_1(parmcount + 2, 7) = -99;
      echoinput << "end check on mirror mask:  " << endl;
    }
    else if (seltype(f, 1) == 11) // setting min-max len range
    {
      echoinput << "check on size selex min-max for fleet: " << f << " " << selparm_1(parmcount + 1, 3) << " " << selparm_1(parmcount + 2, 3) << " nsize bins: " << nlength << endl;
      i = int(selparm_1(parmcount + 1, 3));
      j = int(selparm_1(parmcount + 2, 3));
      if ((selparm_1(parmcount + 1, 3) - i) > 0.)
      {
        warnstream << "fleet: " << f << " age selex range min read is: " << selparm_1(parmcount + 1, 3) << "; SS3 expected an integer and will convert ";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 1, 3) = i;
      }
      if ((selparm_1(parmcount + 2, 3) - j) > 0.)
      {
        warnstream << "fleet: " << f << " age selex range max read is: " << selparm_1(parmcount + 2, 3) << "; SS3 expected an integer and will convert ";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 2, 3) = j;
      }
      if (selparm_1(parmcount + 2, 3) > nlength)
      {
        warnstream << "fleet: " << f << " age selex range max read is: " << selparm_1(parmcount + 2, 3) << "; is >nsizes; SS3 will convert ";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 2, 3) = nlength;
      }
      echoinput << " accepted range: " << selparm_1(parmcount + 1, 3) << " " << selparm_1(parmcount + 2, 3) << endl;
      echoinput << "set to no prior and not estimated, just in case " << endl;
      selparm_1(parmcount + 1, 6) = 0;
      selparm_1(parmcount + 2, 6) = 0;
      selparm_1(parmcount + 1, 7) = -99;
      selparm_1(parmcount + 2, 7) = -99;
      mirror_mask(f) = 1.0e-10;
      mirror_mask(f)(selparm_1(parmcount + 1, 3), selparm_1(parmcount + 2, 3)) = 1.0;
      echoinput << "create mirror_mask: " << mirror_mask(f) << endl;
      echoinput << "end check on min-max ranges for size selex=11" << endl;
    }
  
    parmcount += N_selparmvec(f);
  }
  for (f = 1; f <= Nfleet; f++)
  {
    if (seltype(f + Nfleet, 1) == 11) //  setting min-max age range
    {
      echoinput << "check on age selex min-max for fleet: " << f << " " << selparm_1(parmcount + 1, 3) << " " << selparm_1(parmcount + 2, 3) << " nages: " << nages << endl;
      i = int(selparm_1(parmcount + 1, 3));
      j = int(selparm_1(parmcount + 2, 3));
      echoinput << "set to no prior and not estimated, just in case " << endl;
      selparm_1(parmcount + 1, 6) = 0;
      selparm_1(parmcount + 2, 6) = 0;
      selparm_1(parmcount + 1, 7) = -99;
      selparm_1(parmcount + 2, 7) = -99;
      if ((selparm_1(parmcount + 1, 3) - i) > 0.)
      {
        warnstream << "fleet: " << f << " age selex range min read is: " << selparm_1(parmcount + 1, 3) << "; SS3 expected an integer and will convert ";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 1, 3) = i;
      }
      if ((selparm_1(parmcount + 2, 3) - j) > 0.)
      {
        warnstream << "fleet: " << f << " age selex range max read is: " << selparm_1(parmcount + 2, 3) << "; SS3 expected an integer and will convert ";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 2, 3) = j;
      }
      if (selparm_1(parmcount + 2, 3) > nages)
      {
        warnstream << "fleet: " << f << " age selex range max read is: " << selparm_1(parmcount + 2, 3) << "; is >nages; SS3 will convert ";
        write_message (ADJUST, 0);
        selparm_1(parmcount + 2, 3) = nages;
      }
      echoinput << " accepted range: " << selparm_1(parmcount + 1, 3) << " " << selparm_1(parmcount + 2, 3) << endl;
      mirror_mask_a(f) = 0;
      mirror_mask_a(f)(selparm_1(parmcount + 1, 3), selparm_1(parmcount + 2, 3)) = 1.0;
      echoinput << "create mirror_mask: " << mirror_mask_a(f) << endl;
      echoinput << "end check on min-max ranges for age selex=11" << endl;
    }
    //  seltype 41 check on the min-max age range could go here, rather than in selex calcs
    parmcount += N_selparmvec(f + Nfleet);
  }
  // clang-format off
 END_CALCS

  int timevary_parm_cnt_sel;
  int timevary_parm_start_sel;
  ivector selparm_timevary(1,N_selparm)  //  holds index of timevary used by this base parameter
  imatrix timevary_sel(styr-3,YrMax+1,1,2*Nfleet)
  int TwoD_AR_do;
  int TwoD_AR_cnt
  int makefishsel_yr
  ivector TwoD_AR_use(1,2*Nfleet);

 LOCAL_CALCS
  // clang-format on
  timevary_parm_start_sel = 0;
  timevary_parm_cnt_sel = 0;
  timevary_sel.initialize();
  selparm_timevary.initialize();
  TwoD_AR_use.initialize();
  timevary_used = 0;
  for (j = 1; j <= N_selparm; j++)
  {
    echoinput << j << " sel " << selparm_1(j) << endl;
    k = selparm_fleet(j);
    if (selparm_1(j, 13) == 0 && selparm_1(j, 8) == 0 && selparm_1(j, 9) == 0)
    {
      //  no time-vary parameter effects
    }
    else if (k == 0)
    {
      warnstream << "Comp_err parameters cannot have timevary effects ";
      write_message (WARN, 0);
    }
    else //  set up a timevary parameter defintion
    {
      timevary_pass = column(timevary_sel, k); // year vector for this category of selparm
      timevary_used = 1;
      ivector timevary_setup(1, 14); //  temporary vector for timevary specs
      timevary_setup.initialize();
      if (timevary_parm_start_sel == 0) timevary_parm_start_sel = timevary_parm_cnt + 1;
      echoinput << endl
                << " timevary for sel parameter: " << j << endl;
      timevary_cnt++; //  count parameters with time-vary effect
      selparm_timevary(j) = timevary_cnt; //  base parameter will use this timevary specification
      timevary_setup(1) = 5; //  indicates a sel parm
      timevary_setup(2) = j; //  index of base parm within that type of parameter
      timevary_setup(13) = firstselparm + j; //  index of base parm relative to ParCount which is continuous across all types of parameters
      timevary_setup(3) = timevary_parm_cnt + 1; //  first TV parameter within total list of all timevary parms
      z = selparm_1(j, 13); // specified block or trend definition
  
      k = int(abs(selparm_1(j, 8)) / 100); //  find the env link code
      timevary_setup(6) = k; //  link code for env
      if (selparm_1(j, 8) > 0) //  env variable used
      {
        timevary_setup(7) = int(abs(selparm_1(j, 8))) - k * 100;
        k = timevary_setup(7);
        //         for(y=styr-1;y<=YrMax;y++) env_data_pass(y)=env_data_RD(y,k);
        env_data_pass(1) = env_data_minyr(k);
        env_data_pass(2) = env_data_maxyr(k);
      }
        else if (abs(selparm_1(j, 8) > 0)) //  density-dependence
      {
        timevary_setup(7) = -int(abs(selparm_1(j, 8)) - k * 100);
        do_densitydependent = 1;
        k = 0;
        env_data_pass.initialize();
      }
      if (z > 0) //  doing blocks
      {
        if (z > N_Block_Designs)
        {
          warnstream << "selex block request exceeds N_block patterns";
          write_message (FATAL, 0); // EXIT!
        }
        create_timevary(selparm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), selparm_fleet(j), Block_Design(z), env_data_pass, N_parm_dev, finish_starter);
      }
      else
      {
        create_timevary(selparm_1(j), timevary_setup, timevary_pass, autogen_timevary(timevary_setup(1)), selparm_fleet(j), block_design_null, env_data_pass, N_parm_dev, finish_starter);
      }
      timevary_def.push_back(timevary_setup(1, 14));
      for (y = styr - 3; y <= YrMax + 1; y++) {
        timevary_sel(y, selparm_fleet(j)) = timevary_pass(y);
      } // year vector for this category
    }
  }
    if (do_densitydependent == 1 && Fcast_timevary_Selex == 1) {
      warnstream << "Fcast_timevary_Selex is 1 (do averages); user should change to 0 (timevary) because density dependence affects a selectivity parameter or growth "<<endl;
      write_message(WARN, 0);
    }

  
  timevary_setup.initialize();
  timevary_setup(3) = timevary_parm_cnt + 1; //  one past last one used
  timevary_def.push_back(timevary_setup(1, 14));
  
  N_selparm3 = N_selparm;
  if (timevary_parm_start_sel > 0)
  {
    if (timevary_used == 1) autogen_timevary(5) = 1; //  indicate that some parameter is time-varying
    timevary_parm_cnt_sel = timevary_parm_cnt; //  last timevary_selparm
    N_selparm3 = N_selparm + timevary_parm_cnt_sel - timevary_parm_start_sel + 1;
  }
  N_selparm2 = N_selparm3; //  for distinguishing the 2D_AR parms
  
  //  now add parameters for the 2D_AR1 approach
  //  Input in first parameter line several setup factors:  rho_y, rho_a, ymin, ymax, amin, amax, use_rho, sigma_amax, null9, null10, null11, null12, null13,null14
  //  then one to several parameter lines containing age-specific sigma for ages amin to sigma_amax
  //  note that parm_dev_minyr and parm_dev_maxyr need to map onto the matrix defined by  ymin, ymax, amin, amax,
  TwoD_AR_cnt = 0;
  echoinput << " now read 0/1 for 2D_AR" << endl;
  *(ad_comm::global_datafile) >> TwoD_AR_do;
  echoinput << TwoD_AR_do << "  #_ 0/1 to request experimental 2D_AR selectivity deviations " << endl;
  
  if (TwoD_AR_do > 0)
  {
      //  elements 1-11 are read from control.ss;  12 and 13 are calculated internally
      //  1-fleet, 2-ymin, 3-ymax, 4-amin, 5-amax, 6-sigma_amax, 7-use_rho, 8-age/len, 9-dev_phase
      //  10-before yr range, 11=after yr range, 12-N_parm_dev,  13-selparm_location
      //  rho is used only to calculate the cor matrix in prelim_calcs; it can never be estimated
      //  sigma_sel is generally best fixed to a value of 1.0, estimation should not be undertaken without thorough investigation
    ivector tempvec(1, 13);
    tempvec.initialize();
    TwoD_AR_def.push_back(tempvec); //  bypass that pesky zeroth row
    TwoD_AR_def_rd.push_back(tempvec); //  bypass that pesky zeroth row
    echoinput << "read specification for first 2D_AR1:  fleet, ymin, ymax, amin, amax, sigma_amax, use_rho, len1/age2, phase, before, after" << endl;
    ender = 0;
    do
    {
      ivector tempvec(1, 13);
      ivector tempvec2(1, 13);
      tempvec.initialize();
      tempvec2.initialize();
      *(ad_comm::global_datafile) >> tempvec(1, 11);
      tempvec2 = tempvec;
      echoinput << tempvec(1, 11) << endl;
      f = tempvec(1);
      if (f < 0)
      {
        ender = 1;
      }
      else
      {
        N_parm_dev++;
        TwoD_AR_cnt++;
        if (tempvec(8) == 1)
        {
          anystring = "LEN";
          fs = f;
          TwoD_AR_use(fs) = TwoD_AR_cnt;
        }
        else
        {
          anystring = "AGE";
          fs = f + Nfleet;
          TwoD_AR_use(fs) = TwoD_AR_cnt;
        }
  
        //         save_sigmaval=tempvec(6);  //  to restore into TwoD_AR_def_rd later
        if (tempvec(6) < tempvec(4)) tempvec(6) = tempvec(4);
        if (tempvec(6) > tempvec(5)) tempvec(6) = tempvec(5);
        int sigma_amax = tempvec(6);
        int use_rho = tempvec(7);
        int amin = tempvec(4);
  
        TwoD_AR_def_rd.push_back(tempvec2); //  saves the values as read for writing to control.ss_new
  
        tempvec(12) = N_parm_dev;
        //         apply two lines below later when the timevary_setup is created
        //         tempvec(12)=1;  //  used for dimensioning the dev vectors in SS_param   parm_dev_minyr(k)
        //         tempvec(13)=(tempvec(3)-tempvec(2)+1)*(tempvec(5)-amin+1);   //parm_dev_maxyr(k)
        tempvec(13) = N_selparm2 + 1;
        z = f;
        if (tempvec(8) == 2) z = f + Nfleet;
        for (y = tempvec(2); y <= tempvec(3) + 1; y++) {
          timevary_sel(y, z) = 1;
        }
        TwoD_AR_def.push_back(tempvec);
        echoinput << "now read a parameter line with the sigma for each age from: " << amin << " to sigma_amax: " << sigma_amax << endl;
        for (j = amin; j <= sigma_amax; j++)
        {
          dvector dtempvec(1, 7); //  Lo, Hi, init, prior, prior_sd, prior_type, phase;
          dtempvec.initialize();
          *(ad_comm::global_datafile) >> dtempvec(1, 7);
          timevary_parm_rd.push_back(dtempvec);
          echoinput << " sigmasel for " << anystring << " " << j << " " << dtempvec(3) << endl;
          if (timevary_parm_start_sel == 0) {
            timevary_parm_start_sel = timevary_parm_cnt + 1;
            timevary_parm_cnt_sel = timevary_parm_cnt;
          }
          ParCount++;
          timevary_parm_cnt++;
          timevary_parm_cnt_sel++;
          N_selparm2++;
          ParmLabel += "sigmasel_" + fleetname(f) + "(" + NumLbl(f) + ")_" + anystring + "(" + NumLbl(max(1, j)) + ")";
          if (dtempvec(7) > 0)
          {
            warnstream << "2DAR Sigmasel parameter is not normally estimable; adequate performance usually obtained by fixing to value of 1.0";
            write_message (WARN, 0);
          }
        }
        if (use_rho == 1)
        {
          warnstream << "2DAR rho is incompletely implemented; it should only be used experimentally and never estimated";
          write_message (WARN, 0);
          echoinput << "read one parameter line for rho_yr,  then one for rho_age (or length)" << endl;
          {
            dvector dtempvec(1, 7); //  Lo, Hi, init, prior, prior_sd, prior_type, phase;
            dtempvec.initialize();
            *(ad_comm::global_datafile) >> dtempvec(1, 7);
            dtempvec(7) = -1;  //  force no estimation
            timevary_parm_rd.push_back(dtempvec);
            echoinput << " rho year: " << dtempvec(3) << endl;
            ParCount++;
            timevary_parm_cnt++;
            timevary_parm_cnt_sel++;
            N_selparm2++;
            ParmLabel += "rho_yr_" + fleetname(f) + "(" + NumLbl(f) + ")_" + anystring;
          }
          {
            dvector dtempvec(1, 7); //  Lo, Hi, init, prior, prior_sd, prior_type, phase;
            dtempvec.initialize();
            *(ad_comm::global_datafile) >> dtempvec(1, 7);
            dtempvec(7) = -1;  //  force no estimation
            timevary_parm_rd.push_back(dtempvec);
            echoinput << " rho " << anystring << ": " << dtempvec(3) << endl;
            ParCount++;
            timevary_parm_cnt++;
            timevary_parm_cnt_sel++;
            N_selparm2++;
            ParmLabel += "rho_" + fleetname(f) + "(" + NumLbl(f) + ")" + anystring;
          }
        }
        echoinput << "ready to read next fleet's 2DAR specs, or terminate by reading line starting with negative fleet" << endl;
      }
    } while (ender == 0);
  }
  echoinput << "N_selparm: " << N_selparm << " with timevary: " << N_selparm3 << " with TV and 2D_AR: " << N_selparm2 << " timevary parm range for sel: " << timevary_parm_start_sel << " " << timevary_parm_cnt_sel << " " << timevary_parm_cnt << endl;
  
  if (timevary_parm_cnt > 0)
  {
    echoinput << "list all parms used for timevary implementation" << endl;
    for (y = 1; y <= timevary_parm_cnt; y++)
    {
      echoinput << y << " parm " << timevary_parm_rd[y](1, 7) << endl;
    }
  }
  // clang-format off
 END_CALCS

!!// SS_Label_Info_4.9.xx #Create arrays needed for timevary_parameters
  vector baseparm_min(1,timevary_parm_cnt)
  vector baseparm_max(1,timevary_parm_cnt)

!!//  SS_Label_Info_4.9.9 #Create arrays for the total set of selex parameters
  vector selparm_LO(1,N_selparm2)
  vector selparm_HI(1,N_selparm2)
  vector selparm_RD(1,N_selparm2)
  vector selparm_PR(1,N_selparm2)
  vector selparm_PRtype(1,N_selparm2)
  vector selparm_CV(1,N_selparm2)
  ivector selparm_PH(1,N_selparm2)
  ivector selparm_PH_soft(1,N_selparm2)

 LOCAL_CALCS
   // clang-format on
   //  SS_Label_Info_4.9.12 #Create vectors, e.g. selparm_PH(), that will be used to create actual array of estimted parameters
   for (f = 1; f <= N_selparm; f++)
  {
    selparm_LO(f) = selparm_1(f, 1);
    selparm_HI(f) = selparm_1(f, 2);
    selparm_RD(f) = selparm_1(f, 3);
    selparm_PR(f) = selparm_1(f, 4);
    selparm_PRtype(f) = selparm_1(f, 6);
    selparm_CV(f) = selparm_1(f, 5);
    selparm_PH(f) = selparm_1(f, 7);
  }
  j = N_selparm;
  if (timevary_parm_start_sel > 0)
  {
    for (f = timevary_parm_start_sel; f <= timevary_parm_cnt_sel; f++)
    {
      j++;
      selparm_LO(j) = timevary_parm_rd[f](1);
      selparm_HI(j) = timevary_parm_rd[f](2);
      selparm_RD(j) = timevary_parm_rd[f](3);
      selparm_PR(j) = timevary_parm_rd[f](4);
      selparm_PRtype(j) = timevary_parm_rd[f](6);
      selparm_CV(j) = timevary_parm_rd[f](5);
      selparm_PH(j) = timevary_parm_rd[f](7);
    }
  }
  
  //  SS_Label_Info_4.9.10 #Special bound checking for size selex parameters
  z = 0; // parameter counter within this section
  for (f = 1; f <= Nfleet; f++)
  {
    if (seltype(f, 1) == 8 || seltype(f, 1) == 22 || seltype(f, 1) == 23 || seltype(f, 1) == 24 || seltype(f, 1) == 2)
    {
      if (selparm_1(z + 1, 1) < len_bins_m(2))
      {
        warnstream << "Fleet:_" << f << "min bound on parameter for size at peak is " << selparm_1(z + 1, 1) << "; should be >= midsize bin 2 (" << len_bins_m(2) << ")";
        write_message (WARN, 0);
      }
      if (selparm_1(z + 1, 1) < len_bins_dat(1) && (seltype(f, 1) == 24 || seltype(f, 1) == 2))
      {
        warnstream << "Fleet:_" << f << "min bound on parameter for size at peak is " << selparm_1(z + 1, 1) << "; which is < min databin (" << len_bins_dat(1) << "), so illogical.";
        write_message (WARN, 0);
      }
      if (selparm_1(z + 1, 2) > len_bins_m(nlength - 1))
      {
        warnstream << "Fleet:_" << f << "max bound on parameter for size at peak is " << selparm_1(z + 1, 2) << "; should be <= midsize bin N-1 (" << len_bins_m(nlength - 1) << ")";
        write_message (WARN, 0);
      }
    }
    z += N_selparmvec(f);
  }
  // end special bound checking
  
  //  SS_Label_Info_4.9.11  #Create time/fleet array indicating when changes in selex occcur
  timevary_sel(styr - 3) = 1;
  timevary_sel(styr) = 1;
  timevary_sel(endyr + 1) = 1;
  
  for (y = styr + 1; y <= endyr; y++)
  {
    z = 0; // parameter counter within this section
    for (f = 1; f <= 2 * Nfleet; f++)
    {
      if (seltype(f, 1) == 5 || seltype(f, 1) == 15) // mirror
      {
        if (f <= Nfleet) {
          timevary_sel(y, f) = timevary_sel(y, seltype(f, 4));
        }
        else
        {
          timevary_sel(y, f) = timevary_sel(y, seltype(f, 4) + Nfleet);
        }
        z += seltype_Nparam(seltype(f, 1));
      }
      if (f <= Nfleet && seltype(f, 2) < 0) //  retention is being mirrored
      {
        k = -seltype(f, 2);
        if (timevary_sel(y, k) > 0) timevary_sel(y, f) = 1;
      }
      if (f <= Nfleet)
      {
        //  CHECK:  why is below needed for WTage_rd>0
        if (timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0 || WTage_rd > 0)
        {
          timevary_sel(y, f) = 1;
        }
      }
    } // end type
  
  } // end years
  echoinput << "Recalc_flag_for_length_selex_recalc_by_year" << endl;
  for (f = 1; f <= Nfleet; f++)
  {
    echoinput << f << " " << fleetname(f) << " " << column(timevary_sel, f) << endl;
  }
  echoinput << "Recalc_flag_for_age_selex_recalc_by_year" << endl;
  for (f = 1; f <= Nfleet; f++)
  {
    int f2 = f + Nfleet;
    echoinput << f << " " << fleetname(f) << " " << column(timevary_sel, f2) << endl;
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.10 #Read tag recapture parameter setup
// if Tags are used, the read parameters for initial tag loss, chronic tag loss, andd
// fleet-specific tag reporting.  Of these, only reporting rate will be allowed to be time-varying
  init_int TG_custom;  // 1=read; 0=create default parameters
!! echoinput<<TG_custom<<" TG_custom (need to read even if no tag data ); tag_data?: "<<Do_TG<<" N_Fleet: "<<Nfleet1<<endl;
!! k=TG_custom*Do_TG*(3*N_TG+2*Nfleet1);
!!
  init_matrix TG_parm1(1,k,1,14);  // read initial values
!! if(k>0) echoinput<<" Tag parameters as read "<<endl<<TG_parm1<<endl;
!! k=Do_TG*(3*N_TG+2*Nfleet1);
  matrix TG_parm2(1,k,1,14);
!!if(Do_TG>0) {k1=k;} else {k1=1;}
  vector TG_parm_LO(1,k1);
  vector TG_parm_HI(1,k1);
  ivector TG_parm_PH(1,k1);
  int firsttagparm;
 LOCAL_CALCS
  // clang-format on
  if (Do_TG > 0)
  {
    if (TG_custom == 1)
    {
      TG_parm2 = TG_parm1; // assign to the read values
    }
    else
    {
      TG_parm2.initialize();
      onenum = "    ";
      for (j = 1; j <= N_TG; j++)
      {
        TG_parm2(j, 1) = -10; // min
        TG_parm2(j, 2) = 10; // max
        TG_parm2(j, 3) = -7.; // init
        TG_parm2(j, 4) = -7.; // prior
        TG_parm2(j, 5) = 0.001; //  prior is quite diffuse
        TG_parm2(j, 6) = 1.; // default prior type is symmetric beta
        if (j == 1)
        {
          TG_parm2(j, 7) = -4;
        } // phase
        else
        {
          TG_parm2(j, 7) = -1000;
        } // phase
      }
  
      for (j = 1; j <= N_TG; j++)
      {
        TG_parm2(j + N_TG) = TG_parm2(1); // set chronic tag retention equal to initial tag_retention
      }
      for (j = 1; j <= N_TG; j++) // set overdispersion
      {
        TG_parm2(j + 2 * N_TG, 1) = 1; // min
        TG_parm2(j + 2 * N_TG, 2) = 10; // max
        TG_parm2(j + 2 * N_TG, 3) = 2.; // init
        TG_parm2(j + 2 * N_TG, 4) = 2.; // prior
        TG_parm2(j + 2 * N_TG, 5) = 0.001; //  prior is quite diffuse
        TG_parm2(j + 2 * N_TG, 6) = 1.; // default prior type is symmetric beta
        if (j == 1)
        {
          TG_parm2(j + 2 * N_TG, 7) = -4;
        } // phase
        else
        {
          TG_parm2(j + 2 * N_TG, 7) = -1000;
        } // phase
      }
      for (j = 1; j <= Nfleet1; j++)
      {
        TG_parm2(j + 3 * N_TG, 1) = -10; // min
        TG_parm2(j + 3 * N_TG, 2) = 10; // max
        TG_parm2(j + 3 * N_TG, 3) = 7.; // init
        TG_parm2(j + 3 * N_TG, 4) = 7.; // prior
        TG_parm2(j + 3 * N_TG, 5) = 0.001; //  prior is quite diffuse
        TG_parm2(j + 3 * N_TG, 6) = 1.; // default prior type is symmetric beta
        if (j == 1)
        {
          TG_parm2(j + 3 * N_TG, 7) = -4;
        } // phase
        else
        {
          TG_parm2(j + 3 * N_TG, 7) = -1000;
        } // phase
      }
      // set tag reporting decay to nil decay rate
      for (j = 1; j <= Nfleet1; j++)
      {
        k = j + 3 * N_TG + Nfleet1;
        TG_parm2(k, 1) = -4.;
        TG_parm2(k, 2) = 0.;
        TG_parm2(k, 3) = 0.;
        TG_parm2(k, 4) = 0.; // prior of zero
        TG_parm2(k, 5) = 2.; // sd dev of prior
        TG_parm2(k, 6) = 6.; // default prior type is squared dev
        if (j == 1)
        {
          TG_parm2(k, 7) = -4;
        } // phase
        else
        {
          TG_parm2(k, 7) = -1000;
        } // phase
      }
    }
  
    TG_parm_LO = column(TG_parm2, 1);
    TG_parm_HI = column(TG_parm2, 2);
    k = 3 * N_TG + 2 * Nfleet1;
    for (j = 1; j <= k; j++) TG_parm_PH(j) = TG_parm2(j, 7); // write it out due to no typecast available
  
    echoinput << "create tag labels " << endl;
    //  SS_Label_Info_4.10.1 #Create parameter count and parameter names for tag parameters
    onenum = "    ";
    firsttagparm = ParCount;
    for (j = 1; j <= N_TG; j++)
    {
      sprintf(onenum, "%d", j);
      ParCount++;
      ParmLabel += "TG_loss_init_" + onenum + CRLF(1);
    }
    for (j = 1; j <= N_TG; j++)
    {
      sprintf(onenum, "%d", j);
      ParCount++;
      ParmLabel += "TG_loss_chronic_" + onenum + CRLF(1);
    }
    for (j = 1; j <= N_TG; j++)
    {
      sprintf(onenum, "%d", j);
      ParCount++;
      ParmLabel += "TG_overdispersion_" + onenum + CRLF(1);
      if (TG_parm_LO(2 * N_TG + j) < 1.0)
      {
        warnstream << "Overdispersion par_min is <1.0 for TG= " << j << "; value = " << TG_parm_LO(2 * N_TG + j) << "; changed to 1.001 for run";
        write_message (ADJUST, 0);
        TG_parm_LO(2 * N_TG + j) = 1.001;
      }
      if (TG_parm2(2 * N_TG + j, 3) < 1.0)
      {
        warnstream << "Overdispersion parameter is <1.0 for TG= " << j << "; value = " << TG_parm2(2 * N_TG + j, 3) << "; changed to 1.001 for run";
        write_message (ADJUST, 0);
        TG_parm2(2 * N_TG + j, 3) = 1.001;
      }
    }
    for (j = 1; j <= Nfleet; j++)
    {
      if (fleet_type(j) <= 2)
      {
        sprintf(onenum, "%d", j);
        ParCount++;
        ParmLabel += "TG_report_fleet:_" + onenum + CRLF(1);
      }
    }
    for (j = 1; j <= Nfleet; j++)
    {
      if (fleet_type(j) <= 2)
      {
        sprintf(onenum, "%d", j);
        ParCount++;
        ParmLabel += "TG_rpt_decay_fleet:_" + onenum + CRLF(1);
      }
    }
  
    echoinput << " Processed/generated Tag parameters " << endl
              << TG_parm2 << endl;
  }
  else
  {
    TG_parm_LO.initialize();
    TG_parm_HI.initialize();
    TG_parm_PH.initialize();
  }
  // clang-format off
 END_CALCS

   ivector parm_dev_minyr(1,N_parm_dev);
   ivector parm_dev_maxyr(1,N_parm_dev);
   ivector parm_dev_PH(1,N_parm_dev);
   int Do_Var_adjust

   ivector parm_dev_type(1,N_parm_dev);  //  distinguish parameter dev vectors from 2DAR devs
   ivector parm_dev_use_rho(1,N_parm_dev);  //  uses rho parameter, or not
   ivector parm_dev_info(1,N_parm_dev);  //  pointer from list of devvectors to 2DAR list
   ivector TwoD_AR_ymin(1,TwoD_AR_cnt)
   ivector TwoD_AR_ymax(1,TwoD_AR_cnt)
   ivector TwoD_AR_amin(1,TwoD_AR_cnt)
   ivector TwoD_AR_amax(1,TwoD_AR_cnt)
   ivector TwoD_AR_before(1,TwoD_AR_cnt) //  what to do in years before the year range
   ivector TwoD_AR_after(1,TwoD_AR_cnt)  //  what to do in years after the year range
   ivector TwoD_AR_degfree(1,TwoD_AR_cnt)  //  N years with observations * nages in the 2D_AR range
   ivector TwoD_AR_cor_dim(1,TwoD_AR_cnt)

 LOCAL_CALCS
      // clang-format on
      parm_dev_use_rho.initialize();
  if (timevary_cnt > 0)
  {
    for (j = 1; j <= timevary_cnt; j++) //  loop all timevary to set up devs; note that 2D_AR1 is counted in N_parm_dev, but not in timevary_cnt
    {
      ivector timevary_setup(1, 14);
      timevary_setup(1, 14) = timevary_def[j](1, 14);
      if (timevary_setup(8) > 0)
      {
        k = timevary_setup(8); //  dev vector used
        parm_dev_minyr(k) = timevary_setup(10); //  used for dimensioning the dev vectors in SS_param
        parm_dev_maxyr(k) = timevary_setup(11);
        parm_dev_PH(k) = timevary_setup(12);
        echoinput << " dev vector #:  " << k << " setup: " << timevary_setup << " phase: " << parm_dev_PH(k) << endl;
        f = timevary_setup(13); //  index of base parameter
        int picker = timevary_setup(9);
        parm_dev_type(k) = 1; //  so P'=P+dev*se with objfun using  -log(1); so expects se of devs to be approx unit normal
                              //  parm_dev_type is used in SS_objfunc.tpl
        if (picker > 20)
        {
          picker -= 20;
          timevary_setup(14) = 1; //  flag to continue last dev through to YrMax
          timevary_def[j](14) = 1; //  save in array also
          echoinput << j << " setting flag to continue last dev " << Fcast_timevary_Selex << " " << firstselparm << " " << f << " " << firstselparm + N_selparm << " " << endl;
          if (Fcast_timevary_Selex == 1 && f >= firstselparm && f <= (firstselparm + N_selparm))
          {
            warnstream << "for selectivity parmdevs, must change Fcast_timevary_Selex to 0 when using continue last dev";
            write_message (WARN, 1);
          }
        }
        if (picker > 10)
        {
          parm_dev_type(k) = 3; // P'=P+dev; objfun using -log(se) to match 3.30.12 and earlier
          picker -= 10;
        }
        if (picker == 6) parm_dev_type(k) = 4; //  add penalty to keep rmse near 1. Needs to estimate stddev factor
        //  this works, but slow final convergence because getting stddev exactly to 1.0 causes high correlation among devs
        timevary_setup(9) = picker; //  set to its core function because parm_dev_type has been setup
        timevary_def[j](9) = picker; //  save in array also
  
        parm_dev_use_rho(k) = 0;
        // require rho to be used for some dev approaches
        if (picker == 4 || picker == 5 || picker == 6) parm_dev_use_rho(k) = 1;
        for (y = parm_dev_minyr(k); y <= parm_dev_maxyr(k); y++)
        {
          sprintf(onenum, "%d", y);
          ParCount++;
          if (picker == 1)
          {
            ParmLabel += ParmLabel(f) + "_DEVmult_" + onenum + CRLF(1);
          }
          else if (picker == 2)
          {
            ParmLabel += ParmLabel(f) + "_DEVadd_" + onenum + CRLF(1);
          }
          else if (picker == 3)
          {
            ParmLabel += ParmLabel(f) + "_DEVrwalk_" + onenum + CRLF(1);
          }
          else if (picker == 4)
          {
            ParmLabel += ParmLabel(f) + "_DEV_MR_rwalk_" + onenum + CRLF(1);
          }
          else if (picker == 5)
          {
            ParmLabel += ParmLabel(f) + "_DEV_MR_rwalk_bnd_" + onenum + CRLF(1);
          } //  for bounding result on base parm min-max
          else if (picker == 6)
          {
            ParmLabel += ParmLabel(f) + "_DEV_MR_rwalk_pen_" + onenum + CRLF(1);
          } //  like 3.24
          else
          {
            warnstream << "illegal parmdevtype for parm " << f;
            write_message (FATAL, 0); // EXIT!
          }
        }
      }
    }
  }
  
  //  now add dev vectors for the 2D_AR1
  TwoD_AR_degfree.initialize();
  for (f = 1; f <= TwoD_AR_cnt; f++)
  {
    ivector TwoD_AR_setup(1, 13);
    //  1-fleet, 2-ymin, 3-ymax, 4-amin, 5-amax, 6-sigma_amax, 7-use_rho, 8-age/len, 9-dev_phase
    //  10-mindimension, 11=maxdim, 12-N_parm_dev, 13-selparm_location
    //  note that elements 10 and 11 have different usages when used for time-varying parameters
    TwoD_AR_setup(1, 13) = TwoD_AR_def[f](1, 13);
    echoinput << f << " 2D_AR1 setup " << TwoD_AR_setup << endl;
    k = TwoD_AR_setup(12); //  dev vector used
    parm_dev_minyr(k) = 1; //  used for dimensioning the dev vectors in SS_param   parm_dev_minyr(k)
    parm_dev_maxyr(k) = (TwoD_AR_setup(3) - TwoD_AR_setup(2) + 1) * (TwoD_AR_setup(5) - TwoD_AR_setup(4) + 1); //parm_dev_maxyr(k)
    parm_dev_PH(k) = TwoD_AR_setup(9);
    parm_dev_type(k) = 2; //  distinguish 2D_AR devs from parameter devs
    parm_dev_use_rho(k) = 0; //  need to update when implemented
    parm_dev_info(k) = f; //  pointer from parmdev list to the 2D_AR list
    TwoD_AR_ymin(f) = TwoD_AR_setup(2);
    TwoD_AR_ymax(f) = TwoD_AR_setup(3);
    TwoD_AR_amin(f) = TwoD_AR_setup(4);
    TwoD_AR_amax(f) = TwoD_AR_setup(5);
    TwoD_AR_before(f) = TwoD_AR_setup(10);
    TwoD_AR_after(f) = TwoD_AR_setup(11);
    TwoD_AR_cor_dim(f) = (TwoD_AR_ymax(f) - TwoD_AR_ymin(f) + 1) * (TwoD_AR_amax(f) - TwoD_AR_amin(f) + 1);
    for (y = TwoD_AR_ymin(f); y <= TwoD_AR_ymax(f); y++)
    {
      TwoD_AR_degfree(f) += have_data_yr(y, timevary_setup(1));
      for (a = TwoD_AR_amin(f); a <= TwoD_AR_amax(f); a++)
      {
        sprintf(onenum, "%d", y);
        sprintf(anystring, "%d", a);
        ParCount++;
        if (TwoD_AR_setup(8) == 1)
        {
          ParmLabel += fleetname(TwoD_AR_setup(1)) + "_ARDEV_y" + onenum + "_Lbin" + anystring + CRLF(1);
        }
        else
        {
          ParmLabel += fleetname(TwoD_AR_setup(1)) + "_ARDEV_y" + onenum + "_A" + anystring + CRLF(1);
        }
      }
    }
    echoinput << " total years, and with data  " << TwoD_AR_ymax(f) - TwoD_AR_ymin(f) + 1 << " " << TwoD_AR_degfree(f) << "  times nages: ";
    TwoD_AR_degfree(f) *= (TwoD_AR_amax(f) - TwoD_AR_amin(f) + 1);
    echoinput << TwoD_AR_degfree(f) << endl;
  }
  
  echoinput << " read var_adjust list until -9999" << endl;
  ender = 0;
  do
  {
    dvector tempvec(1, 3);
    *(ad_comm::global_datafile) >> tempvec(1, 3);
    echoinput << tempvec << endl;
    if (tempvec(1) == -9999.) ender = 1;
    var_adjust_data.push_back(tempvec(1, 3));
  } while (ender == 0);
  Do_Var_adjust = var_adjust_data.size() - 1;
  echoinput << " number of variance adjustment records = " << Do_Var_adjust << endl;
  // clang-format off
 END_CALCS
  matrix var_adjust(1,7,1,Nfleet)
  // init_matrix var_adjust_list(1,Do_Var_adjust+1,1,3)

 LOCAL_CALCS
      // clang-format on
      var_adjust.initialize();
  for (j = 4; j <= 7; j++)
  {
    var_adjust(j) = 1.0; //  null value
  }
  if (Do_Var_adjust > 0)
  {
    for (j = 1; j <= Do_Var_adjust; j++)
    {
      var_adjust(var_adjust_data[j - 1](1), var_adjust_data[j - 1](2)) = var_adjust_data[j - 1](3);
    }
    echoinput << " Var_adjustments as read " << endl
              << var_adjust << endl;
  }
  else
  {
    var_adjust(1) = 0.;
    var_adjust(2) = 0.;
    var_adjust(3) = 0.;
    var_adjust(4) = 1.;
    var_adjust(5) = 1.;
    var_adjust(6) = 1.;
    var_adjust(7) = 1.;
  }
  // clang-format off
 END_CALCS

  init_int max_lambda_phase
  init_number sd_offset

 LOCAL_CALCS
      // clang-format on
      echoinput
      << max_lambda_phase << " max_lambda_phase " << endl;
  if (max_lambda_phase < 1) max_lambda_phase = 1;
  echoinput << sd_offset << " sd_offset (adds log(s)); needed if variance parameters are estimated " << endl;
  if (sd_offset == 0)
  {
    if (varparm_estimated(1) == 1)
    {
      warnstream << "growth variance is estimated parameter, so change sd_offset to 1";
      write_message (FATAL, 0); // EXIT!
    }
    if (varparm_estimated(2) == 1)
    {
      warnstream << "recruitment sigmaR is estimated parameter, so change sd_offset to 1";
      write_message (FATAL, 0); // EXIT!
    }
    if (varparm_estimated(3) == 1)
    {
      warnstream << "survey extraSD is estimated parameter, so change sd_offset to 1";
      write_message (FATAL, 0); // EXIT!
    }
  }
  if (depletion_fleet > 0 && depletion_type < 2 && max_lambda_phase < 2)
  {
    max_lambda_phase = 2;
    warnstream << "Increase max_lambda_phase to 2 because depletion fleet is being used";
    write_message (ADJUST, 0);
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.11.1 #Define type_phase arrays for lambdas
  matrix surv_lambda(1,Nfleet,1,max_lambda_phase)
  matrix disc_lambda(1,Nfleet,1,max_lambda_phase)
  matrix mnwt_lambda(1,Nfleet,1,max_lambda_phase)
  matrix length_lambda(1,Nfleet,1,max_lambda_phase)
  matrix age_lambda(1,Nfleet,1,max_lambda_phase)
  matrix sizeage_lambda(1,Nfleet,1,max_lambda_phase)
  matrix init_equ_lambda(1,Nfleet,1,max_lambda_phase)
  matrix catch_lambda(1,Nfleet,1,max_lambda_phase)
  vector recrdev_lambda(1,max_lambda_phase)
  vector regime_lambda(1,max_lambda_phase)
  vector parm_prior_lambda(1,max_lambda_phase)
  vector parm_dev_lambda(1,max_lambda_phase)
  vector CrashPen_lambda(1,max_lambda_phase)
  vector Morphcomp_lambda(1,max_lambda_phase)
  matrix SzFreq_lambda(1,SzFreq_N_Like,1,max_lambda_phase)
  matrix TG_lambda1(1,N_TG2,1,max_lambda_phase)
  matrix TG_lambda2(1,N_TG2,1,max_lambda_phase)
  vector F_ballpark_lambda(1,max_lambda_phase)

!!//  SS_Label_Info_4.11.2 #Read and process any lambda adjustments
  int N_lambda_changes
  int N_changed_lambdas
 LOCAL_CALCS
  // clang-format on
  echoinput << endl << "LAMBDA" << endl
  << " each line has 5 values: like_code, fleet, beginning_phase, value, code_for_sizefreq "<< endl
  << " terminate reading with like_code = -9999" << endl
  << " like_code options are:  1=surv; 2=disc; 3=mnwt; 4=length; 5=age; 6=SizeFreq; 7=sizeage; 8=catch; 9=init_equ_catch; " << endl
  << " 10=recrdev; 11=parm_prior; 12=parm_dev; 13=CrashPen; 14=Morphcomp; 15=Tag-comp; 16=Tag-negbin; 17=F_ballpark; 18=initEQregime." << endl
  << " 2nd value (fleet) only used for like_codes 1 - 9, which are fleet-specific, except" << endl
  << "   2nd value is used for Tag-Group, instead of fleet, for like_codes 15 & 16." << endl
  << " 5th value is used only for like_code=6 and specifies the SizeFreq method used, which is in addition to fleet designation." << endl;

  ender = 0;  //  begin reading lambda changes
  do
  {
    dvector tempvec(1, 5);
    *(ad_comm::global_datafile) >> tempvec(1, 5);
    if (tempvec(1) == -9999.) ender = 1;
    lambda_change_data.push_back(tempvec(1, 5));
  } while (ender == 0);
  N_lambda_changes = lambda_change_data.size() - 1;
  // clang-format off
 END_CALCS

  matrix Lambda_changes(1,N_lambda_changes,1,5)
 LOCAL_CALCS
  // clang-format on
  for (f = 1; f <= N_lambda_changes; f++) Lambda_changes(f) = lambda_change_data[f - 1];
  if (N_lambda_changes > 0) echoinput << N_lambda_changes << " lambda changes: " << endl
                                      << Lambda_changes << endl;
  surv_lambda = 1.; // 1
  disc_lambda = 1.; // 2
  mnwt_lambda = 1.; // 3
  length_lambda = 1.; // 4
  age_lambda = 1.; // 5
  SzFreq_lambda = 1.; // 6
  sizeage_lambda = 1.; // 7
  catch_lambda = 1.; // 8
  init_equ_lambda = 1.; // 9
  recrdev_lambda = 1.; // 10
  parm_prior_lambda = 1.; // 11
  parm_dev_lambda = 1.; // 12
  CrashPen_lambda = 1.; // 13
  Morphcomp_lambda = 1.; // 14
  TG_lambda1 = 1.; // 15
  TG_lambda2 = 1.; //16
  F_ballpark_lambda = 1.; // 17
  regime_lambda = 1.; //  18
  
  if (depletion_fleet > 0 && depletion_type < 2)
  {
    for (f = 1; f <= Nfleet; f++)
    {
      surv_lambda(f, 1) = 0.0;
      init_equ_lambda(f, 1) = 0.0;
      disc_lambda(f, 1) = 0.0;
      mnwt_lambda(f, 1) = 0.0;
      length_lambda(f, 1) = 0.0;
      age_lambda(f, 1) = 0.0;
      sizeage_lambda(f, 1) = 0.0;
      //        catch_lambda(f,1)=0.0;  //  keep this positive to prevent crashes from bad fit to catch
    }
    if (SzFreq_Nmeth > 0)
    {
      for (z = 1; z <= SzFreq_N_Like; z++)
      {
        SzFreq_lambda(z, 1) = 0.0;
      }
    }
    if (N_TG2 > 0)
    {
      for (z = 1; z <= N_TG2; z++)
      {
        TG_lambda1(z, 1) = 0.0;
        TG_lambda2(z, 1) = 0.0;
      }
    }
    recrdev_lambda(1) = 0.0;
    Morphcomp_lambda(1) = 0.0;
    F_ballpark_lambda(1) = 0.0;
  
    surv_lambda(depletion_fleet, 1) = 1.0;
  }
  
  N_changed_lambdas = 0;
  for (j = 1; j <= N_lambda_changes; j++)
  {
    k = Lambda_changes(j, 1); // like component
    f = Lambda_changes(j, 2); // fleet
    s = Lambda_changes(j, 3); // phase
    if (k <= 9)   //  only check those codes that are fleet-specific
    {
      if (f > Nfleet)
      {
        k = 0;
        warnstream << "Illegal fleet/survey for lambda change at row: " << j << " fleet: " << f << " > Nfleet";
        write_message (ADJUST, 0);
      }
    }
    else if (k == 15 || k == 16) // tag data
    {
      if (f > N_TG2)
      {
        k = 0;
        warnstream << "Illegal tag group for lambda change at row: " << j << " Tag: " << f << " > N_taggroups";
        write_message (ADJUST, 0);
      }
    }
    else if (k > 18)
    {
      k = 0;
      warnstream << "Illegal lambda_type for lambda change at row: " << j << " Method: " << k << " > 17";
      write_message (ADJUST, 0);
    }
    if (s > max_lambda_phase)
    {
      k = 0;
      warnstream << "Illegal request for lambda change at row: " << j << " phase: " << s << " > max_lambda_phase: " << max_lambda_phase;
      write_message (ADJUST, 0);
    }
    //      if(s>Turn_off_phase) s=max(1,Turn_off_phase);
    temp = Lambda_changes(j, 4); // value
    if (temp != 0.0 && temp != 1.0) N_changed_lambdas++;
    z = Lambda_changes(j, 5); // special for sizefreq
    switch (k)
    {
      case 0: // do nothing
      {
        break;
      }
      case 1: // survey
      {
        surv_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 2: // discard
      {
        disc_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 3: // meanbodywt
      {
        mnwt_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 4: // lengthcomp
      {
        length_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 5: // agecomp
      {
        age_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 6: // sizefreq comp
      {
        z = Lambda_changes(j, 5); //  sizefreq method
        if (z > SzFreq_Nmeth)
        {
          warnstream << "reading sizefreq lambda change for method > Nmeth " << Lambda_changes(j, 5);
          write_message (FATAL, 0); // EXIT!
        }
        SzFreq_lambda(SzFreq_LikeComponent(f, z))(s, max_lambda_phase) = temp;
        break;
      }
      case 7: // size-at-age
      {
        sizeage_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 8: // catch
      {
        catch_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 9: // init_equ_catch
      {
        init_equ_lambda(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 10: // recr_dev
      {
        recrdev_lambda(s, max_lambda_phase) = temp;
        break;
      }
      case 11: // parm_prior
      {
        parm_prior_lambda(s, max_lambda_phase) = temp;
        break;
      }
      case 12: // parm_dev
      {
        parm_dev_lambda(s, max_lambda_phase) = temp;
        break;
      }
      case 13: // crash_penalty
      {
        CrashPen_lambda(s, max_lambda_phase) = temp;
        break;
      }
      case 14: // morphcomp
      {
        Morphcomp_lambda(s, max_lambda_phase) = temp;
        break;
      }
      case 15: // Tag - multinomial by fleet  where f is now tag group
      {
        TG_lambda1(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 16: // Tag - total by time where f is now tag group
      {
        TG_lambda2(f)(s, max_lambda_phase) = temp;
        break;
      }
      case 17: // F ballpark
      {
        F_ballpark_lambda(s, max_lambda_phase) = temp;
        break;
      }
      case 18: // regime lambda - only for initial equilibrium
      {
        regime_lambda(s, max_lambda_phase) = temp;
        break;
      }
    }
  }
  for (f = 1; f <= Nfleet; f++)
  {
    if (Svy_N_fleet(f) == 0) surv_lambda(f) = 0.;
    if (disc_N_fleet(f) == 0) disc_lambda(f) = 0.;
    if (Nobs_l(f) == 0) length_lambda(f) = 0.;
    if (Nobs_a(f) == 0) age_lambda(f) = 0.;
    if (Nobs_ms(f) == 0) sizeage_lambda(f) = 0.;
  }
  if (nobs_mnwt == 0) mnwt_lambda = 0.; //  more complicated to turn off for each fleet
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.12 #Read setup for more derived quantities to include in the STD report
  init_int Do_More_Std   // option (currently 0, 1, or 2)
  int More_Std_N_Inputs; // count of inputs (depends on option above)
 LOCAL_CALCS
  // clang-format on
  More_Std_N_Inputs = 0;
  if (Do_More_Std == 1) {
    More_Std_N_Inputs = 9;
  }
  if (Do_More_Std == 2) {
    More_Std_N_Inputs = 13;
  }
  // clang-format off
 END_CALCS
  ivector More_Std_Input(1,13); // read dimensions
  init_ivector temp_std_input(1,More_Std_N_Inputs)
 LOCAL_CALCS
      // clang-format on
      echoinput
      << Do_More_Std << " # extra stdev reporting: 0 = skip, 1 = read specs for reporting stdev for selectivity, size, and numbers, 2 = add option for M, dyn. Bzero & Smrybio " << endl;
  More_Std_Input.initialize();
  if (Do_More_Std > 0)
  {
    echoinput << "inpt_as_read: " << temp_std_input << endl;
    More_Std_Input(1, More_Std_N_Inputs) = temp_std_input(1, More_Std_N_Inputs);
    echoinput << More_Std_Input(1, 4) << " # Selectivity: (1) 0 to skip or fleet, (2) 1=len/2=age/3=combined, (3) year, (4) N selex bins; NOTE: combined reports in age bins" << endl;
    echoinput << More_Std_Input(5, 6) << " # Growth: (1) 0 to skip or growth pattern, (2) growth ages; NOTE: does each sex" << endl;
    echoinput << More_Std_Input(7, 9) << " # Numbers-at-age: (1) 0 to skip or area(-1 for all), (2) year, (3) N ages;  NOTE: sums across morphs" << endl;
  }
  if (Do_More_Std >= 2)
  {
    echoinput << More_Std_Input(10, 11) << " # Mortality: (1) 0 to skip or growth pattern, (2) N ages for mortality; NOTE: does each sex" << endl;
    echoinput << More_Std_Input(12) << " # Dyn_Bzero: 0 to skip, 1 to do, 2 w/ recr" << endl;
    echoinput << More_Std_Input(13) << " # SmryBio: 0 to skip, 1 to do" << endl;
  }
  // clang-format off
 END_CALCS

  int Do_Selex_Std;
  int Selex_Std_AL;
  int Selex_Std_Year;
  int Selex_Std_Cnt;
  int Do_Growth_Std;
  int Growth_Std_Cnt;
  int Do_NatAge_Std;
  int NatAge_Std_Year;
  int NatAge_Std_Cnt;
  int Do_NatM_Std;
  int NatM_Std_Cnt;
  int Do_Dyn_Bzero;
  int Do_se_smrybio;
  int Do_se_LnSSB;
  int Extra_Std_N;   //  dimension for the sdreport vector Selex_Std which also contains the Growth_Std

 LOCAL_CALCS
  // clang-format on
  Extra_Std_N = 0;
  
  // don't read any extra std inputs
  if (Do_More_Std == 0)
  {
    Do_Selex_Std = 0;
    Selex_Std_AL = 1;
    Selex_Std_Year = endyr;
    Selex_Std_Cnt = 0;
    Do_Growth_Std = 0;
    Growth_Std_Cnt = 0;
    Do_NatAge_Std = 0;
    NatAge_Std_Cnt = 0;
    NatAge_Std_Year = endyr;
    Do_NatM_Std = 0;
    NatM_Std_Cnt = 0;
    Do_Dyn_Bzero = 0;
    Do_se_smrybio = 0;
    Do_se_LnSSB = 0;
  }
  
  // read standard extra std inputs (only option prior to 3.30.15)
  if (Do_More_Std > 0)
  {
    Do_Selex_Std = More_Std_Input(1);
    Selex_Std_AL = More_Std_Input(2);
    Selex_Std_Year = More_Std_Input(3);
    if (Selex_Std_Year < 0) Selex_Std_Year = endyr;
    Selex_Std_Cnt = More_Std_Input(4);
    Do_Growth_Std = More_Std_Input(5);
    Growth_Std_Cnt = More_Std_Input(6);
    Do_NatAge_Std = More_Std_Input(7);
    NatAge_Std_Year = More_Std_Input(8);
    if (NatAge_Std_Year < 0) NatAge_Std_Year = endyr + 1;
    NatAge_Std_Cnt = More_Std_Input(9);
    if (Do_Selex_Std <= 0) Selex_Std_Cnt = 0;
    if (Do_Growth_Std <= 0) Growth_Std_Cnt = 0;
    if (Do_NatAge_Std == 0) NatAge_Std_Cnt = 0;
    Do_NatM_Std = 0; // value replaced below if Do_More_Std==2
    NatM_Std_Cnt = 0; // value replaced below if Do_More_Std==2
  }
  
  // read additional extra std inputs for NatM (added in 3.30.15)
  if (Do_More_Std == 2)
  {
    Do_NatM_Std = More_Std_Input(10);
    NatM_Std_Cnt = More_Std_Input(11);
    if (Do_NatM_Std <= 0) {
      NatM_Std_Cnt = 0;
    }
    Do_Dyn_Bzero = More_Std_Input(12);
    Do_se_smrybio = More_Std_Input(13);
  }
  // clang-format off
 END_CALCS

  // get vector of length bins or ages for selex std (either input or autogenerate)
  init_ivector Selex_Std_Pick(1,Selex_Std_Cnt);
 LOCAL_CALCS
  // clang-format on
  if (Do_Selex_Std > 0)
  {
    echoinput << Selex_Std_Pick << " # vector with selex std bins (-1 in first bin to self-generate)" << endl;
    if (Selex_Std_Pick(1) < 0) //  then self-generate even bin selection
    {
      if (Selex_Std_AL == 1) // length-based selex
      {
        if (Selex_Std_Cnt == 1)
        {
          Selex_Std_Pick(1) = nlength / 2;
        }
        else if (Selex_Std_Cnt == 2)
        {
          Selex_Std_Pick(1) = nlength / 2;
          Selex_Std_Pick(2) = nlength;
        }
        else
        {
          j = nlength / (Selex_Std_Cnt - 1);
          Selex_Std_Pick(1) = j / 2;
          for (i = 2; i <= Selex_Std_Cnt - 1; i++) Selex_Std_Pick(i) = Selex_Std_Pick(i - 1) + j;
          Selex_Std_Pick(Selex_Std_Cnt) = nlength;
        }
        echoinput << "generate length selex std for fleet: " << Do_Selex_Std << " in year: " << Selex_Std_Year << " at bins: " << Selex_Std_Pick << endl;
      }
      else // age-based or age-length-combined selex
      {
        if (Selex_Std_Cnt == 1)
        {
          Selex_Std_Pick(1) = nages / 2;
        }
        else if (Selex_Std_Cnt == 2)
        {
          Selex_Std_Pick(1) = nages / 2;
          Selex_Std_Pick(2) = nages;
        }
        else
        {
          j = nages / (Selex_Std_Cnt - 1);
          Selex_Std_Pick(1) = j / 2;
          for (i = 2; i <= Selex_Std_Cnt - 1; i++) Selex_Std_Pick(i) = Selex_Std_Pick(i - 1) + j;
          Selex_Std_Pick(Selex_Std_Cnt) = nages;
        }
        echoinput << "generate age selex std for fleet: " << Do_Selex_Std << " in year: " << Selex_Std_Year << " at ages: " << Selex_Std_Pick << endl;
      }
    }
    // adjust values to keep in range
    for (i = 1; i <= Selex_Std_Cnt; i++)
    {
      if (Selex_Std_AL == 1) // length-based selex
      {
        if (Selex_Std_Pick(i) <= 0) Selex_Std_Pick(i) = 1;
        if (Selex_Std_Pick(i) > nlength)
        {
          warnstream << "Selex_std requested output past nlength, resets to nlength, may produce duplicates";
          write_message (ADJUST, 0);
          Selex_Std_Pick(i) = nlength;
        }
      }
      else // age-based or age-length-combined selex
      {
        if (Selex_Std_Pick(i) < 0) Selex_Std_Pick(i) = 0;
        if (Selex_Std_Pick(i) > nages)
        {
          warnstream << "Selex_std requested output past nages, resets to nages, may produce duplicates";
          write_message (ADJUST, 0);
          Selex_Std_Pick(i) = nages;
        }
      }
    }
    // increment count
    Extra_Std_N = gender * Selex_Std_Cnt;
  }
  // clang-format off
 END_CALCS

  // get vector of bins for growth std (either input or autogenerate)
  init_ivector Growth_Std_Pick(1,Growth_Std_Cnt);
 LOCAL_CALCS
  // clang-format on
  if (Do_Growth_Std > 0)
  {
    echoinput << Growth_Std_Pick << " # vector with growth std ages (-1 in first bin to self-generate)" << endl;
    // turn off growth extra stderr for growth if no estimated growth parameters
    if (MG_active(2) == 0)
    {
      warnstream << "Growth output stderr requested but no growth parameters are estimated, changing growth stddev reporting specifications to 0";
      write_message (ADJUST, 0);
      Do_Growth_Std = 0;
      //  		More_Std_Input(5)=0;
      //  		More_Std_Input(6)=0;
      Growth_Std_Cnt = 0;
    }
    else
    {
      // there are active growth parameters so proceed with processing stderr
      if (Growth_Std_Pick(1) < 0)
      {
        Growth_Std_Pick(1) = AFIX;
        Growth_Std_Pick(Growth_Std_Cnt) = nages;
        if (Growth_Std_Cnt > 2)
        {
          k = Growth_Std_Cnt / 2;
          for (i = 2; i <= k; i++) Growth_Std_Pick(i) = Growth_Std_Pick(i - 1) + 1;
          j = (nages - Growth_Std_Pick(k)) / (Growth_Std_Cnt - k);
          for (i = k + 1; i <= Growth_Std_Cnt - 1; i++) Growth_Std_Pick(i) = Growth_Std_Pick(i - 1) + j;
        }
      }
      for (i = 1; i <= Growth_Std_Cnt; i++)
      {
        if (Growth_Std_Pick(i) < 0) Growth_Std_Pick(i) = 0;
        if (Growth_Std_Pick(i) > nages) Growth_Std_Pick(i) = nages;
      }
    }
    Extra_Std_N += gender * Growth_Std_Cnt;
  }
  // clang-format off
 END_CALCS

  // get vector of bins for N-at-age std (either input or autogenerate)
  init_ivector NatAge_Std_Pick(1,NatAge_Std_Cnt);
 LOCAL_CALCS
  // clang-format on
  if (Do_NatAge_Std != 0)
  {
    echoinput << NatAge_Std_Pick << " # vector with NatAge std bins (-1 in first bin to self-generate)" << endl;
    if (NatAge_Std_Pick(1) < 0)
    {
      NatAge_Std_Pick(1) = 1;
      NatAge_Std_Pick(NatAge_Std_Cnt) = nages;
      if (NatAge_Std_Cnt > 2)
      {
        k = NatAge_Std_Cnt / 2;
        for (i = 2; i <= k; i++) NatAge_Std_Pick(i) = NatAge_Std_Pick(i - 1) + 1;
        j = (nages - NatAge_Std_Pick(k)) / (NatAge_Std_Cnt - k);
        for (i = k + 1; i <= NatAge_Std_Cnt - 1; i++) NatAge_Std_Pick(i) = NatAge_Std_Pick(i - 1) + j;
      }
    }
    for (i = 1; i <= NatAge_Std_Cnt; i++)
    {
      if (NatAge_Std_Pick(i) <= 0) NatAge_Std_Pick(i) = 0;
      if (NatAge_Std_Pick(i) > nages) NatAge_Std_Pick(i) = nages;
    }
    Extra_Std_N += gender * NatAge_Std_Cnt;
  }
  
  // clang-format off
 END_CALCS

  // get vector of bins for NatM std (either input or autogenerate)
  init_ivector NatM_Std_Pick(1,NatM_Std_Cnt);
 LOCAL_CALCS
  // clang-format on
  if (Do_NatM_Std > 0)
  {
    echoinput << NatM_Std_Pick << " # vector with NatM std ages (-1 in first bin to self-generate)" << endl;
    // autogenerate the ages
    if (NatM_Std_Pick(1) < 0)
    {
      // set first and last to reference ages
      NatM_Std_Pick(1) = AFIX;
      NatM_Std_Pick(NatM_Std_Cnt) = nages;
      // if there is more than 2, fill in the middle
      if (NatM_Std_Cnt > 2)
      {
        // first half of values increment by 1
        k = NatM_Std_Cnt / 2;
        for (i = 2; i <= k; i++) {
          NatM_Std_Pick(i) = NatM_Std_Pick(i - 1) + 1;
        }
        // remainder are evently distributed across range
        j = (nages - NatM_Std_Pick(k)) / (NatM_Std_Cnt - k);
        for (i = k + 1; i <= NatM_Std_Cnt - 1; i++) {
          NatM_Std_Pick(i) = NatM_Std_Pick(i - 1) + j;
        }
      }
    }
    // shift any negative values to 0 and any that are too large down to nages
    for (i = 1; i <= NatM_Std_Cnt; i++)
    {
      if (NatM_Std_Pick(i) < 0) NatM_Std_Pick(i) = 0;
      if (NatM_Std_Pick(i) > nages) NatM_Std_Pick(i) = nages;
    }
    // increment counter
    Extra_Std_N += gender * NatM_Std_Cnt;
  }
  
  if (Do_Dyn_Bzero > 0)
  {
    Do_Dyn_Bzero = Extra_Std_N + 1; //  start spot for Dynamic Bzero
    Extra_Std_N += YrMax - (styr - 2) + 1;
    if (More_Std_Input(12) == 2) Extra_Std_N += YrMax - (styr - 2) + 1; //  for recruitment
  }
  // add 3 values for ln(SSBio)
  // (years are automatically generated as startyr, mid-point, and endyr)
  Do_se_LnSSB = Extra_Std_N + 1;
  Extra_Std_N += 3;
  
  if (Do_se_smrybio > 0)
  {
    Do_se_smrybio = Extra_Std_N + 1; //  start spot
    Extra_Std_N += YrMax - (styr - 2) + 1;
  }
  // else  smrybio will be written anyway, but without se
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.13 #End of reading from control file
  init_int fim // end of file indicator

 LOCAL_CALCS
   // clang-format on
   if (fim == 999)
  {
    cout << "End of control file successful! " << fim << endl;
    echoinput << "End of control file successful! " << fim << endl;
  }
  else
  {
    cout << " Unsuccessful end of control file. Check echoinput for clues.  Last read is: " << fim << endl;
    exit(1);
  }
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_4.14 #Create count of active parameters and derived quantities
  int CoVar_Count;
  int active_count;    // count the active parameters
  int active_parms;    // count the active parameters
  int deriv_start;  //  start index for derived quantities
  int deriv_covar_start

 LOCAL_CALCS
      // clang-format on
      if (Do_Benchmark > 0)
  {
    N_STD_Mgmt_Quant = 22;
    if (Do_Benchmark == 3) N_STD_Mgmt_Quant += 3; //  for Blimit
  }
  else
  {
    N_STD_Mgmt_Quant = 4;
  }
  Fcast_catch_start = N_STD_Mgmt_Quant;
  if (max(Do_Retain) > 0) {
    j = 1;
  }
  else
  {
    j = 0;
  }
  if (Do_Forecast > 0) {
    N_STD_Mgmt_Quant += N_Fcast_Yrs * (1 + j) + N_Fcast_Yrs;
  }
  k = ParCount + 2 * N_STD_Yr + N_STD_Yr_Dep + N_STD_Yr_Ofish + N_STD_Yr_F + N_STD_Mgmt_Quant + gender * Selex_Std_Cnt + gender * Growth_Std_Cnt + gender * NatAge_Std_Cnt + gender * NatM_Std_Cnt;
  if (Do_More_Std >= 2)
  {
    k += Do_Dyn_Bzero * (YrMax - (styr - 2) - 1);
    if (More_Std_Input(12) == 2) k += (YrMax - (styr - 2) - 1); //  for recruits
    k += Do_se_smrybio * (YrMax - (styr - 2) - 1);
  }
  k += 3 + Svy_N_sdreport;
  echoinput << "N parameters: " << ParCount << endl
            << "Parameters plus derived quant: " << k << endl;
  // clang-format off
 END_CALCS
  ivector active_parm(1,k)  //  pointer from active list to the element of the full parameter list to get label later

//***********************************************
!!//  SS_Label_Info_4.14.1 #Adjust the phases to negative if beyond turn_off_phase and find resultant max_phase
  int max_phase;
  int Turn_off_phase2

 LOCAL_CALCS
      // clang-format on
      echoinput
      << "Adjust the phases " << endl;
  Turn_off_phase2 = Turn_off_phase;
  echoinput << " requested turn_off phase: " << Turn_off_phase << endl;
  if (depletion_fleet > 0 && depletion_type == 1)
  {
    Turn_off_phase2 = 1;
    echoinput << "depletion fleet and type are: " << depletion_fleet << " " << depletion_type << " so set turn-off to phase 1 " << endl;
  }
  max_phase = 1;
  active_count = 0;
  active_parm(1, ParCount) = 0;
  ParCount = 0;
  
  j = MGparm_PH.indexmax();
  
  for (k = 1; k <= j; k++)
  {
    ParCount++;
    if (MGparm_PH(k) == -9999) {
      MGparm_RD(k) = prof_var(prof_var_cnt);
      prof_var_cnt += 1;
    }
    if (depletion_fleet > 0 && depletion_type < 2 && MGparm_PH(k) > 0) MGparm_PH(k)++; //  add 1 to phase if using depletion fleet
    if (MGparm_PH(k) > Turn_off_phase2) MGparm_PH(k) = -1;
    if (MGparm_PH(k) > max_phase) max_phase = MGparm_PH(k);
    if (MGparm_PH(k) >= 0)
    {
      active_count++;
      active_parm(active_count) = ParCount;
    }
  }
  
  for (j = 1; j <= SRparm_PH.indexmax(); j++)
  {
    ParCount++;
    if (SRparm_PH(j) == -9999) {
      SRparm_1(j, 3) = prof_var(prof_var_cnt);
      SRparm_RD(j, 3) = SRparm_1(j, 3);
      prof_var_cnt += 1;
    }
    if (depletion_fleet > 0 && depletion_type < 2 && SRparm_PH(j) > 0) SRparm_PH(j)++; //  add 1 to phase if using depletion fleet
    if (depletion_fleet > 0 && depletion_type < 2 && j == 1) SRparm_PH(1) = 1; //  R0 active in phase 1, unless type==2
    if (SRparm_PH(j) > Turn_off_phase2) SRparm_PH(j) = -1;
    if (SRparm_PH(j) > max_phase) max_phase = SRparm_PH(j);
    if (SRparm_PH(j) >= 0)
    {
      active_count++;
      active_parm(active_count) = ParCount;
    }
  }
  
  if (recdev_cycle > 0)
  {
    for (y = 1; y <= recdev_cycle; y++)
    {
      ParCount++;
      recdev_cycle_LO(y) = recdev_cycle_parm_RD(y, 1);
      recdev_cycle_HI(y) = recdev_cycle_parm_RD(y, 2);
      recdev_cycle_PH(y) = recdev_cycle_parm_RD(y, 7);
      if (depletion_fleet > 0 && depletion_type < 2 && recdev_cycle_PH(y) > 0) recdev_cycle_PH(y)++; //  add 1 to phase if using depletion fleet
      if (recdev_cycle_PH(y) > Turn_off_phase2) recdev_cycle_PH(y) = -1;
      if (recdev_cycle_PH(y) > max_phase) max_phase = recdev_cycle_PH(y);
      if (recdev_cycle_PH(y) >= 0) {
        active_count++;
        active_parm(active_count) = ParCount;
      }
    }
  }
  
  if (depletion_fleet > 0 && depletion_type < 2 && recdev_early_PH_rd > 0) recdev_early_PH_rd++; //  add 1 to phase if using depletion fleet
  if (recdev_early_PH_rd > Turn_off_phase2)
  {
    recdev_early_PH = -1;
  }
  else
  {
    recdev_early_PH = recdev_early_PH_rd;
  }
  
  if (recdev_early_PH > max_phase) max_phase = recdev_early_PH;
  
  if (recdev_do_early > 0)
  {
    for (y = recdev_early_start; y <= recdev_early_end; y++)
    {
      ParCount++;
      if (recdev_early_PH >= 0) {
        active_count++;
        active_parm(active_count) = ParCount;
      }
    }
  }
  
  if (depletion_fleet > 0 && depletion_type < 2 && recdev_PH > 0) recdev_PH++; //  add 1 to phase if using depletion fleet
  if (recdev_PH > Turn_off_phase2) recdev_PH = -1;
  if (recdev_PH > max_phase) max_phase = recdev_PH;
  if (do_recdev > 0)
  {
    for (y = recdev_start; y <= recdev_end; y++)
    {
      ParCount++;
      if (recdev_PH >= 0) {
        active_count++;
        active_parm(active_count) = ParCount;
      }
    }
  }
  
  Fcast_recr_PH2 = max_phase + 1;
  Fcast_recr_PH = Fcast_recr_PH_rd;
  if (Do_Forecast > 0)
  {
    if (Turn_off_phase > 0)
    {
      if (Fcast_recr_PH_rd != 0) // read value for forecast_PH
      {
        Fcast_recr_PH2 = Fcast_recr_PH;
        if (depletion_fleet > 0 && depletion_type < 2 && Fcast_recr_PH2 > 0) Fcast_recr_PH2++;
        if (Fcast_recr_PH2 > Turn_off_phase2) Fcast_recr_PH2 = -1;
        if (Fcast_recr_PH2 > max_phase) max_phase = Fcast_recr_PH2;
      }
      if (depletion_fleet > 0 && depletion_type == 1)
      {
        max_phase = 1;
        Fcast_recr_PH2 = -1;
      }
    }
    else
    {
      Fcast_recr_PH2 = -1;
    }
  
    if (do_recdev != 0) {
      for (y = recdev_end + 1; y <= YrMax; y++)
      {
        ParCount++;
        if (Fcast_recr_PH2 > -1) {
          active_count++;
          active_parm(active_count) = ParCount;
        }
      }
    }
    if (Do_Impl_Error > 0) {
      for (y = endyr + 1; y <= YrMax; y++)
      {
        ParCount++;
        if (Fcast_recr_PH2 > -1)
        {
          active_count++;
          active_parm(active_count) = ParCount;
        }
      }
    }
  }
  else
  {
    Fcast_recr_PH2 = -1;
  }
  
  echoinput << "Fcast_dev_phase (read and adjusted): " << Fcast_recr_PH_rd << " " << Fcast_recr_PH2 << endl;
  
  for (s = 1; s <= nseas; s++)
    for (f = 1; f <= Nfleet; f++)
    {
      if (init_F_loc(s, f) > 0)
      {
        j = init_F_loc(s, f);
        ParCount++;
        if (init_F_PH(j) == -9999) {
          init_F_parm_1(j, 3) = prof_var(prof_var_cnt);
          init_F_RD(j) = init_F_parm_1(j, 3);
          prof_var_cnt++;
        }
        if (depletion_fleet > 0 && depletion_type < 2 && init_F_PH(j) > 0) init_F_PH(j)++;
        if (init_F_PH(j) > Turn_off_phase2) init_F_PH(j) = -1;
        if (init_F_PH(j) > max_phase) max_phase = init_F_PH(j);
        if (init_F_PH(j) >= 0)
        {
          active_count++;
          active_parm(active_count) = ParCount;
        }
      }
    }
  
  if (N_Fparm > 0)
  {
    Fparm_PH_dim.deallocate();
    Fparm_PH_dim.allocate(1, N_Fparm);
    for (g = 1; g <= N_Fparm; g++)
    {
      ParCount++;
      if (depletion_fleet > 0 && depletion_type < 2 && Fparm_PH[g] > 0) Fparm_PH[g]++; //  increase phase by 1
      if (Fparm_PH[g] > Turn_off_phase2) Fparm_PH[g] = -1;
      if (Fparm_PH[g] > max_phase) max_phase = Fparm_PH[g];
      Fparm_PH_dim(g) = Fparm_PH[g];  //  move values into ivector
      if (Fparm_PH[g] > 0)
      {
        active_count++;
        active_parm(active_count) = ParCount;
      }
    echoinput<<g<<" dim  "<<Fparm_PH_dim(g)<<endl;
    }
  }
  
  for (f = 1; f <= Q_Npar2; f++)
  {
    ParCount++;
    if (Q_parm_PH(f) == -9999) {
      Q_parm_1(f, 3) = prof_var(prof_var_cnt);
      Q_parm_RD(f, 3) = prof_var(prof_var_cnt);
      prof_var_cnt++;
    }
    if (depletion_fleet > 0 && depletion_type < 2 && Q_parm_PH(f) > 0) Q_parm_PH(f)++;
    if (Q_parm_PH(f) > Turn_off_phase2) Q_parm_PH(f) = -1;
    if (Q_parm_PH(f) > max_phase) max_phase = Q_parm_PH(f);
    if (Q_parm_PH(f) >= 0)
    {
      active_count++;
      active_parm(active_count) = ParCount;
    }
  }
  
  //  SS_Label_Info_4.14.2 #Auto-generate cubic spline setup while inside this parameter counting loop
  Ip = 0;
  int N_knots;
  for (f = 1; f <= 2 * Nfleet; f++) //  check for cubic spline setup
  {
    if (f <= Nfleet)
    {
      fs = f;
    }
    else
    {
      fs = f - Nfleet;
    }
    if (seltype(f, 1) == 27 || seltype(f, 1) == 42) //  reset the cubic spline knots for size or age comp
    {
      // TODO - may need adjustments below for selex pattern 42
  
      k = int(selparm_RD(Ip + 1)); // setup method
      N_knots = seltype(f, 4); //  number of knots
  
      if (k == 0 || k == 10)
      {
      } //  do nothing
      else if (k == 1 || k == 2 || k == 11 || k == 12) //  get new knots according to cumulative distribution of data
      {
        echoinput << "Adjust the ";
        if (f <= Nfleet)
        {
          echoinput << "size-based ";
        }
        else
        {
          echoinput << "age-based ";
        }
        echoinput << "cubic spline setup for fleet: " << fs << endl;
  
        j = 4; // counter for which knot is being set (first knot is 4th spline parameter line)
        z = 1; //  counter for  bins in cumulative distribution
        if (N_knots >= 3)
        {
          temp = 0.025;
          temp1 = 0.950 / float(N_knots - 1); //  increment
        }
        else
        {
          warnstream << "There must be at least 3 knots in spline ";
          write_message (FATAL, 0); // EXIT!
        }
        if (f <= Nfleet) // doing size Selex
        {
          // exit if no length data available on which to base the knots
          if (Nobs_l(fs) == 0)
          {
            warnstream << "No length data for fleet " << fs << ": can't autogenerate cubic spline knots ";
            write_message (FATAL, 0); // EXIT!
          }
          // calculate cumulative length distribution
          dvector templen(1, nlen_bin);
          templen.initialize();
          for (s = 1; s <= nseas; s++)
          {
            templen += obs_l_all(2, s, f);
          }
          templen /= double(nseas);
          while (temp <= 0.975001)
          {
            while (templen(z) < temp)
            {
              z++;
            }
            //  intermediate knots are calculated from data_length_bins
            if (z > 1)
            {
              selparm_RD(Ip + j) = len_bins_dat(z - 1) + (temp - templen(z - 1)) / (templen(z) - templen(z - 1)) * (len_bins_dat(z) - len_bins_dat(z - 1));
            }
            else
            {
              selparm_RD(Ip + j) = len_bins_dat(z);
            }
            j++;
            temp += temp1;
          }
          echoinput << "len_bins_dat: " << len_bins_dat << endl;
          echoinput << "Cum_comp: " << templen << endl;
          echoinput << "Knots: " << selparm_RD(Ip + 3 + 1, Ip + 3 + N_knots) << endl;
        }
        else //  age selex
        {
          // exit if no age data available on which to base the knots
          if (Nobs_a(fs) == 0)
          {
            warnstream << "no age data for fleet " << fs << ": can't autogenerate cubic spline knots ";
            write_message (FATAL, 0); // EXIT!
          }
          // calculate cumulative age distribution
          dvector tempage(1, n_abins);
          tempage.initialize();
          for (s = 1; s <= nseas; s++)
          {
            tempage += obs_a_all(2, s, fs);
          }
          tempage /= double(nseas);
          while (temp <= 0.975001)
          {
            while (tempage(z) < temp)
            {
              z++;
            }
            //  intermediate knots are calculated from age_bins
            if (z > 1)
            {
              selparm_RD(Ip + j) = age_bins(z - 1) + (temp - tempage(z - 1)) / (tempage(z) - tempage(z - 1)) * (age_bins(z) - age_bins(z - 1));
            }
            else
            {
              selparm_RD(Ip + j) = age_bins(z);
            }
            j++;
            temp += temp1;
          }
          echoinput << "age_bins: " << age_bins << endl;
          echoinput << "Cum_comp: " << tempage(1, n_abins) << endl;
          echoinput << "Knots: " << selparm_RD(Ip + 3 + 1, Ip + 3 + N_knots) << endl;
        }
        if (k == 2 || k == 12) //  create default bounds, priors, etc.
        {
          echoinput << "Do complete setup of lo, hi, prior, etc. for cubic spline" << endl;
          for (z = Ip + 4; z <= Ip + 3 + N_knots; z++)
          {
            // set bounds at outer limits of data bins
            if (f <= Nfleet)
            {
              selparm_LO(z) = len_bins_dat(1);
              selparm_HI(z) = len_bins_dat(nlen_bin);
            }
            else
            {
              selparm_LO(z) = age_bins(1);
              selparm_HI(z) = age_bins(n_abins);
            }
            // set prior at mid-point
            selparm_PR(z) = int((selparm_LO(z) + selparm_HI(z)) / 2.);
            // set prior type to 0 and SD to 1.0
            selparm_PRtype(z) = 0;
            selparm_CV(z) = 1.0;
            // set phase for knots to negative
            selparm_PH(z) = -99;
          }
  
          if (N_knots == 3)
          {
            p = 8;
          }
          else if (N_knots == 4)
          {
            p = 10;
          }
          else
          {
            p = 3 + N_knots + 1 + 0.5 * N_knots;
          }
          // loop over parameters for splines value at each knot
          for (z = N_knots + 1 + 3; z <= 3 + 2 * N_knots; z++)
          {
            a = Ip + z;
            // set initial value for each parameter
            if (z <= p)
            {
              selparm_RD(a) = -5. + float(z - (N_knots + 4)) / float(p - (N_knots + 4)) * 4.;
            }
            else
            {
              selparm_RD(a) = 0.0;
            }
            // set bounds and symmetric beta prior
            selparm_LO(a) = -9.;
            selparm_HI(a) = 7.;
            selparm_PR(a) = 0.;
            selparm_PRtype(a) = 1; //  symmetric beta
            selparm_CV(a) = 0.001;
            selparm_PH(a) = 2;
          }
          // fix one of the parameters at 0 (because rescaling removes a degree of freedom)
          selparm_PH(Ip + p) = -99;
          selparm_PRtype(Ip + p) = 0;
          selparm_CV(Ip + p) = 1.0;
          // set values for gradient parameters
          p = Ip + 1;
          selparm_LO(p) = 0.;
          selparm_HI(p) = 2.;
          selparm_PR(p) = 0.;
          selparm_PRtype(p) = 0;
          selparm_CV(p) = 1.0;
          selparm_PH(p) = -99;
          p++;
          selparm_LO(p) = -0.001;
          selparm_HI(p) = 1.;
          selparm_RD(p) = 0.1; // moderate positive gradient at bottom
          selparm_PR(p) = 0.;
          selparm_PRtype(p) = 1; // SYMMETRIC BETA
          selparm_CV(p) = 0.001;
          selparm_PH(p) = 3;
          p++;
          selparm_LO(p) = -1.;
          selparm_HI(p) = 0.001;
          if (N_knots >= 3)
          {
            selparm_RD(p) = -0.001; // small negative gradient at top
            selparm_PR(p) = 0.;
            selparm_PRtype(p) = 1;
            selparm_CV(p) = 0.001;
            selparm_PH(p) = 3;
          }
          else
          {
            selparm_RD(p) = 0.00;
            selparm_PR(p) = 0.;
            selparm_PRtype(p) = 0;
            selparm_CV(p) = 1.0;
            selparm_PH(p) = -99;
          }
  
          for (z = Ip + 1; z <= Ip + 3 + 2 * N_knots; z++)
          {
            selparm_1(z, 1) = selparm_LO(z);
            selparm_1(z, 2) = selparm_HI(z);
            selparm_1(z, 3) = selparm_RD(z);
            selparm_1(z, 4) = selparm_PR(z);
            selparm_1(z, 6) = selparm_PRtype(z);
            selparm_1(z, 5) = selparm_CV(z);
            selparm_1(z, 7) = selparm_PH(z);
          }
        }
      }
    }
    Ip += N_selparmvec(f);
  }
  selparm_PH_soft = selparm_PH;
  for (k = 1; k <= selparm_PH.indexmax(); k++)
  {
    ParCount++;
    if (selparm_PH(k) == -9999) {
      selparm_RD(k) = prof_var(prof_var_cnt);
      selparm_1(k) = prof_var(prof_var_cnt);
      prof_var_cnt++;
    }
    if (depletion_fleet > 0 && depletion_type < 2 && selparm_PH(k) > 0) selparm_PH(k)++;
    if (selparm_PH(k) > Turn_off_phase2) selparm_PH(k) = -1;
    if (selparm_PH(k) > max_phase) max_phase = selparm_PH(k);
    if (selparm_PH(k) >= 0)
    {
      active_count++;
      active_parm(active_count) = ParCount;
    }
  }
  
  if (Do_TG > 0)
  {
    for (k = 1; k <= 3 * N_TG + 2 * Nfleet1; k++)
    {
      ParCount++;
      if (depletion_fleet > 0 && depletion_type < 2 && TG_parm_PH(k) > 0) TG_parm_PH(k)++;
      if (TG_parm_PH(k) > Turn_off_phase2) TG_parm_PH(k) = -1;
      if (TG_parm_PH(k) > max_phase) max_phase = TG_parm_PH(k);
      if (TG_parm_PH(k) >= 0)
      {
        active_count++;
        active_parm(active_count) = ParCount;
      }
    }
  }
  
  if (timevary_cnt > 0)
  {
    for (j = 1; j <= timevary_cnt; j++) //  loop all timevary to set up devs; note that 2D_AR1 is counted in N_parm_dev, but not in timevary_cnt
    {
      ivector timevary_setup(1, 14);
      timevary_setup(1, 14) = timevary_def[j](1, 14);
      if (timevary_setup(8) > 0)
      {
        k = timevary_setup(8); //  dev vector used
        if (depletion_fleet > 0 && depletion_type < 2 && parm_dev_PH(k) > 0) parm_dev_PH(k)++; //  add 1 to phase if using depletion fleet
        if (parm_dev_PH(k) > Turn_off_phase2) parm_dev_PH(k) = -1;
        if (parm_dev_PH(k) > max_phase) max_phase = parm_dev_PH(k);
      }
    }
  }
  
  if (TwoD_AR_cnt > 0)
  {
    for (j = 1; j <= TwoD_AR_cnt; j++) //  loop all timevary to set up devs; note that 2D_AR1 is counted in N_parm_dev, but not in timevary_cnt
    {
      ivector TwoD_AR_setup(1, 13);
      TwoD_AR_setup(1, 13) = TwoD_AR_def[j](1, 13);
      if (TwoD_AR_setup(12) > 0)
      {
        k = TwoD_AR_setup(12); //  dev vector used
        if (depletion_fleet > 0 && depletion_type < 2 && parm_dev_PH(k) > 0) parm_dev_PH(k)++; //  add 1 to phase if using depletion fleet
        if (parm_dev_PH(k) > Turn_off_phase2) parm_dev_PH(k) = -1;
        if (parm_dev_PH(k) > max_phase) max_phase = parm_dev_PH(k);
      }
    }
  }
  
  if (N_parm_dev > 0)
  {
    for (k = 1; k <= N_parm_dev; k++)
    {
      for (y = parm_dev_minyr(k); y <= parm_dev_maxyr(k); y++)
      {
        ParCount++;
        if (parm_dev_PH(k) >= 0)
        {
          active_count++;
          active_parm(active_count) = ParCount;
        }
      }
    }
  }
  
  if (Do_Forecast > 0 && Turn_off_phase > 0)
  {
    if (Fcast_recr_PH == 0) // read value for forecast_PH.  This code is repeats earlier code in case other parameters have changed maxphase
    {
      if (depletion_fleet > 0 && depletion_type == 1)
      {
      }
      else
      {
        Fcast_recr_PH2 = max_phase + 1;
      }
    }
  }
  
  echoinput << "ParCount " << ParCount << "   Active parameters: " << active_count << endl
            << "Turn_off_phase " << Turn_off_phase << endl
            << " max_phase " << max_phase << endl;
  echoinput << active_parm.indexmax() << endl;
  
  if (Turn_off_phase <= 0)
  {
    func_eval(1) = 1;
  }
  else
  {
    func_conv(max_phase) = final_conv;
    func_eval(max_phase) = 10000;
    func_conv(max_phase + 1) = final_conv;
    func_eval(max_phase + 1) = 10000;
  }
  
  //  SS_Label_Info_4.14.3 #Add count of derived quantities and create labels for these quantities
  j = ParCount;
  active_parms = active_count;
  CoVar_Count = active_count;
  deriv_start = ParCount;
  deriv_covar_start = active_count;
  echoinput << "parm " << j << " covar " << CoVar_Count << endl;
  echoinput << "deriv_start " << deriv_start << " " << deriv_covar_start << endl;
  onenum = "    ";
  for (y = styr - 2; y <= YrMax; y++)
  {
    if (STD_Yr_Reverse(y) > 0)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      if (y == styr - 2)
      {
        ParmLabel += "SSB_Virgin";
      }
      else if (y == styr - 1)
      {
        ParmLabel += "SSB_Initial";
      }
      else
      {
        //      _itoa(y,onenum,10);
        sprintf(onenum, "%d", y);
        ParmLabel += "SSB_" + onenum + CRLF(1);
      }
    }
  }
  
  echoinput << "parm " << j << " covar " << CoVar_Count << endl;
  for (y = styr - 2; y <= YrMax; y++)
  {
    if (STD_Yr_Reverse(y) > 0)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      if (y == styr - 2)
      {
        ParmLabel += "Recr_Virgin";
      }
      else if (y == styr - 1)
      {
        ParmLabel += "Recr_Initial";
      }
      else
      {
        //      _itoa(y,onenum,10);
        sprintf(onenum, "%d", y);
        ParmLabel += "Recr_" + onenum + CRLF(1);
      }
    }
  }
  
  echoinput << "parm " << j << " covar " << CoVar_Count << endl;
  for (y = styr; y <= YrMax; y++)
  {
    if (STD_Yr_Reverse_Ofish(y) > 0)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      //      _itoa(y,onenum,10);
      sprintf(onenum, "%d", y);
      ParmLabel += "SPRratio_" + onenum + CRLF(1);
    }
  }
  
  //F_std
  echoinput << "parm " << j << " covar " << CoVar_Count << endl;
  for (y = styr; y <= YrMax; y++)
  {
    if (STD_Yr_Reverse_F(y) > 0)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      //      _itoa(y,onenum,10);
      sprintf(onenum, "%d", y);
      ParmLabel += "F_" + onenum + CRLF(1);
    }
  }
  
  echoinput << "parm " << j << " covar " << CoVar_Count << endl;
  for (y = styr; y <= YrMax; y++)
  {
    if (STD_Yr_Reverse_Dep(y) > 0)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      //      _itoa(y,onenum,10);
      sprintf(onenum, "%d", y);
      ParmLabel += "Bratio_" + onenum + CRLF(1);
    }
  }
  echoinput << "parm " << j << " covar " << CoVar_Count << endl;
  //  create labels for Mgmt_Quant
  if (Do_Benchmark > 0)
  {
    ParmLabel += "SSB_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Totbio_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "SmryBio_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Recr_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    if (Do_Benchmark == 1 || Do_Benchmark == 3)
    {
      ParmLabel += "SSB_Btgt" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "SPR_Btgt" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "annF_Btgt" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "Dead_Catch_Btgt" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
    }
    else if (Do_Benchmark == 2)
    {
      ParmLabel += "SSB_F01" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "SPR_F01" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "annF_F01" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "Dead_Catch_F01" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
    }
    ParmLabel += "SSB_SPR" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "annF_SPR" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Dead_Catch_SPR" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "SSB_MSY" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "SPR_MSY" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "annF_MSY" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Dead_Catch_MSY" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Ret_Catch_MSY" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "B_MSY/SSB_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
// add quantities needed when time-vary life history is used; but report here for all cases; elements 18-21 of mgmt_quant
    ParmLabel += "Recr_MSY_bmarkbio" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Depletion_denom" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "HCR_inflect" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "R0_for_SRR_bench" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "SSB_for_SRR_bench" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;

    if (Do_Benchmark == 3)
    {
      ParmLabel += "SSB_Blim" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "annF_Blim" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      ParmLabel += "Dead_Catch_Blim" + CRLF(1);
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
    }
  }
  else
  {
    ParmLabel += "Bzero_again" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Totbio_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "SmryBio_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Recr_unfished" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
  }
  
  echoinput << "parm " << j << " covar " << CoVar_Count << "  after benchmark " << endl;
  if (Do_Forecast > 0)
  {
    for (y = endyr + 1; y <= YrMax; y++)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      sprintf(onenum, "%d", y);
      ParmLabel += "ForeCatch_" + onenum + CRLF(1);
    }
    for (y = endyr + 1; y <= YrMax; y++)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      sprintf(onenum, "%d", y);
      ParmLabel += "OFLCatch_" + onenum + CRLF(1);
    }
    if (max(Do_Retain) > 0)
    {
      for (y = endyr + 1; y <= YrMax; y++)
      {
        CoVar_Count++;
        j++;
        active_parm(CoVar_Count) = j;
        sprintf(onenum, "%d", y);
        ParmLabel += "ForeCatchret_" + onenum + CRLF(1);
      }
    }
  }
  echoinput << "parm " << j << " covar " << CoVar_Count << "  after forecast " << endl;
  
  // do labels for Selex_Std
  if (Do_Selex_Std > 0)
  {
    echoinput << " do selex std labels " << Selex_Std_Cnt << " " << Selex_Std_AL << endl;
    for (g = 1; g <= gender; g++)
      for (i = 1; i <= Selex_Std_Cnt; i++)
      {
        CoVar_Count++;
        j++;
        active_parm(CoVar_Count) = j;
        if (Selex_Std_AL == 1)
        {
          if (Selex_Std_Pick(i) > nlength)
          {
            warnstream << "cannot select stdev for length bin greater than nlength " << Selex_Std_Pick(i) << " > " << nlength;
            write_message (FATAL, 0); // EXIT!
          }
          ParmLabel += "LenSelex_std_" + NumLbl(Do_Selex_Std) + "_" + GenderLbl(g) + "_L_" + NumLbl(len_bins(Selex_Std_Pick(i))) + CRLF(1);
        }
        else if (Selex_Std_AL == 2)
        {
          if (Selex_Std_Pick(i) > nages)
          {
            warnstream << "cannot select stdev for age bin greater than maxage " << Selex_Std_Pick(i) << " > " << nages;
            write_message (FATAL, 0); // EXIT!
          }
          ParmLabel += "AgeSelex_std_" + NumLbl(Do_Selex_Std) + "_" + GenderLbl(g) + "_A_" + NumLbl0(age_vector(Selex_Std_Pick(i)) + 1) + CRLF(1);
        }
        else if (Selex_Std_AL == 3)
        {
          if (Selex_Std_Pick(i) > nages)
          {
            warnstream << "cannot select stdev for age bin greater than maxage " << Selex_Std_Pick(i) << " > " << nages;
            write_message (FATAL, 0); // EXIT!
          }
          ParmLabel += "AgeLenSelex_std_" + NumLbl(Do_Selex_Std) + "_GP1_" + GenderLbl(g) + "_A_" + NumLbl0(age_vector(Selex_Std_Pick(i)) + 1) + CRLF(1);
        }
      }
  }
  if (Do_Growth_Std > 0)
  {
    echoinput << " do growth std labels " << Growth_Std_Cnt << endl;
    for (g = 1; g <= gender; g++)
      for (i = 1; i <= Growth_Std_Cnt; i++)
      {
        CoVar_Count++;
        j++;
        active_parm(CoVar_Count) = j;
        ParmLabel += "Grow_std_GP:_" + NumLbl(Do_Growth_Std) + "_" + GenderLbl(g) + "_A_" + NumLbl0(age_vector(Growth_Std_Pick(i)) + 1) + CRLF(1);
      }
  }
  
  if (Do_NatAge_Std != 0)
  {
    echoinput << " do natage std labels " << NatAge_Std_Cnt << endl;
    for (g = 1; g <= gender; g++)
      for (i = 1; i <= NatAge_Std_Cnt; i++)
      {
        CoVar_Count++;
        j++;
        active_parm(CoVar_Count) = j;
        if (Do_NatAge_Std > 0)
        {
          ParmLabel += "NatAge_std_" + NumLbl(Do_NatAge_Std) + "_" + GenderLbl(g) + "_A_" + NumLbl0(age_vector(NatAge_Std_Pick(i)) + 1) + CRLF(1);
        }
        else
        {
          ParmLabel += "NatAge_std_All_" + GenderLbl(g) + "_A_" + NumLbl0(age_vector(NatAge_Std_Pick(i)) + 1) + CRLF(1);
        }
      }
  }
  
  if (Do_NatM_Std > 0)
  {
    echoinput << " do NatM std labels " << NatM_Std_Cnt << endl;
    for (g = 1; g <= gender; g++)
      for (i = 1; i <= NatM_Std_Cnt; i++)
      {
        CoVar_Count++;
        j++;
        active_parm(CoVar_Count) = j;
        // cout<<"i: "<<i<<endl;
        // cout<<"NatM_Std_Pick(i): "<<NatM_Std_Pick(i)<<endl;
        // cout<<"age_vector(NatM_Std_Pick(i)): "<<age_vector(NatM_Std_Pick(i))<<endl;
        // cout<<"NumLbl0(age_vector(NatM_Std_Pick(i))+1): "<<NumLbl0(age_vector(NatM_Std_Pick(i))+1)<<endl;
        ParmLabel += "NatM_std_GP:_" + NumLbl(Do_NatM_Std) + "_" + GenderLbl(g) + "_A_" + NumLbl0(age_vector(NatM_Std_Pick(i)) + 1) + CRLF(1);
      }
  }
  
  if (Do_Dyn_Bzero > 0)
  {
    echoinput << " do Dyn Bzero std labels " << endl;
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Dyn_Bzero_Virg" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Dyn_Bzero_InitEq" + CRLF(1);
    for (y = styr; y <= YrMax; y++)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      sprintf(onenum, "%d", y);
      ParmLabel += "Dyn_Bzero_" + onenum + CRLF(1);
    }
  }
  else if (depletion_basis_rd == 5)
  {
    warnstream << "must select dyn_bzero in control file extra_std for it to be used as depletion denominator ";
    write_message (FATAL, 0); // EXIT!
  }
  if (More_Std_Input(12) == 2)
  {
    echoinput << " do Dyn Bzero Recruits std labels " << endl;
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Dyn_Recr_Virg" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "Dyn_Recr_InitEq" + CRLF(1);
    for (y = styr; y <= YrMax; y++)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      sprintf(onenum, "%d", y);
      ParmLabel += "Dyn_Recr_" + onenum + CRLF(1);
    }
  }
  
  //  output ln(SSB) std for selected years
  echoinput << " do ln(SSB) std labels for 3 years" << endl;
  CoVar_Count++;
  j++;
  active_parm(CoVar_Count) = j;
  sprintf(onenum, "%d", styr);
  ParmLabel += "ln(SSB)_" + onenum + CRLF(1);
  CoVar_Count++;
  j++;
  active_parm(CoVar_Count) = j;
  sprintf(onenum, "%d", int((endyr + styr) / 2));
  ParmLabel += "ln(SSB)_" + onenum + CRLF(1);
  CoVar_Count++;
  j++;
  active_parm(CoVar_Count) = j;
  sprintf(onenum, "%d", endyr);
  ParmLabel += "ln(SSB)_" + onenum + CRLF(1);
  
  if (Do_se_smrybio > 0)
  {
    echoinput << " do SmryBio std labels " << endl;
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "SmryBio_Virg" + CRLF(1);
    CoVar_Count++;
    j++;
    active_parm(CoVar_Count) = j;
    ParmLabel += "SmryBio_InitEq" + CRLF(1);
    for (y = styr; y <= YrMax; y++)
    {
      CoVar_Count++;
      j++;
      active_parm(CoVar_Count) = j;
      sprintf(onenum, "%d", y);
      ParmLabel += "SmryBio_" + onenum + CRLF(1);
    }
  }
  
  //  output Svy_sdreport value std for selected years
  echoinput << " do Svy_sdreport labels " << Svy_N_sdreport << endl;
  if (Svy_N_sdreport > 0)
  {
    k = 0;
    for (f = 1; f <= Nfleet; ++f)
    {
      if (Svy_sdreport(f) > 0)
      {
        for (i = 1; i <= Svy_N_fleet(f); i++)
        {
          CoVar_Count++;
          j++;
          active_parm(CoVar_Count) = j;
          sprintf(onenum, "%d", Svy_yr(f, i));
          ParmLabel += fleetname(f) + "_" + onenum + CRLF(1);
        }
      }
    }
  }
  
  // additional labels
  echoinput << "parm " << j << " covar " << CoVar_Count << "  after all derived quantities " << endl;
  sprintf(onenum, "%d", int(100 * depletion_level));
  switch (depletion_basis)
  {
    case 0:
    {
      depletion_basis_label += "no_depletion_basis";
      break;
    }
    case 1:
    {
      depletion_basis_label += " " + onenum + "%*Virgin_Biomass";
      break;
    }
    case 2:
    {
      depletion_basis_label += " " + onenum + "%*B_MSY";
      break;
    }
    case 3:
    {
      depletion_basis_label += " " + onenum + "%*StartYr_Biomass";
      break;
    }
    case 4:
    {
      depletion_basis_label += " " + onenum + "%*EndYr_Biomass";
      break;
    }
    case 5:
    {
      depletion_basis_label += " " + onenum + "%*Dyn_Bzero";
      break;
    }
    case 6:
    {
      depletion_basis_label += " " + onenum + "%*Bmark_Biomass";
      break;
    }
  }
  if (depletion_log == 1) depletion_basis_label += ";log";
  if (depletion_multi > 1)
  {
    sprintf(onenum, "%d", depletion_multi);
    depletion_basis_label += ";multi:" + onenum;
  }
  
  switch (SPR_reporting)
  {
    case 0: // skip SPR reporting
    {
      SPR_report_label += " raw_SPR";
      break;
    }
    case 5: // keep as raw %SPR value
    {
      SPR_report_label += " raw_SPR";
      break;
    }
    case 1: // compare to SPR
    {
      sprintf(onenum, "%d", int(100. * SPR_target));
      SPR_report_label += " (1-SPR)/(1-SPR_" + onenum + "%)";
      break;
    }
    case 2: // compare to SPR_MSY
    {
      SPR_report_label += " (1-SPR)/(1-SPR_MSY)";
      break;
    }
    case 3: // compare to SPR_Btarget
    {
      sprintf(onenum, "%d", int(100. * BTGT_frac));
      SPR_report_label += " (1-SPR)/(1-SPR_at_B" + onenum + "%)";
      break;
    }
    case 4:
    {
      SPR_report_label += " 1-SPR";
      break;
    }
  }
  
  switch (F_std_basis)
  {
    case 0: // raw
    {
      F_report_label = "_abs_F";
      break;
    }
    case 1:
    {
      sprintf(onenum, "%d", int(100. * SPR_target));
      F_report_label = "(F)/(F" + onenum + "%SPR)";
      break;
    }
    case 2:
    {
      F_report_label = "(F)/(Fmsy)";
      break;
    }
    case 3:
    {
      sprintf(onenum, "%d", int(100. * BTGT_frac));
      F_report_label = "(F)/(F_at_B" + onenum + "%)";
      break;
    }
  }
  
  switch (F_reporting)
  {
    case 0: // keep as raw value
    {
      F_report_label += ";_no_F_report";
      break;
    }
    case 1: // exploitation rate in biomass
    {
      F_report_label += ";_with_F=Exploit(bio)";
      break;
    }
    case 2: // exploitation rate in numbers
    {
      F_report_label += ";_with_F=Exploit(num)";
      break;
    }
    case 3: // sum of F mults
    {
      F_report_label += ";_with_F=sum(full_Fs)";
      break;
    }
    case 4: // F=Z-M for specified ages
    {
      F_report_label += ";_with_F=Z-M;_for_ages_";
      sprintf(onenum, "%d", int(F_reporting_ages(1)));
      F_report_label += onenum;
      sprintf(onenum, "%d", int(F_reporting_ages(2)));
      F_report_label += "_" + onenum;
      break;
    }
    case 5: // F=Z-M for specified ages (unweighted)
    {
      F_report_label += ";_with_F=Z-M;_for_ages_unweighted_";
      sprintf(onenum, "%d", int(F_reporting_ages(1)));
      F_report_label += onenum;
      sprintf(onenum, "%d", int(F_reporting_ages(2)));
      F_report_label += "_" + onenum;
      break;
    }
  }
  if (F_std_log == 1) F_report_label += ";log";
  if (F_std_multi > 1)
  {
    sprintf(onenum, "%d", F_std_multi);
    F_report_label += ";multi:" + onenum;
  }
  
  echoinput << "Active parameters plus derived quantities:  " << CoVar_Count << endl;
  // clang-format off
 END_CALCS

//  containers for parameter values after jitter
    vector MGparm_use(1,N_MGparm2)
    vector SRparm_use(1,N_SRparm3);
    vector recdev_cycle_use(1,recdev_cycle);
    vector recdev_use(recdev_first,YrMax);
    vector recdev_RD(recdev_first,YrMax);
    vector Q_parm_use(1,Q_Npar2);
    vector init_F_use(1,N_init_F);
    vector Fparm_use(1,N_Fparm);
    vector selparm_use(1,N_selparm2);
!!k=Do_TG*(3*N_TG+2*Nfleet1);
    vector TG_parm_use(1,k);
    matrix parm_dev_RD(1,N_parm_dev,parm_dev_minyr,parm_dev_maxyr);
    matrix parm_dev_use(1,N_parm_dev,parm_dev_minyr,parm_dev_maxyr);

!!k=gmorph*(YrMax-styr+1);
!!//  SS_Label_Info_4.14.4 #Create matrix CoVar and set it to receive the covariance output
  matrix save_G_parm(1,k,1,22);
  matrix save_seas_parm(1,nseas,1,10);
  matrix CoVar(1,CoVar_Count,1,CoVar_Count+1);
!!save_G_parm.initialize();
!!CoVar.initialize();
!!set_covariance_matrix(CoVar);

  //  SS_Label_Info_4.15 #Prepare for read empirical wt-at-age, which happens in prelim
  int N_WTage_rd
  int N_WTage_maxage
  int y2
  ivector last_yr_read(-2,Nfleet)
  ivector filled_once(-2,Nfleet)
  int f2
// SS_Label_file  #5. **SS_param.tpl**
// SS_Label_file  # - <div style="color: #ff0000">INITIALIZE_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #      - not used in SS3
// SS_Label_file  # - <div style="color: #ff0000">PARAMETER_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #      - create needed parameters and derived quantities as dvar arrays

//  SS_Label_Section_4.99 #INITIALIZE_SECTION (not used in SS3)
INITIALIZATION_SECTION

//  SS_Label_Section_5.0 #PARAMETER_SECTION
PARAMETER_SECTION
//  {
//  SS_Label_Info_5.0.1 #Setup convergence critera and max func evaluations
 LOCAL_CALCS
  // clang-format on
  // set the filename to all ADMB output files to "base_modelname.[ext]"
  //  where base_modelname can be read from command line with command modelname followed by text
  //  e.g.  ss3_win.exe -nohess -stopph 3  modelname ss4you
  //  if requested modelname.par is not found, then will attempt to read from ss3.par then ss.par
  //  whatever name is read, the write will be to modelname.par.  Which has default of ss3.par
  ad_comm::adprogram_name = base_modelname;
  echoinput << "Begin setting up parameters" << endl;
  cout << "Begin setting up parameters ... ";
  if (readparfile >= 1)
  {
    anystring = base_modelname + ".par";
    cout << " read parm file: " << anystring << endl;

    ifstream fin(anystring);
    if(fin.fail() ) {
      cout << " no find, try ss3.par" << endl;
      anystring = "ss3.par";
      ifstream fin(anystring);
      if(fin.fail() ) {
      cout << " no find, try ss.par" << endl;
      anystring = "ss.par";
      ifstream fin(anystring);
      if(fin.fail() ) {
    	  warnstream << "could not find ss3.par, ss.par, or requested parfile " << base_modelname << ".par";
    	  write_message(FATAL, 0);
      }
    }}
    cout << " found "<<anystring<<endl;

    ad_comm::change_pinfile_name(anystring);
  }

  maximum_function_evaluations.allocate(func_eval.indexmin(), func_eval.indexmax());
  maximum_function_evaluations = func_eval;
  convergence_criteria.allocate(func_conv.indexmin(), func_conv.indexmax());
  convergence_criteria = func_conv;
  if (do_ageK == 1) //  need for age-specific K
  {
    k = nages;
  } // use for dimension of VBK()
  else
  {
    k = 0;
  }
  // clang-format off
 END_CALCS

!! //  SS_Label_Info_5.0.2 #Create dummy_parm that will be estimated even if turn_off_phase is set to 0
  init_bounded_number dummy_parm(0,2,dummy_phase)  //  estimate in phase 0

!! //  SS_Label_Info_5.1.1 #Create MGparm vector and associated arrays
  // growth
  init_bounded_number_vector MGparm(1,N_MGparm2,MGparm_LO,MGparm_HI,MGparm_PH)
  vector femfrac(1,N_GP*gender);
  vector L_inf(1,N_GP*gender);
  vector Lmax_temp(1,N_GP*gender);
  vector CV_delta(1,N_GP*gender);
  matrix VBK(1,N_GP*gender,0,k);
  vector Richards(1,N_GP*gender);

  vector Lmin(1,N_GP*gender);
  vector Lmin_last(1,N_GP*gender);

  vector CVLmin(1,N_GP*gender)
  vector CVLmax(1,N_GP*gender)
  vector CV_const(1,N_GP*gender)
  matrix mgp_save(styr,YrMax,1,N_MGparm2);
  vector mgp_adj(1,N_MGparm2);
  matrix Cohort_Growth(styr,YrMax,0,nages)
  3darray Cohort_Lmin(1,N_GP*gender,styr,YrMax,0,nages)
  vector VBK_seas(0,nseas);

  3darray wtlen_seas(0,nseas,1,N_GP,1,8);  //  contains seasonally adjusted wtlen_p
  matrix wtlen_p(1,N_GP,1,8);
  vector parm_dev_stddev(1,N_parm_dev)
  vector parm_dev_rho(1,N_parm_dev)  // determines the mean regressive characteristic: with 0 = no autoregressive; 1= all autoregressive
  3darray wt_len(1,nseas,1,N_GP*gender,1,nlength)  //  stores wt at mid-bin

//  following wt_len are defined for 1,N_GP, but only use gp=1 due to complications in vbio, exp_ms and sizefreq calc
  3darray wt_len2(1,nseas,1,N_GP,1,nlength2)    //  stores wt at midbin; stacked genders
  3darray wt_len2_sq(1,nseas,1,N_GP,1,nlength2)    //  stores wt at midbin^2; stacked genders
  3darray wt_len_low(1,nseas,1,N_GP,1,nlength2)  //  wt at lower edge of size bin
  3darray wt_len_fd(1,nseas,1,N_GP,1,nlength2-1)  //  first diff of wt_len_low

  matrix mat_len(1,N_GP,1,nlength)
  matrix fec_len(1,N_GP,1,nlength)   // fecundity at length
  matrix mat_fec_len(1,N_GP,1,nlength)
  matrix mat_age(1,N_GP,0,nages)
  matrix Hermaphro_val(1,N_GP,0,nages)

  matrix catch_mult(styr-1,YrMax,1,Nfleet)
  4darray Save_PopLen(styr-3*nseas,TimeMax_Fcast_std+nseas,1,2*pop,1,gmorph,1,nlength)
  4darray Save_PopWt(styr-3*nseas,TimeMax_Fcast_std+nseas,1,2*pop,1,gmorph,1,nlength)
  4darray Save_PopAge(styr-3*nseas,TimeMax_Fcast_std+nseas,1,2*pop,1,gmorph,0,nages)
  4darray Save_PopBio(styr-3*nseas,TimeMax_Fcast_std+nseas,1,2*pop,1,gmorph,0,nages)

 LOCAL_CALCS
  // clang-format on
  // If empirical wt-at-age is used, maturity and fecundity vectors are set to a distinctive value of 0.5
  // If parameters are used, then the calcs could be age-based or length-based or both, so start with default value of 1.0
  // These calculations happen in function get_mat_fec() in file SS_biofxn.tpl
   if (WTage_rd == 1 || Maturity_Option == 4 || Maturity_Option == 5 ) {
     mat_len = 0.5;
     mat_age = 0.5;
     mat_fec_len = 0.5;
     fec_len = 0.5;
   }
   else {
     mat_len = 1.0;
     mat_age = 1.0;
     mat_fec_len = 1.0;
     fec_len = 1.0;
   }    
  // clang-format off
 END_CALCS

  3darray age_age(0,N_ageerr+store_agekey_add,1,n_abins2,0,gender*nages+gender-1)
  //  where store_agekey_add will normally be 0, but can be the number of blocks if key is from parameters that invoke blocks
  3darray age_err(1,N_ageerr+store_agekey_add,1,2,0,nages) // ageing imprecision as stddev for each age

// Age-length keys for each gmorph
  4darray ALK(1,N_subseas*nseas,1,gmorph,0,nages,1,nlength)
  matrix exp_AL(0,nages2,1,nlength2);
  matrix exp_AL_ret(0,nages2,1,nlength2);
  3darray Sd_Size_within(1,N_subseas*nseas,1,gmorph,0,nages)
  3darray Sd_Size_between(1,N_subseas*nseas,1,gmorph,0,nages)
  4darray Ave_Size(styr-3*nseas,TimeMax_Fcast_std+nseas,1,N_subseas,1,gmorph,0,nages)
  3darray CV_G(1,N_GP*gender,1,N_subseas*nseas,0,nages);   //  temporary storage of CV enroute to sd of len-at-age
//  3darray Wt_Age_save(styr-3*nseas,TimeMax_Fcast_std+nseas,1,gmorph,0,nages)
  3darray Wt_Age_beg(1,nseas,1,gmorph,0,nages)
  3darray Wt_Age_mid(1,nseas,1,gmorph,0,nages)
  4darray Wt_Age_t(styr-3*nseas,TimeMax_Fcast_std+nseas,-2,Nfleet,1,gmorph,0,nages)  //  set to begin period for pop (type=0), or mid period for fleet/survey
// read:  yr, seas, gender, morph, settlement, fleet, <age vec> where first value is for age 0!
// if yr=-yr, then fill remaining years for that seas, growpattern, gender, fleet
// fleet 0 contains begin season pop WT
// fleet -1 contains mid season pop WT
// fleet -2 contains maturity*fecundity

  3darray migrrate(styr-3,YrMax,1,do_migr2,0,nages)
  4darray recr_dist(styr-3,YrMax,1,N_GP*gender,1,N_settle_timings,1,pop);
  3darray recr_dist_unf(1,N_GP*gender,1,N_settle_timings,1,pop);
  3darray recr_dist_endyr(1,N_GP*gender,1,N_settle_timings,1,pop);
!!//  SS_Label_Info_5.1.2 #Create SRparm vector, recruitment vectors
  init_bounded_number_vector SRparm(1,N_SRparm3,SRparm_LO,SRparm_HI,SRparm_PH)
  matrix SRparm_byyr(styr-3,YrMax,1,N_SRparm2+1)  //  R0, steepness, parm3, sigmar, rec_dev_offset, R1, rho, SSB   Time_vary implementation of spawner-recruitment
  vector SRparm_virg(1,N_SRparm2+1)
  vector SRparm_work(1,N_SRparm2+1)
  vector SRparm_bench(1,N_SRparm2+1)
  number two_sigmaRsq;
  number half_sigmaRsq;
  number sigmaR;
  number SSBpR_virgin;
  number SSBpR_bench;
  number SSB0_4_SRR;
  number R0_4_SRR;
  number regime_change;
  number rho;
  number dirichlet_Parm;
 LOCAL_CALCS
  // clang-format on
  Ave_Size.initialize();
  //  if(SRparm(N_SRparm2)!=0.0 || SRparm_PH(N_SRparm2)>0) {SR_autocorr=1;} else {SR_autocorr=0;}  // flag for recruitment autocorrelation
  if (do_recdev == 1)
  {
    k = recdev_start;
    j = recdev_end;
    s = 1;
    p = -1;
  }
  else if (do_recdev >= 2)
  {
    s = recdev_start;
    p = recdev_end;
    k = 1;
    j = -1;
  }
  else
  {
    s = 1;
    p = -1;
    k = 1;
    j = -1;
  }
  // clang-format off
 END_CALCS

//  vector biasadj(styr-nages,YrMax)  // biasadj as used; depends on whether a recdev is estimated or not
//  vector biasadj_full(styr-nages,YrMax)  //  full time series of biasadj values, only used in defined conditions
  number sd_offset_rec

  init_bounded_number_vector recdev_cycle_parm(1,recdev_cycle,recdev_cycle_LO,recdev_cycle_HI,recdev_cycle_PH)

//  init_bounded_dev_vector recdev_early(recdev_early_start,recdev_early_end,recdev_LO,recdev_HI,recdev_early_PH)
  init_bounded_vector recdev_early(recdev_early_start,recdev_early_end,recdev_LO,recdev_HI,recdev_early_PH)
  init_bounded_dev_vector recdev1(k,j,recdev_LO,recdev_HI,recdev_PH)
  init_bounded_vector recdev2(s,p,recdev_LO,recdev_HI,recdev_PH)
  vector recdev(recdev_first,YrMax);

 LOCAL_CALCS
  // clang-format on
  if (do_recdev == 0)
  {
    s = -1;
  }
  else
  {
    s = YrMax;
  }
  if (Do_Impl_Error > 0)
  {
    k = Fcast_recr_PH2;
    j = YrMax;
  }
  else
  {
    k = -1;
    j = -1;
  }
  // clang-format off
 END_CALCS
  init_bounded_vector Fcast_recruitments(recdev_end+1,s,recdev_LO,recdev_HI,Fcast_recr_PH2)
  init_bounded_vector Fcast_impl_error(endyr+1,j,-1,1,k)
  vector ABC_buffer(endyr+1,YrMax);
  number HCR_anchor  //  basis (denominator) for inflection in control rule.  Select virgin SSB or benchmark SSB

//  SPAWN-RECR:   define some spawning biomass and recruitment entities
  number SSB_virgin
  number Recr_virgin
  number SSB_vir_LH

  number SSB_unf //  SSB unfished, based on benchmark biology
  number Recr_unf
  number SSB_use
  number R0_use

  number SSB_deplete //  SSB that will be used as denominator for depletion calculations and as basis for control rule inflection
  number SSB_current;                            // Spawning biomass
  number SSB_equil;

  number SPR_trial
  number SPR_actual;
  number SSBpR_temp;  //  SSB per Recruit; used to pass quantity into Equil_SpawnRecr
  number Recruits;                            // Age0 Recruits
  number equ_mat_bio
  number equ_mat_num

  number YPR    // variable still used in SPR series
  number YPR_Btgt_enc;
  number YPR_Btgt_dead;
  number YPR_Btgt_N_dead;
  number YPR_Btgt_ret;
  number YPR_Btgt_cost;
  number YPR_Btgt_revenue;
  number YPR_Btgt_profit;
  number YPR_Btgt;

  number YPR_spr_enc;
  number YPR_spr_dead;
  number YPR_spr_N_dead;
  number YPR_spr_ret;
  number YPR_spr_cost;
  number YPR_spr_revenue;
  number YPR_spr_profit;

  number Vbio_spr;
  number Vbio1_spr;
  number Vbio_Btgt;
  number Vbio1_Btgt;

  number Btgt;
  number Btgttgt;
  number SPR_Btgt;
  number Btgt_Rec;
  number Bspr;
  number Bspr_rec;

  number MSY
  number Bmsy
  number Recr_msy
  number YPR_msy_enc;
  number YPR_msy_dead;
  number YPR_msy_N_dead;
  number YPR_msy_ret;
  number YPR_msy_cost;
  number YPR_msy_revenue;
  number YPR_msy_profit;

  number YPR_enc;
  number YPR_dead;
  number YPR_opt;  //  used to find F0.1 and Fmsy  contains all dead catch
  vector YPR_val_vec(1,Nfleet);  // used to calculate value, so is multipled by price per unit
  number YPR_N_dead;
  number YPR_ret;
  number Cost;  //  total fishery cost across all fleets
  number Profit;  //  total revenues - Cost
  number MSY_Fmult;
  number SPR_Fmult;
  number Btgt_Fmult;
  number MSY_SPR;

  number Btgt2;
  number Btgttgt2;
  number SPR_Btgt2;
  number Btgt_Rec2;
  number Btgt_Fmult2;
  number H4010_top;

  3darray SSB_pop_gp(styr-3,YrMax,1,pop,1,N_GP)         //Spawning biomass
  vector SSB_yr(styr-3,YrMax)
  vector SSB_B_yr(styr-3,YrMax)  //  mature biomass (no fecundity)
  vector SSB_N_yr(styr-3,YrMax)   //  mature numbers
!!k=0;
!!if(Hermaphro_Option!=0) k=1;

  3darray MaleSSB(styr-3,YrMax*k,1,pop,1,N_GP)         //Male Spawning biomass

  matrix SSB_equil_pop_gp(1,pop,1,N_GP);
  matrix MaleSSB_equil_pop_gp(1,pop,1,N_GP);
  matrix Recr(1,pop,styr-2*nseas,TimeMax_Fcast_std+nseas)         //Recruitment
  matrix exp_rec(styr-2,YrMax,1,4) //expected value for recruitment: 1=spawner-recr only; 2=with environ and cycle; 3=with bias_adj; 4=with dev
  matrix Nmid(1,gmorph,0,nages);
  matrix Nsurv(1,gmorph,0,nages);
  3darray natage_temp(1,pop,1,gmorph,0,nages)
  number ave_age    //  average age of fish in unfished population; used to weight R1

!!//  SS_Label_Info_5.1.3 #Create M, F, and Z parameters and associated arrays and constants
  init_bounded_number_vector init_F(1,N_init_F,init_F_LO,init_F_HI,init_F_PH)
//  matrix est_equ_catch(1,nseas,1,Nfleet)

//  natural, predation and fishing mortality
  matrix natMparms(1,N_natMparms,1,N_GP*gender)  // will be derived from the MGparms
!!if(Do_Forecast>0) {k=TimeMax_Fcast_std+nseas;} else {k=TimeMax+nseas;}
  4darray natM(styr-3*nseas,k,0,pop,1,N_GP*gender*N_settle_timings,0,nages)  // M1 + pred_M2, see desc. in biofxn.tpl
//  3darray natM_M1(1,nseas,1,N_GP*gender*N_settle_timings,0,nages)  //  base M, biology only
  matrix pred_M2(1,N_pred,styr-3*nseas,TimeMax_Fcast_std+nseas);  //  predator M2

  //  add area (pop) dimension to same dimension as season; use s1=(p-1)*pop + s
  3darray surv1(1,nseas*pop,1,N_GP*gender*N_settle_timings,0,nages)
  3darray surv2(1,nseas*pop,1,N_GP*gender*N_settle_timings,0,nages)
  4darray Z_rate(styr-3*nseas,k,1,pop,1,gmorph,0,nages)
  3darray Zrate2(1,pop,1,gmorph,0,nages)
  matrix Hrate(1,Nfleet,styr-3*nseas,k) //Harvest Rate for each fleet; this is F
  4darray natage(styr-3*nseas,k,1,pop,1,gmorph,0,nages)  //  add +1 year
  4darray catage(styr-3*nseas,k,1,Nfleet,1,gmorph,0,nages)
  4darray disc_age(styr-3*nseas,TimeMax_Fcast_std+nseas,1,2*N_retain_fleets,1,gmorph,0,nages);
  4darray equ_catage(1,nseas,1,Nfleet,1,gmorph,0,nages)
  4darray equ_numbers(1,nseas,1,pop,1,gmorph,0,3*nages)
  4darray equ_Z(1,nseas,1,pop,1,gmorph,0,nages)
  matrix catage_tot(1,gmorph,0,nages)//sum the catches for all fleets, reuse matrix each year
  matrix bycatch_F(1,Nfleet,1,nseas)
  3darray catch_fleet(styr-3*nseas,k,1,Nfleet,1,6)  //  1=sel_bio, 2=kill_bio; 3=ret_bio; 4=sel_num; 5=kill_num; 6=ret_num
  matrix annual_catch(styr-1,YrMax,1,6)  //  same six as above
  matrix annual_F(styr-1,YrMax,1,3)  //  1=sum of hrate (if Pope fmethod) or sum hrate*seasdur if F; 2=Z-M for selected ages; 3=M
  3darray equ_catch_fleet(1,6,1,nseas,1,Nfleet)
  matrix vuln_bio(styr-3*nseas,k,1,Nfleet)  //  biomass selected by each fleet
  matrix vuln_num(styr-3*nseas,k,1,Nfleet)  //  numbers selected by each fleet

  matrix fec(1,gmorph,0,nages)            //relative fecundity at age, is the maturity times the weight-at-age times eggs/kg for females
  matrix make_mature_bio(1,gmorph,0,nages)  //  mature female weight at age
  matrix make_mature_numbers(1,gmorph,0,nages)  //  mature females at age
  matrix virg_fec(1,gmorph,0,nages)
  vector Equ_SpawnRecr_Result(1,2);
  number fish_bio;
  number fish_bio_r;
  number fish_bio_e;
  number fish_num_e;
  number fish_num;
  number fish_num_r;
  number vbio;
  number totbio;
  number smrybio;
  number smrynum;
  number smryage;  // mean age of the summary numbers (not accounting for settlement timing)
  number catch_mnage;  //  mean age of the catch (not accounting for settlement timing or season of the catch)
  number catch_mnage_d;  // total catch numbers for calc of mean age
  number harvest_rate;                        // Harvest rate
  number maxpossF;


 LOCAL_CALCS
  // clang-format on
  if (N_Fparm > 0) // continuous F
  {
    k = N_Fparm;
  }
  else
  {
    k = -1;
  }
  // clang-format off
 END_CALCS
 //  defining F_rate as number_vector allows for Fparm_PH to be element specific
  init_bounded_number_vector F_rate(1,k,0.,max_harvest_rate,Fparm_PH_dim)

  vector Nmigr(1,pop);
  number Nsurvive;

  number caa;
   number Fmult;
   number Fcast_Fmult;
   number Fcurr_Fmult;
   number Fchange;
   number last_calc;
   matrix Fcast_RelF_Use(1,nseas,1,Nfleet);
   matrix Bmark_RelF_Use(1,nseas,1,Nfleet);  //  relative F among all catch fleets
   matrix Bmark_HistF(1,nseas,1,Nfleet);  //  save F to use for non-optimized fleets
   //  note that bycatch_F(1,Nfleet,1,nseas) has similar role  
   number alpha;
   number beta;
   number steepness;
   number GenTime;
   number Yield;
   number Adj4010;

//  !!k1 = styr+(endyr-styr)*nseas-1 + nseas + 1;
//  !!y=k1+N_Fcast_Yrs*nseas-1;

!!//  SS_Label_Info_5.1.4 #Create Q_parm and associated arrays
  init_bounded_number_vector Q_parm(1,Q_Npar2,Q_parm_LO,Q_parm_HI,Q_parm_PH)

  matrix Svy_log_q(1,Nfleet,1,Svy_N_fleet);
  matrix Svy_q(1,Nfleet,1,Svy_N_fleet);
  matrix Svy_se_use(1,Nfleet,1,Svy_N_fleet)
  matrix Svy_est(1,Nfleet,1,Svy_N_fleet)    //  will store expected survey in normal or lognormal units as needed
  matrix Svy_selec_abund(1,Nfleet,1,Svy_N_fleet);        // Vulnerable biomass
  matrix Svy_like_I(1,Nfleet,1,Svy_N_fleet)  
  vector surv_like(1,Nfleet) // likelihood of the indices
  matrix Q_dev_like(1,Nfleet,1,2) // likelihood of the Q deviations

  vector disc_like(1,Nfleet) // likelihood of the discard biomass
  vector mnwt_like(1,Nfleet) // likelihood of the mean body wt

  matrix exp_disc(1,Nfleet,1,disc_N_fleet)
  3darray retain(styr-3,YrMax,1,Nfleet,1,nlength2)
  vector retain_M(1,nlength)
  3darray discmort(styr-3,YrMax,1,Nfleet,1,nlength2)
  vector discmort_M(1,nlength)
  vector exp_mnwt(1,nobs_mnwt)

  matrix Morphcomp_exp(1,Morphcomp_nobs,6,5+Morphcomp_nmorph)   // expected value for catch by growthpattern

  3darray SzFreqTrans(1,SzFreq_Nmeth*nseas,1,nlength2,1,SzFreq_Nbins_seas_g);

!!//  SS_Label_Info_5.1.5 #Selectivity-related parameters
!!  echoinput<<" now dimension the selectivity arrays "<<N_selparm2<<endl;
!! echoinput<<selparm_LO<<endl;
!! echoinput<<selparm_HI<<endl;
!! echoinput<<selparm_PH<<endl;
  init_bounded_number_vector selparm(1,N_selparm2,selparm_LO,selparm_HI,selparm_PH)

//  init_bounded_matrix selparm_dev(1,N_selparm_dev,selparm_dev_minyr,selparm_dev_maxyr,-10,10,selparm_dev_PH)
//  matrix selparm_dev_rwalk(1,N_selparm_dev,selparm_dev_minyr,selparm_dev_maxyr)
//  vector selparm_dev_stddev(1,N_selparm_dev)
//  vector selparm_dev_rho(1,N_selparm_dev)  // determines the mean regressive characteristic: with 0 = no autoregressive; 1= all autoregressive

  4darray sel_l(styr-3,YrMax,1,Nfleet,1,gender,1,nlength)
  4darray sel_l_r(styr-3,YrMax,1,Nfleet,1,gender,1,nlength)   //  selex x retained
  4darray discmort2(styr-3,YrMax,1,Nfleet,1,gender,1,nlength)
  4darray sel_a(styr-3,YrMax,1,Nfleet,1,gender,0,nages)
  vector sel(1,nlength)  //  used to multiply by ALK

  4darray retain_a(styr-3,YrMax,1,Nfleet,1,gender,0,nages)
  4darray discmort_a(styr-3,YrMax,1,Nfleet,1,gender,0,nages)
  4darray discmort2_a(styr-3,YrMax,1,Nfleet,1,gender,0,nages)
  4darray sel_a_r(styr-3,YrMax,1,Nfleet,1,gender,0,nages)

!!  echoinput<<" OK after dimension the selectivity arrays "<<endl;
!!  echoinput<<" check "<<TwoD_AR_cnt<<" "<<TwoD_AR_cor_dim<<endl;

  3darray cor(1,TwoD_AR_cnt,1,TwoD_AR_cor_dim,1,TwoD_AR_cor_dim)
  3darray inv_cor(1,TwoD_AR_cnt,1,TwoD_AR_cor_dim,1,TwoD_AR_cor_dim)
  vector det_cor(1,TwoD_AR_cnt);
  matrix TwoD_AR_ave(1,TwoD_AR_cnt,TwoD_AR_amin,TwoD_AR_amax) //  ragged array for these averages
!!  echoinput<<" OK after dimension the 2dar arrays "<<endl;

!!//  SS_Label_Info_5.1.6 #Create tag parameters and associated arrays
  matrix TG_alive(1,pop,1,gmorph)
  matrix TG_alive_temp(1,pop,1,gmorph)
  3darray TG_recap_exp(1,N_TG2,0,TG_endtime,0,Nfleet)   //  do not need to store POP index because each fleet is in just one area
  matrix TG_recap_gen(1,100000,1,5)   // changes courtesy of Gavin Fay
  vector TG_like1(1,N_TG2)
  vector TG_like2(1,N_TG2)
  number overdisp     // overdispersion

 LOCAL_CALCS
   // clang-format on
   k = Do_TG * (3 * N_TG + 2 * Nfleet1);
  // clang-format off
 END_CALCS

  init_bounded_number_vector TG_parm(1,k,TG_parm_LO,TG_parm_HI,TG_parm_PH);

  init_bounded_vector_vector parm_dev(1,N_parm_dev,parm_dev_minyr,parm_dev_maxyr,-10,10,parm_dev_PH)
  matrix parm_dev_rwalk(1,N_parm_dev,parm_dev_minyr,parm_dev_maxyr);

  init_bounded_number checksum999(998,1000,-1)  //  value must be 999 to check reading of ss.par
  vector timevary_parm(1,timevary_parm_cnt);  //  holds the link parameters; in SS_timevaryparm these are set to actual parms in MGparms, SRparms, Qparms, selparms
  matrix parm_timevary(1,timevary_cnt,styr-1,YrMax);  //  time series of adjusted parm values for block and trend

 LOCAL_CALCS
  // clang-format on
  if (Do_Forecast > 0)
    k = TimeMax_Fcast_std + nseas;
  else
    k = TimeMax + nseas;
  // clang-format off
 END_CALCS

!!//  SS_Label_Info_5.1.7 #Create arrays for storing derived selectivity quantities for use in mortality calculations
//  4darray fish_body_wt(styr-3*nseas,k,1,Nfleet,1,gmorph,0,nages);  // wt (adjusted for size selex)
  4darray sel_bio(1,nseas,1,Nfleet,1,gmorph,0,nages);  // selected * wt
  4darray sel_ret_bio(1,nseas,1,Nfleet,1,gmorph,0,nages);  // selected * retained * wt
  4darray sel_num(1,nseas,1,Nfleet,1,gmorph,0,nages);  // selected numbers
  4darray sel_ret_num(1,nseas,1,Nfleet,1,gmorph,0,nages);  // selected * retained numbers
  4darray sel_dead_num(1,nseas,1,Nfleet,1,gmorph,0,nages);  // sel * (retain + (1-retain)*discmort)
  4darray sel_dead_bio(1,nseas,1,Nfleet,1,gmorph,0,nages);  // sel * (retain + (1-retain)*discmort) * wt

  4darray save_sel_num(styr-3*nseas,TimeMax_Fcast_std+nseas,1,Nfleet,1,gmorph,0,nages)  //  save sel_num (Asel_2) and save fecundity for output;  +nseas covers no forecast setups

  4darray Sel_for_tag(TG_timestart*Do_TG,TimeMax*Do_TG,1,Nfleet,1,gmorph*Do_TG,0,nages)
  vector TG_report(1,Nfleet*Do_TG);
  vector TG_rep_decay(1,Nfleet*Do_TG);

  3darray save_sp_len(styr,YrMax,1,2*Nfleet,1,50);     // use to output selex parm values after adjustment

  3darray exp_l(1,Nfleet,1,Nobs_l,1,nlen_bin2)
  matrix neff_l(1,Nfleet,1,Nobs_l)
  vector tempvec_l(1,nlength);
  vector exp_l_temp(1,nlength2);
  vector exp_truea_ret(0,nages2);
  vector exp_l_temp_ret(1,nlength2);     // retained lengthcomp
  vector exp_l_temp_dat(1,nlen_bin2);
//  vector offset_l(1,Nfleet) // Compute OFFSET for multinomial (i.e, value for the multinonial function
  matrix length_like(1,Nfleet,1,Nobs_l)  // likelihood of the length-frequency data
  vector length_like_tot(1,Nfleet)  // likelihood of the length-frequency data
  matrix SzFreq_exp(1,SzFreq_totobs,1,SzFreq_Setup2);
  vector SzFreq_like(1,SzFreq_N_Like)
  3darray exp_a(1,Nfleet,1,Nobs_a,1,n_abins2)
  vector exp_a_temp(1,n_abins2)
  vector tempvec_a(0,nages)
  vector agetemp(0,nages2)
  matrix neff_a(1,Nfleet,1,Nobs_a)
  matrix age_like(1,Nfleet,1,Nobs_a)  // likelihood of the age-frequency data
  vector age_like_tot(1,Nfleet)  // likelihood of the age-frequency data
  vector sizeage_like(1,Nfleet)  // likelihood of the age-frequency data
  3darray exp_ms(1,Nfleet,1,Nobs_ms,1,n_abins2)
  3darray exp_ms_sq(1,Nfleet,1,Nobs_ms,1,n_abins2)

  number Morphcomp_like
  vector equ_catch_like(1,Nfleet)
  vector catch_like(1,Nfleet)
  number recr_like
  number noBias_recr_like
  number JT_obj_fun
  number regime_like
  number sum_recdev
  number Fcast_recr_like
  number parm_like
  matrix parm_dev_like(1,N_parm_dev,1,2)
//  vector selparm_dev_like(1,N_selparm_dev)
  number CrashPen
  number SoftBoundPen
  number Equ_penalty
  number F_ballpark_like

  number R1
  number R1_exp
  number t1
  number t2
  number temp
  number temp1
  number temp2
  number temp3
  number temp4
  number join1
  number join2
  number join3
  number upselex
  number downselex
  number peak
  number peak2
  number point1
  number point2
  number point3
  number point4
  number timing
  number equ_Recr
  number equ_F_std
  number equ_M_std
  
!!//  SS_Label_Info_5.1.8 #Create matrix called smry to store derived quantities of interest
  matrix Smry_Table(styr-3,YrMax,1,17);
  // 1=totbio, 2=smrybio, 3=smrynum, 4=enc_catch, 5=dead_catch, 6=ret_catch, 7=spbio, 8=recruit,
  // 9=equ_totbio, 10=equ_smrybio, 11=equ_SSB_virgin, 12=equ_S1, 13=Gentime, 14=YPR, 15=meanage_spawners, 16=meanage_smrynums, 17=meanage_catch
 

  matrix env_data(styr-1,YrMax,-4,N_envvar)
  matrix TG_save(1,N_TG,1,3+TG_endtime)

  // save gradients for all active parameters
!! int parm_grad_active_count = max(1,active_count);     // the dummy parameter is still in there even if no other params are estimated
  vector parm_gradients(1,parm_grad_active_count);

!!//  SS_Label_Info_5.2 #Create sdreport vectors
  sdreport_vector SSB_std(1,N_STD_Yr);
  sdreport_vector recr_std(1,N_STD_Yr);
  sdreport_vector SPR_std(1,N_STD_Yr_Ofish);
  sdreport_vector F_std(1,N_STD_Yr_F);
  sdreport_vector depletion(1,N_STD_Yr_Dep);
  sdreport_vector Mgmt_quant(1,N_STD_Mgmt_Quant)
  sdreport_vector Extra_Std(1,Extra_Std_N)  // includes many subvectors created in SS_readcontrol

  sdreport_vector Svy_sdreport_est(1,Svy_N_sdreport)

!!//  SS_Label_Info_5.3 #Create log-Likelihood vectors
  vector MGparm_Like(1,N_MGparm2)
  vector init_F_Like(1,N_init_F)
  vector Q_parm_Like(1,Q_Npar2)
  vector selparm_Like(1,N_selparm2)
  vector SRparm_Like(1,N_SRparm3)
  vector recdev_cycle_Like(1,recdev_cycle)
!! k=Do_TG*(3*N_TG+2*Nfleet1);
  vector TG_parm_Like(1,k);

!!//  SS_Label_Info_5.4  #Define objective function
  objective_function_value obj_fun
  number last_objfun
  vector phase_output(1,max_phase+1)
!!cout<<" end of parameter section "<<endl;
!!echoinput<<"end of parameter section"<<endl;
//  }  // end of parameter section



// SS_Label_file  #6. **SS_prelim.tpl**
// SS_Label_file  # - <div style="color: #ff0000">PRELIMINARY_CALCS_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - preprocessing of the comp logL
// SS_Label_file  #     - get initial parameter values from *ss.par* or from values in control file
// SS_Label_file  #     - check parameter initial values and ranges and apply jitter using function check_parm() found in SS_objfun.tpl
// SS_Label_file  #     - set y=styr and do_once flag=1; then call <u>all biology functions</u> once to check for problems
// SS_Label_file  #     - exit if turn_off_phase<0, else continue to the PROCEDURE_SECTION found in SS_proced.tpl

//******************************************************************************************
//  SS_Label_Section_6.0 #PRELIMINARY_CALCS_SECTION
  PRELIMINARY_CALCS_SECTION
  {
  //  SS_Label_Info_6.1 #Some initial housekeeping
  //  SS_Label_Info_6.1.1 #Create and initialize random number generator
  random_number_generator radm(long(time(&start)));
  if (F_ballpark_yr > retro_yr)
    F_ballpark_yr = retro_yr;
  if (F_ballpark_yr < styr)
  {
    F_ballpark_lambda = 0.;
  }
  sel_l.initialize();
  sel_a.initialize();
  offset_l.initialize();
  offset_a.initialize();
  save_sp_len.initialize();
  save_sel_num.initialize();
  catch_mult = 1.0;

  //  SS_Label_Info_4.15 #read empirical wt-at-age
  last_yr_read.initialize();
  filled_once.initialize();
  if (WTage_rd > 0)
  {
    ad_comm::change_datafile_name("wtatage.ss");
    echoinput << "Begin reading the empirical weight at age file" << endl;
    cout << "Reading the empirical weight at age file ...";
    *(ad_comm::global_datafile) >> N_WTage_maxage;
    k = 7 + N_WTage_maxage;
    echoinput << " N_WTage_max " << N_WTage_maxage << endl;
    ender = 0;
    do
    {
      dvector tempvec(1, k);
      *(ad_comm::global_datafile) >> tempvec(1, k);
      if (tempvec(1) == -9999.)
        ender = 1;
      echoinput << tempvec(1, k) << endl;
      y = abs(tempvec(1));
      f = tempvec(6);
      if (f == -2)
      {
        if (tempvec(7) > 0.0)
        {
          warnstream << "WTATAGE.SS has positive fecundity at age 0 for year = " << y << " Are you sure? fecundity is for the time of spawning and age 0 fish normally do not exist at time of spawning";
          write_message(WARN, 0);
        }
      }
      if (y < 9999)
        last_yr_read(f) = max(y, last_yr_read(f));
      if (y < 9999 && tempvec(1) < 0)
        filled_once(f) = y; //  record latest fill event for this input category
      WTage_in.push_back(tempvec(1, k));
    } while (ender == 0);
    N_WTage_rd = WTage_in.size() - 1;
    k2 = TimeMax_Fcast_std + 1;
    echoinput << " N_WTage_rd " << N_WTage_rd << endl;
    echoinput << " last year read for -2 through Nfleet:  " << last_yr_read << endl;
    echoinput << " latest fill year for -2 through Nfleet:  " << filled_once << endl;

    for (f = -2; f <= Nfleet; f++)
      for (t = styr; t <= k2; t++)
        for (g = 1; g <= gmorph; g++)
          for (a = 0; a <= nages; a++)
          {
            Wt_Age_t(t, f, g, a) = -9999.;
          }
    if (N_WTage_maxage > nages)
      N_WTage_maxage = nages; //  so extra ages being read will be ignored
    dvector tempvec(1, 7 + N_WTage_maxage);
    for (i = 0; i <= N_WTage_rd - 1; i++)
    {
      tempvec(1, 7 + N_WTage_maxage) = WTage_in[i](1, 7 + N_WTage_maxage);
      y = abs(tempvec(1));
      f = tempvec(6);
      if (y < styr)
        y = styr;
      if (tempvec(1) < 0 || (y == last_yr_read(f) && filled_once(f) == 0))
      {
        y2 = max(YrMax, endyr + 50);
      }
      else
      {
        y2 = y;
      } //  allows filling to end of time series
      s = abs(tempvec(2));
      if (tempvec(2) < 0)
      {
        f2 = Nfleet;
      }
      else
      {
        f2 = f;
      } //  allows filling all fleets
      gg = tempvec(3);
      gp = tempvec(4);
      birthseas = tempvec(5);
      g = (gg - 1) * N_GP * nseas + (gp - 1) * nseas + birthseas; //  note  cannot handle platoons
      if (s <= nseas && gg <= gender && gp <= N_GP && birthseas <= nseas && f <= Nfleet)
      {
        for (j = y; j <= y2; j++) // loop years
        {
          for (k = f; k <= f2; k++)
          {
            t = styr + (j - styr) * nseas + s - 1;
            for (a = 0; a <= N_WTage_maxage; a++)
              Wt_Age_t(t, k, g, a) = tempvec(7 + a);
            for (a = N_WTage_maxage; a <= nages; a++)
              Wt_Age_t(t, k, g, a) = Wt_Age_t(t, k, g, N_WTage_maxage); //  fills out remaining ages, if any
            if (j == y && k == f)
              echoinput << "year " << y << " s " << s << " sex " << gg << " gp " << gp << " bs " << birthseas << " morph " << g << " pop/fleet " << f << " " << Wt_Age_t(t, k, g)(0, min(6, nages)) << endl;
          }
        }
      }
    }
    dvar_vector junkvec2(0, nages);
    for (f = -2; f <= Nfleet; f++)
      for (t = styr; t <= k2 - 1; t++)
        for (g = 1; g <= gmorph; g++)
          for (a = 0; a <= nages; a++)
            if (Wt_Age_t(t, f, g, a) == -9999.)
            {
              warnstream << "wtatage not assigned for: time, morph, fleet, age: " << t << " " << g << " " << f << " " << a;
              write_message (WARN, 0);
            }
    temp = float(Bmark_Yr(2) - Bmark_Yr(1) + 1.); //  get denominator
    echoinput << " fill benchmark years with mean " << endl;
    for (f = -2; f <= Nfleet; f++)
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (s = 0; s <= nseas - 1; s++)
          {
            junkvec2.initialize();
            for (t = Bmark_t(1); t <= Bmark_t(2); t += nseas)
            {
              junkvec2 += Wt_Age_t(t + s, f, g);
            }
            Wt_Age_t(styr - 3 * nseas + s, f, g) = junkvec2 / temp;
          }
        }
    echoinput << "Finished reading the empirical weight at age file" << endl;
    cout << "done" << endl; // Done reading the empirical weight at age file
  }
  else
  {
    N_WTage_rd = 0;
    N_WTage_maxage = nages;
  }

  //  SS_Label_Info_6.1.2 #Initialize the dummy parameter as needed
  if (Turn_off_phase <= 0)
  {
    dummy_parm = 0.99999999999999;
  }
  else
  {
    dummy_parm = 1.0;
  }

  Cohort_Growth = 1.0; // base value for cohort growth deviations

  //  SS_Label_Info_6.2 #Apply input variance adjustments to each data type
  //  SS_Label_Info_6.2.1 #Do variance adjustment for surveys

  echoinput << " do variance adjustment for surveys " << endl;
  for (f = 1; f <= Nfleet; f++)
    if (Svy_N_fleet(f) > 0)
    {
      for (i = 1; i <= Svy_N_fleet(f); i++)
      {
        Svy_se(f, i) = Svy_se_rd(f, i); // don't overwrite the input values

        if (Svy_use(f, i) > 0)
        {
          if (Svy_errtype(f) >= 0) // lognormal or lognormal T-dist
          {
            if (Svy_obs(f, i) <= 0.0)
            {
              warnstream << "Survey obs must be positive for lognormal error";
              write_message (FATAL, 0); // EXIT!
            }
            Svy_obs_log(f, i) = log(Svy_obs(f, i));
            Svy_se(f, i) += var_adjust(1, f);
            if (Svy_se(f, i) <= 0.0)
              Svy_se(f, i) = 0.001;
          }
          else if ( Svy_errtype(f) == -1 ) // normal distribution
          {
            Svy_se(f, i) += var_adjust(1, f);
            if (Svy_se(f, i) <= 0.0)
              Svy_se(f, i) = 0.001;
          }
          else
          {
            //  gamma will go here
          }
          
        }
      }
    }
  echoinput << " survey stderr has been set-up " << endl;

  //  SS_Label_Info_6.2.2 #Set up variance for discard observations
  for (f = 1; f <= Nfleet; f++)
    if (disc_N_fleet(f) > 0)
    {
      for (i = 1; i <= disc_N_fleet(f); i++)
      {
        if (yr_disc_use(f, i) >= 0.)
        {
          if (cv_disc(f, i) <= 0.0)
            cv_disc(f, i) = 0.001;
          if (disc_errtype(f) >= 0 || disc_errtype(f) == -3)
          {
            // input is CV
            sd_disc(f, i) = cv_disc(f, i) * obs_disc(f, i);
          }
          else
          {
            // input is SD
            sd_disc(f, i) = cv_disc(f, i);
          }

          sd_disc(f, i) += var_adjust(2, f); // note that adjustment is to the sd, not the CV
          if (sd_disc(f, i) < 0.001)
            sd_disc(f, i) = 0.001;
        }
      }
    }
  echoinput << " discard stderr has been set-up " << endl;

  //  SS_Label_Info_6.2.3 #Set up variance for mean body wt data, note different reference to array that was read
  //  10 items are:  1yr, 2seas, 3fleet, 4part, 5type, 6obs, 7se, then three intermediate variance quantities
  for (i = 1; i <= nobs_mnwt; i++)
  {
    if (mnwtdata(3, i) > 0.) //  used observation
    {
      mnwtdata(7, i) += var_adjust(3, mnwtdata(3, i));
      if (mnwtdata(7, i) <= 0.0)
        mnwtdata(7, i) = 0.001;
      mnwtdata(8, i) = mnwtdata(6, i) * mnwtdata(7, i); //  se = cv*obs
      mnwtdata(9, i) = DF_bodywt * square(mnwtdata(8, i));
      mnwtdata(10, i) = sd_offset * log(mnwtdata(8, i));
    }
  }
  echoinput << " mean bodywt stderr has been set-up " << endl;

  //  SS_Label_Info_6.2.4 #Do variance adjustment and compute OFFSET for length comp
  if (Nobs_l_tot > 0)
    for (f = 1; f <= Nfleet; f++)
      for (i = 1; i <= Nobs_l(f); i++)
      //  if(header_l(f,i,3)>0)
      {
        nsamp_l(f, i) *= var_adjust(4, f);
        // {if(nsamp_l(f,i)<=1.0) nsamp_l(f,i)=1.;}                              //  adjust sample size
        // calculate lencomp offsets
        if (Comp_Err_L(0, f) == 0)
        {
          // multinomial
          nsamp_l(f, i) = max(min_sample_size_L(0, f), nsamp_l(f, i));
          if (gen_l(f, i) != 2)
          {
            offset_l(f, i) -= nsamp_l(f, i) *
                obs_l(f, i)(tails_l(f, i, 1), tails_l(f, i, 2)) * log(obs_l(f, i)(tails_l(f, i, 1), tails_l(f, i, 2)));
          }
          if (gen_l(f, i) >= 2 && gender == 2)
          {
            offset_l(f, i) -= nsamp_l(f, i) *
                obs_l(f, i)(tails_l(f, i, 3), tails_l(f, i, 4)) * log(obs_l(f, i)(tails_l(f, i, 3), tails_l(f, i, 4)));
          }
        }
        else if( (Comp_Err_L(0, f)==1) || (Comp_Err_L(0, f)==2) ) //  dirichlet
        {
          // Dirichlet-Multinomial (either 1 = linear, 2 = saturating)
          // cannot use fxn Comp_Err_Dirichlet for this calc because only need the first part here
          offset_l(f, i) = gammln(nsamp_l(f, i) + 1.);
          if (gen_l(f, i) != 2)
          {
            int z1 = tails_l(f, i, 1);
            int z2 = tails_l(f, i, 2);
            offset_l(f, i) -= sum(gammln(1. + nsamp_l(f, i) * obs_l(f, i)(z1, z2)));
                //        sum(gammln(1. + nsamp_l(f,i)*obs_l(f,i)(tails_l(f,i,3),tails_l(f,i,4))));
          }
          if (gen_l(f, i) >= 2 && gender == 2)
          {
            int z1 = tails_l(f, i, 3);
            int z2 = tails_l(f, i, 4);
            offset_l(f, i) -= sum(gammln(1. + nsamp_l(f, i) * obs_l(f, i)(z1, z2)));
          }
        }
        else if( (Comp_Err_L(0, f)==3)) //  MV Tweedie
        {
          //  no MV Tweedie offset
        }
      }
  //  echoinput<<" length_comp offset: "<<offset_l<<endl;
  echoinput << " length comp var adjust has been set-up " << endl;

  //  SS_Label_Info_6.2.4.1 #Get sample weights for the super-period components in length comp
  //  the combined obs will have a logL sample size equal to the sample size input for the accumulator observation
  //  the accumulator observation is assigned a weight of 1.0 (because there is no place to read this from)
  //  the obs to be combined with the accumulator get a weight equal to value input in the nsamp_l element
  //  so, nsamp_l can no longer have negative observations
  for (f = 1; f <= Nfleet; f++)
  {
    if (Svy_super_N(f) > 0)
    {
      echoinput << "Create superperiod sample weights for survey obs" << endl
                << "Flt_num SuperP Obs_num Flt_code SE_input samp_wt" << endl;
      for (j = 1; j <= Svy_super_N(f); j++) // do each super period
      {
        temp = 1.0; //  relative sample weight for time period the accumulator observation
        k = 0; // count of samples with real information
        for (i = Svy_super_start(f, j); i <= Svy_super_end(f, j); i++) //  loop obs of this super period
        {
          if (Svy_use(f, i) < 0) //  so one of the obs to be combined
          {
            temp += Svy_se(f, i);
          } //  add in its weight relative to 1.0 for the observation with real info
          else
          {
            k++;
          }
        }
        if (k != 1)
        {
          warnstream << "There must only be 1 sample with real info in survey superperiod " << j;
          write_message (FATAL, 0); // EXIT!
        }
        for (i = Svy_super_start(f, j); i <= Svy_super_end(f, j); i++)
        {
          if (Svy_use(f, i) < 0) //  so one of the obs to be combined
          {
            Svy_super_weight(f, i) = Svy_se(f, i) / value(temp);
          }
          else
          {
            Svy_super_weight(f, i) = 1.0 / value(temp);
          }
          echoinput << f << " " << j << " " << i << " " << Svy_use(f, i) << " " << Svy_se(f, i) << " " << Svy_super_weight(f, i) << endl;
        }
      }
    }

    if (N_suprper_disc(f) > 0)
    {
      echoinput << "Create superperiod sample weights for discard obs" << endl
                << "Flt_num SuperP Obs_num Flt_code SE_input samp_wt" << endl;
      for (j = 1; j <= N_suprper_disc(f); j++) // do each super period
      {
        temp = 1.0; //  relative sample weight for time period the accumulator observation
        k = 0; // count of samples with real information
        for (i = suprper_disc1(f, j); i <= suprper_disc2(f, j); i++) //  loop obs of this super period
        {
          if (yr_disc_use(f, i) < 0) //  so one of the obs to be combined
          {
            temp += cv_disc(f, i);
          } //  add in its weight relative to 1.0 for the observation with real info
          else
          {
            k++;
          }
        }
        if (k != 1)
        {
          warnstream << "There must only be 1 sample with real info in survey superperiod " << j;
          write_message (FATAL, 0); // EXIT!
        }
        for (i = suprper_disc1(f, j); i <= suprper_disc2(f, j); i++)
        {
          if (yr_disc_use(f, i) < 0) //  so one of the obs to be combined
          {
            suprper_disc_sampwt(f, i) = cv_disc(f, i) / value(temp);
          }
          else
          {
            suprper_disc_sampwt(f, i) = 1.0 / value(temp);
          }
          echoinput << f << " " << j << " " << i << " " << yr_disc_use(f, i) << " " << cv_disc(f, i) << " " << suprper_disc_sampwt(f, i) << endl;
        }
      }
    }

    if (N_suprper_l(f) > 0)
    {
      echoinput << "Create superperiod sample weights for length obs" << endl
                << "Flt_num SuperP Obs_num Flt_code effN_input samp_wt" << endl;
      for (j = 1; j <= N_suprper_l(f); j++) // do each super period
      {
        temp = 1.0; //  relative sample weight for time period the accumulator observation
        k = 0; // count of samples with real information
        for (i = suprper_l1(f, j); i <= suprper_l2(f, j); i++) //  loop obs of this super period
        {
          if (header_l(f, i, 3) < 0) //  so one of the obs to be combined
          {
            temp += nsamp_l(f, i);
          }
          else
          {
            k++;
          }
        }
        if (k > 1)
        {
          warnstream << "There must only be 1 sample with real info in length superperiod " << j;
          write_message (FATAL, 0); // EXIT!
        }
        for (i = suprper_l1(f, j); i <= suprper_l2(f, j); i++)
        {
          if (header_l(f, i, 3) < 0) //  so one of the obs to be combined
          {
            suprper_l_sampwt(f, i) = nsamp_l(f, i) / value(temp);
          }
          else
          {
            suprper_l_sampwt(f, i) = 1.0 / value(temp);
          }
          echoinput << f << " " << j << " " << i << " " << header_l(f, i, 3) << " " << nsamp_l(f, i) << " " << suprper_l_sampwt(f, i) << endl;
        }
      }
    }

    if (N_suprper_a(f) > 0)
    {
      echoinput << "Create superperiod sample weights for age obs" << endl
                << "Flt_num SuperP Obs_num Flt_code effN_input samp_wt" << endl;
      for (j = 1; j <= N_suprper_a(f); j++) // do each super period
      {
        temp = 1.0; //  relative sample weight for time period the accumulator observation
        k = 0; // count of samples with real information
        for (i = suprper_a1(f, j); i <= suprper_a2(f, j); i++) //  loop obs of this super period
        {
          if (header_a(f, i, 3) < 0) //  so one of the obs to be combined
          {
            temp += nsamp_a(f, i);
          }
          else
          {
            k++;
          }
        }
        if (k != 1)
        {
          warnstream << "There must only be 1 sample with real info in age superperiod " << j;
          write_message (FATAL, 0); // EXIT!
        }
        for (i = suprper_a1(f, j); i <= suprper_a2(f, j); i++)
        {
          if (header_a(f, i, 3) < 0) //  so one of the obs to be combined
          {
            suprper_a_sampwt(f, i) = nsamp_a(f, i) / value(temp);
          }
          else
          {
            suprper_a_sampwt(f, i) = 1.0 / value(temp);
          } //  for the element holding the combined observation
          echoinput << f << " " << j << " " << i << " " << header_a(f, i, 3) << " " << nsamp_a(f, i) << " " << suprper_a_sampwt(f, i) << endl;
        }
      }
    }
    if (N_suprper_ms(f) > 0)
    {
      echoinput << "Create superperiod sample weights for meansize obs" << endl
                << "Flt_num SuperP Obs_num Flt_code effN_input samp_wt" << endl;
      for (j = 1; j <= N_suprper_ms(f); j++) // do each super period
      {
        temp = 1.0; //  relative sample weight for time period the accumulator observation
        k = 0; // count of samples with real information
        for (i = suprper_ms1(f, j); i <= suprper_ms2(f, j); i++) //  loop obs of this super period
        {
          if (header_ms(f, i, 3) < 0) //  so one of the obs to be combined
          {
            temp += header_ms(f, i, 7);
          }
          else
          {
            k++;
          }
        }
        if (k != 1)
        {
          warnstream << "There must only be 1 sample with real info in meansize superperiod " << j;
          write_message (FATAL, 0); // EXIT!
        }
        for (i = suprper_ms1(f, j); i <= suprper_ms2(f, j); i++)
        {
          if (header_ms(f, i, 3) < 0) //  so one of the obs to be combined
          {
            suprper_ms_sampwt(f, i) = header_ms(f, i, 7) / value(temp);
          }
          else
          {
            suprper_ms_sampwt(f, i) = 1.0 / value(temp);
          } //  for the element holding the combined observation
          echoinput << f << " " << j << " " << i << " " << header_ms(f, i, 3) << " " << header_ms(f, i, 7) << " " << suprper_ms_sampwt(f, i) << endl;
        }
      }
    }
  }

  //  SS_Label_Info_6.2.5 #Do variance adjustment and compute OFFSET for age comp
  if (Nobs_a_tot > 0)
    for (f = 1; f <= Nfleet; f++)
      for (i = 1; i <= Nobs_a(f); i++)
      //  if(header_a(f,i,3)>0)
      {
        nsamp_a(f, i) *= var_adjust(5, f);
        // {if(nsamp_a(f,i)<=1.0) nsamp_a(f,i)=1.;}                                //  adjust sample size
        nsamp_a(f, i) = max(min_sample_size_A(f), nsamp_a(f, i));
        // calculate agecomp offsets
        // multinomial
        if (Comp_Err_A(f) == 0)
        {
          if (gen_a(f, i) != 2)
          {
            offset_a(f, i) -= nsamp_a(f, i) *
                obs_a(f, i)(tails_a(f, i, 1), tails_a(f, i, 2)) * log(obs_a(f, i)(tails_a(f, i, 1), tails_a(f, i, 2)));
          }
          if (gen_a(f, i) >= 2 && gender == 2)
          {
            offset_a(f, i) -= nsamp_a(f, i) *
                obs_a(f, i)(tails_a(f, i, 3), tails_a(f, i, 4)) * log(obs_a(f, i)(tails_a(f, i, 3), tails_a(f, i, 4)));
          }
        }
        else if( (Comp_Err_A(f)==1) || (Comp_Err_A(f)==2) ) //  dirichlet
        {
          // Dirichlet-Multinomial (either 1 = linear, 2 = saturating)
          offset_a(f, i) = gammln(nsamp_a(f, i) + 1.);
          if (gen_a(f, i) != 2)
          {
            int z1 = tails_a(f, i, 1);
            int z2 = tails_a(f, i, 2);
            offset_a(f, i) -= sum(gammln(1. + nsamp_a(f, i) * obs_a(f, i)(z1, z2)));
          }
          if (gen_a(f, i) >= 2 && gender == 2)
          {
            int z1 = tails_a(f, i, 3);
            int z2 = tails_a(f, i, 4);
            offset_a(f, i) -= sum(gammln(1. + nsamp_a(f, i) * obs_a(f, i)(z1, z2)));
          }
        }
        else if( (Comp_Err_A(f)==3) ) //  MV Tweedie
        {
          // MV Tweedie has no offset, at least yet
        }

      }
  //   echoinput<<" agecomp offset "<<offset_a<<endl;
  echoinput << " age comp var adjust has been set-up " << endl;

  //  SS_Label_Info_6.2.6 #Do variance adjustment for mean size-at-age data
  if (nobs_ms_tot > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      for (i = 1; i <= Nobs_ms(f); i++)
        for (b = 1; b <= n_abins2; b++)
        {
          if (obs_ms_n(f, i, b) > 0)
          {
            obs_ms_n(f, i, b) = sqrt(var_adjust(6, f) * obs_ms_n(f, i, b));
            // if(obs_ms_n(f,i,b)<=1.0) obs_ms_n(f,i,b)=1.;                          //  adjust sample size
          }
        }
  }
  echoinput << " setup stderr for mean size-at-age: " << endl;

  //  SS_Label_Info_6.2.7 #Input variance adjustment for generalized size comp
  if (SzFreq_Nmeth > 0)
  {
    N_suprper_SzFreq = 0; // redo this counter so can use the counter

    in_superperiod = 0;
    for (iobs = 1; iobs <= SzFreq_totobs; iobs++)
    {
      f = abs(SzFreq_obs1(iobs, 4));
      y = abs(SzFreq_obs1(iobs, 2));
      if (var_adjust(7, f) != 1.0)
      {
        SzFreq_sampleN(iobs) *= var_adjust(7, f);
        //            if (SzFreq_sampleN(iobs) < 1.0) SzFreq_sampleN(iobs) = 1.;
      }
      k = SzFreq_obs_hdr(iobs, 6); //  get the method
      f = abs(SzFreq_obs_hdr(iobs, 3));
      s = SzFreq_obs_hdr(iobs, 2); // sign used to indicate start/stop of super period
      if (SzFreq_sampleN(iobs) > 0 && SzFreq_obs_hdr(iobs, 3) > 0)
      {
        z1 = SzFreq_obs_hdr(iobs, 7);
        z2 = SzFreq_obs_hdr(iobs, 8);
        g = SzFreq_LikeComponent(f, k);
        if (Comp_Err_Sz(k) == 0) // Multinomial
        {
          offset_Sz_tot(g) -= SzFreq_sampleN(iobs) * SzFreq_obs(iobs)(z1, z2) * log(SzFreq_obs(iobs)(z1, z2));
          SzFreq_each_offset(iobs) -= SzFreq_sampleN(iobs) * SzFreq_obs(iobs)(z1, z2) * log(SzFreq_obs(iobs)(z1, z2));
        }
        else if (Comp_Err_Sz(k) == 1 || Comp_Err_Sz(k) == 2 ) // Dirichlet
        {
          offset_Sz_tot(g) += gammln(SzFreq_sampleN(iobs) + 1.) - sum(gammln(1. + SzFreq_sampleN(iobs) * SzFreq_obs(iobs)(z1, z2)));
          SzFreq_each_offset(iobs) += gammln(SzFreq_sampleN(iobs) + 1.) - sum(gammln(1. + SzFreq_sampleN(iobs) * SzFreq_obs(iobs)(z1, z2)));
        }
        else if (Comp_Err_Sz(k) == 3)  //  MV Tweedie
        {
          //  MV Tweedie not available
        }
      }
      // identify super-period starts and stops
      if (s < 0) // start/stop a super-period  ALL observations must be continguous in the file
      {
        if (in_superperiod == 0)
        {
          N_suprper_SzFreq++;
          suprper_SzFreq_start(N_suprper_SzFreq) = iobs;
          in_superperiod = 1;
        }
        else if (in_superperiod == 1) // end a super-period
        {
          suprper_SzFreq_end(N_suprper_SzFreq) = iobs;
          in_superperiod = 0;
        }
      }
    }
    echoinput << " Sizefreq comp var adjust has been applied and offset calculated " << endl;

    if (N_suprper_SzFreq > 0)
    {
      echoinput << "sizefreq superperiod start obs: " << suprper_SzFreq_start << endl
                << "sizefreq superperiod end obs:   " << suprper_SzFreq_end << endl;

      echoinput << "Create superperiod sample weights for sizecomp obs " << endl
                << "Flt_num SuperP Obs_num Sample_N_read samp_wt" << endl;
      for (j = 1; j <= N_suprper_SzFreq; j++) // do each super period
      {
        temp = 1.0; //  relative sample weight for time period the accumulator observation
        k = 0; // count of samples with real information
        for (iobs = suprper_SzFreq_start(j); iobs <= suprper_SzFreq_end(j); iobs++) //  loop obs of this super period
        {
          if (SzFreq_obs_hdr(iobs, 3) < 0) //  so one of the obs to be combined
          {
            temp += SzFreq_sampleN(iobs);
          }
          else
          {
            k++;
          } //  so counts the obs that are not just placeholders
        }
        if (k != 1)
        {
          warnstream << "There must only be 1 sample with real info in sizecomp superperiod " << j;
          write_message (FATAL, 0); // EXIT!
        }
        for (iobs = suprper_SzFreq_start(j); iobs <= suprper_SzFreq_end(j); iobs++)
        {
          if (SzFreq_obs_hdr(iobs, 3) < 0) //  so one of the obs to be combined
          {
            suprper_SzFreq_sampwt(iobs) = SzFreq_sampleN(iobs) / value(temp);
          }
          else
          {
            suprper_SzFreq_sampwt(iobs) = 1.0 / value(temp);
          } //  for the element holding the combined observation
          echoinput << SzFreq_obs_hdr(iobs, 3) << " " << j << " " << iobs << " " << SzFreq_sampleN(iobs) << " " << suprper_SzFreq_sampwt(iobs) << endl;
        }
      }
    }
  }

  //  SS_Label_Info_6.4 #Conditionally copy the initial parameter values read from the "CTL" file into the parameter arrays
  //   skip this assignment if the parameters are being read from a "SS2.PAR" file

  if (readparfile == 0)
  {
    echoinput << " set parms to init values in CTL file " << endl;
    for (i = 1; i <= N_MGparm2; i++)
    {
      MGparm(i) = MGparm_RD(i);
    } //  set vector of initial natmort and growth parms
    echoinput << " MGparms read from ctl " << MGparm << endl;

    for (i = 1; i <= N_SRparm3; i++)
    {
      SRparm(i) = SRparm_RD(i);
    }
    echoinput << " SRR_parms read from ctl " << SRparm << endl;

    if (recdev_cycle > 0)
    {
      for (y = 1; y <= recdev_cycle; y++)
      {
        recdev_cycle_parm(y) = recdev_cycle_parm_RD(y, 3);
      }
    }

    if (recdev_do_early > 0) recdev_early.initialize();
    if (Do_Forecast > 0 && do_recdev != 0) Fcast_recruitments.initialize();
    if (Do_Impl_Error > 0) Fcast_impl_error.initialize();

    if (do_recdev == 1)
    {
      recdev1.initialize();
    } // set devs to zero
    else if (do_recdev >= 2)
    {
      recdev2.initialize();
    } // set devs to zero

    if (recdev_read > 0)
    {
      for (j = 1; j <= recdev_read; j++)
      {
        y = recdev_input(j, 1);
        if (y >= recdev_first && y <= YrMax)
        {
          if (y < recdev_start)
          {
            recdev_early(y) = recdev_input(j, 2);
          }
          else if (y <= recdev_end)
          {
            if (do_recdev == 1)
            {
              recdev1(y) = recdev_input(j, 2);
            }
            else if (do_recdev >= 2)
            {
              recdev2(y) = recdev_input(j, 2);
            }
          }
          else
          {
            Fcast_recruitments(y) = recdev_input(j, 2);
          }
        }
        else
        {
          warnstream << "Trying to specify a recdev out of allowable range of years " << y;
          write_message (WARN, 0);
        }
      }
    }
    echoinput << " rec_devs read from ctl ";
    if (do_recdev == 1)
      echoinput << recdev1 << endl;
    if (do_recdev >= 2)
      echoinput << recdev2 << endl;

    // **************************************************
    if (Q_Npar2 > 0)
    {
      for (i = 1; i <= Q_Npar2; i++)
      {
        Q_parm(i) = Q_parm_RD(i);
      } //  set vector of initial index Q parms
      echoinput << " Q_parms read from ctl " << Q_parm << endl;
    }

    if (N_init_F > 0)
    {
      for (i = 1; i <= N_init_F; i++)
  init_F(i) = init_F_RD(i); //  set vector of initial parms
      echoinput << " initF_parms read from ctl " << init_F << endl;
    }

    //SS_Label_Info_xxx setup F as parameters
    if (N_Fparm > 0)
    {
      if (readparfile == 0)
      {
        for (g = 1; g <= N_Fparm; g++)
        {
          f = Fparm_loc[g](1);
          t = Fparm_loc[g](2);
          if(catch_ret_obs(f,t) > 0.0) {
          F_rate(g) = F_parm_intval(f);
          Hrate(f, t) = F_parm_intval(f);
          }
        }

        if (F_detail > 0)
        {
          // note that detailed phase and catch_se have already been set in readcontrol
          for (k = 1; k <= F_detail; k++)
          {
            f = F_setup2(k, 1);
            y = F_setup2(k, 2);
            s = F_setup2(k, 3);
            if (y > 0)
            {
              y1 = y;
              y2 = y;
            }
            else
            {
              y1 = -y;
              y2 = endyr;
            }
            for (y = y1; y <= y2; y++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              g = do_Fparm_loc(f, t);
              if (g > 0)
              {
                F_rate(g) = F_setup2(k, 4);
                Hrate(f, t) = F_setup2(k, 4);
              }
            }
          }
        }
        echoinput << " Fmort_parms have been set according to F_detail input" << endl;
      }
      else
      {
        echoinput << " Fmort_parms obtained from ss.par " << endl;
      }
    }

    for (i = 1; i <= N_selparm2; i++)
      selparm(i) = selparm_RD(i); //  set vector of initial selex parms
    echoinput << " selex_parms read from ctl " << selparm << endl;

    if (Do_TG > 0)
    {
      k = Do_TG * (3 * N_TG + 2 * Nfleet1);
      for (i = 1; i <= k; i++)
      {
        TG_parm(i) = TG_parm2(i, 3);
      }
      echoinput << " Tag_parms read from ctl " << TG_parm << endl;
    }
    checksum999 = 999.;
  }
  else
  {
        echoinput << "checksum from par file "<<checksum999<<endl;
    if (checksum999 != 999.)
    {
          warnstream << "error on ss.par read; final value was not 999; total number parms changed  " << checksum999;
          write_message (FATAL, 1);
    }
  }

  //  SS_Label_Info_6.5 #Check parameter bounds and do jitter
  echoinput << endl
            << " now check MGparm bounds and priors and do jitter if requested " << endl;
  for (i = 1; i <= N_MGparm2; i++)
  {
    MGparm(i) = Check_Parm(i, MGparm_PH(i), MGparm_LO(i), MGparm_HI(i), MGparm_PRtype(i), MGparm_PR(i), MGparm_CV(i), jitter, MGparm(i));
  }
  echoinput << " MG_parms after check " << MGparm << endl;
  MGparm_use = value(MGparm);

  echoinput << endl
            << " now check SRparm bounds and priors and do jitter if requested " << endl;
  for (i = 1; i <= N_SRparm3; i++)
  {
    SRparm(i) = Check_Parm(i, SRparm_PH(i), SRparm_LO(i), SRparm_HI(i), SRparm_PRtype(i), SRparm_PR(i), SRparm_CV(i), jitter, SRparm(i));
  }
  echoinput << " SRR_parms after check " << SRparm << endl;
  SRparm_use = value(SRparm);

  recdev_use.initialize();
  if (recdev_cycle > 0)
  {
    echoinput << endl
              << " now check recdev_cycle bounds and priors and do jitter if requested " << endl;
    for (j = 1; j <= recdev_cycle; j++)
    {
      recdev_cycle_parm(j) = Check_Parm(j, recdev_cycle_PH(j), recdev_cycle_LO(j), recdev_cycle_HI(j), recdev_cycle_parm_RD(j, 6), recdev_cycle_parm_RD(j, 4), recdev_cycle_parm_RD(j, 5), jitter, recdev_cycle_parm(j));
    }
    echoinput << " recdev_cycle after check " << recdev_cycle_parm << endl;
    recdev_cycle_use = value(recdev_cycle_parm);
  }

  if (recdev_do_early > 0)
  {
    recdev_RD(recdev_early_start, recdev_early_end) = value(recdev_early(recdev_early_start, recdev_early_end));

    for (y = recdev_early_start; y <= recdev_early_end; y++)
    {
      recdev_early(y) = Check_Parm(y, recdev_early_PH, recdev_LO, recdev_HI, 0, 0., 1., jitter, recdev_early(y));
    }
    //      recdev_early -=sum(recdev_early)/(recdev_early_end-recdev_early_start+1);

    recdev_use(recdev_early_start, recdev_early_end) = value(recdev_early(recdev_early_start, recdev_early_end));
  }

  if (recdev_PH > 0 && do_recdev > 0)
  {
    echoinput << endl
              << " now check recdev bounds and priors and do jitter if requested " << endl;
    if (do_recdev == 1)
    {
      recdev_RD(recdev_start, recdev_end) = value(recdev1(recdev_start, recdev_end));
      for (i = recdev_start; i <= recdev_end; i++)
      {
        recdev1(i) = Check_Parm(i, recdev_PH, recdev_LO, recdev_HI, 0, 0., 1., jitter, recdev1(i));
      }
      recdev1 -= sum(recdev1) / (recdev_end - recdev_start + 1);
      recdev_use(recdev_start, recdev_end) = value(recdev1(recdev_start, recdev_end));
    }
    else
    {
      recdev_RD(recdev_start, recdev_end) = value(recdev2(recdev_start, recdev_end));
      for (i = recdev_start; i <= recdev_end; i++)
      {
        recdev2(i) = Check_Parm(i, recdev_PH, recdev_LO, recdev_HI, 0, 0., 1., jitter, recdev2(i));
      }
      //        recdev2 -=sum(recdev2)/(recdev_end-recdev_start+1);
      recdev_use(recdev_start, recdev_end) = value(recdev2(recdev_start, recdev_end));
    }
  }

  if (Do_Forecast >= 0 && do_recdev > 0)
  {
    recdev_RD(recdev_end + 1, YrMax) = value(Fcast_recruitments(recdev_end + 1, YrMax));
    recdev_use(recdev_end + 1, YrMax) = value(Fcast_recruitments(recdev_end + 1, YrMax));
  }

  echoinput << " rec_devs after check " << recdev_use << endl;

  if (Q_Npar2 > 0)
  {
    echoinput << endl
              << " now check Qparm bounds and priors and do jitter if requested " << endl;
    for (i = 1; i <= Q_Npar2; i++)
    {
      Q_parm(i) = Check_Parm(i, Q_parm_PH(i), Q_parm_LO(i), Q_parm_HI(i), Q_parm_PRtype(i), Q_parm_PR(i), Q_parm_CV(i), jitter, Q_parm(i));
    }
    echoinput << " Q_parms after check " << Q_parm << endl;
    Q_parm_use = value(Q_parm);
  }

  if (N_init_F > 0)
  {
    echoinput << endl
              << " now check init_F parm bounds and priors and do jitter if requested " << endl;
    for (i = 1; i <= N_init_F; i++)
    {
  init_F(i) = Check_Parm(i, init_F_PH(i), init_F_LO(i), init_F_HI(i), init_F_PRtype(i), init_F_PR(i), init_F_CV(i), jitter, init_F(i));
    }
    echoinput << " initF_parms after check " << init_F << endl;
  init_F_use = value(init_F);
  }

  if (N_Fparm > 0)
  {
    echoinput << endl
              << " now check F parm bounds and priors and do jitter if requested " << endl;
    for (i = 1; i <= N_Fparm; i++)
    {
      {
        F_rate(i) = Check_Parm(i, Fparm_PH[i], 0., max_harvest_rate, 0, 0.05, 1., jitter, F_rate(i));
      }
    }
    echoinput << " F_parms after check " << F_rate << endl;
    Fparm_use = value(F_rate);
  }

  if (N_selparm2 > 0)
  {
    echoinput << endl
              << " now check sel_parm bounds and priors and do jitter if requested " << endl;
    for (i = 1; i <= N_selparm2; i++)
    {
      selparm(i) = Check_Parm(i, selparm_PH(i), selparm_LO(i), selparm_HI(i), selparm_PRtype(i), selparm_PR(i), selparm_CV(i), jitter, selparm(i));
    }
    echoinput << " selex_parms after check  " << selparm << endl;
    selparm_use = value(selparm);
  }

  if (Do_TG > 0)
  {
    echoinput << endl
              << " now check TAG parm bounds and priors and do jitter if requested " << endl;
    k = Do_TG * (3 * N_TG + 2 * Nfleet1);
    for (i = 1; i <= k; i++)
    {
      {
        TG_parm(i) = Check_Parm(i, TG_parm_PH(i), TG_parm_LO(i), TG_parm_HI(i), TG_parm2(i, 6), TG_parm2(i, 4), TG_parm2(i, 5), jitter, TG_parm(i));
      }
    }
    echoinput << " Tag_parms after check  " << TG_parm << endl;
    TG_parm_use = value(TG_parm);
  }

  if (N_parm_dev > 0)
  {
    echoinput << endl
              << " now check parmdev bounds and priors and do jitter if requested " << endl;
    for (i = 1; i <= N_parm_dev; i++)
      for (j = parm_dev_minyr(i); j <= parm_dev_maxyr(i); j++)
      {
        parm_dev_RD(i, j) = value(parm_dev(i, j));
      }

    for (i = 1; i <= N_parm_dev; i++)
      if (parm_dev_PH(i) > 0)
        for (j = parm_dev_minyr(i); j <= parm_dev_maxyr(i); j++)
        {
          parm_dev(i, j) = Check_Parm(j, parm_dev_PH(i), -10, 10, 0, 0., 1., jitter, parm_dev(i, j));
        }
    for (i = 1; i <= N_parm_dev; i++)
      for (j = parm_dev_minyr(i); j <= parm_dev_maxyr(i); j++)
      {
        parm_dev_use(i, j) = value(parm_dev(i, j));
      }
    echoinput << " parm_devs after check  " << parm_dev_use << endl;
  }
  //  end bound check and jitter
  if (Do_all_priors == 0 && prior_ignore_warning > 0)
  {
    warnstream << "Setting in starter does not request all priors, and " << prior_ignore_warning << " parameters have priors and are not estimated, so their prior not included in obj_fun.";
    write_message (WARN, 0);
  }
  if (TwoD_AR_cnt > 0)
  {
    //  create correlation matrix for 2D_AR approaches
    //  TwoD_AR_def:  1-fleet, 2-ymin, 3-ymax, 4-amin, 5-amax, 6-sigma_amax, 7-use_rho, 8-age/len, 9-dev_phase
    //  10-mindimension, 11=maxdim, 12-N_parm_dev, 13-selparm_location
    cor.initialize();
    det_cor = 1.0;
    inv_cor.initialize();

    for (f = 1; f <= TwoD_AR_cnt; f++)
    {
      double rho_a;
      double rho_y;
      //  location in selparm of rho
      if (TwoD_AR_def[f](7) == 0)
      {
        echoinput << "fleet: " << f << " no 2D_AR rho " << endl;
      }
      else
      {
        if (TwoD_AR_def[f](6) < 0)
        {
          j = TwoD_AR_def[f](13) + 1;
        }
        else
        {
          j = TwoD_AR_def[f](13) + TwoD_AR_def[f](6) - TwoD_AR_def[f](4) + 1;
        } //  first sigmalocation + other sigmasels, then the rho's
        rho_y = value(selparm(j));
        rho_a = value(selparm(j + 1));
        echoinput << "fleet: " << f << " 2D_AR rho in prelim for time and age/size " << rho_y << " " << rho_a << endl;
        for (int i = TwoD_AR_ymin(f); i <= TwoD_AR_ymax(f); i++)
        {
          for (int j = TwoD_AR_amin(f); j <= TwoD_AR_amax(f); j++)
          {
            for (int m = TwoD_AR_ymin(f); m <= TwoD_AR_ymax(f); m++)
            {
              for (int n = TwoD_AR_amin(f); n <= TwoD_AR_amax(f); n++)
              {
                cor(f, (TwoD_AR_amax(f) - TwoD_AR_amin(f) + 1) * (i - TwoD_AR_ymin(f)) + j - TwoD_AR_amin(f) + 1,
                    (TwoD_AR_amax(f) - TwoD_AR_amin(f) + 1) * (m - TwoD_AR_ymin(f)) + n - TwoD_AR_amin(f) + 1) = pow(rho_a, abs(j - n)) * pow(rho_y, abs(i - m));
              }
            }
          }
        }
        inv_cor(f) = inv(cor(f));
        det_cor(f) = det(cor(f));
        echoinput << "determinant for 2D_AR cor: " << f << "  is: " << det_cor(f) << endl;
      }
    }
  }
  //  SS_Label_Info_6.6 #Copy the environmental data as read into the dmatrix environmental data array
  //  this will allow dynamic derived quantities like biomass and recruitment to be mapped into this same dmatrix

  env_data.initialize();

  if (N_envdata > 0)
  {
    //  raw input is in vector vector env_temp
    //  the fields are yr, envvar, value
    //  yr=-2 instructs SS3 to subtract mean before storing
    //  yr=-1 instructs SS3 to subtract mean and divide by stddev

    //  first pass to calculate means and other summary data
    for (i = 0; i <= N_envdata - 1; i++)
    {
      y = env_temp[i](1);
      if (y >= (styr - 1) && y <= YrMax)
      {
        k = env_temp[i](2);
        double val = env_temp[i](3);
        env_data(y, k) = val;
        if (env_data_do_mean(k) == 1)
          env_data(y, k) -= env_data_mean(k);
        if (env_data_do_stdev(k) == 1)
          env_data(y, k) /= env_data_stdev(k);
      }
    }
    echoinput << " env matrix after processing" << endl
              << env_data << endl;
  }

  //  SS_Label_Info_6.7 #Initialize several rebuilding items
  if (Rebuild_Ydecl == -1)
    Rebuild_Ydecl = 1999;
  if (Rebuild_Yinit == -1)
    Rebuild_Yinit = endyr + 1;

  if (Rebuild_Ydecl > YrMax)
    Rebuild_Ydecl = YrMax;
  if (Rebuild_Yinit > YrMax)
    Rebuild_Yinit = YrMax;

  migrrate.initialize();
  depletion.initialize();
  natage.initialize();
  sel_l.initialize();
  sel_a.initialize();
  retain.initialize();
  discmort.initialize();
  discmort2.initialize();
  discmort2_a.initialize();

  for (f = 1; f <= Nfleet; f++)
    for (y = styr; y <= YrMax; y++)
      for (gg = 1; gg <= gender; gg++)
      {
        discmort2(y, f, gg) = 1.0;
        discmort(y, f) = 1.0;
        discmort_a(y, f) = 1.0;
        retain(y, f) = 1.0;
      }
  Richards = 1.0;

  //  check data against settings for inconsistencies
  // check for composition obs with partition =1 or =2; use a new summary of obs by partition type for this test
  ivector parti_cnt(0, 2);
  for (f = 1; f <= Nfleet; f++)
  {
    // check for discard obs
    if (disc_N_fleet(f) > 0 && Do_Retain(f) == 0)
    {
      warnstream << "Fleet: " << f << "  discard data exist but retention fxn not defined";
      write_message (FATAL, 0); // EXIT!
    }

    parti_cnt.initialize();
    if (Nobs_l(f) > 0)
    {
      for (i = 1; i <= Nobs_l(f); i++)
      {
        parti_cnt(abs(mkt_l(f, i)))++;
        if (Do_Retain(f) == 0) mkt_l(f,i) = 0;  //  force to partition 0 if retention not defined
      }
      if (parti_cnt(1) > 0 && Do_Retain(f) == 0)
      {
        warnstream << "Fleet: " << f << "  lencomp contains N obs with partition==1 and retention fxn not defined; N= " << parti_cnt(1);
        write_message (FATAL, 0); // EXIT!
      }
      if (parti_cnt(2) > 0 && Do_Retain(f) == 0)
      {
        warnstream <<  "fleet: " << f << " lencomp has N obs with partition==2 (retained); changed to partition=0 because retention not defined; N= " << parti_cnt(2);
        write_message (WARN, 0);
      }
      if (parti_cnt(2) > 0 && (fleet_type(f) == 2 || seltype(f, 2) == 3 || seltype(Nfleet + f, 2) == 3)) //  error if retained catch obs are with no retention fleets
      {
        warnstream << "Fleet: " << f << "  lencomp has obs with partition==2; but fleet does not retain any catch; N= " << parti_cnt(2);
        write_message (FATAL, 0); // EXIT!
      }
    }

    parti_cnt.initialize();
    if (Nobs_a(f) > 0)
    {
      for (i = 1; i <= Nobs_a(f); i++)
      {
        parti_cnt(abs(mkt_a(f, i)))++;
        if (Do_Retain(f) == 0) mkt_a(f,i) = 0;  //  force to partition 0 if retention not defined
      }
      if (parti_cnt(1) > 0 && Do_Retain(f) == 0)
      {
        warnstream << "Fleet: " << f << "  agecomp contains N obs with partition==1 and retention fxn not defined; N= " << parti_cnt(1);
        write_message (FATAL, 0); // EXIT!
      }
      if (parti_cnt(2) > 0 && Do_Retain(f) == 0)
      {
        warnstream << "Fleet: " << f << "  agecomp has N obs with partition==2 (retained); changed to partition=0 because retention not defined; N= " << parti_cnt(2);
        write_message (ADJUST, 0);
      }
      if (parti_cnt(2) > 0 && (fleet_type(f) == 2 || seltype(f, 2) == 3 || seltype(Nfleet + f, 2) == 3)) //  error if retained catch obs are with no retention fleets
      {
        warnstream << "Fleet: " << f << "  agecomp has obs with partition==2; but fleet does not retain any catch; N= " << parti_cnt(2);
        write_message (FATAL, 0); // EXIT!
      }
    }

    parti_cnt.initialize();
    if (Nobs_ms(f) > 0)
    {
      for (i = 1; i <= Nobs_ms(f); i++)
      {
        parti_cnt(abs(mkt_ms(f, i)))++;
        if (Do_Retain(f) == 0) mkt_ms(f, i) = 0;  //  force to partition 0 if retention not defined
    }
      if (parti_cnt(1) > 0 && Do_Retain(f) == 0)
      {
        warnstream << "Fleet: " << f << "  size-at-age data contains obs with partition==1 and retention fxn not defined; N= " << parti_cnt(1);
        write_message (FATAL, 0); // EXIT!
      }
      if (parti_cnt(2) > 0 && Do_Retain(f) == 0)
      {
        warnstream << "Fleet: " << f << "  size-at-age data has N obs with partition==2 (retained); changed to partition=0 because retention not defined; N= " << parti_cnt(2);
        write_message (ADJUST, 0);
      }
      if (parti_cnt(2) > 0 && (fleet_type(f) == 2 || seltype(f, 2) == 3 || seltype(Nfleet + f, 2) == 3)) //  error if retained catch obs are with no retention fleets
      {
        warnstream << "Fleet: " << f << " EXIT; size-at-age data has obs with partition==2; but fleet does not retain any catch; N= " << parti_cnt(2);
        write_message (FATAL, 0); // EXIT!
      }
    }

    parti_cnt.initialize();
    if (nobs_mnwt > 0)
    {
      for (i = 1; i <= nobs_mnwt; i++)
      {
        int f1 = mnwtdata(3, i);
        if (f1 == f)
        {
          int parti = abs(mnwtdata(4, i)); //  partition:  0=all, 1=discard, 2=retained
          parti_cnt(parti)++;
          if (Do_Retain(f) == 0) mnwtdata(4, i) = 0;  //  force to partition 0 if retention not defined
        }
      }
      if (parti_cnt(1) > 0 && Do_Retain(f) == 0)
      {
        warnstream << "Fleet: " << f << "  meansize data contains obs with partition==1 and retention fxn not defined; N= " << parti_cnt(1);
        write_message (FATAL, 0); // EXIT!
      }
      if (parti_cnt(2) > 0 && Do_Retain(f) == 0)
      {
        warnstream << "Fleet: " << f << "  meansize data has N obs with partition==2 (retained); changed to partition=0 because retention not defined; N= " << parti_cnt(2);
        write_message (ADJUST, 0);
      }
      if (parti_cnt(2) > 0 && (fleet_type(f) == 2 || seltype(f, 2) == 3 || seltype(Nfleet + f, 2) == 3)) //  error if retained catch obs are with no retention fleets
      {
        warnstream << "Fleet: " << f << " EXIT; meansize data has obs with partition==2; but fleet does not retain any catch; N= " << parti_cnt(2);
        write_message (FATAL, 0); // EXIT!
      }
    }
  }

  //  SS_Label_Info_6.8 #Go thru biological calculations once, with do_once flag=1 to produce extra output to echoinput.sso
  cout << "Evaluating biology calculations once ... ";
  echoinput << "Begin evaluating biology calculations once" << endl;
  ALK_subseas_update = 1; //  vector to indicate if ALK needs recalculating
  do_once = 1;
  niter = 0;
  y = styr;
  yz = styr;
  t_base = styr + (y - styr) * nseas - 1;

  make_timevaryparm();

  //  SS_Label_Info_6.8.1 #Call fxn get_MGsetup() to copy MGparms to working array and applies time-varying factors
  get_MGsetup(styr);
  echoinput << "Finished MGsetup" << endl;

  //  SS_Label_Info_6.8.2 #Call fxn get_growth1() to calculate quantities that are not time-varying
  get_growth1();
  echoinput << "Finished growth1" << endl;
  VBK_seas = value(VBK_seas);
  wtlen_seas = value(wtlen_seas);
  CVLmin = value(CVLmin);
  CVLmax = value(CVLmax);

  //  SS_Label_Info_6.8.3 #Call fxn get_growth2() to calculate size-at-age
  get_growth2(styr); //   in preliminary calcs
  gp = 0;
  for (gg = 1; gg <= gender; gg++)
    for (int GPat = 1; GPat <= N_GP; GPat++)
    {
      gp++;
      g = g_Start(gp); //  base platoon
      for (settle = 1; settle <= N_settle_timings; settle++)
      {
        g += N_platoon;
        echoinput << "sex: " << gg << "; Gpat: " << GPat << " settle: " << settle << "; L-at-Amin: " << Lmin(gp) << "; L at max age: " << Ave_Size(styr, 1, g, nages) << endl;
        if (len_bins(1) > Lmin(gp))
        {
          warnstream << "Minimum pop size bin:_" << len_bins(1) << "; is > L at Amin for sex: " << gg
                  << "; Gpat: " << GPat << "; L= " << Lmin(gp);
          write_message (WARN, 0);
        }
        if (Ave_Size(styr, 1, g, nages) > 0.95 * len_bins(nlength))
        {
          warnstream << "Maximum pop size bin:_" << len_bins(nlength) << "; is within 5% of L at maxage for sex: " << gg
                  << "; Gpat: " << GPat << " settle: " << settle << "; L= " << Ave_Size(styr, 1, g, nages);
          write_message (WARN, 0);
        }
      }
    }

  for (s = 1; s <= nseas; s++) //  get growth here in case needed for Lorenzen
  {
    t = t_base + s;
    for (subseas = 1; subseas <= N_subseas; subseas++)
    {
      ALK_idx = (s - 1) * N_subseas + subseas;
      get_growth3(styr, t, s, subseas); //  this will calculate the growth for all subseasons of first year
      Make_AgeLength_Key(s, subseas); //  ALK_idx calculated within Make_AgeLength_Key
      ALK(ALK_idx) = value(ALK(ALK_idx));
    }
  }

  //  SS_Label_Info_6.8.5 #Call fxn get_wtlen() and get_mat_fec() to calculate weight-at-length and maturity and fecundity vectors
  get_wtlen();
  get_mat_fec();
  wt_len = value(wt_len);
  wt_len2 = value(wt_len2);
  wt_len_fd = value(wt_len_fd);
  mat_len = value(mat_len);
  mat_fec_len = value(mat_fec_len);
  mat_age = value(mat_age);

  //  SS_Label_Info_6.8.4 #Call fxn get_natmort()
  echoinput << "ready to do natmort " << endl;
  get_natmort();

  s = spawn_seas;
  subseas = spawn_subseas;
  ALK_idx = (s - 1) * N_subseas + subseas;

  //  SS_Label_Info_6.8.6 #Call fxn get_recr_distribution() for distribution of recruitment among areas and seasons, which can be time-varying
  echoinput << "do recrdist: " << endl;
  get_recr_distribution();
  recr_dist(y) = value(recr_dist(y)); //  so the just calculated constant values will be used unless its parms are active

  //  SS_Label_Info_6.8.7 #Call fxn get_migration()
  if (do_migration > 0) // set up migration rates
  {
    get_migration();
    migrrate = value(migrrate);
  }

  //  SS_Label_Info_6.8.8 #Call fxn get_age_age()  transition matrix from real age to observed age'
  if (N_ageerr > 0)
  {
    AgeKey_StartAge = 0;
    AgeKey_Linear1 = 1;
    AgeKey_Linear2 = 1;
    for (j = 1; j <= N_ageerr; j++)
    {
      if (j != Use_AgeKeyZero)
      {
        age_err(j) = age_err_rd(j); //  this is an age err definition that has been read
      }
      else
      {
        AgeKey_StartAge = int(value(mgp_adj(AgeKeyParm)));
        if (mgp_adj(AgeKeyParm + 3) == 0.0000)
        {
          AgeKey_Linear1 = 1;
        }
        else
        {
          AgeKey_Linear1 = 0;
        }
        if (mgp_adj(AgeKeyParm + 6) == 0.0000)
        {
          AgeKey_Linear2 = 1;
        }
        else
        {
          AgeKey_Linear2 = 0;
        }
      }
      get_age_age(j, AgeKey_StartAge, AgeKey_Linear1, AgeKey_Linear2); //  call function to get the age_age key
    }
    age_age = value(age_age); //   because these are not based on parameters
  }
  echoinput << " made the age_age' key " << endl;

  if (catch_mult_pointer > 0)
  {
    get_catch_mult(y, catch_mult_pointer);
    for (j = styr; j <= YrMax; j++) //  so get this value for all years, but can be overwritten by time-varying
    {
      catch_mult(j) = catch_mult(y);
    }
  }

  //  SS_Label_Info_6.8.9 #Calculated values have been set equal to value() to remove derivative info and save space if their parameters are held constant

  //  SS_Label_Info_6.9 #Set up headers for ParmTrace
  if (Do_ParmTrace > 0)
    ParmTrace << "Phase Iter ObjFun Change SSB_start SSB_end BiasAdj_st BiasAdj_max BiasAdj_end ";
  if (Do_ParmTrace == 1 || Do_ParmTrace == 4)
  {
    for (i = 1; i <= active_count; i++)
    {
      ParmTrace << " " << ParmLabel(active_parm(i));
    }
    ParmTrace << " Component_like_starts_here ";
  }
  else if (Do_ParmTrace >= 2)
  {
    for (i = 1; i <= ParCount; i++)
    {
      ParmTrace << " " << ParmLabel(i);
    }
  }
  ParmTrace << endl;

  //  SS_Label_Info_6.10 #Preliminary calcs done; Ready for estimation
  cout << "done" << endl; // evaluating biology calculations once
  echoinput << "Finished evaluating biology calculations once" << endl;

  if (pick_report_use(60) == "Y")
  {
    bodywtout << nages << " # maxage" << endl;
    bodywtout << "# if Yr is negative, then fill remaining years for that Seas, growpattern, Bio_Pattern, Fleet" << endl;
    bodywtout << "# if season is negative, then fill remaining fleets for that Seas, Bio_Pattern, Sex, Fleet" << endl;
    bodywtout << "# will fill through forecast years, so be careful" << endl;
    bodywtout << "# fleet 0 contains begin season pop WT" << endl;
    bodywtout << "# fleet -1 contains mid season pop WT" << endl;
    bodywtout << "# fleet -2 contains maturity*fecundity" << endl;
    bodywtout << "#_year seas sex bio_pattern birthseas fleet " << age_vector << endl;
  }

  if (Turn_off_phase < 0)
  {
    cout << "Exit requested after read with phase < 0 " << endl;
    N_nudata = 1;
    write_nudata();
    cout << "Finished writing data_echo.ss_new" << endl;
    write_nucontrol();
    cout << "Finished writing control.ss_new" << endl;
    exit(1);
  }

  if (noest_flag == 1)
  {
    cout << endl
         << "skip to final section for -noest" << endl;
    N_nudata = 1;
  }
  else
  {
    echoinput << endl << endl << "Begin estimating" << endl;
  }
  last_objfun = 1.0e30;
  } // end PRELIMINARY_CALCS_SECTION
// SS_Label_file  #7. **SS_global.tpl**
// SS_Label_file  # - <div style="color: #ff0000">RUNTIME_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - not used by SS3
// SS_Label_file  # - <div style="color: #ff0000">TOP_OF_MAIN_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - revise some memory and array constraints
// SS_Label_file  # - <div style="color: #ff0000">GLOBALS_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - open some output files
// SS_Label_file  #     - create needed adstring_arrays for labels
// SS_Label_file  #     - create vector_vector arrays that are appended to in readdata
// SS_Label_file  #     - two functions included here in GLOBALS because need to be used in the DATA_SECTION:
// SS_Label_file  #         - <u>get_data_timing()</u> and   <u>create_timevary()</u>
// SS_Label_file  # - <div style="color: #ff0000">BETWEEN_PHASES_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - for F_method 2, convert F as scaling factors to F as parameters in designated phase
// SS_Label_file  # - <div style="color: #ff0000">FINAL_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - output *covar.sso*
// SS_Label_file  #     - set save_for_report to 1, then call: <u>setup_recdevs()</u>, <u>get_initial_conditions()</u>, <u>get_time_series()</u>, <u>evaluate_the_objective_function()</u>
// SS_Label_file  #
// SS_Label_file  #     - call benchmark and forecast if not already done in sdphase
// SS_Label_file  #     - <u>call Process_STDquant()</u> and <u>get_posteriors()</u>
// SS_Label_file  #     - write other reports using function calls: *cumreport.sso*, *ss_summary.sso*, *ss_rebuild.sso*, *SIS_table.sso*
// SS_Label_file  #     - call write_big_output() to produce *report.sso* and *compreport.sso*
// SS_Label_file  # - <div style="color: #ff0000">REPORT_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - produces *ss.rep*, but see write_big_output for the more complete *report.sso*
// SS_Label_file  #

//  SS_Label_Section_8 #RUNTIME_SECTION (not used in SS3)
RUNTIME_SECTION
//  {
//  maximum_function_evaluations 200, 200, 200, 200, 200, 200, 200, 2000;
//  convergence_criteria 100, 10, 1, 0.1, 1e-4, 1e-4, 1e-4, 1e-4;
//  }

//  SS_Label_Section_9 #TOP_OF_MAIN_SECTION
TOP_OF_MAIN_SECTION
//  {
//  SS_Label_Info_9.1 #Set array and gradient structure space
  arrmblsize = 200000000; // 2e8 = about 0.2 GB.
//  gradient_structure::set_GRADSTACK_BUFFER_SIZE(672647168);
  gradient_structure::set_GRADSTACK_BUFFER_SIZE(20000000); // 2e7 gets multiplied by the gradstack size (usually 48), to reach about 0.9 GB.
//  gradstack is not allocated unless needed by the model, but arrmblsize and cmpdif are allocated immediately
//  gradient_structure::set_CMPDIF_BUFFER_SIZE(500000000);
  gradient_structure::set_CMPDIF_BUFFER_SIZE(200000000); // 2e8 = about 0.2GB
  gradient_structure::set_MAX_NVAR_OFFSET(5000);
  gradient_structure::set_NUM_DEPENDENT_VARIABLES(10000);
  gradient_structure::set_MAX_DLINKS(10000000);

//  SS_Label_Info_9.2 #Set clock start time
  time(&start); //this is to see how long it takes to run
//  }

//  SS_Label_Section_10. #GLOBALS_SECTION
GLOBALS_SECTION
//  {
  #include <admodel.h>
  #include <time.h>
  #include <fvar.hpp>
  #include <vector>
  #include <iostream>
  #include <sstream>
    #define NOTE    1 // information that could be useful
    #define SUGGEST 2 // a possible better way
    #define PERFORM 3 // can help performance
    #define WARN    4 // might be a problem, execution continues anyway
    #define ADJUST  5 // adjustment has been made, execution continues
    #define FATAL   6 // major problem, program will exit
    adstring_array MessageIntro;
  #include <sys/types.h>
  #include <sys/stat.h>


  time_t start, finish;
  long hour, minute, second;
  double elapsed_time;

//  SS_Label_Info_10.2 #Define some adstring variables
  adstring_array ParmLabel; // extendable array to hold the parameter labels
  adstring_array Parm_info; // extendable array to hold the parameter labels
  adstring_array SzFreq_units_label;
  adstring_array SzFreq_scale_label;
  adstring_array fleetname;
  adstring ssnew_pathname;
  adstring sso_pathname;
  adstring base_modelname = "ss3";
  adstring fleetnameread;
  adstring depletion_basis_label;
  adstring F_report_label;
  adstring SPR_report_label;
  adstring onenum(4);
  adstring onenum2(4);
  adstring anystring;
  adstring anystring2;
  adstring report_sso_filename;
  adstring MSY_name; // label describing what Do_MSY and MSY_units are being used

  adstring_array version_info;
  adstring_array version_info2;
  adstring_array Starter_Comments;
  adstring_array Data_Comments;
  adstring_array Control_Comments;
  adstring_array Forecast_Comments;
  adstring_array NumLbl; // label for numbers 1 to 199
  adstring_array NumLbl0; // label for numbers 0 to 198 (needed for ages)
  adstring_array GenderLbl; // gender label
  adstring_array MGtype_Lbl; // label for MGtypes, i.e. Natmort, Growth
  adstring_array GP_Lbl; // gender label
  adstring_array CRLF; // blank to terminate lines
  adstring_array pick_report_name; //  name of report
  adstring_array pick_report_use; //  X if used; 0 if not

//  SS_Label_Info_10.1 #Open output files using ofstream
  ofstream warning; // warning.sso - where warnings, notes, etc. are put
  ofstream echoinput; // echoes input (for debugging) and includes some comments
  ofstream ParmTrace;
  ofstream report5; // forecast-report
  ofstream report2; // control.ss_new
  ofstream bodywtout;
  ofstream SS2out; // this is just a create
  ofstream SS_compout; // this is just a create
  ofstream report1; // for data output files
  ofstream covarout;
  ofstream rebuilder;
  ofstream rebuild_dat;
  ofstream posts;
  ofstream der_posts;
  ofstream post_vecs;
  ofstream post_obj_func;
  ofstream SS_smry;
  ofstream SIS_table;
//  declare some entities that need global access
  std::stringstream warnstream;
  std::string usermsg;
  int ParCount;
  int timevary_parm_cnt;
  int N_warn = 0; // track the number of warnings and adjustments
  int N_note = 0; // track the number of suggestions and notes
  int styr;
  int endyr;
  int YrMax;
  int nseas;
  int Ncycle;
  int seas_as_year;
  int special_flag = 0; //  for whenever a flag is needed

//  SS_Label_Info_10.3  #start random number generator with seed based on time
  random_number_generator radm(long(time(&start)));

  std::vector<int> Parm_minmax;
  std::vector<dvector> catch_read;
  std::vector<dvector> Svy_data;
  std::vector<dvector> discdata;
  std::vector<dvector> mnwtdata1;
  std::vector<dvector> lendata;
  std::vector<dvector> Age_Data;
  std::vector<dvector> sizeAge_Data;
  std::vector<dvector> H4010_scale_vec_rd;
  std::vector<dvector> Fcast_InputCatch_list;
  std::vector<dvector> Fcast_Catch_Allocation_list;
  std::vector<dvector> env_temp;
  std::vector<dvector> WTage_in;
  std::vector<dvector> var_adjust_data;
  std::vector<dvector> lambda_change_data;
  std::vector<dvector> timevary_parm_rd;
  std::vector<ivector> timevary_def;
  std::vector<ivector> TwoD_AR_def;
  std::vector<ivector> TwoD_AR_def_rd;
  std::vector<ivector> reportdetail_list;
  std::vector<ivector> Fparm_loc;
  std::vector<dvector> F_Method_4_input;
  std::vector<dvector> F_detail_input;
  std::vector<int> Fparm_PH;
  std::vector<dvector> comp_control_L;
  std::vector<dvector> comp_control_A;
  std::vector<dvector> comp_control_Sz;
  std::vector<dvector> fcast_mgparm_ave_rd;
  
//  function in GLOBALS to do the timing setup in the data section

// SS_Label_Function_xxxa write_msg(string,int,int,int); output a message.
// options are output the string to echoinput.sso and warning.sso with an option to exit
// SS_Label_Function_xxxa # ### write_msg (string, echoflag, warnflag, exitflag)
// SS_Label_Function_xxxa # 
// SS_Label_Function_xxxa # Writes a string to either echoinput.sso or warning.sso 
// SS_Label_Function_xxxa # or both. The last option tells it to exit the program
// SS_Label_Function_xxxa # with appropriate output to warning.sso and cout.
// SS_Label_Function_xxxa # 
  void write_msg(std::string msg, int echo, int warn, int exitflag)
  {
    std::string totmsg;
    if (msg.length() == 0)
    {
      msg = "unknown message";
    }

    if (echo == 1)
    {
      echoinput << msg << endl;
    }
    if (warn > 0)
    {
      size_t b = msg.find ("parameter", 0);
      warning << msg;
      if (echo == 1 && (b > 0 && b < msg.size()))
      {
        warning << "; search for <now check> in echoinput.sso for parm_type";
      }
      warning << endl;
    }
    if (exitflag == 1)
    {
      warning.close();
      echoinput.close();
      cout << msg << endl;
      cout << "Also see warning.sso" << endl;
      cout << "Exiting SS3! " << endl;
      exit(1);
    }
  }
// SS_Label_Function_xxxb write_message(int,int,int); increment warning count and output a warning with an option to exit (when fatal)
// SS_Label_Function_xxxb # ### write_message (type, echo)
// SS_Label_Function_xxxb # 
// SS_Label_Function_xxxb # type is one of the following:
// SS_Label_Function_xxxb # - NOTE    : information that could be useful
// SS_Label_Function_xxxb # - SUGGEST : a possible better way
// SS_Label_Function_xxxb # - PERFORM : can help performance
// SS_Label_Function_xxxb # - WARN    : might be a problem, execution continues anyway
// SS_Label_Function_xxxb # - ADJUST  : adjustment has been made, execution continues
// SS_Label_Function_xxxb # - FATAL   : major problem, program will exit
// SS_Label_Function_xxxb # 
// SS_Label_Function_xxxb # and echo is either 1 to write to echoinput.sso or 0.
// SS_Label_Function_xxxb # 
// SS_Label_Function_xxxb # This writes the text in warnstream and resets it.
// SS_Label_Function_xxxb # 
  void write_message(int type, int echo)
  {
    int exitflag = 0;
    int warn = 0;
    std::string msg(warnstream.str());
    warnstream.str("");
    if (msg.length() == 0)
      msg = "unknown condition.";

    switch (type)
    {
      case NOTE:
      case SUGGEST:
      case PERFORM:
        N_note++;
        warn = N_note;
        warnstream << "Note " << N_note;
        break;
      case FATAL:
        exitflag = 1;
	[[fallthrough]];
      case ADJUST:
      case WARN:
        N_warn++;
        warn = N_warn;
        warnstream << "Warning " << N_warn;
        break;
    }
    warnstream << MessageIntro(type) << msg;
    write_msg(warnstream.str(), echo, warn, exitflag);
    warnstream.str("");
  }

// SS_Label_Function_xxxx  #get_data_timing()  called by readdata
  void get_data_timing(const dvector& to_process, const ivector& timing_constants, ivector i_result, dvector r_result, const dvector& seasdur, const dvector& subseasdur_delta, const dvector& azero_seas, const dvector& surveytime)
  {
  // r_result(1,3) will contain: real_month, data_timing_seas, data_timing_yr,
  // i_result(1,6) will contain y, t, s, f, ALK_time, use_midseas
  int f, s, subseas, y;
  double temp, temp1, month, data_timing_seas;
  //  timing_constants(1)=read_seas_mo;
  //  timing_constants(2)=nseas;
  //  timing_constants(3)=N_subseas;
  //  timing_constants(4)=mid_subseas;
  //  timing_constants(5)=styr;
  //  timing_constants(6)-endyr;

  y = int(to_process(1));
  month = fabs(to_process(2));
  f = abs(int(to_process(3)));
  if (timing_constants(1) == 1) // reading season
  {
    s = int(month);
    subseas = timing_constants(4); //  mid subseas
    if (surveytime(f) >= 0.)
    { //  fraction of season
      data_timing_seas = surveytime(f);
      i_result(6) = 1;
    }
    else
    { //  for fishing fleets;  use midseason and fishery catch
      data_timing_seas = 0.5;
      i_result(6) = -1; //  flag to use season-long fishery catch as the sample
    }
    month = 1.0 + azero_seas(s) * 12. + 12. * data_timing_seas * seasdur(s);
  }
  else //  reading month.fraction
  {
    if (surveytime(f) < 0) //  so a fishing fleet
    {
      if (month > 999)
      { // override to allow a fishing fleet to have explicit timing
        month -= 1000.;
        i_result(6) = 1;
      }
      else
      {
        i_result(6) = -1; //  flag to use season-long fishery catch as the sample
      }
    }
    else
    {
      i_result(6) = 1; //  explicit timing for all survey fleet obs
      if (month > 999)
      { // override to allow a fishing fleet to have explicit timing
        month -= 1000.;
      }
    }

    if (seas_as_year == 0)
    {
      if (month >= 13.0)
      {
    	  warnstream << "month must be <13.0, end of year is 12.99, value read is: " << month;
    	  write_message(FATAL, 0);
      }
      temp1 = max(0.00001, (month - 1.0) / 12.); //  month as fraction of year
      s = 1; // earlist possible seas;
      subseas = 1; //  earliest possible subseas in seas
      temp = subseasdur_delta(s); //  starting value
      while (temp <= temp1 + 1.0e-9)
      {
        if (subseas == timing_constants(3))
        {
          s++;
          subseas = 1;
        }
        else
        {
          subseas++;
        }
        temp += subseasdur_delta(s);
      }
      data_timing_seas = (temp1 - azero_seas(s)) / seasdur(s); //  remainder converted to fraction of season (and multiplied by seasdur when used)
    }
    else
    {
      temp1 = 0.5;
      month = 0.5 * seasdur(1) * 12.;
      s = 1;
      subseas = timing_constants(4);
      data_timing_seas = 0.5;
    }
  }

  // i_result(1,6) will contain y, t, s, f, ALK_time, use_midseas
  // r_result(1,3) will contain: real_month, data_timing_seas*use_midseas, data_timing_yr,
  //    t=styr+(y-styr)*nseas+s-1;
  //    ALK_time=(yr-styr)*nseas*N_subseas+(s-1)*N_subseas+subseas;
  i_result(1) = y;
  i_result(2) = timing_constants(5) + (y - timing_constants(5)) * timing_constants(2) + s - 1; //  t
  i_result(3) = s;
  i_result(4) = f;

  if (seas_as_year == 0)
  {
    if (i_result(6) >= 0)
    {
      i_result(5) = (y - timing_constants(5)) * timing_constants(2) * timing_constants(3) + (s - 1) * timing_constants(3) + subseas; //  ALK_time
      // r_result(1,3) : real_month, data_timing_seas, data_timing_yr,
      r_result(1) = month;
      r_result(2) = data_timing_seas * i_result(6);
      r_result(3) = float(y) + (month - 1.) / 12.; //  year.fraction
    }
    else //  assign to midseason
    {
      i_result(5) = (y - timing_constants(5)) * timing_constants(2) * timing_constants(3) + (s - 1) * timing_constants(3) + timing_constants(4); //  ALK_time
      data_timing_seas = 0.5;
      month = 1.0 + azero_seas(s) * 12. + 12. * data_timing_seas * seasdur(s);
      r_result(1) = month;
      r_result(2) = data_timing_seas * i_result(6);
      r_result(3) = float(y) + (month - 1.) / 12.; //  year.fraction
    }
  }
  else
  {
    i_result(5) = (y - timing_constants(5)) * timing_constants(2) * timing_constants(3) + (s - 1) * timing_constants(3) + timing_constants(4); //  ALK_time
    r_result(1) = month;
    r_result(2) = data_timing_seas * i_result(6);
    r_result(3) = float(y) + 0.5; //  year.fraction
  }
  return;
  }

// SS_Label_Function_xxxx  #create_timevary()  called by readdata to create timevary parameters
  /*
   where:
   baseparm_list:           vector with the base parameter which has some type of timevary characteristic
   timevary_setup:        vector which contains specs of all types of timevary  for this base parameter
                          will be pushed to timevary_def cumulative across all types of base parameters
   timevary_byyear:        vector containing column(timevary_MG,mgp_type(j)), will be modified in create_timevary
   autogen_timevary:      switch to autogenerate or not
   targettype:           integer with type of MGparm being worked on; analogous to 2*fleet in the selectivity section
   block_design_pass:       block design, if any, being used
   env_data_pass:           matrix containing entire set of environmental data as read
   N_parm_dev:            integer that is incremented in create_timevary as dev vectors are created; cumulative across all types of parameters
   finish_starter:  End of starter file value
  */
  void create_timevary(dvector& baseparm_list, ivector& timevary_setup,
    ivector& timevary_byyear, int& autogen_timevary, const int& targettype,
    const ivector& block_design_pass, const dvector& env_data_pass,
    int& N_parm_dev, const double& finish_starter)
  {
  //  where timevary_byyear is a selected column of a year x type matrix (e.g. timevary_MG) in read_control
  //  timevary_setup(1)=baseparm type;
  //  timevary_setup(2)=baseparm index;
  //  timevary_setup(3)=first timevary parm
  //  timevary_setup(4)=block or trend type
  //  timevary_setup(5)=block pattern
  //  timevary_setup(6)=env link type
  //  timevary_setup(7)=env variable
  //  timevary_setup(8)=dev vector used
  //  timevary_setup(9)=dev link type
  //  timevary_setup(10)=dev min year
  //  timevary_setup(11)=dev maxyear
  //  timevary_setup(12)=dev phase
  //  timevary_setup(13)=all parm index of baseparm
  //  timevary_setup(14)=continue_last dev
  echoinput << "baseparm: " << baseparm_list << endl;
  int j;
  int g;
  int y;
  int a; // int f;
  int k;
  int z;
  int Nblocks;
  j = timevary_setup(13); //  index of base in all parameters to get correct baseparm label
  if (baseparm_list(13) != 0) //  blocks or trends
  {
    z = baseparm_list(13); // specified block or trend definition
    timevary_setup(4) = z; //  block or trend type
    timevary_setup(5) = baseparm_list(14); //  block pattern
    if (z > 0) //  blocks with z as the block pattern
    {
      Nblocks = 0.5 * (block_design_pass.size());
      k = int(baseparm_list(14)); //  block method
      echoinput << "block pattern: " << z << " method " << k << " Nblocks: " << Nblocks << endl;

      g = 1; //  index to list of years in block design; will increment by 2 for begin-end of block
      for (a = 1; a <= Nblocks; a++) //  loop blocks for block pattern z
      {
        timevary_parm_cnt++;
        ParCount++;
        echoinput << " create parm for block " << a << endl;
        y = block_design_pass(g);
        timevary_byyear(y) = 1;
        sprintf(onenum, "%d", y);

        echoinput << " block method " << k << endl;
        switch (k)
        {
          case 0:
          {
            ParmLabel += ParmLabel(j) + "_BLK" + NumLbl(z) + "mult_" + onenum + CRLF(1);
            dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
            tempvec.initialize();
            if (autogen_timevary >= 1) //  read
            {
              *(ad_comm::global_datafile) >> tempvec(1, 7);
              echoinput << "read timevary block parameter: " << tempvec << endl;
            }
            if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
            {
              tempvec.fill("{-10,10,0.,0.,5,6,4}");
              if (baseparm_list(1) <= 0.0)
              {
                warnstream << "cannot use multiplicative blocks for parameter with a negative lower bound;  exit " << endl
                        << baseparm_list(1) << " " << baseparm_list(2) << " " << baseparm_list(3) << endl;
                write_message(FATAL, 0);
              }
              tempvec(1) = log(baseparm_list(1) / baseparm_list(3)); //  max negative change
              tempvec(2) = log(baseparm_list(2) / baseparm_list(3)); //  max positive change
              //              tempvec(5)=0.5*fmin(fabs(tempvec(1)),tempvec(2));   //  sd of normal prior
              tempvec(5) = (tempvec(2) - tempvec(1)) / 4.; //  range/4 to approx sd of normal prior
              echoinput << " autogen mult block: " << tempvec << endl;
            }
            timevary_parm_rd.push_back(tempvec);
            break;
          }
          case 1:
          {
            ParmLabel += ParmLabel(j) + "_BLK" + NumLbl(z) + "add_" + onenum + CRLF(1);
            dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
            tempvec.initialize();
            if (autogen_timevary >= 1) //  read
            {
              *(ad_comm::global_datafile) >> tempvec(1, 7);
              echoinput << "read timevary block parameter: " << tempvec << endl;
            }
            if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
            {
              tempvec.fill("{-10,10,0.,0.,5,6,4}");
              tempvec(1) = baseparm_list(1) - baseparm_list(3); //  max negative change
              tempvec(2) = baseparm_list(2) - baseparm_list(3); //  max positive change
              tempvec(5) = (tempvec(2) - tempvec(1)) / 4.; //  range/4 to approx sd of normal prior
              echoinput << " autogen additive block: " << tempvec << endl;
            }
            timevary_parm_rd.push_back(tempvec);
            break;
          }
          case 2:
          {
            ParmLabel += ParmLabel(j) + "_BLK" + NumLbl(z) + "repl_" + onenum + CRLF(1);
            dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
            tempvec.initialize();
            if (autogen_timevary >= 1) //  read
            {
              *(ad_comm::global_datafile) >> tempvec(1, 7);
              echoinput << "read timevary block parameter: " << tempvec << endl;
            }
            if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
            {
              for (int s = 1; s <= 7; s++)
                tempvec(s) = baseparm_list(s);
              if (finish_starter == 999)
              {
                double temp;
                temp = tempvec(5);
                tempvec(5) = tempvec(6);
                tempvec(6) = temp;
              }
              echoinput << "autogen block replace: " << tempvec << endl;
            }
            timevary_parm_rd.push_back(tempvec);
            break;
          }
          case 3:
          {
            ParmLabel += ParmLabel(j) + "_BLK" + NumLbl(z) + "delta_" + onenum + CRLF(1);
            dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
            tempvec.initialize();
            if (autogen_timevary >= 1) //  read
            {
              *(ad_comm::global_datafile) >> tempvec(1, 7);
              echoinput << " read timevary block parm: " << tempvec << endl;
            }
            if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
            {
              tempvec.fill("{-10,10,0.,0.,5,6,4}");
              tempvec(1) = baseparm_list(1) - baseparm_list(3); //  max negative change
              tempvec(2) = baseparm_list(2) - baseparm_list(3); //  max positive change
              tempvec(5) = (tempvec(2) - tempvec(1)) / 4.; //  range/4 to approx sd of normal prior
              echoinput << " autogen block delta: " << tempvec << endl;
            }
            timevary_parm_rd.push_back(tempvec);
            break;
          }
        }
        y = block_design_pass(g + 1) + 1; // first year after block
        if (y <= YrMax)
          timevary_byyear(y) = 1;
        if (targettype == 7 && timevary_setup(1) == 1) //  so doing catch_mult which needs annual values calculated for each year of the block
        {
          for (int z = block_design_pass(g); z <= y; z++) //  where y has end year of block + 1
          {
            timevary_byyear(z) = 1;
          }
        }
        g += 2;
      }
    }
    else //  (z<0) so invoke a trend
    {
      echoinput << "trend " << endl;
      if (baseparm_list(13) == -1)
      {
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendFinal_LogstOffset" + CRLF(1);
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendInfl_LogstOffset" + CRLF(1);
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendWidth_yrs_" + CRLF(1);
        for (k = 1; k <= 3; k++) //  for the 3 trend parameters
        {
          timevary_parm_cnt++;
          dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
          tempvec.initialize();
          if (autogen_timevary >= 1) //  read
          {
            *(ad_comm::global_datafile) >> tempvec(1, 7);
          }
          if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
          {
            if (k == 1)
            {
              tempvec.fill("{-4.0,4.0,0.,0.,0.5,6,4}");
            }
            if (k == 2)
            {
              tempvec.fill("{-4.0,4.0,0.,0.,0.5,6,4}");
            }
            if (k == 3)
            {
              tempvec.fill("{1.0,20.0,3.,3.,3.0,6,4}");
            }
          }
          timevary_parm_rd.push_back(tempvec);
        }
      }
      else if (baseparm_list(13) == -2)
      {
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendFinal_direct_" + CRLF(1);
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendInfl_yr_" + CRLF(1);
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendWidth_yr_" + CRLF(1);
        for (k = 1; k <= 3; k++) //  for the 3 trend parameters
        {
          timevary_parm_cnt++;
          dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
          tempvec.initialize();
          if (autogen_timevary >= 1) //  read
          {
            *(ad_comm::global_datafile) >> tempvec(1, 7);
          }
          if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
          {
            if (k == 1)
            {
              for (a = 1; a <= 7; a++)
                tempvec(a) = baseparm_list(a);
            }
            if (k == 2)
            {
              tempvec.fill("{-2.0,2.0,0.,0.,0.5,6,4}");
              tempvec(1) = styr;
              tempvec(2) = endyr;
              tempvec(3) = (styr + endyr) * 0.5;
              tempvec(4) = tempvec(3);
            }
            if (k == 3)
            {
              tempvec.fill("{1.0,20.0,3.,3.,3.0,6,4}");
            }
          }
          timevary_parm_rd.push_back(tempvec);
        }
      }
      else if (baseparm_list(13) == -3)
      {
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendFinal_frac_" + CRLF(1);
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendInfl_frac_" + CRLF(1);
        ParCount++;
        ParmLabel += ParmLabel(j) + "_TrendWidth_yr_" + CRLF(1);
        for (k = 1; k <= 3; k++) //  for the 3 trend parameters
        {
          timevary_parm_cnt++;
          dvector tempvec(1, 7); //  temporary vector for a time-vary parameter  LO HI INIT PRIOR PR_type SD PHASE
          tempvec.initialize();
          if (autogen_timevary >= 1) //  read
          {
            *(ad_comm::global_datafile) >> tempvec(1, 7);
          }
          if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
          {
            if (k == 1)
            {
              tempvec.fill("{0.0001,0.999,0.,0.,0.5,6,4}");
              tempvec(3) = (baseparm_list(3) - baseparm_list(1)) / (baseparm_list(2) - baseparm_list(1));
              tempvec(4) = tempvec(3);
            }
            if (k == 2)
            {
              tempvec.fill("{0.0001,0.999,0.5,0.5,0.5,6,4}");
            }
            if (k == 3)
            {
              tempvec.fill("{1.0,20.0,3.,3.,3.,6,4}");
            }
          }
          timevary_parm_rd.push_back(tempvec);
        }
      }
      else
      {
        for (int icycle = 1; icycle <= Ncycle; icycle++)
        {
          ParCount++;
          ParmLabel += ParmLabel(j) + "_Cycle_" + NumLbl(icycle) + CRLF(1);
          timevary_parm_cnt += 1; //  count the cycle parameters
        }
      }
      for (y = styr - 1; y <= YrMax; y++)
      {
        timevary_byyear(y) = 1;
      } //  all years need calculation for trends
    }
  }

  if (baseparm_list(8) != 0) //  env effect is used
  {
    k = timevary_setup(6);
    //      if(timevary_setup(7)==99) timevary_setup(7)=-1;  //  for linking to rel_spawn biomass
    //      if(timevary_setup(7)==98) timevary_setup(7)=-2;  //  for linking to exp(recdev)
    //      if(timevary_setup(7)==97) timevary_setup(7)=-3;  //  for linking to rel_smrybio
    //      if(timevary_setup(7)==96) timevary_setup(7)=-4;  //  for linking to rel_smry_num
    echoinput << "env link_type: " << k << " env_var: " << timevary_setup(7) << endl;
    switch (k)
    {
      case 1: //  multiplicative
      {
        echoinput << " do env mult for parm: " << j << " " << ParmLabel(j) << endl;
        ParCount++;
        ParmLabel += ParmLabel(j) + "_ENV_mult";
        timevary_parm_cnt++;
        dvector tempvec(1, 7);
        tempvec.initialize();
        if (autogen_timevary >= 1) //  read
        {
          *(ad_comm::global_datafile) >> tempvec(1, 7);
        }
        if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
        {
          tempvec.fill("{-10.,10.0,1.0,1.0,0.5,6,4}");
        }
        timevary_parm_rd.push_back(tempvec(1, 7));
        break;
      }
      case 2: //  additive
      {
        echoinput << " do env additive " << endl;
        ParCount++;
        ParmLabel += ParmLabel(j) + "_ENV_add";
        timevary_parm_cnt++;
        dvector tempvec(1, 7);
        tempvec.initialize();
        if (autogen_timevary >= 1) //  read
        {
          *(ad_comm::global_datafile) >> tempvec(1, 7);
        }
        if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
        {
          tempvec.fill("{-10.,10.0,1.0,1.0,0.5,6,4}");
        }
        timevary_parm_rd.push_back(tempvec(1, 7));
        break;
      }
      case 3: //  additive in logistic space to stay in min-max bounds
      {
        echoinput << " do env constrained " << endl;
        ParCount++;
        ParmLabel += ParmLabel(j) + "_ENV_add_constr";
        timevary_parm_cnt++;
        dvector tempvec(1, 7);
        tempvec.initialize();
        if (autogen_timevary >= 1) //  read
        {
          *(ad_comm::global_datafile) >> tempvec(1, 7);
        }
        if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
        {
          tempvec.fill("{-1.8,1.8,1.0,1.0,0.5,6,4}");
        }
        timevary_parm_rd.push_back(tempvec(1, 7));
        break;
      }
      case 4: //  logistic with offset
      {
        ParCount++;
        ParmLabel += ParmLabel(j) + "_ENV_offset";
        timevary_parm_cnt++;
        dvector tempvec(1, 7);
        tempvec.initialize();
        if (autogen_timevary >= 1) //  read
        {
          *(ad_comm::global_datafile) >> tempvec(1, 7);
        }
        if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
        {
          tempvec.fill("{-0.9,0.9,0.0,0.0,0.5,6,4}");
        }
        timevary_parm_rd.push_back(tempvec(1, 7));
        ParCount++;
        ParmLabel += ParmLabel(j) + "_ENV_lgst_slope";
        timevary_parm_cnt++;
        tempvec.initialize();
        if (autogen_timevary >= 1) //  read
        {
          *(ad_comm::global_datafile) >> tempvec(1, 7);
        }
        if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
        {
          tempvec.fill("{-0.9,0.9,0.0,0.0,0.5,6,4}");
        }
        timevary_parm_rd.push_back(tempvec(1, 7));
        break;
      }
    }
    {
      if (timevary_setup(7) > 0)
      {
        timevary_byyear(env_data_pass(1), env_data_pass(2) + 1) = 1;
      }
      else if (timevary_setup(7) < 0) //  density-dependence being used
      {
        timevary_byyear(styr, YrMax) = 1;
      }
    }
  }

  if (baseparm_list(9) > 0) //  devs are used
  {
    N_parm_dev++; //  count of dev vectors that are used
    timevary_setup(8) = N_parm_dev; //    specifies which dev vector will be used by a parameter
    timevary_setup(9) = baseparm_list(9); //   code for dev link type
    y = baseparm_list(10);
    if (y < styr)
    {
      warnstream << "reset parm_dev start year to styr for parm: " << j << " " << y;
      write_message(ADJUST, 0);
      y = styr;
    }
    timevary_setup(10) = y;

    y = baseparm_list(11);
    if (y > YrMax)
    {
	  warnstream << "reset parm_dev end year to YrMax for parm: " << j << " " << y;
	  write_message(ADJUST, 0);
      y = YrMax;
    }
    timevary_setup(11) = y;
    for (y = timevary_setup(10); y <= timevary_setup(11) + 1; y++)
    {
      timevary_byyear(y) = 1;
    }

    ParCount++;
    ParmLabel += ParmLabel(j) + "_dev_se" + CRLF(1);
    timevary_parm_cnt++;
    dvector tempvec(1, 7);
    tempvec.initialize();
    if (autogen_timevary >= 1) //  read
    {
      *(ad_comm::global_datafile) >> tempvec(1, 7);
    }
    timevary_setup(12) = baseparm_list(12); //  dev phase
    echoinput << "parameter dev vector created with phase set to: " << timevary_setup(12) << endl;
    if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec(1) == -12345)) //  create or overwrite
    {
      tempvec.fill("{0.0001,2.0,0.5,0.5,0.5,6,-5}");
      if (finish_starter == 999)
      {
        tempvec(3) = baseparm_list(12); //  set init to value on the 3.24 format base parameter line
        tempvec(4) = baseparm_list(12); //  set prior
      }
      //       timevary_setup(12)=-5;  //  set reasonable phase for devs;
      //       baseparm_list(12)=-5;
    }
    timevary_parm_rd.push_back(dvector(tempvec(1, 7)));

    ParCount++;
    ParmLabel += ParmLabel(j) + "_dev_autocorr" + CRLF(1);
    timevary_parm_cnt++;
    dvector tempvec2(1, 7);
    tempvec2.initialize();
    if (autogen_timevary >= 1)
    {
      *(ad_comm::global_datafile) >> tempvec2(1, 7);
    } // read
    if (autogen_timevary == 0 || (autogen_timevary == 2 && tempvec2(1) == -12345)) //  create or overwrite
    {
      tempvec2.fill("{-0.99,0.99,0.0,0.0,0.5,6,-6}");
    }
    timevary_parm_rd.push_back(dvector(tempvec2(1, 7)));
    echoinput << "dev vec: " << timevary_setup(8) << " with link: " << timevary_setup(9) << " min, max year " << timevary_setup(10, 11) << endl;
  }
  echoinput << "timevary_setup" << timevary_setup << endl;
  return;
  }

//  }  //  end GLOBALS_SECTION

//  SS_Label_Section_11. #BETWEEN_PHASES_SECTION
BETWEEN_PHASES_SECTION
  {
  int j_phase = current_phase(); // this is the phase to come

  //  SS_Label_Info_11.1 #Save last value of objective function
  if (j_phase > 1)
  {
    last_objfun = obj_fun;
  }

  //  SS_Label_Info_11.2 #For Fmethod=2 & 4, set parameter values (F_rate) equal to Hrate calculated using hybrid method in previous phase
  if (N_Fparm > 0 && j_phase > 1)
  {
    for (g = 1; g <= N_Fparm; g++)
    {
      f = Fparm_loc[g](1);
      t = Fparm_loc[g](2);
      if (j_phase == F_PH_time(f, t))
      {
        F_rate(g) = Hrate(f, t);
      }
    }

    if (F_detail > 0)
    {
      for (k = 1; k <= F_detail; k++)
      {
        f = F_setup2(k, 1);
        y = F_setup2(k, 2);
        s = F_setup2(k, 3);
        if (y > 0)
        {
          y1 = y;
          y2 = y;
        }
        else
        {
          y1 = -y;
          y2 = endyr;
        }
        for (y = y1; y <= y2; y++)
        {
          t = styr + (y - styr) * nseas + s - 1;
          g = do_Fparm_loc(f, t);
          if (j_phase == F_setup2(k, 6))  //  so code will be bypassed if phase is set negative
          {
            F_rate(g) = F_setup2(k, 4);
            Hrate(f, t) = F_setup2(k, 4);
          }
        }
      }
    }
  }

  } //  end BETWEEN_PHASES_SECTION

//  SS_Label_Section_12. #FINAL_SECTION
FINAL_SECTION
  {
  //  SS_Label_Info_12.1 #Get run ending time

  if (No_Report == 1)
  {
    cout << "MCMC finished; *.ss_new files and most .sso not written after MCMC or MCEVAL" << endl;
  }

  else
  {
    cout << "Iterations: " << niter << endl;
    echoinput << "Iterations: " << niter << endl;
    if (objective_function_value::pobjfun->gmax > final_conv)
    {
      warnstream << "Final gradient: " << objective_function_value::pobjfun->gmax << " is larger than final_conv: " << final_conv;
	  write_message(WARN, 0);
    }

    //  SS_Label_Info_12.2 #Output the covariance matrix to covar.sso
    anystring = sso_pathname + "covar.sso";
    covarout.open(anystring);
    covarout << version_info << endl;
    covarout << "start_time: " << ctime(&start) << endl;
    covarout << active_parms << " " << CoVar_Count << endl;
    covarout << "active-i active-j all-i all-j Par?-i Par?-j label-i label-j corr" << endl;
    if (CoVar(1, 1) == 0.00 && CoVar(2, 2) == 0.0)
    {
      covarout << "Variances are 0.0 for first two elements, so do not write " << endl;
    }
    else
    {
      for (i = 1; i <= CoVar_Count; i++)
      {
        covarout << i << " " << 0 << " " << active_parm(i) << " " << active_parm(i);
        if (i <= active_parms)
        {
          covarout << " Par ";
        }
        else
        {
          covarout << " Der ";
        }
        covarout << " Std " << ParmLabel(active_parm(i)) << "   _   " << CoVar(i, 1) << endl;
        for (j = 2; j <= i; j++)
        {
          covarout << i << " " << j - 1 << " " << active_parm(i) << " " << active_parm(j - 1);
          if (i <= active_parms)
          {
            covarout << " Par ";
          }
          else
          {
            covarout << " Der ";
          }
          if ((j - 1) <= active_parms)
          {
            covarout << " Par ";
          }
          else
          {
            covarout << " Der ";
          }
          covarout << ParmLabel(active_parm(i)) << " " << ParmLabel(active_parm(j - 1)) << " " << CoVar(i, j) << endl;
        }
      }
      if (mceval_phase() == 0)
        echoinput << " finished COVAR.SSO" << endl;
    }

    //  SS_Label_Info_12.3 #Go thru time series calculations again to get extra output quantities
    //  SS_Label_Info_12.3.2 #Set save_for_report=1 then call initial_conditions and time_series to get other output quantities
    if (Do_Dyn_Bzero > 0) //  do dynamic Bzero
    {
      fishery_on_off = 0;
      setup_recdevs();
      y = styr;
      get_initial_conditions();
      get_time_series();
      if (Do_Forecast > 0)
      {
        show_MSY = 0;
        Get_Forecast(); // First call to forecast
      }
      k = Do_Dyn_Bzero;
      for (j = styr - 2; j <= YrMax; j++)
      {
        Extra_Std(k) = SSB_yr(j);
        k++;
      }
      if (More_Std_Input(12) == 2)
      {
        for (j = styr - 2; j <= YrMax; j++)
        {
          Extra_Std(k) = exp_rec(j, 4);
          k++;
        }
      }
    } //  end dynamic Bzero

    fishery_on_off = 1;
    save_for_report = 1;
    bigsaver = 1;
    if (SDmode == 0 && pick_report_use(60) == "Y")
      write_bodywt = 1; //  turn on conditional on SDMode because SDMode=1 situation already written
    y = styr;
    setup_recdevs();
    get_initial_conditions();
    get_time_series(); //  in final_section with save_for_report on
    evaluate_the_objective_function();
    //  SS_Label_Info_12.3.3 #Do benchmarks and forecast and stdquantities with save_for_report=1
    if (mceval_phase() == 0)
    {
      show_MSY = 1;
    }
    else
    {
      show_MSY = 0;
    } //  turn on reporting if not in mceval
    if (pick_report_use(60) == "Y")
    {
      write_bodywt = 1;
    } //  turn on bodywt after time series
    setup_Benchmark(); //  calculates biology and selectivity to be used
    if (Do_Benchmark > 0)
    {
      if (did_MSY == 0)
      {
        Get_Benchmarks(show_MSY);
        if (mceval_phase() == 0)
        {
          cout << "Finished calculating benchmarks" << endl;
          echoinput << "Finished calculating benchmarks" << endl;
        }
      }
    }
    if (Do_Forecast >= 0)
    {
      report5 << "THIS FORECAST IS FOR PURPOSES OF GETTING DISPLAY QUANTITIES" << endl;
      if (did_MSY > 0)
        show_MSY = 0; //  so to not repeat forecast_report.sso
      Get_Forecast();
      if (mceval_phase() == 0) {
        cout << "Finished forecast" << endl;
        echoinput << "Finished forecast" << endl;
      }
    }

    if (write_bodywt > 0)
    {
      cout << "Writing wtatage.ss_new" << endl;
      echoinput << "Writing wtatage.ss_new" << endl;
      bodywtout << -9999 << " " << 1 << " " << 1 << " " << 1 << " " << 1 << " " << 0 << " " << Wt_Age_mid(1, 1) << " #terminator " << endl;
      bodywtout.close();
    }
    write_bodywt = 0;

    //  SS_Label_Info_12.3.4  #call fxn STDquant()
    Process_STDquant();
    if (mceval_phase() == 0)
      echoinput << "Finished StdDev quantities" << endl;
    get_posteriors();
    if (mceval_phase() == 0)
    {
      cout << "Finished posteriors" << endl;
      echoinput << "Finished posteriors" << endl;
    }

    //  SS_Label_Info_12.4.2 #Call fxn write_summaryoutput()
    if (Do_CumReport > 0)
      write_summaryoutput();

    if (pick_report_use(56) == "Y")
    {
      write_SS_summary();
    }

    //  SS_Label_Info_12.4.3 #Call fxn write_rebuilder_output to produce rebuilder.sso
    {
      if (pick_report_use(57) == "Y" && Do_Rebuilder == 1 && mceval_counter <= 1)
      {
        write_rebuilder_output();
      }

      if (pick_report_use(58) == "Y")
      {
        write_SIStable(); //note: SIStable is deprecated, but file with warning written for now
      }

      //  SS_Label_Info_12.4 #Do Outputs
      //  SS_Label_Info_12.4.1 #Call fxn write_bigoutput()
      write_bigoutput();
      cout << "Finished final writing of report.sso" << endl;
      echoinput << "Finished final writing of report.sso" << endl;
    }
    //  SS_Label_Info_12.4.4 #Call fxn write_nudata() to create bootstrap data
    if (N_nudata > 0)
    {
      cout << "Begin writing *.ss_new output files ... ";
      write_nudata();
      //  SS_Label_Info_12.4.5 #Call fxn write_nucontrol() to produce control.ss_new
      write_nucontrol();
      cout << "Finished writing *.ss_new output files" << endl;
    }
    else
    {
      {
        warnstream << "No *.ss_new and fewer *.sso files written after mceval";
		write_message(NOTE, 0);
      }
    }

    echoinput << "Begin final output calculations and warnings" << endl;
    //  SS_Label_Info_12.4.6 #Call fxn write_Bzero_output()  appended to report.sso
    if (pick_report_use(59) == "Y")
    {
      write_Bzero_output();
    }

    if (pick_report_use(54) == "Y" && Do_Benchmark > 0)
    {
      setup_Benchmark();
      SPR_profile();
    }

    if (pick_report_use(55) == "Y" && Do_Benchmark > 0)
    {
      Global_MSY();
    }

    if (parm_adjust_method == 3)
    {
      warnstream << "Time-vary parms not bound checked";
	  write_message(WARN, 0);
    }

    //  SS_Label_Info_12.4.7 #Finish up with final writes to warning.sso
    if (N_changed_lambdas > 0)
    {
      warnstream << "Reminder: Number of lambdas !=0.0 and !=1.0:  " << N_changed_lambdas;
	  write_message(WARN, 0);
    }

    if (Nparm_on_bound > 0)
    {
      warnstream << " N parameters that are on or within 1% of min-max bound: " << Nparm_on_bound;
      cout << endl << warnstream.str() << endl;
      warnstream << "; check results, variance may be suspect";
      write_message (NOTE, 0);
    }
    if (N_warn > 0)
    {
      warnstream << " " << N_warn << " warning" << (N_warn > 1? "s ": " ");
      if (N_note > 0)
      {
        warnstream << " and " << N_note << " note" << (N_note > 1? "s ": " ");
      }
    }
    else if (N_note > 0)
    {
      warnstream << " " << N_note << " note" << (N_note > 1? "s ": " ");
    }
    warning << warnstream.str() << endl;

    cout << endl
         << "!!  Run has completed  !! " << endl;
    if (N_warn + N_note > 0)
    {
      cout << "!!  See warning.sso for" << warnstream.str() << endl;
    }
    else
    {
      cout << "--  No warnings or notes :)  --" << endl;
    }
  }
  } //  end final section

//  SS_Label_Section_13. #REPORT_SECTION  produces SS3.rep,which is less extensive than report.sso produced in final section
REPORT_SECTION
  {
  int k = gradients.size();
  int k1 = parm_gradients.size();
  if (k1 < k)
    k = k1;
  for (int i = 1; i <= k; i++)
    parm_gradients(i) = gradients(i);
  if (current_phase() >= max_phase && finished_minimize == 0)
    finished_minimize = 1; //  because REPORT occurs after minimize finished
  //  SS_Label_Info_13.1 #Write limited output to SS.rep
  if (reportdetail > 0)
  {
    if (Svy_N > 0)
      report << " CPUE " << surv_like << endl;
    if (nobs_disc > 0)
      report << " Disc " << disc_like << endl;
    if (nobs_mnwt > 0)
      report << " MnWt " << mnwt_like << endl;
    if (Nobs_l_tot > 0)
      report << " LEN  " << length_like_tot << endl;
    if (Nobs_a_tot > 0)
      report << " AGE  " << age_like_tot << endl;
    if (nobs_ms_tot > 0)
      report << " L-at-A  " << sizeage_like << endl;
    report << " EQUL " << equ_catch_like << endl;
    report << " Recr " << recr_like << endl;
    report << " Parm " << parm_like << endl;
    report << " F_ballpark " << F_ballpark_like << endl;
    if (F_Method > 1)
    {
      report << "Catch " << catch_like << endl;
    }
    else
    {
      report << "  crash " << CrashPen << endl;
    }
    if (SzFreq_Nmeth > 0)
      report << " sizefreq " << SzFreq_like << endl;
    if (Do_TG > 0)
      report << " TG-fleetcomp " << TG_like1 << endl
             << " TG-negbin " << TG_like2 << endl;
    report << " -log(L): " << obj_fun << "  SSBio: " << value(SSB_yr(styr)) << " " << value(SSB_yr(endyr)) << endl;

    report << endl
           << "Year SSBio Recruitment" << endl;
    report << "Virg " << SSB_yr(styr - 2) << " " << exp_rec(styr - 2, 4) << endl;
    report << "Init " << SSB_yr(styr - 1) << " " << exp_rec(styr - 1, 4) << endl;
    for (y = styr; y <= endyr; y++)
      report << y << " " << SSB_yr(y) << " " << exp_rec(y, 4) << endl;

    report << endl
           << "EXPLOITATION F_Method: ";
    if (F_Method == 1)
    {
      report << " Pope's_approx ";
    }
    else
    {
      report << " instantaneous_annual_F ";
    }
    report << endl
           << "X Catch_Units ";
    for (f = 1; f <= Nfleet; f++)
      if (catchunits(f) == 1)
      {
        report << " Bio ";
      }
      else
      {
        report << " Num ";
      }
    report << endl
           << "Yr Seas";
    for (f = 1; f <= Nfleet; f++)
      report << " " << f;
    report << endl
           << "init_yr 1 ";
    for (s = 1; s <= nseas; s++)
      for (f = 1; f <= Nfleet; f++)
      {
        if (init_F_loc(s, f) > 0)
        {
          report << " " << init_F(init_F_loc(s, f));
        }
        else
        {
          report << " NA ";
        }
      }
    report << endl;
    for (y = styr; y <= endyr; y++)
      for (s = 1; s <= nseas; s++)
      {
        t = styr + (y - styr) * nseas + s - 1;
        report << y << " " << s << " " << column(Hrate, t) << endl;
      }

    report << endl
           << "LEN_SELEX" << endl;
    report << "Fleet Sex " << len_bins_m << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (seltype(f, 1) > 0)
      {
        for (gg = 1; gg <= gender; gg++)
          report << f << "-" << fleetname(f) << gg << " " << sel_l(endyr, f, gg) << endl;
      }
    }

    report << endl
           << "AGE_SELEX" << endl;
    report << "Fleet Sex " << age_vector << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (seltype(f + Nfleet, 1) > 10)
      {
        for (gg = 1; gg <= gender; gg++)
          report << f << "-" << fleetname(f) << " " << gg << " " << sel_a(endyr, f, gg) << endl;
      }
    }
  }

  //  SS_Label_Info_13.2 #Call fxn write_bigoutput() as last_phase finishes and before doing Hessian
  if (last_phase() && SDmode == 1)
  {
    if (pick_report_use(60) == "Y")
    {
      write_bodywt = 1;
    }
    save_for_report = 1;
    y = styr;
    setup_recdevs();
    get_initial_conditions();
    get_time_series(); //  in ADMB's report_section
    evaluate_the_objective_function();
    write_bigoutput();
    echoinput << "Wrote first version of output files (before hessian, benchmark, and forecast)" << endl;
    cout << "Wrote first version of output files (before hessian, benchmark, and forecast)" << endl;
    save_for_report = 0;
    write_bodywt = 0;
    //    SS2out.close();
  }
  } //  end standard report section
// SS_Label_file  #8. **SS_proced.tpl**
// SS_Label_file  # - <div style="color: #ff0000">PROCEDURE_SECTION</div>
// SS_Label_file  #
// SS_Label_file  #     - do iterations under control of ADMB, in each iteration, call:  <u>setup_recdevs()</u>, <u>get_initial_conditions()</u>, <u>get_time_series()</u>, <u>evaluate_the_objective_function()</u>
// SS_Label_file  #     - writes to *parmtrace.sso*
// SS_Label_file  #     - calls <u>get_posteriors()</u>  //  to write to *posteriors.sso*
// SS_Label_file  #     - upon reaching convergence, or if in mceval, do Dynamic_Bzero by calling those functions again with fishery_on_off=0
// SS_Label_file  #
// SS_Label_file  #  - call <u>setup_Benchmark(), Get_Benchmark(), Get_Forecast()</u>

// ****************************************************************************************************************
//  SS_Label_Section_7.0 #PROCEDURE_SECTION
PROCEDURE_SECTION
  {
  Mgmt_quant.initialize();
  Extra_Std.initialize();
  CrashPen.initialize();
  Smry_Table.initialize();
  niter++;
  if (mceval_phase())
    mceval_counter++; // increment the counter

  if (initial_params::mc_phase == 1) //  in MCMC phase
  {
    if (mcmc_counter == 0)
    {
      SRparm(1) += MCMC_bump;
      cout << mcmc_counter << "   adjusted SRparm in first mcmc call " << SRparm(1) << "  by  " << MCMC_bump << endl;
    }

    mcmc_counter++;
  }

  if (mcmcFlag == 1) //  so will do mcmc this run or is in mceval
  {
    if (Do_ParmTrace == 1)
      Do_ParmTrace = 4; // to get all iterations
    if (Do_ParmTrace == 2)
      Do_ParmTrace = 3; // to get all iterations
    if (mcmc_counter > 10 || mceval_counter > 10)
      Do_ParmTrace = 0;
  }

  //  SS_Label_Info_7.3 #get Hrate from the parameter vector F_rate
  //  note that in SS_global  BETWEEN_PHASES is where F_rate, which is the parameter, gets assigned a starting value Hrate from Hrate calculated by hybrid in previous PH
  //  be careful about phases for when this mapping occurs for a whole fleet, versus estimation phase which can be value specific
  if (N_Fparm > 0)
  {
    for (g = 1; g <= N_Fparm; g++)
    {
      f = Fparm_loc[g](1);
      t = Fparm_loc[g](2);
      if (current_phase() >= F_PH_time(f, t))
      {
        Hrate(f, t) = F_rate(g);
      }
    }
  }

  //  SS_Label_Info_7.4 #Do the time series calculations
  if (mceval_counter == 0 || (mceval_counter > burn_intvl && ((double(mceval_counter) / double(thin_intvl)) - double((mceval_counter / thin_intvl)) == 0))) // check to see if burn in period is over
  {

    //  create bigsaver to simplfy some condition statements later
    if ((save_for_report > 0) || ((sd_phase() || mceval_phase()) && (initial_params::mc_phase == 0))) // (SAVE || ( (SD || EVAL) && (!MCMC) ) )
    {
      bigsaver = 1;
    }
    else
    {
      bigsaver = 0;
    }
    setup_recdevs();
    y = styr;
    //  SS_Label_Info_7.4.1 #Call fxn get_initial_conditions() to get the virgin and initial equilibrium population
    get_initial_conditions();
    if (do_once == 1)
      echoinput << "Finished initial_conditions" << endl;
    //  SS_Label_Info_7.4.2 #Call fxn get_time_series() to do population calculations for each year and get expected values for observations
    get_time_series(); //  in procedure_section
    if (do_once == 1)
    {
      echoinput << "Finished time_series" << endl;
    }

    //  SS_Label_Info_7.4.3 #Call fxn evaluate_the_objective_function()
    evaluate_the_objective_function();

    //  SS_Label_Info_7.6 #If sdphase or mcevalphase, do benchmarks and forecast and derived quantities
    if ((sd_phase() || mceval_phase()) && (initial_params::mc_phase == 0))
    {

      //  SS_Label_Info_7.6.1 #Call fxn Get_Benchmarks()
      if (Do_Benchmark > 0)
      {
        did_MSY = 0; // so that benchmarks will get calculated here
        setup_Benchmark();
        Get_Benchmarks(show_MSY);
      }
      did_MSY = 1; //  set flag to not calculate the benchmarks again in final section

      if (Do_Dyn_Bzero > 0) //  do dynamic Bzero
      {
        fishery_on_off = 0;
        setup_recdevs();
        y = styr;
        get_initial_conditions();
        get_time_series();
        if (Do_Forecast > 0)
        {
          show_MSY = 0;
          Get_Forecast();
        }
        k = Do_Dyn_Bzero;
        for (j = styr - 2; j <= YrMax; j++)
        {
          Extra_Std(k) = SSB_yr(j);
          k++;
        }
        if (More_Std_Input(12) == 2)
        {
          for (j = styr - 2; j <= YrMax; j++)
          {
            Extra_Std(k) = exp_rec(j, 4);
            k++;
          }
        }
      } //  end dynamic Bzero calculations, will write after big report

      fishery_on_off = 1;
      if (mceval_phase() > 0)
        save_for_report = 1;
      if (mceval_phase() == 0)
      {
        show_MSY = 1;
      } //  so only show details if not in mceval
      if (show_MSY == 1)
      {
        echoinput << "Start benchmark and forecast, if requested" << endl;
      }
      setup_recdevs();
      y = styr;
      get_initial_conditions();
      get_time_series(); //  in write_big_report
      evaluate_the_objective_function();
      if (Do_Benchmark > 0)
      {
        setup_Benchmark();
        Get_Benchmarks(show_MSY);
      }

      //  SS_Label_Info_7.6.2 #Call fxn Get_Forecast()
      if (Do_Forecast > 0)
      {
        if (show_MSY == 1)
          report5 << "THIS FORECAST FOR PURPOSES OF STD REPORTING" << endl; // controls writing to forecast-report.sso
        Get_Forecast();
      }

      //  SS_Label_Info_7.7 #Call fxn Process_STDquant() to move calculated values into sd_containers
      Process_STDquant();
      if (mceval_phase() == 0)
      {
        echoinput << "Finished benchmark, forecast, and sdreporting" << endl;
      }
    } // end of things to do in std_phase

    //  SS_Label_Info_7.9 #Do screen output of procedure results from this iteration
    if (current_phase() <= max_phase + 1)
      phase_output(current_phase()) = value(obj_fun);
    if (rundetail > 1)
    {
      if (Svy_N > 0)
        cout << " CPUE " << surv_like << endl;
      if (nobs_disc > 0)
        cout << " Disc " << disc_like << endl;
      if (nobs_mnwt > 0)
        cout << " MnWt " << mnwt_like << endl;
      if (Nobs_l_tot > 0)
        cout << " Length  " << length_like_tot << endl;
      if (Nobs_a_tot > 0)
        cout << " AGE  " << age_like_tot << endl;
      if (nobs_ms_tot > 0)
        cout << " L-at-A  " << sizeage_like << endl;
      if (SzFreq_Nmeth > 0)
        cout << " sizefreq " << SzFreq_like << endl;
      if (Do_TG > 0)
        cout << " TG-fleetcomp " << TG_like1 << endl
             << " TG-negbin " << TG_like2 << endl;
      cout << " Recr " << recr_like << "  sum_recdev: " << sum_recdev << endl;
      cout << " InitEQ_Regime " << regime_like << endl;
      cout << " Parm_Priors " << parm_like << endl;
      cout << " Parm_devs " << parm_dev_like << endl;
      cout << " SoftBound " << SoftBoundPen << endl;
      cout << " F_ballpark " << F_ballpark_like << endl;
      if (F_Method > 1)
      {
        cout << "Catch " << sum(catch_like) << endl;
      }
      cout << " EQUL_catch " << sum(equ_catch_like) << endl;
      cout << "  crash " << CrashPen << endl;
    }
    if (rundetail > 0)
    {
      temp = norm2(recdev(recdev_start, recdev_end));
      temp = sqrt((temp + 0.0000001) / (double(recdev_end - recdev_start + 1)));
      if (mcmc_counter == 0 && mceval_counter == 0)
      {
        cout << current_phase() << " " << niter << " -log(L): " << obj_fun << "  SSBio: " << value(SSB_yr(styr)) << " " << value(SSB_yr(endyr));
      }
      else if (mcmc_counter > 0)
      {
        cout << " MCMC: " << mcmc_counter << " -log(L): " << obj_fun << "  SSBio: " << value(SSB_yr(styr)) << " " << value(SSB_yr(endyr));
      }
      else if (mceval_counter > 0)
      {
        cout << " MCeval: " << mceval_counter << " -log(L): " << obj_fun << "  SSBio: " << value(SSB_yr(styr)) << " " << value(SSB_yr(endyr));
      }
      if (F_Method > 1 && sum(catch_like) > 0.01)
      {
        cout << " cat " << sum(catch_like);
      }
      else if (CrashPen > 0.01)
      {
        cout << "  crash " << CrashPen;
      }
      cout << endl;
    }
    //  SS_Label_Info_7.10 #Write parameter values to ParmTrace
    if ((Do_ParmTrace == 1 && obj_fun <= last_objfun) || Do_ParmTrace == 4) // only report active parameters
    {
      ParmTrace << current_phase();
      if (sd_phase())
      {
        ParmTrace << "_sd";
        finished_minimize = 3;
      } // so flag is no longer==2
      if (finished_minimize == 2)
        ParmTrace << "_hs"; //  each Hessian calculation takes 4 calls, all will get this flag, so output processor needs to create a 1-4 counter
      if (finished_minimize == 1)
        finished_minimize = 2; //  this prevents _hs flag  for the one iteration that occurs after minimizer ends and before first tweak of Hessian
      if (mceval_phase())
        ParmTrace << "_mc";

      ParmTrace << " " << niter << " ";
      ParmTrace.precision(10);
      ParmTrace << obj_fun << " " << obj_fun - last_objfun << " " << value(SSB_yr(styr)) << " " << value(SSB_yr(endyr));
      ParmTrace.precision(2);
      ParmTrace << " " << biasadj(styr) << " " << max(biasadj) << " " << biasadj(endyr);
      ParmTrace.precision(7);
      for (j = 1; j <= MGparm_PH.indexmax(); j++)
      {
        if (MGparm_PH(j) >= 0)
        {
          ParmTrace << " " << MGparm(j);
        }
      }
      for (j = 1; j <= SRparm_PH.indexmax(); j++)
      {
        if (SRparm_PH(j) >= 0)
        {
          ParmTrace << " " << SRparm(j);
        }
      }
      if (recdev_cycle > 0)
      {
        for (j = 1; j <= recdev_cycle; j++)
        {
          if (recdev_cycle_PH(j) >= 0)
          {
            ParmTrace << " " << recdev_cycle_parm(j);
          }
        }
      }
      if (recdev_early_PH > 0)
      {
        ParmTrace << " " << recdev_early;
      }
      if (recdev_PH > 0)
      {
        if (do_recdev == 1)
        {
          ParmTrace << " " << recdev1;
        }
        if (do_recdev >= 2)
        {
          ParmTrace << " " << recdev2;
        }
      }
      if (Fcast_recr_PH2 > 0 && Do_Forecast > 0)
      {
        ParmTrace << Fcast_recruitments << " ";
        if (Do_Impl_Error > 0)
          ParmTrace << Fcast_impl_error << " ";
      }

      for (f = 1; f <= N_init_F; f++)
      {
        if (init_F_PH(f) > 0)
        {
          ParmTrace << " " << init_F(f);
        }
      }
      if (N_Fparm > 0) // continuous F
      {
        for (k = 1; k <= N_Fparm; k++)
        {
          if (Fparm_PH[k] > 0)
          {
            ParmTrace << " " << F_rate(k);
          }
        }
      }

      for (f = 1; f <= Q_Npar2; f++)
      {
        if (Q_parm_PH(f) > 0)
        {
          ParmTrace << " " << Q_parm(f);
        }
      }
      for (k = 1; k <= selparm_PH.indexmax(); k++)
      {
        if (selparm_PH(k) > 0)
        {
          ParmTrace << " " << selparm(k);
        }
      }
      for (k = 1; k <= TG_parm_PH.indexmax(); k++)
      {
        if (TG_parm_PH(k) > 0)
        {
          ParmTrace << " " << TG_parm(k);
        }
      }
      if (N_parm_dev > 0)
      {
        for (j = 1; j <= N_parm_dev; j++)
        {
          if (parm_dev_PH(j) > 0)
            ParmTrace << parm_dev(j) << " ";
        }
      }
      ParmTrace.precision(10);
      k = min(current_phase(), max_lambda_phase);
      if (F_Method > 1)
        ParmTrace << " Catch " << catch_like * column(catch_lambda, k);
      if (N_init_F > 0)
        ParmTrace << " Equil_catch " << equ_catch_like * column(init_equ_lambda, k);
      if (Svy_N > 0)
        ParmTrace << " Survey " << k << " " << surv_like * column(surv_lambda, k) << " " << elem_prod(surv_like, column(surv_lambda, k));
      if (nobs_disc > 0)
        ParmTrace << " Discard " << disc_like * column(disc_lambda, k) << " " << elem_prod(disc_like, column(disc_lambda, k));
      if (nobs_mnwt > 0)
        ParmTrace << " Mean_body_wt " << mnwt_like * column(mnwt_lambda, k) << " " << elem_prod(mnwt_like, column(mnwt_lambda, k));
      if (Nobs_l_tot > 0)
        ParmTrace << " Length " << length_like_tot * column(length_lambda, k) << " " << elem_prod(length_like_tot, column(length_lambda, k));
      if (Nobs_a_tot > 0)
        ParmTrace << " Age " << age_like_tot * column(age_lambda, k) << " " << elem_prod(age_like_tot, column(age_lambda, k));
      if (nobs_ms_tot > 0)
        ParmTrace << " Size_at_age " << sizeage_like * column(sizeage_lambda, k) << " " << elem_prod(sizeage_like, column(sizeage_lambda, k));
      if (SzFreq_Nmeth > 0)
        ParmTrace << " SizeFreq " << SzFreq_like * column(SzFreq_lambda, k) << " " << elem_prod(SzFreq_like, column(SzFreq_lambda, k));
      if (Do_Morphcomp > 0)
        ParmTrace << " Morph " << Morphcomp_lambda(k) * Morphcomp_like;
      if (Do_TG > 0)
        ParmTrace << " Tag_comp " << TG_like1 * column(TG_lambda1, k) << " " << elem_prod(TG_like1, column(TG_lambda1, k));
      if (Do_TG > 0)
        ParmTrace << " Tag_negbin " << TG_like2 * column(TG_lambda2, k) << " " << elem_prod(TG_like2, column(TG_lambda2, k));
      ParmTrace << " Recr_dev " << recr_like * recrdev_lambda(k);
      ParmTrace << " Regime " << regime_like * regime_lambda(k);
      ParmTrace << " Fore_Recdev " << Fcast_recr_like;
      ParmTrace << " Parm_priors " << parm_like * parm_prior_lambda(k);
      if (SoftBound > 0)
        ParmTrace << " Softbounds " << SoftBoundPen;
      if (N_parm_dev > 0)
        ParmTrace << " Parm_devs " << (sum(parm_dev_like)) * parm_dev_lambda(k);
      if (F_ballpark_yr > 0)
        ParmTrace << " F_Ballpark " << F_ballpark_lambda(k) * F_ballpark_like;
      ParmTrace << endl;
    }
    else if ((Do_ParmTrace == 2 && obj_fun <= last_objfun) || Do_ParmTrace == 3) //  report active and inactive parameters
    {
      ParmTrace << current_phase() << " " << niter << " " << obj_fun << " " << obj_fun - last_objfun
                << " " << value(SSB_yr(styr)) << " " << value(SSB_yr(endyr)) << " " << biasadj(styr) << " " << max(biasadj) << " " << biasadj(endyr);
      ParmTrace << " " << MGparm << " ";
      ParmTrace << SRparm << " ";
      if (recdev_cycle > 0)
        ParmTrace << recdev_cycle_parm;
      if (recdev_do_early > 0)
        ParmTrace << recdev_early << " ";
      if (do_recdev == 1)
      {
        ParmTrace << recdev1 << " ";
      }
      if (do_recdev >= 2)
      {
        ParmTrace << recdev2 << " ";
      }
      if (Do_Forecast > 0)
        ParmTrace << Fcast_recruitments << " ";
      if (Do_Impl_Error > 0)
        ParmTrace << Fcast_impl_error << " ";
      if (N_init_F > 0)
        ParmTrace << init_F << " ";
      if (N_Fparm > 0)
        ParmTrace << F_rate << " ";
      if (Q_Npar > 0)
        ParmTrace << Q_parm << " ";
      ParmTrace << selparm << " ";
      if (Do_TG > 0)
        ParmTrace << TG_parm << " ";
      if (N_parm_dev > 0)
      {
        for (j = 1; j <= N_parm_dev; j++)
        {
          ParmTrace << parm_dev(j);
        }
      }
      ParmTrace << endl;
    }
    if (obj_fun <= last_objfun)
      last_objfun = obj_fun;
    docheckup = 0; // turn off reporting to checkup.sso
    //  SS_Label_Info_7.11 #Call fxn get_posteriors if in mceval_phase
    if (mceval_phase())
    {
      get_posteriors();

      //SS_Label_Info_7.12 #write report_mce_XXXX.sso and compreport_mce_XXXX.sso for each MCEVAL
      //        warning<<mceval_counter<<" SSB 2021 2022 "<<SSB_std(N_STD_Yr-4)<<" "<<SSB_std(N_STD_Yr-3)<<endl<<endl;
      if (mcmc_output_detail >= 2)
      {
        write_bodywt = 0;
        pick_report_use(54) = 0;
        pick_report_use(55) = 0;
        save_for_report = 1;
        write_bigoutput();
        if (Do_Dyn_Bzero > 0)
          write_Bzero_output();
        save_for_report = 0;
        write_bodywt = 0;
      }
    }
  } //  end doing of the calculations
  if (mceval_phase() || initial_params::mc_phase == 1)
  {
    No_Report = 1; //  flag to skip output reports after MCMC and McEVAL
  }
  }
//  SS_Label_Info_7.13 #End of PROCEDURE_SECTION

// SS_Label_file  #9. **SS_biofxn.tpl**
// SS_Label_file  # * <u>get_MGsetup()</u>  // get parameter values for this year
// SS_Label_file  # * <u>get_growth1()</u>  // prep growth quantities
// SS_Label_file  # * <u>get_growth2()</u>  // growth to beginning of each season of upcoming year
// SS_Label_file  # * <u>get_growth3()</u>  // growth to particular time point in a season
// SS_Label_file  # * <u>get_natmort()</u>
// SS_Label_file  # * <u>get_recr_distribution()</u>
// SS_Label_file  # * <u>get_wtlen()</u>
// SS_Label_file  # * <u>get_mat_fec()</u>
// SS_Label_file  # * <u>get_Hermaphro()</u>
// SS_Label_file  # * <u>get_migration()</u>
// SS_Label_file  # * <u>get_saveGparm()</u>
// SS_Label_file  # *

//*********************************************************************
 /*  SS_Label_Function_14 #Get_MGsetup:  apply time-varying factors this year to the MG parameters to create mgp_adj vector */
FUNCTION void get_MGsetup(const int yz)
  {
  mgp_adj = MGparm; //  set all to base parm value
  //    int y1;

  for (f = 1; f <= N_MGparm; f++)
  {
    if (MGparm_timevary(f) > 0) // timevary
    {
      mgp_adj(f) = parm_timevary(MGparm_timevary(f), yz);
      if (parm_adjust_method == 1 && (save_for_report > 0 || do_once == 1))
      {
        if (mgp_adj(f) < MGparm_1(f, 1) || mgp_adj(f) > MGparm_1(f, 2))
        {
          warnstream << "adjusted MGparm out of base parm bounds. Phase: " << current_phase()
               << "; Inter: " << niter << "; parm#: " << f << "; y: " << yz << "; min: "
               << MGparm_1(f, 1) << "; max: " << MGparm_1(f, 2) << "; base: " << MGparm(f)
               << " timevary_val: " << mgp_adj(f) << " " << ParmLabel(f);
          write_message (WARN, 0);
        }
      }
    }
  } // end parm loop

  //  SS_Label_Info_14.5 #if MGparm method =1 (no offsets), then do direct assignment if parm value is 0.0. (only for natMort and growth parms)
  if (MGparm_def == 1)
  {
    for (j = 1; j <= N_MGparm; j++)
    {
      if (MGparm_offset(j) > 0)
        mgp_adj(j) = mgp_adj(MGparm_offset(j));
    }
  }
  //  SS_Label_Info_19.1  #set wtlen and maturity/fecundity factors equal to annual values from mgp_adj
  gp = 0;
  for (gg = 1; gg <= gender; gg++)
    for (GPat = 1; GPat <= N_GP; GPat++)
    {
      gp++;
      if (gg == 1)
      {
        for (f = 1; f <= 6; f++)
        {
          wtlen_p(GPat, f) = mgp_adj(MGparm_point(gg, GPat) + N_M_Grow_parms + f - 1);
        }
      }
      else
      {
        for (f = 7; f <= 8; f++)
        {
          wtlen_p(GPat, f) = mgp_adj(MGparm_point(gg, GPat) + N_M_Grow_parms + (f - 6) - 1);
        }
      }
      if (do_once == 1)
        echoinput << "get wtlen parms sex: " << gg << " Gpat: " << GPat << " sex*Gpat: " << gp << " " << wtlen_p(GPat) << endl;
    }
  if (save_for_report > 0)
    mgp_save(yz) = value(mgp_adj);
  }

//********************************************************************
 /*  SS_Label_FUNCTION 15 get_growth1;  calc some seasonal and CV_growth biology factors that cannot be time-varying */
FUNCTION void get_growth1()
  {
  //  SS_Label_Info_15.1  #create seasonal effects for growth K, and for wt_len parameters
  if (MGparm_doseas > 0)
  {
    if (MGparm_seas_effects(10) > 0) // for seasonal K
    {
      VBK_seas(0) = 0.0;
      for (s = 1; s <= nseas; s++)
      {
        VBK_seas(s) = mfexp(MGparm(MGparm_seas_effects(10) + s));
        VBK_seas(0) += VBK_seas(s) * seasdur(s);
      }
    }
    else
    {
      VBK_seas = sum(seasdur); // set vector to null effect
    }
    for (gp = 1; gp <= N_GP; gp++)
      for (j = 1; j <= 8; j++)
      {
  #ifdef DO_ONCE
        {
          if (do_once == 1)
            echoinput << j << "  wt_len seas " << MGparm_seas_effects(j) << endl;
        }
  #endif
        if (MGparm_seas_effects(j) > 0)
        {
          wtlen_seas(0, gp, j) = 0.0;
          for (s = 1; s <= nseas; s++)
          {
            wtlen_seas(s, gp, j) = mfexp(MGparm(MGparm_seas_effects(j) + s));
            wtlen_seas(0, gp, j) += wtlen_seas(s, gp, j) * seasdur(s); //  this seems not to be used
          }
        }
        else
        {
          for (s = 0; s <= nseas; s++)
          {
            wtlen_seas(s, gp, j) = 1.0;
          }
        }
      }
  }
  else
  {
    VBK_seas = sum(seasdur); // set vector to null effect
    for (s = 1; s <= nseas; s++)
      wtlen_seas(s) = 1.0; // set vector to null effect
  }

  //  SS_Label_Info_15.2  #create variability of size-at-age factors using direct assignment or offset approaches
  gp = 0;
  for (gg = 1; gg <= gender; gg++)
    for (g = 1; g <= N_GP; g++)
    {
      gp++;
      Ip = MGparm_point(gg, g);
      j = Ip + N_M_Grow_parms - 2; // index for CVmin
      k = j + 1; // index for CVmax
      switch (MGparm_def) // for CV of size-at-age
      {
        case 1: // direct
        {
          if (MGparm(j) > 0)
          {
            CVLmin(gp) = MGparm(j);
          }
          else
          {
            CVLmin(gp) = MGparm(N_M_Grow_parms - 1);
          }
          if (MGparm(k) > 0)
          {
            CVLmax(gp) = MGparm(k);
          }
          else
          {
            CVLmax(gp) = MGparm(N_M_Grow_parms);
          }
          break;
        }
        case 2: // offset
        {
          if (gp == 1)
          {
            CVLmin(gp) = MGparm(j);
            CVLmax(gp) = MGparm(k);
          }
          else
          {
            CVLmin(gp) = CVLmin(1) * mfexp(MGparm(j));
            CVLmax(gp) = CVLmax(1) * mfexp(MGparm(k));
          }
          break;
        }
        case 3: // offset like SS2 V1.23
        {
          if (gp == 1)
          {
            CVLmin(gp) = MGparm(j);
            CVLmax(gp) = CVLmin(1) * mfexp(MGparm(k));
          }
          else
          {
            CVLmin(gp) = CVLmin(1) * mfexp(MGparm(j));
            CVLmax(gp) = CVLmin(gp) * mfexp(MGparm(k));
          }
          break;
        }
      } // end switch
      if ((CVLmin(gp) != CVLmax(gp)) || active(MGparm(N_M_Grow_parms)) || active(MGparm(k)))
      {
        CV_const(gp) = 1;
      }
      else
      {
        CV_const(gp) = 0;
      }
    }
  }

//********************************************************************
 /*  SS_Label_Function_ 16 #get_growth2; (do seasonal growth calculations for a selected year) */
FUNCTION void get_growth2(const int y)
  {
  //  called at beginning of each year, so y is known
  //  if y=styr, then does equilibrium size-at-age according to start year growth parameters
  //  for any year, calculates for each season the size at the beginning of the next season, with growth increment calculated according to that year's parameters

  //Growth Cessation Model code added by Mark Maunder October 2018
  //The growth cessation model is described in
  //Maunder, M.N., Deriso, R.B., Schaefer, K.M., Fuller, D.W., Aires-da-Silva, A.M., MinteVera, C.V., Campana, S.E. 2018. The growth cessation model: a growth model for species showing a near cessation in growth with application to bigeye tuna (Thunnus obesus). Marine Biology (2018) 165:76.
  //Ian Taylor derived the formula for Linf

  int k2;
  int add_age;
  int ALK_idx2; //  beginning of first subseas of next season
  dvariable plusgroupsize;
  dvariable current_size;
  dvariable VBK_temp;
  dvariable VBK_temp2; //  with VBKseas(s) multiplied
  dvariable LminR;
  dvariable LmaxR;
  dvariable LinfR;
  dvariable inv_Richards;
  dvariable t50;
  //  SS_Label_Info_16.1 #Create Cohort_Growth offset for the cohort borne (age 0) this year
  if (CGD_onoff > 0) //  cohort specific growth multiplier
  {
    temp = mgp_adj(MGP_CGD);
    k = min(nages, (YrMax - y));
    for (a = 0; a <= k; a++)
    {
      Cohort_Growth(y + a, a) = temp;
    } //  so this multiplier on growth_increment is stored on a diagonal into the future
  }

  //  SS_Label_Info_16.2 #Loop growth patterns (sex*N_GP)
  gp = 0;
  #ifdef DO_ONCE
  {
    if (do_once == 1)
      echoinput << "GROWTH,  yr= " << y << endl;
  }
  #endif
  for (gg = 1; gg <= gender; gg++)
    for (GPat = 1; GPat <= N_GP; GPat++)
    {
      gp++;
      Ip = MGparm_point(gg, GPat) + N_natMparms;
      switch (Grow_type) //  create specific growth parameters from the mgp_adj list of current MGparms
      {
        case 7: //  empirical length
        {
          break;
        }

        default: //  process parameters for all other grow_type
        {
          //  SS_Label_Info_16.2.1  #set Lmin, Lmax, VBK, Richards to this year's values for mgp_adj
          if (MGparm_def > 1 && gp > 1) // do offset approach
          {
            Lmin(gp) = Lmin(1) * mfexp(mgp_adj(Ip));
            Lmax_temp(gp) = Lmax_temp(1) * mfexp(mgp_adj(Ip + 1));
            VBK(gp) = VBK(1) * mfexp(mgp_adj(Ip + 2)); //  assigns to all ages for which VBK is defined
          }
          else
          {
            Lmin(gp) = mgp_adj(Ip);
            Lmax_temp(gp) = mgp_adj(Ip + 1); //  size at A2; could be 999 to indicate Linf
            VBK(gp) = -mgp_adj(Ip + 2); // because always used as negative; assigns to all ages for which VBK is defined
          }
          VBK_temp = VBK(gp, 0); //  will be reset to VBK(gp,nages) if using age-specific K

          //  SS_Label_Info_16.2.2  #Set up age specific k
          if (Grow_type == 3) //  age specific k
          {
            j = 1;
            for (a = 1; a <= nages; a++)
            {
              if (a == Age_K_points(j))
              {
                VBK(gp, a) = VBK(gp, a - 1) * mgp_adj(Ip + 2 + j);
                if (j < Age_K_count)
                  j++;
              }
              else
              {
                VBK(gp, a) = VBK(gp, a - 1);
              }
            }
            VBK_temp = VBK(gp, nages);
          }
          else if (Grow_type == 4) //  age specific k  reverse order, so age_k_points need to be descending
          {
            j = 1;
            VBK(gp, nages) = VBK_temp;
            for (a = nages - 1; a >= 0; a--)
            {
              if (a == Age_K_points(j))
              {
                VBK(gp, a) = VBK(gp, a + 1) * mgp_adj(Ip + 2 + j);
                if (j < Age_K_count)
                  j++;
              }
              else
              {
                VBK(gp, a) = VBK(gp, a + 1);
              }
            }
          }
          else if (Grow_type == 5) //  age specific k replacement, so age_k_points need to be descending
          {
            j = 1;
            for (a = nages; a >= 0; a--)
            {
              if (a == Age_K_points(j))
              {
                VBK(gp, a) = mgp_adj(Ip + 2 + j) * VBK_temp;
                if (j < Age_K_count)
                  j++;
              }
              else
              {
                VBK(gp, a) = VBK_temp;
              }
            }
            VBK_temp = VBK(gp, nages);
          }

          //  get Linf from Lmax
          //  get Richards or growth cessation parameter if appropriate
          if (Grow_type == 2) //  Richards
          {
            if (MGparm_def > 1 && gp > 1)
            {
              Richards(gp) = Richards(1) * mfexp(mgp_adj(Ip + 3));
            }
            else
            {
              Richards(gp) = mgp_adj(Ip + 3);
            }
            LminR = pow(Lmin(gp), Richards(gp));
            inv_Richards = 1.0 / Richards(gp);
            if (AFIX2 == 999)
            {
              L_inf(gp) = Lmax_temp(gp);
              LinfR = pow(L_inf(gp), Richards(gp));
            }
            else
            {
              LmaxR = pow(Lmax_temp(gp), Richards(gp));
              LinfR = LminR + (LmaxR - LminR) / (1. - mfexp(VBK_temp * VBK_seas(0) * (AFIX_delta)));
              L_inf(gp) = pow(LinfR, inv_Richards);
            }
  #ifdef DO_ONCE
            if (do_once == 1)
              echoinput << " linf  " << L_inf(gp) << "   VBK: " << VBK_temp << endl;
  #endif
          }
          else if (Grow_type == 8)
          {
            if (MGparm_def > 1 && gp > 1)
            {
              Richards(gp) = Richards(1) * mfexp(mgp_adj(Ip + 3));
            }
            else
            {
              Richards(gp) = mgp_adj(Ip + 3);
            }
            L_inf(gp) = Lmax_temp(gp);
            VBK_temp = -VBK(gp, 0) * VBK_seas(0);
            // t50 is the calculated inflection age for the decline in K
            t50 = log(exp((L_inf(gp) - Lmin(gp)) * Richards(gp) / VBK_temp) - 1.0) / Richards(gp);
          }
          else
          {
            if (AFIX2 == 999)
            {
              L_inf(gp) = Lmax_temp(gp);
            }
            else
            {
              L_inf(gp) = Lmin(gp) + (Lmax_temp(gp) - Lmin(gp)) / (1. - mfexp(VBK_temp * VBK_seas(0) * (AFIX_delta)));
  #ifdef DO_ONCE
              if (do_once == 1)
                echoinput << VBK_temp << " " << VBK_seas(0) << " " << VBK_temp * VBK_seas(0) << " " << Lmax_temp(gp) << " " << L_inf(gp) << endl;
  #endif
            }
          }

          //  SS_Label_Info_16.2.3  #Set up Lmin and Lmax in Start Year
          if (y == styr)
          {
            Cohort_Lmin(gp) = Lmin(gp); //  sets for all years and ages
          }
          else if (timevary_MG(y, 2) > 0) //  using time-vary growth
          {
            k = min(nages, (YrMax - y));
            for (a = 0; a <= k; a++)
            {
              Cohort_Lmin(gp, y + a, a) = Lmin(gp);
            } //  sets for future years so cohort remembers its size at birth; with Lmin(gp) being size at birth this year
          }
        } //  end setup of parametric growth parameters
      } //  end switch between parametric and non-parametric growth
  #ifdef DO_ONCE
      if (do_once == 1)
      {
        echoinput << "sex: " << gg << " GP: " << gp << " Lmin: " << Lmin(gp) << " Linf: " << L_inf(gp) << " VBK_temp: " << VBK_temp << " VBK@age: " << -VBK(gp) << endl;
        if (Grow_type == 2)
          echoinput << "  Richards: " << Richards(gp) << endl;
        if (Grow_type == 8)
          echoinput << "  Cessation_decay: " << Richards(gp) << endl;
      }
  #endif
      //  SS_Label_Info_16.2.4  #Loop settlement events because growth starts at time of settlement
      g = g_Start(gp); //  base platoon
      for (settle = 1; settle <= N_settle_timings; settle++)
      {
        g += N_platoon; //  increment by N_platoon because only middle platoon has growth modeled
        if (use_morph(g) > 0)
        {
          if (y == styr)
          {
            switch (Grow_type)
            {
              case 7: //  non-parametric
              {
                break;
              }
              default:
              {
                //  SS_Label_Info_16.2.4.1  #set up the delta in growth variability across ages if needed
                if (CV_const(gp) > 0)
                {
                  if (CV_depvar_a == 0)
                  {
                    CV_delta(gp) = (CVLmax(gp) - CVLmin(gp)) / (Lmax_temp(gp) - Lmin(gp));
                  }
                  else
                  {
                    CV_delta(gp) = (CVLmax(gp) - CVLmin(gp)) / (AFIX2_forCV - AFIX);
                  }
                }
                else
                {
                  CV_delta(gp) = 0.0;
                  CV_G(gp) = CVLmin(gp); // sets all seasons and whole age range
                }
              }
            }

            //  SS_Label_Info_16.2.4.1.1  #if y=styr, get size-at-age in first subseason of first season of this first year
            switch (Grow_type)
            {
              case 1:
              {
                VBK_temp2 = VBK_temp * VBK_seas(0);
                for (a = 0; a <= nages; a++)
                {
                  //                    Ave_Size(styr,1,g,a) = Lmin(gp) + (Lmin(gp)-L_inf(gp))* (mfexp(VBK_temp2*(real_age(g,1,a)-AFIX))-1.0);
                  Ave_Size(styr, 1, g, a) = L_inf(gp) + (Lmin(gp) - L_inf(gp)) * mfexp(VBK_temp2 * (real_age(g, 1, a) - AFIX));
                } // done ageloop
                break;
              }
              case 2: // Richards
              {
                Ave_Size(styr, 1, g)(0, first_grow_age(g)) = Lmin(gp);
                VBK_temp2 = VBK_temp * VBK_seas(0);
                for (a = first_grow_age(g); a <= nages; a++)
                {
                  temp = LinfR + (LminR - LinfR) * mfexp(VBK_temp2 * (real_age(g, 1, a) - AFIX));
                  Ave_Size(styr, 1, g, a) = pow(temp, inv_Richards);
                } // done ageloop
                break;
              }
              case 5:
              {
              }
              case 4:
              {
              }
              case 3: //  age-specific K, so need age-by-age calculations
              {
                ALK_idx = 1;
                //VBK_seas(0) accounts for season duration
                for (a = 0; a <= nages; a++)
                {
                  k2 = a - 1;
                  if (lin_grow(g, ALK_idx, a) >= -1.0) // linear segment, or first time point beyond AFIX;
                  {
                    Ave_Size(styr, 1, g, a) = Lmin(gp) + (Lmin(gp) - L_inf(gp)) * (mfexp(VBK(gp, 0) * VBK_seas(0) * (real_age(g, 1, a) - AFIX)) - 1.0);
                  }
                  else
                  {
                    Ave_Size(styr, 1, g, a) = Ave_Size(styr, 1, g, k2) + (mfexp(VBK(gp, k2) * VBK_seas(0)) - 1.0) * (Ave_Size(styr, 1, g, k2) - L_inf(gp));
                  }
                  //                  echoinput<<a<<" "<<lin_grow(g,ALK_idx,a)<<" "<<real_age(g,1,a)-AFIX<<" "<<Ave_Size(styr,1,g,a) <<endl;
                } // done ageloop
                break;
              }
              case 8: // Growth Cessation Model
              {
                //  r_max (parameter related to maximum growth rate) = vbktemp
                //  L0 (mean length at age 0)
                //  Linf (asymptotic mean length)
                //  k (steepness of the logistic function that models the reduction in the growth increment) = Richards
                VBK_temp2 = VBK_temp * VBK_seas(0);
                Ave_Size(styr, 1, g)(0, first_grow_age(g)) = Lmin(gp); //assume first_grow_age(g) = 0
                for (a = first_grow_age(g); a <= nages; a++)
                {
                  Ave_Size(styr, 1, g, a) = Lmin(gp) + VBK_temp2 * ((log(exp(-Richards(gp) * t50) + 1) - log(exp(Richards(gp) * (real_age(g, 1, a) - AFIX - t50)) + 1)) / Richards(gp) + real_age(g, 1, a) - AFIX);
                } // done ageloop
                break;
              }
            }
  #ifdef DO_ONCE
            if (do_once == 1)
              echoinput << "  settlement: " << settle << " g: " << g << endl
                        << "  L@A initial_year (w/o lin): " << Ave_Size(styr, 1, g)(0, min(6, nages)) << " plusgroup: " << Ave_Size(styr, 1, g, nages) << endl;
  #endif

            //  SS_Label_Info_16.2.4.1.4  #calc approximation to mean size at maxage to account for growth after reaching the maxage (accumulator age)
            current_size = Ave_Size(styr, 1, g, nages);
            if (Linf_decay > -997.) //  decay rate has been read;  uses same code for Richards and standard
            {
              temp1 = 1.0;
              temp4 = 1.0;
              temp = current_size;
              temp2 = mfexp(-Linf_decay); //  cannot use natM or Z because growth is calculated first
  #ifdef DO_ONCE
              if (do_once == 1)
                echoinput << " L_inf " << L_inf(gp) << " size@exactly maxage " << current_size << endl;
  #endif
              if (Grow_type < 3)
              {
                VBK_temp2 = VBK(gp, 0);
              }
              else
              {
                VBK_temp2 = VBK(gp, nages);
              }
              VBK_temp2 = (1.0 - mfexp(VBK_temp2 * VBK_seas(0)));
              for (a = nages + 1; a <= 3 * nages; a++)
              {
                temp4 *= temp2; //  decay numbers at age by exp(-0.xxx)
                current_size += (L_inf(gp) - current_size) * VBK_temp2;
                temp += temp4 * current_size;
                temp1 += temp4; //  accumulate numbers to create denominator for mean size calculation
              }
              Ave_Size(styr, 1, g, nages) = temp / temp1; //  this is weighted mean size at nages
            }
            else if (Linf_decay == -999.) //  mimic SS3.24
            {
              temp = 0.0;
              temp1 = 0.0;
              temp2 = mfexp(-0.2); //  cannot use natM or Z because growth is calculated first
              temp3 = L_inf(gp) - current_size; // delta between linf and the size at nages
              //  frac_ages = age/nages, so is fraction of a lifetime
              temp4 = 1.0;
              for (a = 0; a <= nages; a++)
              {
                temp += temp4 * (current_size + frac_ages(a) * temp3); // so grows linearly from size at nages to size at nages+nages
                temp1 += temp4; //  accumulate numbers to create denominator for mean size calculation
                temp4 *= temp2; //  decay numbers at age by exp(-0.2)
              }
              Ave_Size(styr, 1, g, nages) = temp / temp1; //  this is weighted mean size at nages
            }
            else
            {
              //  no adjustment
            }
  #ifdef DO_ONCE
            if (do_once == 1)
              echoinput << "  adjusted size at maxage " << Ave_Size(styr, 1, g, nages) << "  using decay of: " << Linf_decay << endl;
  #endif
          } //  end initial year calcs

          //  SS_Label_Info_16.2.4.2  #loop seasons for growth calculation
          for (s = 1; s <= nseas; s++)
          {
            t = t_base + s;
            ALK_idx = s * N_subseas; // last subseas of season; so checks to see if still in linear phase at end of this season
            if (s == nseas)
            {
              ALK_idx2 = 1; //  first subseas of next year
            }
            else
            {
              ALK_idx2 = s * N_subseas + 1; //  for the beginning of first subseas of next season
            }
            if (s == nseas)
              add_age = 1;
            else
              add_age = 0; //      advance age or not
            // growth to next season
            VBK_temp2 = (mfexp(VBK_temp * seasdur(s) * VBK_seas(s)) - 1.0);
            //    warning<<t<<" ave_size_grow2_start "<<Ave_Size(t,1,1)(0,6)<<endl;
            switch (Grow_type)
            {
              case 1:
              {
                Ave_Size(t + 1, 1, g, 0) = Ave_Size(t, 1, g, 0); // carryforward, but may be overwritten in some circumstances
                for (a = 0; a <= nages; a++)
                {
                  if (a == nages)
                  {
                    k2 = a;
                  }
                  else
                  {
                    k2 = a + add_age;
                  } // where add_age =1 if s=nseas, else 0  (k2 assignment could be in a matrix so not recalculated
                  // NOTE:  there is no seasonal interpolation, or real age adjustment for age-specific K.  Maybe someday....
                  if (lin_grow(g, ALK_idx, a) == -2.0) //  so doing growth curve
                  {
                    t2 = Ave_Size(t, 1, g, a) - L_inf(gp); //  remaining growth potential from first subseas
                    if (timevary_MG(y, 2) > 0 && t2 > -1.)
                    {
                      join1 = 1.0 / (1.0 + mfexp(-(50. * t2 / (1.0 + fabs(t2))))); //  note the logit transform is not perfect, so growth near Linf will not be exactly same as with native growth function
                      t2 *= (1. - join1); // trap to prevent decrease in size-at-age
                    }

                    //  SS_Label_info_16.2.4.2.1.1  #calc size at end of the season, which will be size at begin of next season using current seasons growth parms
                    //  with k2 adding an age if at the end of the year
                    if ((a < nages || s < nseas))
                      Ave_Size(t + 1, 1, g, k2) = Ave_Size(t, 1, g, a) + VBK_temp2 * t2 * Cohort_Growth(y, a);
                    if (a == nages && s == nseas)
                    {
                      plusgroupsize = Ave_Size(t, 1, g, nages) + VBK_temp2 * t2 * Cohort_Growth(y, nages);
                    }
                  }
                  else if (lin_grow(g, ALK_idx, a) == -1.0) // first time point beyond AFIX;  lin_grow will stay at -1 for all remaining subseas of this season
                  {
                    Ave_Size(t + 1, 1, g, k2) = Cohort_Lmin(gp, y, a) + (Cohort_Lmin(gp, y, a) - L_inf(gp)) * (mfexp(VBK_temp * (real_age(g, ALK_idx2, k2) - AFIX) * VBK_seas(s)) - 1.0) * Cohort_Growth(y, a);
                  }
                  else // in linear phase
                  {
                    Ave_Size(t + 1, 1, g, k2) = len_bins(1) + lin_grow(g, ALK_idx, a) * (Cohort_Lmin(gp, y, a) - len_bins(1));
                  }
                  //                  if(y==1990 && g==1) warning<<a<<" "<<lin_grow(g,ALK_idx,a)<<" "<<Ave_Size(t,1,g,a)<<" "<<Ave_Size(t+1,1,g,k2)<<endl;
                } // done ageloop
                break;
              }
              case 2: // Richards
              {
                for (a = 0; a <= nages; a++)
                {
                  if (a == nages)
                  {
                    k2 = a;
                  }
                  else
                  {
                    k2 = a + add_age;
                  } // where add_age =1 if s=nseas, else 0  (k2 assignment could be in a matrix so not recalculated
                  // NOTE:  there is no seasonal interpolation, or real age adjustment for age-specific K.  Maybe someday....
                  if (lin_grow(g, ALK_idx, a) == -2.0)
                  {
                    temp = pow(Ave_Size(t, 1, g, a), Richards(gp));
                    t2 = temp - LinfR; //  remaining growth potential in transformed units
                    if ((a < nages || s < nseas))
                      Ave_Size(t + 1, 1, g, k2) =
                          pow((temp + VBK_temp2 * t2 * Cohort_Growth(y, a)), inv_Richards);
                    if (a == nages && s == nseas)
                      plusgroupsize = pow((temp + VBK_temp2 * t2 * Cohort_Growth(y, a)), inv_Richards);
                  }
                  else if (lin_grow(g, ALK_idx, a) == -1.0) // first time point beyond AFIX;  lin_grow will stay at -1 for all remaining subseas of this season
                  {
                    //                  temp=LminR + (LminR-LinfR)*(mfexp(VBK_temp*seasdur(s)*(real_age(g,ALK_idx2,k2)-AFIX))-1.0)*Cohort_Growth(y,a);
                    temp = LminR + (LminR - LinfR) * (mfexp(VBK_temp * (real_age(g, ALK_idx2, k2) - AFIX) * VBK_seas(s)) - 1.0) * Cohort_Growth(y, a);
                    Ave_Size(t + 1, 1, g, k2) = pow(temp, inv_Richards);
                  }
                  else // in linear phase for subseas
                  {
                    Ave_Size(t + 1, 1, g, a) = len_bins(1) + lin_grow(g, ALK_idx, a) * (Cohort_Lmin(gp, y, a) - len_bins(1));
                  }

                } // done ageloop
                break;
              }
              case 8: // Cessation
              {
                for (a = 0; a <= nages; a++)
                {
                  k2 = a + add_age; // where add_age =1 if s=nseas, else 0  (k2 assignment could be in a matrix so not recalculated
                  if (a == nages)
                    k2 = a;
                  // calculate a full year's growth increment, then multiple by seasdur(s)
                  if (a < nages || s < nseas)
                    Ave_Size(t + 1, 1, g, k2) = Ave_Size(t, 1, g, a) +
                        (VBK_temp - (VBK_temp / Richards(gp)) * (log(exp(Richards(gp) * (real_age(g, 1, a) + 1 - t50)) + 1) - log(exp(Richards(gp) * (real_age(g, 1, a) - t50)) + 1))) * seasdur(s);
                  if (a == nages && s == nseas)
                    plusgroupsize = Ave_Size(t, 1, g, nages) +
                        (VBK_temp - (VBK_temp / Richards(gp)) * (log(exp(Richards(gp) * (real_age(g, 1, a) + 1 - t50)) + 1) - log(exp(Richards(gp) * (real_age(g, 1, a) - t50)) + 1))) * seasdur(s);
                  /*
                  echoinput<<a<<" "<<k2<<" "<<grow_inc<<" lin? "<<lin_grow(g,ALK_idx,a)<<" "<<Cohort_Lmin(gp,y,a)<<endl;
                  if(lin_grow(g,ALK_idx,a)==-2.0)
                  {
                    if((a<nages || s<nseas)) Ave_Size(t+1,1,g,k2) =  Ave_Size(t,1,g,a)+grow_inc*seasdur(s);
                    if(a==nages && s==nseas) plusgroupsize = Ave_Size(t,1,g,nages)+grow_inc*seasdur(s);
                  }
                  else if(lin_grow(g,ALK_idx,a)==-1.0)  // first time point beyond AFIX;  lin_grow will stay at -1 for all remaining subseas of this season
                  {
                    Ave_Size(t+1,1,g,k2) = Cohort_Lmin(gp,y,a)+grow_inc*seasdur(s);
                  }
                  else  // in linear phase for subseas
                  {
                    Ave_Size(t+1,1,g,a) = len_bins(1)+lin_grow(g,ALK_idx,a)*(Cohort_Lmin(gp,y,a)-len_bins(1));
                  }
   */
                } // done ageloop
                break;
              }
              case 5:
              {
              }
              case 4:
              {
              }
              case 3:
              {
                //  SS_Label_Info_16.2.4.2.1  #standard von Bert growth, loop ages to get size at age at beginning of next season (t+1) which is subseas=1
                for (a = 0; a <= nages; a++)
                {
                  if (a < nages)
                  {
                    k2 = a + add_age;
                  }
                  else
                  {
                    k2 = a;
                  } // where add_age =1 if s=nseas, else 0  (k2 assignment could be in a matrix so not recalculated
                  // NOTE:  there is no seasonal interpolation, or real age adjustment for age-specific K.  Maybe someday....
                  if (lin_grow(g, ALK_idx, a) == -2.0) //  so doing growth curve
                  {
                    t2 = Ave_Size(t, 1, g, a) - L_inf(gp); //  remaining growth potential from first subseas
                    if (timevary_MG(y, 2) > 0 && t2 > -1.)
                    {
                      join1 = 1.0 / (1.0 + mfexp(-(50. * t2 / (1.0 + fabs(t2))))); //  note the logit transform is not perfect, so growth near Linf will not be exactly same as with native growth function
                      t2 *= (1. - join1); // trap to prevent decrease in size-at-age
                    }

                    //  SS_Label_info_16.2.4.2.1.1  #calc size at end of the season, which will be size at begin of next season using current seasons growth parms
                    //  with k2 adding an age if at the end of the year
                    if ((a < nages || s < nseas))
                      Ave_Size(t + 1, 1, g, k2) = Ave_Size(t, 1, g, a) + (mfexp(VBK(gp, a) * seasdur(s) * VBK_seas(s)) - 1.0) * t2 * Cohort_Growth(y, a);
                    if (a == nages && s == nseas)
                      plusgroupsize = Ave_Size(t, 1, g, nages) + (mfexp(VBK(gp, nages) * seasdur(s) * VBK_seas(s)) - 1.0) * t2 * Cohort_Growth(y, nages);
                  }
                  else if (lin_grow(g, ALK_idx, a) == -1.0) // first time point beyond AFIX;  lin_grow will stay at -1 for all remaining subseas of this season
                  {
                    Ave_Size(t + 1, 1, g, k2) = Cohort_Lmin(gp, y, a) + (Cohort_Lmin(gp, y, a) - L_inf(gp)) * (mfexp(VBK(gp, a) * (real_age(g, ALK_idx2, k2) - AFIX) * VBK_seas(s)) - 1.0) * Cohort_Growth(y, a);
                  }
                  else // in linear phase
                  {
                    Ave_Size(t + 1, 1, g, a) = len_bins(1) + lin_grow(g, ALK_idx, a) * (Cohort_Lmin(gp, y, a) - len_bins(1));
                  }
                } // done ageloop
                break;
              }
            }

            //  SS_Label_Info_16.2.4.2.1.2  #after age loop, if(s=nseas) get weighted average for size_at_maxage from carryover fish and fish newly moving into this age
            //  this code needs to execute every year, so need to move to ss_popdyn.  Positioned here, it is only updated in years in which growth changes
            if (s == nseas)
            {
              if (y > styr && Linf_decay != -998.)
              {

//  3.24 code
  #ifdef DO_ONCE
                if (do_once == 1)
                  echoinput << "  plus group calc: "
                            << " N _entering: " << natage(t, 1, g, nages - 1) << " N_inplus: " << natage(t, 1, g, nages) << " size in: " << Ave_Size(t + 1, 1, g, nages) << " old size: " << plusgroupsize << " ";
  #endif
                temp = ((natage(t, 1, g, nages - 1) + 0.01) * Ave_Size(t + 1, 1, g, nages) + (natage(t, 1, g, nages) + 0.01) * plusgroupsize) / (natage(t, 1, g, nages - 1) + natage(t, 1, g, nages) + 0.02);
                Ave_Size(t + 1, 1, g, nages) = temp;
  #ifdef DO_ONCE
                if (do_once == 1 && g == 1)
                  echoinput << "  final_val " << Ave_Size(t + 1, 1, g, nages) << endl;
  #endif
                //  early 3.30 code
                //                  temp4= square(natage(t,1,g,nages-1)+0.00000001)/(natage(t-1,1,g,nages-2)+0.00000001);
                //                  temp=temp4*Ave_Size(t+1,1,g,nages)+(natage(t,1,g,nages)-temp4+0.00000001)*plusgroupsize;
                //                  if(do_once==1&&g==1) echoinput<<t<<" plus group calc: "<<" N "<<" "<<natage(t-1,1,g,nages-2)<<" "<<natage(t,1,g,nages-1)<<" "<<natage(t,1,g,nages)<<" T4  "<<temp4<<" N-T4  "<<natage(t,1,g,nages)-temp4+0.00000001<<
                //                  " size in: "<<Ave_Size(t+1,1,g,nages)<<" old size: "<<plusgroupsize<<" ";

                //  prototype code
                //                  temp4= square(natage(t-1,1,g,nages-1)+0.00000001)/(natage(t-2,1,g,nages-2)+0.00000001);
                //                  temp2=posfun(natage(t,1,g,nages)-temp4+0.00000001,0.0,temp);
                //                  temp=temp4*Ave_Size(t+1,1,g,nages)+(temp2)*plusgroupsize;
                //                  if(do_once==1&&g==1) echoinput<<t<<" plus group calc: "<<" N "<<" "<<natage(t-2,1,g,nages-2)<<" "<<natage(t-1,1,g,nages-1)<<" "<<natage(t,1,g,nages)<<" T4  "<<temp4<<" N-T4  "<<natage(t,1,g,nages)-temp4+0.00000001<<
                //                  " size in: "<<Ave_Size(t+1,1,g,nages)<<" old size: "<<plusgroupsize<<" ";

                //                  Ave_Size(t+1,1,g,nages)=temp/(natage(t,1,g,nages)+0.00000001);
                //                  if(do_once==1&&g==1) echoinput<<" temp "<<temp<<" denom "<<(natage(t,1,g,nages)+0.00000001)<<" Z "<<Z_rate(t-1,1,1,nages-1);
              }
              else
              {
                Ave_Size(t + 1, 1, g, nages) = Ave_Size(t, 1, g, nages);
              }
            }

  #ifdef DO_ONCE
            if (do_once == 1)
              echoinput << "  seas: " << s << "  size@t+1:  " << Ave_Size(t + 1, 1, g)(0, min(6, nages)) << " plusgroup: " << Ave_Size(t + 1, 1, g, nages) << endl;
  #endif
          } // end of season

          /*
//  move this code to popdyn in styr so can use adjustments made by growth3
//  SS_Label_Info_16.2.4.3  #propagate Ave_Size from early years forward until first year that has time-vary growth
          k=y+1;
          j=yz+1;
          while(timevary_MG(j,2)==0 && k<=YrMax)
          {
            for (s=1;s<=nseas;s++)
            {
              t=styr+(k-styr)*nseas+s-1;
              Ave_Size(t,1,g)=Ave_Size(t-nseas,1,g);
              if(s==1 && k<YrMax)
              {
                Ave_Size(t+nseas,1,g)=Ave_Size(t,1,g);  // prep for time-vary next yr
              }
            }  // end season loop
            k++;
            if(j<endyr+1) j++;
          }
   */
        } // end need to consider this GP x settlement combo (usemorph>0)
      } // end loop of settlements
      Ip += N_M_Grow_parms;
    } // end loop of growth patterns, gp
  } // end do growth

//  *******************************************************************************************************
//  SS_Label_Function_16.5  #get_growth3 which calculates mean size-at-age for selected subseason
FUNCTION void get_growth3(const int y, const int t, const int s, const int subseas)
  {
  //  progress mean growth through time series, accounting for seasonality and possible change in parameters
  //   get mean size at the beginning and end of the season
  dvariable LinfR;
  dvariable LminR;
  dvariable inv_Richards;
  dvariable t50;
  dvariable VBK_temp2;

  ALK_idx = (s - 1) * N_subseas + subseas; //  note that this changes a global value
  for (g = g_Start(1) + N_platoon; g <= gmorph; g += N_platoon) // looping the middle platoons for each sex*gp
  {
    if (use_morph(g) > 0)
    {
      gp = GP(g);
      switch (Grow_type)
      {
        case 1: // regular von B
        {
          for (a = 0; a <= nages; a++)
          {
            //  SS_Label_Info_16.5.1  #calc subseas size-at-age from begin season size-at-age, accounting for transition from linear to von Bert as necessary
            //  subseasdur is cumulative time to start of this subseas
            if (lin_grow(g, ALK_idx, a) == -2.0) //  so doing growth curve
            {
              t2 = Ave_Size(t, 1, g, a) - L_inf(gp); //  remaining growth potential from first subseas
              //  the constant in join needs to be at least 30 to get rapid transition
              //   the consequence of (t2>-1.) should be investigated for effect on gradient
              if (timevary_MG(y, 2) > 0 && t2 > -1.)
              {
                join1 = 1.0 / (1.0 + mfexp(-(50. * t2 / (1.0 + fabs(t2))))); //  note the logit transform is not perfect, so growth near Linf will not be exactly same as with native growth function
                t2 *= (1. - join1); // trap to prevent decrease in size-at-age
              }
              Ave_Size(t, subseas, g, a) = Ave_Size(t, 1, g, a) + (mfexp(VBK(gp, 0) * subseasdur(s, subseas) * VBK_seas(s)) - 1.0) * t2 * Cohort_Growth(y, a);
            }
            else if (lin_grow(g, ALK_idx, a) >= 0.0) // in linear phase for subseas
            {
              Ave_Size(t, subseas, g, a) = len_bins(1) + lin_grow(g, ALK_idx, a) * (Cohort_Lmin(gp, y, a) - len_bins(1));
            }
            // NOTE:  there is no seasonal interpolation, age-specific K uses calendar age, not real age.  Maybe someday....
            else if (lin_grow(g, ALK_idx, a) == -1.0) // first time point beyond AFIX;  lin_grow will stay at -1 for all remaining subseas of this season
            {
              Ave_Size(t, subseas, g, a) = Cohort_Lmin(gp, y, a) + (Cohort_Lmin(gp, y, a) - L_inf(gp)) * (mfexp(VBK(gp, 0) * (real_age(g, ALK_idx, a) - AFIX) * VBK_seas(s)) - 1.0) * Cohort_Growth(y, a);
            }
          }
          break;
        }
        case 2: //  Richards
        {
          LinfR = pow(L_inf(gp), Richards(gp));
          LminR = pow(Lmin(gp), Richards(gp));
          inv_Richards = 1.0 / Richards(gp);
          //  uses VBK(nages) because age-specific K not allowed
          //  and Cohort_Lmin has already had the power function applied
          for (a = 0; a <= nages; a++)
          {
            if (lin_grow(g, ALK_idx, a) == -2.0) //  so doing growth curve
            {
              temp = pow(Ave_Size(t, 1, g, a), Richards(gp));
              t2 = temp - LinfR; //  remaining growth potential
              //              disable the shrinkage trap because Richard's parameter could be negative
              //              join1=1.0/(1.0+mfexp(-(50.*t2/(1.0+fabs(t2)))));  //  note the logit transform is not perfect, so growth near Linf will not be exactly same as with native growth function
              //              t2*=(1.-join1);  // trap to prevent decrease in size-at-age
              temp += (mfexp(VBK(gp, 0) * subseasdur(s, subseas) * VBK_seas(s)) - 1.0) * t2 * Cohort_Growth(y, a);
              Ave_Size(t, subseas, g, a) = pow(temp, inv_Richards);
            }
            else if (lin_grow(g, ALK_idx, a) >= 0.0) // in linear phase for subseas
            {
              Ave_Size(t, subseas, g, a) = len_bins(1) + lin_grow(g, ALK_idx, a) * (Cohort_Lmin(gp, y, a) - len_bins(1));
            }
            else if (lin_grow(g, ALK_idx, a) == -1.0) // first time point beyond AFIX;  lin_grow will stay at -1 for all remaining subseas of this season
            {
              //              temp=Cohort_Lmin(gp,y,a) + (Cohort_Lmin(gp,y,a)-LinfR)*
              temp = LminR + (LminR - LinfR) * (mfexp(VBK(gp, 0) * (real_age(g, ALK_idx, a) - AFIX) * VBK_seas(s)) - 1.0) * Cohort_Growth(y, a);
              Ave_Size(t, subseas, g, a) = pow(temp, inv_Richards);
            }
          } // done ageloop
          break;
        } //  done Richards
        case 8: // Cessation
        {
          //                VBK_temp2=-VBK_temp*seasdur(s);  //  negative to restore positive
          // t50 is the calculated inflection age for the decline in K
          dvariable VBK_temp = -VBK(gp, 0);
          t50 = log(exp((L_inf(gp) - Lmin(gp)) * Richards(gp) / (VBK_temp)) - 1.0) / Richards(gp);
          for (a = 0; a <= nages; a++)
          {
            // calculate a full year's growth increment, then multiple by seasdur(s)
            Ave_Size(t, subseas, g, a) = Ave_Size(t, 1, g, a) +
                (VBK_temp - (VBK_temp / Richards(gp)) * (log(exp(Richards(gp) * (real_age(g, ALK_idx, a) + 1 - t50)) + 1) - log(exp(Richards(gp) * (real_age(g, ALK_idx, a) - t50)) + 1))) * subseasdur(s, subseas);
          } // done ageloop
          break;
        }
        case 5: // von B with age-specific K
        {
        }
        case 4: // von B with age-specific K
        {
        }
        case 3: // von B with age-specific K
        {
          for (a = 0; a <= nages; a++)
          {
            //  SS_Label_Info_16.5.1  #calc subseas size-at-age from begin season size-at-age, accounting for transition from linear to von Bert as necessary
            //  subseasdur is cumulative time to start of this subseas
            if (lin_grow(g, ALK_idx, a) == -2.0) //  so doing growth curve
            {
              t2 = Ave_Size(t, 1, g, a) - L_inf(gp); //  remaining growth potential from first subseas
              //  the constant in join needs to be at least 30 to get rapid transition
              //   the consequence of (t2>-1.) should be investigated for effect on gradient
              if (timevary_MG(y, 2) > 0 && t2 > -1.)
              {
                join1 = 1.0 / (1.0 + mfexp(-(50. * t2 / (1.0 + fabs(t2))))); //  note the logit transform is not perfect, so growth near Linf will not be exactly same as with native growth function
                t2 *= (1. - join1); // trap to prevent decrease in size-at-age
              }
              Ave_Size(t, subseas, g, a) = Ave_Size(t, 1, g, a) + (mfexp(VBK(gp, a) * subseasdur(s, subseas) * VBK_seas(s)) - 1.0) * t2 * Cohort_Growth(y, a);
            }
            else if (lin_grow(g, ALK_idx, a) >= 0.0) // in linear phase for subseas
            {
              Ave_Size(t, subseas, g, a) = len_bins(1) + lin_grow(g, ALK_idx, a) * (Cohort_Lmin(gp, y, a) - len_bins(1));
            }
            // NOTE:  there is no seasonal interpolation, age-specific K uses calendar age, not real age.  Maybe someday....
            else if (lin_grow(g, ALK_idx, a) == -1.0) // first time point beyond AFIX;  lin_grow will stay at -1 for all remaining subseas of this season
            {
              Ave_Size(t, subseas, g, a) = Cohort_Lmin(gp, y, a) + (Cohort_Lmin(gp, y, a) - L_inf(gp)) * (mfexp(VBK(gp, a) * (real_age(g, ALK_idx, a) - AFIX) * VBK_seas(s)) - 1.0) * Cohort_Growth(y, a);
            }
          }
          break;
        }
      } //  done switch
    } //  end need this platoon
  } //  done platoon
  } //  end  calc size-at-age at a particular subseason

FUNCTION void get_natmort()
  {
  //  SS_Label_Function #17 get_natmort for all seasons given this year's parameters
  dvariable Loren_M1;
  dvariable Loren_temp;
  dvariable Loren_temp2;
  dvariable Maunder_Mjuv;
  dvariable Maunder_lambda;
  dvariable Maunder_Lmat;
  dvariable Maunder_Mmat;
  dvariable Maunder_beta;
  dvariable Maunder_L50;
  dvar_vector XX_mature(0, nages);
  dvariable t_age;
  int gpi;
  int Do_AveAge;
  int K_index;
  K_index = VBK(1).indexmax();
  Do_AveAge = 0;
  t_base = styr + (yz - styr) * nseas - 1; //  so looping s=1 to nseas; t=t_base + s
  Ip = -N_M_Grow_parms; // start counter for MGparms
  //  SS_Label_Info_17.1  #loop growth patterns in each gender
  gp = 0;
  for (gg = 1; gg <= gender; gg++)
    for (GPat = 1; GPat <= N_GP; GPat++)
    {
      gp++;
      Ip = MGparm_point(gg, GPat) - 1;
      if (N_natMparms > 0)
      {
        //  SS_Label_Info_17.1.1 #Copy parameter values from mgp_adj to natMparms(gp), doing direct or offset for gp>1
        for (j = 1; j <= N_natMparms; j++)
        {
          natMparms(j, gp) = mgp_adj(Ip + j);
        }
        switch (MGparm_def) //  switch for natmort parms
        {
          case 1: // direct
          {
            for (j = 1; j <= N_natMparms; j++)
            {
              if (natMparms(j, gp) < 0)
                natMparms(j, gp) = natMparms(j, 1);
            }
            break;
          }
          case 2: // offset
          {
            if (gp > 1)
            {
              for (j = 1; j <= N_natMparms; j++)
              {
                natMparms(j, gp) = natMparms(j, 1) * mfexp(natMparms(j, gp));
              }
            }
            break;
          }
          case 3: // offset like SS2 V1.23
          {
            if (gp > 1)
              natMparms(1, gp) = natMparms(1, 1) * mfexp(natMparms(1, gp));
            if (N_natMparms > 1)
            {
              for (j = 2; j <= N_natMparms; j++)
              {
                natMparms(j, gp) = natMparms(j - 1, gp) * mfexp(natMparms(j, gp));
              }
            }
            break;
          }
        } // end switch
      } // end have natmort parms

      g = g_Start(gp); //  base platoon
      for (settle = 1; settle <= N_settle_timings; settle++)
      {
        //  SS_Label_Info_17.1.2  #loop settlements
        g += N_platoon;
        gpi = GP3(g); // GP*gender*settlement
        if (use_morph(g) > 0)
        {
          switch (natM_type)
          {
            //  SS_Label_Info_17.1.2.0  #case 0:  constant M
            case 0: // constant M
            {
              for (s = 1; s <= nseas; s++)
              {
                natM(t_base + s, 0, gpi) = natMparms(1, gp);
              }
              break;
            }

            //  SS_Label_Info_17.1.2.1  #case 1:  N breakpoints
            case 1: // breakpoints
            {
              dvariable natM_A;
              dvariable natM_B;
              for (s = 1; s <= nseas; s++)
              {
                if (s >= Bseas(g))
                {
                  a = 0;
                  t_age = azero_seas(s) - azero_G(g);
                }
                else
                {
                  a = 1;
                  t_age = 1.0 + azero_seas(s) - azero_G(g);
                }
                natM_amax = NatM_break(1);
                natM_B = natMparms(1, gp);
                k = a;

                for (loop = 1; loop <= N_natMparms + 1; loop++)
                {
                  natM_amin = natM_amax;
                  natM_A = natM_B;
                  if (loop <= N_natMparms)
                  {
                    natM_amax = NatM_break(loop);
                    natM_B = natMparms(loop, gp);
                  }
                  else
                  {
                    natM_amax = r_ages(nages) + 1.;
                  }
                  if (natM_amax > natM_amin)
                  {
                    temp = (natM_B - natM_A) / (natM_amax - natM_amin);
                  } //  calc the slope
                  else
                  {
                    temp = 0.0;
                  }
                  while (t_age < natM_amax && a <= nages)
                  {
                    natM(t_base + s, 0, gpi, a) = natM_A + (t_age - natM_amin) * temp;
                    t_age += 1.0;
                    a++;
                  }
                }
                if (k == 1)
                  natM(t_base + s, 0, gpi, 0) = natM(t_base + s, 0, gpi, 1);
              } // end season
              break;
            } // end natM_type==1

            //  SS_Label_Info_17.1.2.2  #case 2:  lorenzen M
            case 2: //  Lorenzen M
            {
              Loren_temp2 = L_inf(gp) * (mfexp(-VBK(gp, K_index) * VBK_seas(0)) - 1.); // need to verify use of VBK_seas here
              Loren_temp = Ave_Size(styr, mid_subseas, g, int(natM_amin)); // uses mean size in middle of season 1 for the reference age
              Loren_M1 = natMparms(1, gp) / log(Loren_temp / (Loren_temp + Loren_temp2));
              for (s = nseas; s >= 1; s--)
              {
                int Loren_t = styr + (yz - styr) * nseas + s - 1;
                natM(t_base + s, 0, gpi)(0, nages) = log(
                                              elem_div(Ave_Size(Loren_t, mid_subseas, g)(0, nages), (Ave_Size(Loren_t, mid_subseas, g)(0, nages) + Loren_temp2))) *
                      Loren_M1;
                if (s < Bseas(g))
                  {natM(t_base + s, 0, gpi, 0) = natM(t_base + s + 1, 0, gpi, 0);}
              }
              break;
            }

            //  SS_Label_Info_17.1.2.3  #case 3:  set to empirical M as read from file, no seasonal interpolation
            case (3): // read age_natmort as constant
            {
              for (s = 1; s <= nseas; s++)
              {
                natM(t_base + s, 0, gpi) = Age_NatMort(gp);
              }
              break;
            }

            //  SS_Label_Info_17.1.2.4  #case 4:  read age_natmort as constant and interpolate to seasonal real age
            case (4):
            {
              for (s = 1; s <= nseas; s++)
              {
                if (s >= Bseas(g))
                {
                  k = 0;
                  t_age = azero_seas(s) - azero_G(g);
                  for (a = k; a <= nages - 1; a++)
                  {
                    natM(t_base + s, 0, gpi, a) = Age_NatMort(gp, a) + t_age * (Age_NatMort(gp, a + 1) - Age_NatMort(gp, a));
                  } // end age
                }
                else
                {
                  k = 1;
                  t_age = azero_seas(s) + (1. - azero_G(g));
                  for (a = k; a <= nages - 1; a++)
                  {
                    natM(t_base + s, 0, gpi, a) = Age_NatMort(gp, a) + t_age * (Age_NatMort(gp, a + 1) - Age_NatMort(gp, a));
                  } // end age
                  natM(t_base + s, 0, gpi, 0) = natM(t_base + s, 0, gpi, 1);
                }
                natM(t_base + s, 0, gpi, nages) = Age_NatMort(gp, nages);
              } // end season
              break;
            }
            //  SS_Label_Info_17.1.2.5  #case 5:  age and gender specific M linked to maturity (developed by Mark Maunder and contributed to the SS project in Feb 2021).
            case 5:
            {
              Maunder_Mjuv = natMparms(1, gp); //
              Maunder_lambda = natMparms(2, gp); //
              Maunder_Lmat = natMparms(3, gp); //  constant for juvenile mort
              Maunder_Mmat = natMparms(4, gp); //
              if (natM_5_opt <= 2)
              { //use the SS mat50% and mat_slope parameters
                Maunder_L50 = wtlen_p(GPat, 3); //mat50%
                Maunder_beta = wtlen_p(GPat, 4); //slope
                //          		XX_mature=make_mature_numbers(gpi);  //  will be same for all seasons  THIS LINE SEEMS UNNECESSARY
              }
              else if (natM_5_opt == 3)
              { //use two new parameters  mat50% and mat_slope, which can be Gpat and sex specific.
                Maunder_L50 = natMparms(5, gp);
                Maunder_beta = natMparms(6, gp);
              }
              for (s = 1; s <= nseas; s++)
              {
                t = t_base + s;
                //  using the most recent spawn season's age-maturity for females, unless doing option 3 here
                //  this code uses the length maturity parameters for females, and the ave_size for the current sex in the current season
                XX_mature.initialize();
                XX_mature(First_Mature_Age, nages) = 1. / (1. + mfexp(Maunder_beta * (Ave_Size(t, mid_subseas, g)(First_Mature_Age, nages) - Maunder_L50)));
                {
                  //  original equation had:
                  //  natM(t_base + s,gpi,a) = Maunder_Mjuv*pow(Ave_Size(t,ALK_idx,g,a)/Maunder_Lmat,Maunder_lambda) +
                  //                  (Maunder_Mmat-Maunder_Mjuv*pow(Ave_Size(t,ALK_idx,g,a)/Maunder_Lmat,Maunder_lambda))*XXmaturity_Fem(a)XX;
                  natM(t_base + s, 0, gpi) = Maunder_Mjuv * pow((Ave_Size(t, mid_subseas, g) / Maunder_Lmat), Maunder_lambda);
                  natM(t_base + s, 0, gpi) += elem_prod((Maunder_Mmat - natM(t_base + s, 0, gpi)), XX_mature);
                }
                if (do_once == 1)
                {
                  echoinput << " seas " << s << " sex*GP " << gpi << endl
                            << "M_juv: " << Maunder_Mjuv << "; M_mat: " << Maunder_Mmat << "; lambda: " << Maunder_lambda << endl;
                  echoinput << " L50 " << Maunder_L50 << " beta " << Maunder_beta << " Len_mat " << Maunder_Lmat << endl;
                  echoinput << "Age_mature_for_Maunder_M: " << XX_mature << endl;
                  echoinput << "avesize " << Ave_Size(t, mid_subseas, g) << endl;
                  echoinput << "avesize/Lmat " << Ave_Size(t, mid_subseas, g) / Maunder_Lmat << endl;
                  echoinput << " natM_juv: " << Maunder_Mjuv * pow((Ave_Size(t, mid_subseas, g) / Maunder_Lmat), Maunder_lambda) << endl;
                  echoinput << " natM_mat: " << (Maunder_Mmat)*XX_mature << endl;
                  echoinput << " natM_combined: " << natM(t_base + s, 0, gpi) << endl;
                }
              }
              break;
            }
            //  SS_Label_Info_17.1.2.6  #case 6:  Calculate lorenzen M from survivorship over fixed age range
            case 6: //  Survivorship based Lorenzen M
            {
              Loren_temp2 = L_inf(gp) * (mfexp(-VBK(gp, K_index) * VBK_seas(0)) - 1.); // need to verify use of VBK_seas here
              Loren_M1 = (natMparms(1, gp)); //This is the user specified average M over the input range of ages.
              for (s = nseas ; s >= 1; s--)
              {
                int Loren_t = styr + (yz - styr) * nseas + s - 1;
                dvariable loren_scale_extra = 0; //start with no extra scaler. This will be used if the maximum reference age is greater than nages.
                int ref_age = int(natM_amax); //start with reference age equal to the input maximum age. This will be adjusted below to equal nages if the maximum age is greater than nages.
                if (ref_age > nages)//if reference age is greater than accumulator age need math to approximate the unknown size/age bins
                {
                  int extra_years = ref_age - nages;//determine how many extra ages will be included between accumulator age and reference age

                  //The following code is a simple difference approach to approximate the first and second rate of change in relative M to estimate approximate M for ages older than nages
                  //calculate proportional change in lorenzen M between second to last and last age group
                  dvariable d1 = 1 + (log((Ave_Size(Loren_t, mid_subseas, g)(nages)) / (Ave_Size(Loren_t, mid_subseas, g)(nages) + Loren_temp2)) -
                  log((Ave_Size(Loren_t, mid_subseas, g)(nages - 1)) / (Ave_Size(Loren_t, mid_subseas, g)(nages-1) + Loren_temp2))) /
                  log((Ave_Size(Loren_t, mid_subseas, g)(nages)) / (Ave_Size(Loren_t, mid_subseas, g)(nages) + Loren_temp2));

                  //calculate proportional change in lorenzen M between third to last and second to last age group
                  dvariable d2 = 1 + (log((Ave_Size(Loren_t, mid_subseas, g)(nages - 1))/(Ave_Size(Loren_t, mid_subseas, g)(nages - 1) + Loren_temp2)) -
                  log((Ave_Size(Loren_t, mid_subseas, g)(nages - 2)) / (Ave_Size(Loren_t, mid_subseas, g)(nages - 2) + Loren_temp2))) /
                  log((Ave_Size(Loren_t, mid_subseas, g)(nages - 1)) / (Ave_Size(Loren_t, mid_subseas, g)(nages - 1) + Loren_temp2));

                  //calculate the second order proportional change in proportional changes during the last two age pairs
                  dvariable d3 = 1 + (d1 - d2) / d1;

                  //project total proportion of last years M that will occur in all ages older than nages
                  for (int ey = 1; ey <= extra_years; ey++)
                  {
                    d1 = d1 * d3;//each year adjust the first order proportion by the second order proportion
                    loren_scale_extra += d1;//add that proportion to a scaler that will be multiplied by the nages M value
                  }
                  ref_age = nages; //set reference age to nages to use all available Ave_Size values
                }

                //Calculate loren_temp multiplier that achieves target average M
                Loren_temp = (Loren_M1 * (natM_amax - natM_amin + 1)) / (sum(log(
                elem_div(Ave_Size(Loren_t, mid_subseas, g)(natM_amin, ref_age), (Ave_Size(Loren_t, mid_subseas, g)(natM_amin, ref_age) + Loren_temp2))
                )) + loren_scale_extra * log((Ave_Size(Loren_t, mid_subseas, g)(ref_age)) / (Ave_Size(Loren_t, mid_subseas, g)(ref_age) + Loren_temp2)));

                natM(t_base + s, 0, gpi)(0, nages) = log(
                elem_div(Ave_Size(Loren_t, mid_subseas, g)(0, nages),
                  (Ave_Size(Loren_t, mid_subseas, g)(0, nages) + Loren_temp2)))
                  * Loren_temp;
                if (s < Bseas(g))
                {
                  natM(t_base + s, 0, gpi, 0) = natM(t_base + s + 1, 0, gpi, 0);
                }
              }
              break;
            }
          } // end natM_type switch

          //  SS_Label_Info_17.2  #calc an ave_age for the first gp as a scaling factor in logL for initial recruitment (R1) deviation
          if (Do_AveAge == 0)
          {
            Do_AveAge = 1;
            ave_age = 1.0 / natM(t_base+1, 0, gpi, nages / 2) - 0.5;
          }

  #ifdef DO_ONCE
          if (do_once == 1)
          {
            for (s = 1; s <= nseas; s++)
              echoinput << "Natmort seas:" << s << " sex:" << gg << " Gpat:" << GPat << " sex*Gpat:" << gp << " settlement:" << settle << " gpi:" << gpi << endl
                        << " M: " << natM(t_base + s, 0, gpi) << endl;
          }
  #endif
        } //  end use of this morph
      } // end settlement
    } // end growth pattern x gender loop
  for (s = 1; s <= nseas; s++)
  for (p = 1; p <= pop; p++)
  {
    natM(t_base + s, p) = natM(t_base + s, 0); // copy M1 to eack area's M;
                                     // p=0 holds that M1 as the base M with no predators
                                     // pred_M2 will be added later on area-specific basis
  }
  } // end nat mort

FUNCTION void get_recr_distribution()
  {
  /*  SS_Label_Function_18 #get_recr_distribution among areas and morphs */

  //  SS_Label_Info_18.15  #get fraction female
  // fracfemale_mult is not used to distribute recruits; it is a multiplier used in the SSB calc and has default value of 1, and value of femfrac if requested in 1 sex setup
  if (frac_female_pointer > 0)
  {
    Ip = frac_female_pointer - 1;
    for (gp = 1; gp <= N_GP; gp++)
    {
      femfrac(gp) = mgp_adj(Ip + gp);
      if (gender == 2)
        femfrac(N_GP + gp) = 1.0 - femfrac(gp);
    }
  }
  else
  {
    femfrac(1, N_GP) = fracfemale;
    if (gender == 2)
      femfrac(N_GP, 2 * N_GP) = 1.0 - fracfemale;
  }
  if (gender_rd == -1)
  {
    fracfemale_mult = value(femfrac(1));
  }

  #ifdef DO_ONCE
  if (do_once == 1)
    echoinput << " femfrac " << femfrac << endl;
  #endif
  if (finish_starter == 999)
  {
    k = MGP_CGD - recr_dist_parms + nseas;
  }
  else
  {
    k = MGP_CGD - recr_dist_parms;
  }
  dvar_vector recr_dist_parm(1, k);

  //  recr_dist.initialize();
  //  SS_Label_Info_18.1  #set rec_dist_parms = exp(mgp_adj) for this year
  Ip = recr_dist_parms - 1;
  for (f = 1; f <= MGP_CGD - recr_dist_parms; f++)
  {
    recr_dist_parm(f) = mfexp(mgp_adj(Ip + f));
  }
  //  SS_Label_Info_18.2  #loop gp * settlements * area and multiply together the recr_dist_parm values
  switch (recr_dist_method)
  {

    case 2:
    {
      for (gp = 1; gp <= N_GP; gp++)
        for (settle = 1; settle <= N_settle_timings; settle++)
          for (p = 1; p <= pop; p++)
            if (recr_dist_pattern(gp, settle, p) > 0)
            {
              recr_dist(y, gp, settle, p) = femfrac(gp) * recr_dist_parm(gp) * recr_dist_parm(N_GP + p) * recr_dist_parm(N_GP + pop + settle);
              if (gender == 2)
                recr_dist(y, gp + N_GP, settle, p) = femfrac(gp + N_GP) * recr_dist_parm(gp) * recr_dist_parm(N_GP + p) * recr_dist_parm(N_GP + pop + settle); //males
            }
      //  SS_Label_Info_18.3  #if recr_dist_interaction is chosen, then multiply these in also
      if (recr_dist_inx == 1)
      {
        f = N_GP + pop + N_settle_timings;
        for (gp = 1; gp <= N_GP; gp++)
          for (settle = 1; settle <= N_settle_timings; settle++)
            for (p = 1; p <= pop; p++)
            {
              f++;
              if (recr_dist_pattern(gp, settle, p) > 0)
              {
                recr_dist(y, gp, settle, p) *= recr_dist_parm(f);
                if (gender == 2)
                  recr_dist(y, gp + N_GP, settle, p) *= recr_dist_parm(f);
              }
            }
      }
      break;
    }
    case 3:
    {
      for (settle = 1; settle <= N_settle_assignments; settle++)
      {
        gp = settlement_pattern_rd(settle, 1);
        settle_time = settle_assignments_timing(settle);
        p = settlement_pattern_rd(settle, 3);
        recr_dist(y, gp, settle_time, p) = femfrac(gp) * recr_dist_parm(settle);
        if (gender == 2)
          recr_dist(y, gp + N_GP, settle_time, p) = femfrac(gp + N_GP) * recr_dist_parm(settle); //males
      }
      break;
    }
    case 4:
    {
      recr_dist(y, 1, 1, 1) = femfrac(1);
      if (gender == 2)
        recr_dist(y, 2, 1, 1) = femfrac(2);
      break;
    }
    case 1: //  only used for sstrans
    {
      for (gp = 1; gp <= N_GP; gp++)
        for (p = 1; p <= pop; p++)
          for (s = 1; s <= N_settle_timings; s++)
          {
            if (recr_dist_pattern(gp, s, p) > 0)
            {
              recr_dist(y, gp, s, p) = femfrac(gp) * recr_dist_parm(gp) * recr_dist_parm(N_GP + p) * recr_dist_parm(N_GP + pop + s);
              if (gender == 2)
                recr_dist(y, gp + N_GP, s, p) = femfrac(gp + N_GP) * recr_dist_parm(gp) * recr_dist_parm(N_GP + p) * recr_dist_parm(N_GP + pop + s); //males
            }
          }
      //  SS_Label_Info_18.3  #if recr_dist_interaction is chosen, then multiply these in also
      if (recr_dist_inx == 1)
      {
        f = N_GP + nseas + pop;
        for (gp = 1; gp <= N_GP; gp++)
          for (p = 1; p <= pop; p++)
            for (s = 1; s <= N_settle_timings; s++)
            {
              f++;
              if (recr_dist_pattern(gp, s, p) > 0)
              {
                recr_dist(y, gp, s, p) *= recr_dist_parm(f);
                if (gender == 2)
                  recr_dist(y, gp + N_GP, s, p) *= recr_dist_parm(f);
              }
            }
      }
      break;
    }
  }
  //  SS_Label_Info_18.4  #scale the recr_dist matrix to sum to 1.0
  recr_dist(y) /= sum(recr_dist(y));
  if (y < YrMax)
  {
    k = y + 1;
    while (timevary_MG(k, 4) == 0 && k <= YrMax)
    {
      recr_dist(k) = recr_dist(k - 1);
      k++;
    }
  }
//  if(y==styr)
// 	{for(int yz=styr+1; yz<=YrMax;yz++) recr_dist(yz)=recr_dist(styr);}

  #ifdef DO_ONCE
  if (do_once == 1)
  {
    echoinput << "recruitment distribution in year: " << y << endl
              << "GP Seas Area Use? female_recr_dist" << endl;
    for (gp = 1; gp <= N_GP; gp++)
      for (s = 1; s <= N_settle_timings; s++)
        for (p = 1; p <= pop; p++)
        {
          echoinput << gp << " " << s << " " << p << " " << recr_dist_pattern(gp, s, p) << " " << recr_dist(y, gp, s, p);
          echoinput << endl;
        }
  }
  #endif
  }

//*******************************************************************
 /*  SS_Label_Function 19 get_wtlen, maturity, fecundity, hermaphroditism */
FUNCTION void get_wtlen()
  {
  //  SS_Label_Info_19.1  #set wtlen and maturity/fecundity factors equal to annual values from mgp_adj
  gp = 0;
  for (gg = 1; gg <= gender; gg++)
    for (GPat = 1; GPat <= N_GP; GPat++)
    {
      gp++;

      for (s = 1; s <= nseas; s++)
      {
        //  SS_Label_Info_19.2  #loop seasons for wt-len calc
        t = styr + (y - styr) * nseas + s - 1;
        //  SS_Label_Info_19.2.1  #calc wt_at_length for each season to include seasonal effects on wtlen

        //  NOTES  wt_len is by gp, but wt_len2 and wt_len_low have males stacked after females
        //  so referenced by GPat

        if (gg == 1)
        {
          if (MGparm_seas_effects(1) > 0 || MGparm_seas_effects(2) > 0) //  get seasonal effect on FEMALE wtlen parameters
          {
            wt_len(s, gp) = (wtlen_p(GPat, 1) * wtlen_seas(s, GPat, 1)) * pow(len_bins_m(1, nlength), (wtlen_p(GPat, 2) * wtlen_seas(s, GPat, 2)));
            wt_len_low(s, GPat)(1, nlength) = (wtlen_p(GPat, 1) * wtlen_seas(s, GPat, 1)) * pow(len_bins2(1, nlength), (wtlen_p(GPat, 2) * wtlen_seas(s, GPat, 2)));
          }
          else
          {
            wt_len(s, gp) = wtlen_p(GPat, 1) * pow(len_bins_m(1, nlength), wtlen_p(GPat, 2));
            wt_len_low(s, GPat)(1, nlength) = wtlen_p(GPat, 1) * pow(len_bins2(1, nlength), wtlen_p(GPat, 2));
          }
          wt_len2(s, GPat)(1, nlength) = wt_len(s, gp)(1, nlength);
        }
        //  SS_Label_Info_19.2.2  #calculate male weight_at_length
        else
        {
          if (MGparm_seas_effects(7) > 0 || MGparm_seas_effects(8) > 0) //  get seasonal effect on male wt-len parameters
          {
            wt_len(s, gp) = (wtlen_p(GPat, 7) * wtlen_seas(s, GPat, 7)) * pow(len_bins_m(1, nlength), (wtlen_p(GPat, 8) * wtlen_seas(s, GPat, 8)));
            wt_len_low(s, GPat)(nlength1, nlength2) = (wtlen_p(GPat, 7) * wtlen_seas(s, GPat, 7)) * pow(len_bins2(nlength1, nlength2), (wtlen_p(GPat, 8) * wtlen_seas(s, GPat, 8)));
          }
          else
          {
            wt_len(s, gp) = wtlen_p(GPat, 7) * pow(len_bins_m(1, nlength), wtlen_p(GPat, 8));
            wt_len_low(s, GPat)(nlength1, nlength2) = wtlen_p(GPat, 7) * pow(len_bins2(nlength1, nlength2), wtlen_p(GPat, 8));
          }
          wt_len2(s, GPat)(nlength1, nlength2) = wt_len(s, gp).shift(nlength1);
          wt_len(s, gp).shift(1);
        }

        //  SS_Label_Info_19.2.3  #calculate first diff of wt_len for use in generalized sizp comp bin calculations
        if (gg == gender)
        {
          wt_len2_sq(s, GPat) = elem_prod(wt_len2(s, GPat), wt_len2(s, GPat));
          wt_len_fd(s, GPat) = first_difference(wt_len_low(s, GPat));
          if (gender == 2)
            wt_len_fd(s, GPat, nlength) = wt_len_fd(s, GPat, nlength - 1);
  #ifdef DO_ONCE
          if (do_once == 1)
            echoinput << "wtlen2 " << endl
                      << wt_len2 << endl
                      << "wtlen2^2 " << wt_len2_sq << endl
                      << "wtlen2:firstdiff " << wt_len_fd << endl;
  #endif
        }
      }
    }
  }
FUNCTION void get_mat_fec();
  {
  //  SS_Label_Info_19.2.4  #calculate maturity and fecundity if seas = spawn_seas
  //  these calculations are done in spawn_seas, but are not affected by spawn_time within that season
  //  so age-specific inputs will assume to be at correct timing already; size-specific will later be adjusted to use size-at-age at the exact correct spawn_time_seas
  //  SPAWN-RECR:   calculate maturity and fecundity vectors

  make_mature_numbers.initialize();
  int s = spawn_seas; // makes a local version of "s" as this gets called inside a "s" loop
  int ALK_idx = (spawn_seas - 1) * N_subseas + spawn_subseas;

  for (g = 1; g <= gmorph; g++)
    if (sx(g) == 1 && use_morph(g) > 0)
    {
      GPat = GP4(g);
      gg = sx(g);
      gp = GPat; //
      if (WTage_rd == 1)
      {
        fec(g) = Wt_Age_t(t, -2, g);
        make_mature_numbers(g)(First_Mature_Age, nages) = 1.0;
        //  all other vectors set to contant value of 0.5
      }
      else
      {
        if (do_fec_len == 1)
        {
          // make fecundity from biology

          if (do_once == 1)
          echoinput << "fecundity option: " << Fecund_Option << " parms: " << wtlen_p(GPat)(5, 6) << endl;
          // fec_len should only get calculated in maturity option = 1, 2, 3, or 6
          // maturity option 4 and 5 bypass maturity and read empirical fecundity-at-age

          switch (Fecund_Option)
          {
            case 1: // as eggs/kg (SS original configuration)
            {
              fec_len(gp) = wtlen_p(GPat, 5) + wtlen_p(GPat, 6) * wt_len(s, gp);
              fec_len(gp) = elem_prod(wt_len(s, gp), fec_len(gp));
              break;
            }
            case 2:
            { // as eggs = f(length)
              fec_len(gp) = wtlen_p(GPat, 5) * pow(len_bins_m, wtlen_p(GPat, 6));
              break;
            }
            case 3:
            { // as eggs = f(body weight)
              fec_len(gp) = wtlen_p(GPat, 5) * pow(wt_len(s, gp), wtlen_p(GPat, 6));
              break;
            }
            case 4:
            { // as eggs = a + b*Len
              fec_len(gp) = wtlen_p(GPat, 5) + wtlen_p(GPat, 6) * len_bins_m;
              if (wtlen_p(GPat, 5) < 0.0)
              {
                z = 1;
                while (fec_len(gp, z) < 0.0)
                {
                  fec_len(gp, z) = 0.0;
                  z++;
                }
              }
              break;
            }
            case 5:
            { // as eggs = a + b*Wt
              fec_len(gp) = wtlen_p(GPat, 5) + wtlen_p(GPat, 6) * wt_len(s, gp);
              if (wtlen_p(GPat, 5) < 0.0)
              {
                z = 1;
                while (fec_len(gp, z) < 0.0)
                {
                  fec_len(gp, z) = 0.0;
                  z++;
                }
              }
              break;
            }
          }
        }
        if (do_once == 1)
          echoinput << "maturity option: " << Maturity_Option << " parms: " << wtlen_p(GPat)(3, 4) << endl;

        switch (Maturity_Option)
        {
          case 1: //  Maturity_Option=1  length logistic
          {
            mat_len(GPat) = 1. / (1. + mfexp(wtlen_p(GPat, 4) * (len_bins_m(1, nlength) - wtlen_p(GPat, 3))));
            mat_fec_len(gp) = elem_prod(mat_len(gp), fec_len(gp));
            make_mature_numbers(g)(First_Mature_Age, nages) = 1.0;
            make_mature_numbers(g) = elem_prod(make_mature_numbers(g), ALK(ALK_idx, g) * mat_len(GPat)); //  covers both age and length dimension
            break;
          }
          case 2: //  Maturity_Option=2  age logistic
          {
            mat_age(GPat)(0, First_Mature_Age) = 0.0;
            mat_age(GPat)(First_Mature_Age, nages) = 1. / (1. + mfexp(wtlen_p(GPat, 4) * (r_ages(First_Mature_Age, nages) - wtlen_p(GPat, 3))));
            mat_fec_len(gp) = elem_prod(mat_len(gp), fec_len(gp));
            make_mature_numbers(g) = mat_age(GPat);
            break;
          }
          case 3: //  Maturity_Option=3  read age-maturity
          {
            mat_age(GPat) = Age_Maturity(GPat);
            mat_fec_len(gp) = elem_prod(mat_len(gp), fec_len(gp));
            make_mature_numbers(g) = mat_age(GPat);
            break;
          }
          case 4: //  Maturity_Option=4   read age-fecundity, so no age-maturity
          {
            if (do_once == 1)
              echoinput << "age-fecundity as read from control file" << endl
                        << Age_Maturity(gp) << endl;
            break;
          }
          case 6: //  Maturity_Option=6   read length-maturity
          {
            mat_len(GPat) = Length_Maturity(GPat);
            mat_fec_len(gp) = elem_prod(mat_len(gp), fec_len(gp));
            make_mature_numbers(g)(First_Mature_Age, nages) = 1.0;
            make_mature_numbers(g) = elem_prod(make_mature_numbers(g), ALK(ALK_idx, g) * mat_len(GPat)); //  covers both age and length dimension
            break;
          }
          case 5: //  Maturity_Option=5   read age-fecundity from wtatage.ss disabled different flag now used
          {
            break;
          }
        }
        switch (Maturity_Option)
        {
          case 4: //  Maturity_Option=4   read age-fecundity into age-maturity
          {
            fec(g) = Age_Maturity(GPat);
            make_mature_numbers(g) = fec(g); //  not defined
            make_mature_bio(g) = fec(g); //  not defined
            break;
          }
          case 5: //  Maturity_Option=5   read age-fecundity from wtatage.ss
          {
            fec(g) = Wt_Age_t(t, -2, GP3(g));
            make_mature_numbers(g) = fec(g); //  not defined
            make_mature_bio(g) = fec(g); //  not defined
            break;
          }
          default:
          {
            for (a = First_Mature_Age; a <= nages; a++)
            {
              tempvec_a(a) = ALK(ALK_idx, g, a)(1, nlength) * mat_fec_len(GPat)(1, nlength);
            }
            fec(g)(First_Mature_Age, nages) = elem_prod(tempvec_a(First_Mature_Age, nages), mat_age(GPat)(First_Mature_Age, nages)); //  reproductive output at age
            make_mature_numbers(g) = elem_prod(ALK(ALK_idx, g) * mat_len(GPat), mat_age(GPat)); //  mature numbers at age
            make_mature_bio(g) = elem_prod(ALK(ALK_idx, g) * elem_prod(mat_len(GPat), wt_len(s, GP(g))), mat_age(GPat)); //  mature biomass at age
          }
        }
        if (t >= styr && WTage_rd == 0)
          Wt_Age_t(t, -2, g) = fec(g); //  save sel_num and save fecundity for output
        if (y == endyr && WTage_rd == 0)
          Wt_Age_t(t + nseas, -2, g) = fec(g);
  #ifdef DO_ONCE
        if (do_once == 1)
        {
          echoinput << "gp: " << GPat << " g " << g << endl
                    << "mat_len: " << mat_len(GPat) << endl
                    << " fec_len: " << fec_len(GPat) << endl
                    << " mat_fec_len: " << mat_fec_len(GPat) << endl
                    << " mat_age: " << mat_age(GPat) << endl
                    << " mat_len_age: " << make_mature_numbers(g) << endl
                    << " fecundity_age: " << fec(g) << endl;
        }
  #endif
      }
    } // end g loop
  //  end maturity and fecundity in spawn_seas
  }

FUNCTION void get_Hermaphro()
  {
  //  SS_Label_Info_19.2.5  #Do Hermaphroditism (no seasonality and no gp differences)
  //  should build seasonally component here
  //  only one hermaphroditism definition is allowed (3 parameters), but it is stored by Gpat, so referenced by GP4(g)
  dvariable infl; // inflection
  dvariable stdev; // standard deviation
  dvariable maxval; // max value

  infl = mgp_adj(MGparm_Hermaphro); // inflection
  stdev = mgp_adj(MGparm_Hermaphro + 1); // standard deviation
  maxval = mgp_adj(MGparm_Hermaphro + 2); // max value
  Hermaphro_val.initialize();
  //      minval is 0.0;
  temp2 = cumd_norm((0.0 - infl) / stdev); //  cum_norm at age 0  //  could change to Hermaphro_firstage
  temp = maxval / (cumd_norm((r_ages(nages) - infl) / stdev) - temp2); //  delta in cum_norm between styr and endyr
  for (a = Hermaphro_firstage; a <= nages; a++)
  {
    Hermaphro_val(1, a) = 0.0 + temp * (cumd_norm((r_ages(a) - infl) / stdev) - temp2);
  }
  if (N_GP > 1)
  {
    for (gp = 2; gp <= N_GP; gp++)
    {
      Hermaphro_val(gp) = Hermaphro_val(1);
    }
  }
  return;
  }

FUNCTION void get_migration()
  {
  //*******************************************************************
  //  SS_Label_FUNCTION 20 #get_migration
  Ip = MGP_CGD; // base counter for  movement parms
  //  SS_Label_20.1  loop the needed movement rates
  for (k = 1; k <= do_migr2; k++) //  loop all movement rates for this year (includes seas, morphs)
  {
    t = styr + (yz - styr) * nseas + move_def2(k, 1) - 1;
    if (k <= do_migration) //  so an explicit movement rate
    {
      //  set some movement rates same as the first movement rate
      if (mgp_adj(Ip + 1) == -9999.)
        mgp_adj(Ip + 1) = mgp_adj(MGP_CGD + 1);
      if (mgp_adj(Ip + 2) == -9999.)
        mgp_adj(Ip + 2) = mgp_adj(MGP_CGD + 2);
      //  set movement rate same for all ages
      if (mgp_adj(Ip + 2) == -9998.)
        mgp_adj(Ip + 2) = mgp_adj(Ip + 1);

      //  SS_Label_Info_20.1.1  #age-specific movement strength based on parameters for selected area pairs
      temp = 1. / (move_def2(k, 6) - move_def2(k, 5));
      temp1 = temp * (mgp_adj(Ip + 2) - mgp_adj(Ip + 1));
      for (a = 0; a <= nages; a++)
      {
        if (a <= move_def2(k, 5))
        {
          migrrate(yz, k, a) = mgp_adj(Ip + 1);
        }
        else if (a >= move_def2(k, 6))
        {
          migrrate(yz, k, a) = mgp_adj(Ip + 2);
        }
        else
        {
          migrrate(yz, k, a) = mgp_adj(Ip + 1) + (r_ages(a) - move_def2(k, 5)) * temp1;
        }
      } // end age loop
      migrrate(yz, k) = mfexp(migrrate(yz, k));
      Ip += 2;
    }
    else
    //  SS_Label_Info_20.1.2  #default movement strength =1.0 for other area pairs
    {
      migrrate(yz, k) = 1.;
    }
  }

  //  SS_Label_Info_20.2  #loop seasons, GP, source areas
  for (s = 1; s <= nseas; s++)
  {
    t = styr + (yz - styr) * nseas + s - 1;
    for (gp = 1; gp <= N_GP; gp++)
    {
      for (p = 1; p <= pop; p++)
      {
        tempvec_a.initialize(); // zero out the summation vector
        for (p2 = 1; p2 <= pop; p2++)
        {
          //  SS_Label_Info_20.2.1  #for each destination area, adjust movement rate by season duration and sum across all destination areas
          k = move_pattern(s, gp, p, p2);
          if (k > 0)
          {
            if (p2 != p && nseas > 1)
              migrrate(yz, k) *= seasdur(move_def2(k, 1)); // fraction leaving an area is reduced if the season is short
            tempvec_a += migrrate(yz, k); //  sum of all movement weights for the p2 fish
          }
        } //end destination area
        //  SS_Label_Info_20.2.2 #now normalize for all movement from source area p
        for (p2 = 1; p2 <= pop; p2++)
        {
          k = move_pattern(s, gp, p, p2);
          if (k > 0)
          {
            migrrate(yz, k) = elem_div(migrrate(yz, k), tempvec_a);
            //  SS_Label_Info_20.2.3 #Set rate to 0.0 (or 1.0 for stay rates) below the start age for migration
            if (migr_start(s, gp) > 0)
            {
              if (p != p2)
              {
                migrrate(yz, k)(0, migr_start(s, gp) - 1) = 0.0;
              }
              else
              {
                migrrate(yz, k)(0, migr_start(s, gp) - 1) = 1.0;
              }
            }
          }
        }
      } //  end source areas loop
    } // end growth pattern
  } // end season

  //  SS_Label_Info_20.2.4 #Copy annual migration rates forward until first year with time-varying migration rates
  if (yz < YrMax)
  {
    k = yz + 1;
    while (timevary_MG(k, 5) == 0 && k <= YrMax)
    {
      migrrate(k) = migrrate(k - 1);
      k++;
    }
  }
  //  end migration
  return;
  }

FUNCTION void get_migration2()
  {
  //*******************************************************************
  //  SS_Label_FUNCTION 20 #get_migration
  //  for use with new movement approach
  //  each defined movedef rate (1 to do_migr2) has a min age, max age, functional form
  //  each move_pattern(GP, sex, settlement, seas, source, sink) selects rate it uses
  //  so all could point to just 1 rate definition, or a complex setup could be created
  //  to ease creation of setups of moderate complexity, use 0 to select all of that dimension
  //  for example, 0 in the sex field would assign the specified rate to both sexes
  //  for example, 0 in all fields would assign the same rate to everything

  Ip = MGP_CGD; // base counter for  movement parms
  dvariable move1; //  movement rate for young fish
  dvariable move2; //  movement rate for old fish

  //  SS_Label_20.1  loop the needed movement rates
  for (k = 1; k <= do_migr2; k++) //  loop all movement rates for this year (includes seas, morphs)
  {
    //  seems not used    t=styr+(yz-styr)*nseas+move_def2(k,1)-1;
    if (k <= do_migration) //  so an explicit movement rate
    {
      //  set some movement rates same as the first movement rate
      move1 = mgp_adj(Ip + 1);
      if (mgp_adj(Ip + 1) == -9999.)
        move1 = mgp_adj(MGP_CGD + 1);
      move2 = mgp_adj(Ip + 1);
      if (mgp_adj(Ip + 2) == -9999.)
        move2 = mgp_adj(MGP_CGD + 2);
      //  set movement rate same for all ages
      if (mgp_adj(Ip + 2) == -9998.)
        move2 = move1;

      //  SS_Label_Info_20.1.1  #age-specific movement strength based on parameters for selected area pairs
      temp = 1. / (move_def2(k, 6) - move_def2(k, 5));
      temp1 = temp * (move2 - move1);
      migrrate(yz, k) = move1 + (r_ages - move_def2(k, 5)) * temp1;
      migrrate(yz, k)(0, move_def2(k, 5)) = move1;
      migrrate(yz, k)(move_def2(k, 5), nages) = move2;
      migrrate(yz, k) = mfexp(migrrate(yz, k));
      Ip += 2;
    }
    else
    //  SS_Label_Info_20.1.2  #default movement strength =1.0 for other area pairs
    {
      migrrate(yz, k) = 1.;
    }
  }

  //  SS_Label_Info_20.2  #loop seasons, GP, source areas
  for (s = 1; s <= nseas; s++)
  {
    t = styr + (yz - styr) * nseas + s - 1;
    for (gp = 1; gp <= N_GP; gp++)
    {
      for (p = 1; p <= pop; p++)
      {
        tempvec_a.initialize(); // zero out the summation vector
        for (p2 = 1; p2 <= pop; p2++)
        {
          //  SS_Label_Info_20.2.1  #for each destination area, adjust movement rate by season duration and sum across all destination areas
          k = move_pattern(s, gp, p, p2);
          if (k > 0)
          {
            if (p2 != p && nseas > 1)
              migrrate(yz, k) *= seasdur(move_def2(k, 1)); // fraction leaving an area is reduced if the season is short
            tempvec_a += migrrate(yz, k); //  sum of all movement weights for the p2 fish
          }
        } //end destination area
        //  SS_Label_Info_20.2.2 #now normalize for all movement from source area p
        for (p2 = 1; p2 <= pop; p2++)
        {
          k = move_pattern(s, gp, p, p2);
          if (k > 0)
          {
            migrrate(yz, k) = elem_div(migrrate(yz, k), tempvec_a);
            //  SS_Label_Info_20.2.3 #Set rate to 0.0 (or 1.0 for stay rates) below the start age for migration
            if (migr_start(s, gp) > 0)
            {
              if (p != p2)
              {
                migrrate(yz, k)(0, migr_start(s, gp) - 1) = 0.0;
              }
              else
              {
                migrrate(yz, k)(0, migr_start(s, gp) - 1) = 1.0;
              }
            }
          }
        }
      } //  end source areas loop
    } // end growth pattern
  } // end season

  //  SS_Label_Info_20.2.4 #Copy annual migration rates forward until first year with time-varying migration rates
  if (yz < endyr)
  {
    k = yz + 1;
    while (timevary_MG(k, 5) == 0 && k <= endyr)
    {
      migrrate(k) = migrrate(k - 1);
      k++;
    }
  }
  //  end migration
  return;
  }

FUNCTION void get_saveGparm()
  {
  //*********************************************************************
  /*  SS_Label_Function_21 #get_saveGparm */
  gp = 0;
  for (gg = 1; gg <= gender; gg++)
    for (GPat = 1; GPat <= N_GP; GPat++)
    {
      gp++;
      g = g_Start(gp); //  base platoon
      for (settle = 1; settle <= N_settle_timings; settle++)
      {
        g += N_platoon;
        save_gparm++;
        save_G_parm(save_gparm, 1) = save_gparm;
        save_G_parm(save_gparm, 2) = y;
        save_G_parm(save_gparm, 3) = g;
        save_G_parm(save_gparm, 4) = AFIX;
        save_G_parm(save_gparm, 5) = AFIX2;
        save_G_parm(save_gparm, 6) = value(Lmin(gp));
        save_G_parm(save_gparm, 7) = value(Lmax_temp(gp));
        if (do_ageK == 1)
        {
          save_G_parm(save_gparm, 8) = value(-VBK(gp, nages) * VBK_seas(0));
          save_G_parm(save_gparm, 9) = value(-log(L_inf(gp) / (L_inf(gp) - Lmin(gp))) / (-VBK(gp, nages) * VBK_seas(0)) + AFIX + azero_G(g));
        }
        else
        {
          save_G_parm(save_gparm, 8) = value(-VBK(gp, 0) * VBK_seas(0));
          save_G_parm(save_gparm, 9) = value(-log(L_inf(gp) / (L_inf(gp) - Lmin(gp))) / (-VBK(gp, 0) * VBK_seas(0)) + AFIX + azero_G(g));
        }

        save_G_parm(save_gparm, 10) = value(L_inf(gp));
        save_G_parm(save_gparm, 11) = value(CVLmin(gp));
        save_G_parm(save_gparm, 12) = value(CVLmax(gp));
        save_G_parm(save_gparm, 13) = natM_amin;
        save_G_parm(save_gparm, 14) = natM_amax;
        save_G_parm(save_gparm, 15) = value(natM(t_base+1, 0, GP3(g), 0));
        save_G_parm(save_gparm, 16) = value(natM(t_base+1, 0, GP3(g), nages));
        if (gg == 1)
        {
          for (k = 1; k <= 6; k++)
            save_G_parm(save_gparm, 16 + k) = value(wtlen_p(GPat, k));
        }
        else
        {
          for (k = 1; k <= 2; k++)
            save_G_parm(save_gparm, 16 + k) = value(wtlen_p(GPat, k + 6));
        }
        save_gparm_print = save_gparm;
      }
      if (MGparm_doseas > 0)
      {
        for (s = 1; s <= nseas; s++)
        {
          for (k = 1; k <= 8; k++)
          {
            save_seas_parm(s, k) = value(wtlen_p(GPat, k) * wtlen_seas(s, GPat, k));
          }
          save_seas_parm(s, 9) = value(Lmin(1));
          if (Grow_type <= 2 || Grow_type == 8)
            save_seas_parm(s, 10) = value(VBK(1, 0) * VBK_seas(s));
          if (Grow_type >= 3 && Grow_type <= 5)
            save_seas_parm(s, 10) = value(VBK(1, nages) * VBK_seas(s));
        }
      }
    }
  } //  end save_gparm

//  this function is no longer used.  It has been moved into get_mat_fec()

FUNCTION void Make_Fecundity()
  {
  //********************************************************************
  //  this Make_Fecundity function does the dot product of the distribution of length-at-age (ALK) with maturity and fecundity vectors
  //  to calculate the mean fecundity at each age
  // SS_Label_31.1 FUNCTION Make_Fecundity
  //  SPAWN-RECR:   here is the make_Fecundity function
  fec.initialize();
  ALK_idx = (spawn_seas - 1) * N_subseas + spawn_subseas;
  for (g = 1; g <= gmorph; g++)
    if (sx(g) == 1 && use_morph(g) > 0)
    {
      GPat = GP4(g);
      gg = sx(g);
      switch (Maturity_Option)
      {
        case 4: //  Maturity_Option=4   read age-fecundity into age-maturity
        {
          fec(g) = Age_Maturity(GPat);
          break;
        }
        case 5: //  Maturity_Option=5   read age-fecundity from wtatage.ss
        {
          fec(g) = Wt_Age_t(t, -2, GP3(g));
          break;
        }
        default:
        {
          for (a = First_Mature_Age; a <= nages; a++)
          {
            tempvec_a(a) = ALK(ALK_idx, g, a)(1, nlength) * mat_fec_len(GPat)(1, nlength);
          }
          fec(g)(First_Mature_Age, nages) = elem_prod(tempvec_a(First_Mature_Age, nages), mat_age(GPat)(First_Mature_Age, nages)); //  reproductive output at age
        }
      }
      if (t >= styr)
        Wt_Age_t(t, -2, g) = fec(g); //  save sel_num and save fecundity for output
      if (y == endyr)
        Wt_Age_t(t + nseas, -2, g) = fec(g);

      if (bigsaver == 1)
      {
        switch (Maturity_Option)
        {
          case 1: //  Maturity_Option=1  length logistic
          {
            make_mature_numbers(g) = elem_prod(ALK(ALK_idx, g) * mat_len(GPat), mat_age(GPat)); //  mature numbers at age
            make_mature_bio(g) = elem_prod(ALK(ALK_idx, g) * elem_prod(mat_len(GPat), wt_len(s, GP(g))), mat_age(GPat)); //  mature biomass at age

            break;
          }
          case 2: //  Maturity_Option=2  age logistic
          {
            make_mature_numbers(g) = elem_prod(ALK(ALK_idx, g) * mat_len(GPat), mat_age(GPat)); //  mature numbers at age
            make_mature_bio(g) = elem_prod(ALK(ALK_idx, g) * elem_prod(mat_len(GPat), wt_len(s, GP(g))), mat_age(GPat)); //  mature biomass at age
            break;
          }
          case 3: //  Maturity_Option=3  read age-maturity
          {
            make_mature_numbers(g) = elem_prod(ALK(ALK_idx, g) * mat_len(GPat), mat_age(GPat)); //  mature numbers at age (Age_Maturity already copied to mat_age)
            make_mature_bio(g) = elem_prod(ALK(ALK_idx, g) * elem_prod(mat_len(GPat), wt_len(s, GP(g))), mat_age(GPat)); //  mature biomass at age
            break;
          }
          case 4: //  Maturity_Option=4   read age-fecundity, so no age-maturity
          {
            make_mature_numbers(g) = fec(g); //  not defined
            make_mature_bio(g) = fec(g); //  not defined
            break;
          }
          case 5: //  Maturity_Option=5   read age-fecundity from wtatage.ss
          {
            make_mature_numbers(g) = fec(g); //  not defined
            make_mature_bio(g) = fec(g); //  not defined
            break;
          }
          case 6: //  Maturity_Option=6   read length-maturity
          {
            make_mature_numbers(g) = elem_prod(ALK(ALK_idx, g) * mat_len(GPat), mat_age(GPat)); //  mature numbers at age (Length_Maturity already copied to mat_len)
            make_mature_bio(g) = elem_prod(ALK(ALK_idx, g) * elem_prod(mat_len(GPat), wt_len(s, GP(g))), mat_age(GPat)); //  mature biomass at age
            break;
          }
        }
      }
    }
  }
// SS_Label_file  #10. **SS_miscfxn.tpl**
// SS_Label_file  # * <u>Join_Fxn()</u>    //  joins line segments in differentiable way
// SS_Label_file  # * <u>get_age_age()</u>  //  for ageing error
// SS_Label_file  # * <u>get_catch_mult()</u>
// SS_Label_file  #

//********************************************************************
 /*  SS_Label_FUNCTION 42 Join_Fxn  */
FUNCTION dvariable Join_Fxn(const prevariable& MinPoss, const prevariable& MaxPoss, const prevariable& Inflec, const prevariable& Xvar, const prevariable& Y1, const prevariable& Y2)
  {
  RETURN_ARRAYS_INCREMENT();
  dvariable Yresult;
  dvariable join;
  join = 1.000 / (1.000 + mfexp(1000.0 * (Xvar - Inflec) / (MaxPoss - MinPoss))); //  steep joiner at the inflection
  Yresult = Y1 * (join) + Y2 * (1.000 - join);
  RETURN_ARRAYS_DECREMENT();
  return Yresult;
  }

//********************************************************************
 /*  SS_Label_FUNCTION 45 get_age_age */
FUNCTION void get_age_age(const int Keynum, const int AgeKey_StartAge, const int AgeKey_Linear1, const int AgeKey_Linear2)
  {
  //  FUTURE: calculate adjustment to oldest age based on continued ageing of old fish
  age_age(Keynum).initialize();
  dvariable age;
  dvar_vector age_err_parm(1, 7);
  dvariable temp;

  if (Keynum == Use_AgeKeyZero)
  {
    //  SS_Label_45.1 set age_err_parm to mgp_adj, so can be time-varying according to MGparm options
    for (a = 1; a <= 7; a++)
    {
      age_err_parm(a) = mgp_adj(AgeKeyParm - 1 + a);
    }
    age_err(Use_AgeKeyZero, 1)(0, AgeKey_StartAge) = r_ages(0, AgeKey_StartAge) + 0.5;
    age_err(Use_AgeKeyZero, 2)(0, AgeKey_StartAge) = age_err_parm(5) * (r_ages(0, AgeKey_StartAge) + 0.5) / (age_err_parm(1) + 0.5);
    //  SS_Label_45.3 calc ageing bias
    if (AgeKey_Linear1 == 0)
    {
      age_err(Use_AgeKeyZero, 1)(AgeKey_StartAge, nages) = 0.5 + r_ages(AgeKey_StartAge, nages) + age_err_parm(2) + (age_err_parm(3) - age_err_parm(2)) * (1.0 - mfexp(-age_err_parm(4) * (r_ages(AgeKey_StartAge, nages) - age_err_parm(1)))) / (1.0 - mfexp(-age_err_parm(4) * (r_ages(nages) - age_err_parm(1))));
    }
    else
    {
      age_err(Use_AgeKeyZero, 1)(AgeKey_StartAge, nages) = 0.5 + r_ages(AgeKey_StartAge, nages) + age_err_parm(2) + (age_err_parm(3) - age_err_parm(2)) * (r_ages(AgeKey_StartAge, nages) - age_err_parm(1)) / (r_ages(nages) - age_err_parm(1));
    }
    //  SS_Label_45.4 calc ageing variance
    if (AgeKey_Linear2 == 0)
    {
      age_err(Use_AgeKeyZero, 2)(AgeKey_StartAge, nages) = age_err_parm(5) + (age_err_parm(6) - age_err_parm(5)) * (1.0 - mfexp(-age_err_parm(7) * (r_ages(AgeKey_StartAge, nages) - age_err_parm(1)))) / (1.0 - mfexp(-age_err_parm(7) * (r_ages(nages) - age_err_parm(1))));
    }
    else
    {
      age_err(Use_AgeKeyZero, 2)(AgeKey_StartAge, nages) = age_err_parm(5) + (age_err_parm(6) - age_err_parm(5)) * (r_ages(AgeKey_StartAge, nages) - age_err_parm(1)) / (r_ages(nages) - age_err_parm(1));
    }
  }

  //  SS_Label_45.5 calc distribution of age' for each age
  for (a = 0; a <= nages; a++)
  {
    if (age_err(Keynum, 1, a) <= -1)
    {
      age_err(Keynum, 1, a) = r_ages(a) + 0.5;
    }
    age = age_err(Keynum, 1, a);

    for (b = 2; b <= n_abins; b++) //  so the lower tail is accumulated into the first age' bin
      age_age(Keynum, b, a) = cumd_norm((age_bins(b) - age) / age_err(Keynum, 2, a));

    for (b = 1; b <= n_abins - 1; b++)
      age_age(Keynum, b, a) = age_age(Keynum, b + 1, a) - age_age(Keynum, b, a);

    age_age(Keynum, n_abins, a) = 1. - age_age(Keynum, n_abins, a); // so remainder is accumulated into the last age' bin
  }

  if (gender == 2) //  copy ageing error matrix into male location also
  {
    L2 = n_abins;
    A2 = nages + 1;
    for (b = 1; b <= n_abins; b++)
      for (a = 0; a <= nages; a++)
      {
        age_age(Keynum, b + L2, a + A2) = age_age(Keynum, b, a);
      }
  }
  return;
  } //  end age_age key

FUNCTION void get_catch_mult(int y, int catch_mult_pointer)
  {
  /*  SS_Label_FUNCTION 47  catch_multiplier */
  int j;
  j = 0;
  for (f = 1; f <= Nfleet; f++)
  {
    if (need_catch_mult(f) == 1)
    {
      catch_mult(y, f) = mgp_adj(catch_mult_pointer + j);
      j++;
    }
  }
  return;
  }

//********************************************************************
 /*  SS_Label_FUNCTION 4XX Comp_logL  */
FUNCTION dvariable Comp_logL_multinomial(const double& Nsamp, const dvector& obs_comp, const dvar_vector& exp_comp)
  {
    dvariable logL;
//    logL = - Nsamp * obs_comp(tail_L, tail_H) * log(exp_comp(tail_L, tail_H));
//    the call to this function does the subsetting to tail_L and tail_H, so this function can operate cleanly on the entirety of the passed vector
    logL = - Nsamp * obs_comp * log(exp_comp);
    return (logL);
  }

FUNCTION dvariable Comp_logL_Dirichlet(const double& Nsamp, const dvariable& dirichlet_Parm, const dvector& obs_comp, const dvar_vector& exp_comp)
  {
    dvariable logL;
    logL = sum(gammln(Nsamp * obs_comp + dirichlet_Parm * exp_comp)) - sum(gammln(dirichlet_Parm * exp_comp));
    return (logL);
  }
// SS_Label_file  #11. **SS_selex.tpl**
// SS_Label_file  # * <u>get_selectivity()</u>  // does length and age selectivity and retention for all fleets
// SS_Label_file  # * <u>make_fish_selex()</u>  // for all fleets in a particular season, does the dot product of length distribution with length selectivity and retention vectors to calculate equivalent mean quantities at age for each platoon

FUNCTION void get_selectivity()
  {
  //*******************************************************************
  /*  SS_Label_Function_22 #get_selectivity */
  //  SS_Label_Info_22.01  #define local variables for selectivity
  int fs; // = f-Nfleet to allow reference of actual fleet when looping to 2*Nfleet for the age selectivity calculations
  int scaling_offset = 0;
  dvariable t1;
  dvariable t2;
  dvariable t3;
  dvariable t4;
  dvariable Apical_Selex;
  dvariable t1min;
  dvariable t1max;
  dvariable t1power;
  dvariable t2min;
  dvariable t2max;
  dvariable t2power;
  dvariable final;
  dvariable sel_maxL;
  dvariable lastsel;
  dvariable lastSelPoint;
  dvariable SelPoint;
  dvariable finalSelPoint;
  dvariable asc;
  dvariable dsc;

  dvar_vector sp(1, 199); // temporary vector for selex parms

  Ip = 0;
  //  SS_Label_Info_22.2 #Loop all fisheries and surveys twice; first for size selectivity, then for age selectivity
  for (f = 1; f <= 2 * Nfleet; f++)
  {
    fs = f - Nfleet; //index for saving age selex in the fleet arrays
    //  SS_Label_Info_22.2.1 #recalculate selectivity for any fleets or surveys with time-vary flag set for this year
    if (timevary_sel(y, f) == 1 || save_for_report > 0)
    { // recalculate the selex in this year x type
      if (N_selparmvec(f) > 0) // type has parms, so look for adjustments
      {
        for (j = 1; j <= N_selparmvec(f); j++)
        {
          if (selparm_timevary(Ip + j) == 0)
          {
            sp(j) = selparm(Ip + j);
          }
          else //  time-varying
          {
            sp(j) = parm_timevary(selparm_timevary(Ip + j), y);

            if (parm_adjust_method == 1 && (save_for_report > 0 || do_once == 1))
            {
              if (sp(j) > -999 && (sp(j) < selparm_1(Ip + j, 1) || sp(j) > selparm_1(Ip + j, 2)))
              {
                warnstream << "Adjusted selparm out of base parm bounds. Phase: " << current_phase() << "; Inter: " << niter << "; fleet: " << f << "; base_parm#: " << Ip + j << "; y: " << y << "; min: " << selparm_1(Ip + j, 1) << "; max: " << selparm_1(Ip + j, 2) << "; base: " << selparm(Ip + j) << " timevary_val: " << sp(j) << "  " << ParmLabel(firstselparm + Ip + j);
                write_message (ADJUST, 0);
              }
            }
          }
        } // end j parm loop
        if (docheckup == 1 && f <= Nfleet)
          echoinput << " len selex parms for fleet: " << f << " " << endl
                    << sp(1, N_selparmvec(f)) << endl;
        if (docheckup == 1 && f > Nfleet)
          echoinput << " age selex parms for fleet: " << f - Nfleet << " " << endl
                    << sp(1, N_selparmvec(f)) << endl;
        if (save_for_report > 0 || do_once == 1)
        {
          for (j = 1; j <= N_selparmvec(f); j++)
            save_sp_len(y, f, j) = sp(j);
        }
      }

      if (f <= Nfleet) // do size selectivity, retention, discard mort
      {
        for (gg = 1; gg <= gender; gg++)
        {
          if (gg == 1 || (gg == 2 && seltype(f, 3) >= 3))
          {
            //  SS_Label_Info_22.3 #Switch on size selectivity type
            switch (seltype(f, 1)) // select the selectivity pattern
            {
              //  SS_Label_Info_22.3.0 #case 0 constant size selectivity
              case 0: // ***********   constant
              {
                sel = 1.;
                break;
              }
              //  SS_Label_Info_22.3.1 #case 1 logistic size selectivity
              case 1:
              {
                if (seltype(f, 3) < 3 || (gg == 1 && seltype(f, 3) == 3) || (gg == 2 && seltype(f, 3) == 4)) //  do the primary gender
                {
                  sel = 1. / (1. + mfexp(neglog19 * (len_bins_m - sp(1)) / sp(2)));
                }
                else //  do the offset gender
                {
                  temp = sp(1) + sp(Maleselparm(f));
                  temp1 = sp(2) + sp(Maleselparm(f) + 1);
                  sel = sp(Maleselparm(f) + 2) / (1. + mfexp(neglog19 * (len_bins_m - temp) / temp1));
                }
                break;
              }

              //  SS_Label_Info_22.3.2 #case 2 size selectivity using double_normal_plateau and lots of bells and whistles; old version of 24 available for back compatibility
              case 2:
              //  SS_Label_Info_22.3.24 #case 24 size selectivity using double_normal_plateau and lots of bells and whistles
              case 24:
              {
                if (seltype(f, 3) < 3 || (gg == 1 && seltype(f, 3) == 3) || (gg == 2 && seltype(f, 3) == 4))
                {
                  peak = sp(1);
                  upselex = mfexp(sp(3));
                  downselex = mfexp(sp(4));
                  final = sp(6);
                  Apical_Selex = 1.;
                }
                else
                { // offset male parameters if seltype(f,3)==3, female parameters if seltype(f,3)==4
                  peak = sp(1) + sp(Maleselparm(f));
                  upselex = mfexp(sp(3) + sp(Maleselparm(f) + 1));
                  downselex = mfexp(sp(4) + sp(Maleselparm(f) + 2));
                  if (sp(6) > -999.)
                    final = sp(6) + sp(Maleselparm(f) + 3);
                  Apical_Selex = sp(Maleselparm(f) + 4);
                }

                if (sp(5) < -1000.)
                {
                  j1 = -1001 - int(value(sp(5))); // selex is nil thru bin j1, so set sp(5) equal to first bin with selex (e.g. -1002 to start selex at bin 2)
                  sel(1, j1) = 1.0e-06;
                }
                else
                {
                  j1 = startbin - 1; // start selex at bin equal to min sizecomp databin  (=j1+1)
                  if (sp(5) > -999)
                  {
                    point1 = 1.0 / (1.0 + mfexp(-sp(5)));
                    t1min = mfexp(-(square(len_bins_m(startbin) - peak) / upselex)); // fxn at first bin
                  }
                }
                if (sp(6) < -1000.)
                {
                  j2 = -1000 - int(value(sp(6))); // selex is constant beyond this sizebin, so set sp(6) equal to last bin with estimated selex
                }
                else
                {
                  j2 = nlength;
                }
                peak2 = peak + binwidth2 + (0.99 * len_bins_m(j2) - peak - binwidth2) / (1. + mfexp(-sp(2)));
                if (sp(6) > -999)
                {
                  if (seltype(f, 1) == 24)
                  {
                    point2 = Apical_Selex / (1.0 + mfexp(-final)); // The newer way of doing this
                  }
                  else
                  {
                    point2 = 1.0 / (1.0 + mfexp(-final)); // For back compatibility (old  (3.30.18 and earlier) version of pattern 24, now available as 2)
  #ifdef DO_ONCE
                    if (do_once == 1)
                    {
                      warnstream << "Selectivity 2 is a back-compatible (SS 3.30.18 and earlier) version of selectivity 24. Recommend using 24.";
                      write_message (SUGGEST, 0);
                    }
  #endif
                  }
                  t2min = mfexp(-(square(len_bins_m(j2) - peak2) / downselex)); // fxn at last bin
                }
                for (j = j1 + 1; j <= j2; j++)
                {
                  t1 = len_bins_m(j) - peak;
                  t2 = len_bins_m(j) - peak2;
                  join1 = 1.0 / (1.0 + mfexp(-(20. * t1 / (1.0 + fabs(t1))))); //  note the logit transform on t1 causes range of mfexp to be over -20 to 20
                  join2 = 1.0 / (1.0 + mfexp(-(20. * t2 / (1.0 + fabs(t2)))));
                  if (sp(5) > -999)
                  {
                    asc = point1 + (Apical_Selex - point1) * (mfexp(-square(t1) / upselex) - t1min) / (1.0 - t1min);
                  }
                  else
                  {
                    asc = Apical_Selex * mfexp(-square(t1) / upselex);
                  }
                  if (sp(6) > -999)
                  {
                    dsc = Apical_Selex + (point2 - Apical_Selex) * (mfexp(-square(t2) / downselex) - 1.0) / (t2min - 1.0);
                  }
                  else
                  {
                    dsc = Apical_Selex * mfexp(-square(t2) / downselex);
                  }
                  sel(j) = asc * (1.0 - join1) + join1 * (Apical_Selex * (1.0 - join2) + dsc * join2);
                }
                if (startbin > 1 && sp(5) >= -1000.)
                {
                  for (j = 1; j <= startbin - 1; j++)
                  {
                    sel(j) = square(len_bins_m(j) / len_bins_m(startbin)) * sel(startbin);
                  }
                }

                if (j2 < nlength)
                {
                  sel(j2 + 1, nlength) = sel(j2);
                }
                break;
              }

              //  SS_Label_Info_22.3.3 #case 3 discontinued
              case 3:
              {
                warnstream << "Selectivity pattern 3 discontinued. Use a different pattern.";
                write_message (FATAL, 0); // EXIT!
                break;
              }

              //  SS_Label_Info_22.3.4 #case 4 discontinued; use pattern 30 to get spawning biomass
              case 4:
              {
                warnstream << "Selectivity pattern 4 discontinued; use pattern 0 and special survey units 30 in data file instead.";
                write_message (FATAL, 0); // EXIT!
                break;
              }

              //  SS_Label_Info_22.3.5 #case 5 mirror another fleets size selectivity for specified bin range
              //  use only the specified bin range using mirror_mask created upon read
              // must refer to a lower numbered type (f)
              case 5:
              {
                sel = elem_prod(mirror_mask(f), sel_l(y, seltype(f, 4), 1));
                break;
              }

              //  SS_Label_Info_22.3.15 #case 15 mirror another fleets size selectivity for all size bins
              case 15:
              {
                sel = sel_l(y, seltype(f, 4), 1);
                break;
              }

              //  SS_Label_Info_22.3.6 #case 6 non-parametric size selex pattern
              // #43 non-parametric size selex scaled by average of values at low bin through high bin
              case 43:
                scaling_offset = 2;
                [[fallthrough]];
              case 6:
              {
                lastsel = -10.0; // log(selex) for first bin;
                lastSelPoint = len_bins_m(1); //  first size
                finalSelPoint = value(sp(2 + scaling_offset)); // size beyond which selex is constant
                SelPoint = value(sp(1 + scaling_offset)); //  first size that will get a parameter.  Value will get incremented by step interval (temp1)
                z = 3 + scaling_offset; // parameter counter
                temp1 = (finalSelPoint - SelPoint) / (seltype(f, 4) - 1.0); // step interval

                for (j = 1; j <= nlength; j++)
                {
                  if (len_bins_m(j) < SelPoint)
                  {
                    tempvec_l(j) = lastsel + (len_bins_m(j) - lastSelPoint) / (SelPoint - lastSelPoint) * (sp(z) - lastsel);
                  }
                  else if (len_bins_m(j) == SelPoint)
                  {
                    tempvec_l(j) = sp(z);
                    lastsel = sp(z);
                    lastSelPoint = SelPoint;
                    SelPoint += temp1;
                    if (SelPoint <= finalSelPoint)
                    {
                      z++;
                    }
                    else
                    {
                      SelPoint = finalSelPoint;
                    }
                  }
                  else if (len_bins_m(j) <= finalSelPoint)
                  {
                    lastsel = sp(z);
                    lastSelPoint = SelPoint;
                    SelPoint += temp1;
                    if (SelPoint <= finalSelPoint)
                    {
                      z++;
                    }
                    else
                    {
                      SelPoint = finalSelPoint;
                    }
                    tempvec_l(j) = lastsel + (len_bins_m(j) - lastSelPoint) / (SelPoint - lastSelPoint) * (sp(z) - lastsel);
                  }
                  else
                  {
                    tempvec_l(j) = sp(z);
                  }
  #ifdef DO_ONCE
                  if (do_once == 1)
                    echoinput << "selex42  " << j << " " << len_bins_m(j) << " " << SelPoint << " " << tempvec_l(j) << endl;
  #endif
                }
                if (scaling_offset == 0)
                {
                  temp = max(tempvec_l);
                }
                else
                {
                  int low_bin = int(value(sp(1)));
                  int high_bin = int(value(sp(2)));
                  if (low_bin < 1)
                  {
                    low_bin = 1;
                    warnstream << "Selex pattern 43; value for low bin is less than 1, so set to 1 ";
                    write_message (ADJUST, 0);
                  }
                  if (high_bin > nlength)
                  {
                    high_bin = nlength;
                    warnstream << " selex pattern 43; value for high bin is greater than " << nlength << ", so set to " << nlength;
                    write_message (ADJUST, 0);
                  }
                  if (high_bin < low_bin)
                    high_bin = low_bin;
                  if (low_bin > high_bin)
                    low_bin = high_bin;
                  sp(1) = low_bin;
                  sp(2) = high_bin;
                  temp = mean(tempvec_l(low_bin, high_bin));
                  scaling_offset = 0; // reset scaling offset
                }
                sel = mfexp(tempvec_l - temp);
                break;
              }

              //  SS_Label_Info_22.3.7 #case 7 discontinued; use pattern 8 for double logistic
              case 7:
              {
                warnstream << "Selectivity pattern 7 discontinued; use pattern 8 instead for double logistic, but recommend pattern 24. ";
                write_message (FATAL, 0); // EXIT!
                break;
              }

              //  SS_Label_Info_22.3.8 #case 8 double logistic  with eight parameters
              case 8:

                // 1=peak, 2=init,  3=infl,  4=slope, 5=final, 6=infl2, 7=slope2 8=binwidth;    Mirror=1===const_above_Linf
                {

  #ifdef DO_ONCE
                  if (do_once == 1)
                  {
                    warnstream << "Selectivity pattern 24 is recommended over pattern 8 because it has fewer parameters.";
                    write_message (SUGGEST, 0);
                  }
  #endif

                  t1 = minL + (1. / (1. + mfexp(-sp(3)))) * (sp(1) - minL); // INFL
                  t1min = 1. / (1. + mfexp(-mfexp(sp(4)) * (minL - t1))) * 0.9999; // asc value at minsize
                  t1max = 1. / (1. + mfexp(-mfexp(sp(4)) * (sp(1) - t1))) * 1.0001; // asc value at peak
                  t1power = log(0.5) / log((0.5 - t1min) / (t1max - t1min)); // so the parameter will actual correspond to 50% point

                  if (seltype(f, 4) == 0)
                  {
                    sel_maxL = maxL;
                  }
                  else
                  {
                    sel_maxL = Ave_Size(styr, 1, 1, nages);
                  }
                  t2 = (sp(1) + sp(8)) + (1. / (1. + mfexp(-sp(6)))) * (sel_maxL - (sp(1) + sp(8))); // INFL
                  t2min = 1. / (1. + mfexp(-mfexp(sp(7)) * (sp(1) + sp(8) - t2))) * 0.9999; // asc value at peak+
                  t2max = 1. / (1. + mfexp(-mfexp(sp(7)) * (sel_maxL - t2))) * 1.0001; // asc value at maxL
                  t2power = log(0.5) / log((0.5 - t2min) / (t2max - t2min));
                  final = 1. / (1. + mfexp(-sp(5)));
                  for (j = 1; j <= nlength; j++) //calculate the value over length bins
                  {
                    join1 = 1. / (1. + mfexp(10. * (len_bins_m(j) - sp(1))));
                    join2 = 1. / (1. + mfexp(10. * (len_bins_m(j) - (sp(1) + sp(8)))));
                    join3 = 1. / (1. + mfexp(10. * (len_bins_m(j) - sel_maxL)));
                    upselex = sp(2) + (1. - sp(2)) * pow(((1. / (1. + mfexp(-mfexp(sp(4)) * (len_bins_m(j) - t1))) - t1min) / (t1max - t1min)), t1power);
                    downselex = (1. + (final - 1.) * pow(fabs((((1. / (1. + mfexp(-mfexp(sp(7)) * (len_bins_m(j) - t2))) - t2min) / (t2max - t2min)))), t2power));
                    sel(j) = ((((upselex * join1) + 1.0 * (1.0 - join1)) * join2) + downselex * (1 - join2)) * join3 + final * (1 - join3);
                  } // end size bin loop
                  break;
                } // end New double logistic

              //  SS_Label_Info_22.3.9 #case 9 old double logistic with 4 parameters
              case 9:
              {
                k1 = int(value(sp(5)));
                if (k1 > 1)
                  sel(1, k1 - 1) = 0.0;
                sel(k1, nlength) = elem_prod((1 / (1 + mfexp(-sp(2) * (len_bins_m(k1, nlength) - sp(1))))),
                    (1 - 1 / (1 + mfexp(-sp(4) * (len_bins_m(k1, nlength) - (sp(1) * sp(6) + sp(3)))))));
                sel += 1.0e-6;
                sel /= max(sel);
                break;
              }

              //  SS_Label_Info_22.3.11 #case 11 selex=1.0 within a range of lengths
              case 11:
              {
                sel = mirror_mask(f); // (y,f,1)
                break;
              }
              //  SS_Label_Info_22.3.21 #case 21 non-parametric size selectivity
              /*  N points; where the first N parameters is vector of sizes for the line segment ends
    and second N parameters is selectivity at that size (no transformations) */
              case 21: // *******New non-parametric
              {
                j = 1;
                z = 1;
                k = seltype(f, 4); //  N points
                lastsel = 0.0;
                lastSelPoint = 0.0;

  #ifdef DO_ONCE
                if (do_once == 1)
                {
                  if (sp(k) > len_bins(nlength))
                  {
                    warnstream << "Selex21: cannot have max selpoint > max_pop_lenbin";
                    write_message (FATAL, 0); // EXIT!
                  }
                  if (sp(k - 1) > len_bins(nlength - 1))
                  {
                    warnstream << "Selex21: should not have selpoint(n-1) > pop_lenbin(nlength-1)";
                    write_message (WARN, 0);
                  }
                }
  #endif

                while (j <= nlength)
                {
                  if (len_bins(j) <= sp(z))
                  {
                    sel(j) = lastsel + (len_bins(j) - lastSelPoint) / (sp(z) - lastSelPoint) * (sp(z + k) - lastsel);
                    j++;
                  }
                  else if (z <= k)
                  {
                    lastSelPoint = sp(z);
                    lastsel = sp(z + k);
                    z++;
                  }
                  else //  for sizes beyond last point
                  {
                    sel(j) = sp(k + k);
                    j++;
                  }
                }
                break;
              }

              //  SS_Label_Info_22.3.22 #case 22 size selectivity using double_normal_plateau (similar to CASAL)
              case 22:
              {
                peak2 = sp(1) + (0.99 * len_bins(nlength) - sp(1)) / (1. + mfexp(-sp(2)));
                upselex = mfexp(sp(3));
                downselex = mfexp(sp(4));
                for (j = 1; j <= nlength; j++)
                {
                  t1 = len_bins_m(j);
                  if (t1 < sp(1))
                  {
                    sel(j) = mfexp(-square(t1 - sp(1)) / upselex);
                  }
                  else if (t1 <= peak2)
                  {
                    sel(j) = 1.0;
                  }
                  else
                  {
                    sel(j) = mfexp(-square(t1 - peak2) / downselex);
                  }
                }
                break;
              }

              //  SS_Label_Info_22.3.23 #case 23 size selectivity double_normal_plateau where final value can be greater than 1.0
              /*  cannot be used with Pope's because can cause selex to be >1.0 */
              case 23:
              {
                if (seltype(f, 3) < 3 || (gg == 1 && seltype(f, 3) == 3) || (gg == 2 && seltype(f, 3) == 4))
                {
                  peak = sp(1);
                  upselex = mfexp(sp(3));
                  downselex = mfexp(sp(4));
                  final = sp(6);
                }
                else
                { // offset male parameters if seltype(f,3)==3
                  peak = sp(1) + sp(Maleselparm(f));
                  upselex = mfexp(sp(3) + sp(Maleselparm(f) + 1));
                  downselex = mfexp(sp(4) + sp(Maleselparm(f) + 2));
                  if (sp(6) > -999.)
                    final = sp(6) + sp(Maleselparm(f) + 3);
                }

                if (sp(5) < -1000.)
                {
                  j1 = -1001 - int(value(sp(5))); // selex is nil thru bin j1, so set sp(5) equal to first bin with selex (e.g. -1002 to start selex at bin 2)
                  sel(1, j1) = 1.0e-06;
                }
                else
                {
                  j1 = startbin - 1; // start selex at bin equal to min sizecomp databin  (=j1+1)
                  if (sp(5) > -999)
                  {
                    point1 = 1.0 / (1.0 + mfexp(-sp(5)));
                    t1min = mfexp(-(square(len_bins_m(startbin) - peak) / upselex)); // fxn at first bin
                  }
                }
                if (sp(6) < -1000.)
                {
                  j2 = -1000 - int(value(sp(6))); // selex is constant beyond this sizebin, so set sp(6) equal to last bin with estimated selex
                }
                else
                {
                  j2 = nlength;
                }
                peak2 = peak + binwidth2 + (0.99 * len_bins_m(j2) - peak - binwidth2) / (1. + mfexp(-sp(2)));
                if (sp(6) > -999)
                {
                  point2 = final;
                  t2min = mfexp(-(square(len_bins_m(j2) - peak2) / downselex)); // fxn at last bin
                }
                for (j = j1 + 1; j <= j2; j++)
                {
                  t1 = len_bins_m(j) - peak;
                  t2 = len_bins_m(j) - peak2;
                  join1 = 1.0 / (1.0 + mfexp(-(20. * t1 / (1.0 + fabs(t1))))); //  note the logit transform on t1 causes range of mfexp to be over -20 to 20
                  join2 = 1.0 / (1.0 + mfexp(-(20. * t2 / (1.0 + fabs(t2)))));
                  if (sp(5) > -999)
                  {
                    asc = point1 + (1.0 - point1) * (mfexp(-square(t1) / upselex) - t1min) / (1.0 - t1min);
                  }
                  else
                  {
                    asc = mfexp(-square(t1) / upselex);
                  }
                  if (sp(6) > -999)
                  {
                    dsc = 1.0 + (point2 - 1.0) * (mfexp(-square(t2) / downselex) - 1.0) / (t2min - 1.0);
                  }
                  else
                  {
                    dsc = mfexp(-square(t2) / downselex);
                  }
                  sel(j) = asc * (1.0 - join1) + join1 * (1.0 - join2 + dsc * join2);
                }
                if (startbin > 1 && sp(5) >= -1000.)
                {
                  for (j = 1; j <= startbin - 1; j++)
                  {
                    sel(j) = square(len_bins_m(j) / len_bins_m(startbin)) * sel(startbin);
                  }
                }

                if (j2 < nlength)
                {
                  sel(j2 + 1, nlength) = sel(j2);
                }
                break;
              }

              //  SS_Label_Info_22.3.25 #case 25 size selectivity using exponential-logistic
              case 25:
              {
                peak = len_bins_m(1) + sp(2) * (len_bins_m(nlength) - len_bins_m(1));
                for (j = 1; j <= nlength; j++)
                {
                  sel(j) = mfexp(sp(3) * sp(1) * (peak - len_bins_m(j))) / (1.0 - sp(3) * (1.0 - mfexp(sp(1) * (peak - len_bins_m(j)))));
                }
                break;
              }

              //  SS_Label_Info_22.3.27 #case 27 size selectivity using cubic spline
              // #42 size selectivity using cubic spline scaled by average of values at low bin through high bin
              /*  first N parameters are the spline knots; second N parameters are ln(selex) at the knot */
              /*  uses max(raw vector) to achieve scale to 1.0 */
              case 42:
                scaling_offset = 2;
                [[fallthrough]];
              case 27:
              {
                int j2;
                // define vectors which form the basis for cubic spline selectivity
                // IMPORTANT: these vectors might need to be expanded to fit values for multiple fleets
                dvector splineX(1, 200);
                dvar_vector splineY(1, 200);
                splineX.initialize();
                splineY.initialize();
                k = seltype(f, 4); // n points to include in cubic spline
                for (i = 1; i <= k; i++)
                {
                  splineX(i) = value(sp(i + 3 + scaling_offset)); // "value" required to avoid error, but values should be always fixed anyway
                  splineY(i) = sp(i + 3 + k + scaling_offset);
                }
                // calculate last size bin before first knot
                z = 1;
                while (len_bins_m(z) < splineX(1))
                {
                  z++;
                }
                j1 = z - 1; //  last size bin before first knot
                // calculate first size bin beyond last knot
                z = nlength;
                while (len_bins_m(z) > splineX(k))
                {
                  z--;
                }
                j2 = z + 1; //  first size bin beyond last knot

                vcubic_spline_function splinefn = vcubic_spline_function(splineX(1, k), splineY(1, k), sp(2 + scaling_offset), sp(3 + scaling_offset));
                tempvec_l = splinefn(len_bins_m); // interpolate selectivity at the mid-point of each population size bin
                if (scaling_offset == 0)
                {
                  temp = max(tempvec_l(1, j2));
                  // if spline code on first parameter line is 10, 11, or 12, then
                  // scale only based on interval between knots (unless first knot is at first bin)
                  if ((sp(1) >= 10) & (j1 >= 1))
                  {
                    temp = max(tempvec_l(j1, j2));
                  }
                }
                else
                {
                  int low_bin = int(value(sp(1)));
                  int high_bin = int(value(sp(2)));
                  if (low_bin < 1)
                  {
                    low_bin = 1;
                    warnstream << "Selex pattern 42; value for low bin is less than 1, so set to 1 ";
                    write_message (ADJUST, 0);
                  }
                  if (high_bin > nlength)
                  {
                    high_bin = nlength;
                    warnstream << "Selex pattern 42; value for high bin is greater than " << nlength << ", so set to " << nlength;
                    write_message (ADJUST, 0);
                  }
                  if (high_bin < low_bin)
                    high_bin = low_bin;
                  if (low_bin > high_bin)
                    low_bin = high_bin;
                  sp(1) = low_bin;
                  sp(2) = high_bin;
                  temp = mean(tempvec_l(low_bin, high_bin));
                }
                tempvec_l -= temp; // rescale to get max of 0.0
                tempvec_l(j2 + 1, nlength) = tempvec_l(j2); //  set constant above last knot
                sel = mfexp(tempvec_l);
                // if spline code on third parameter line is 10, 11, or 12, then
                // set to zero before the first knot (unless first knot is at first bin)
                if ((sp(1 + scaling_offset) >= 10) & (j1 >= 1))
                {
                  sel(1, j1) = 0; //  set to 0 before first knot
                }
                scaling_offset = 0; // reset scaling offset
                break;
              } // end length-based cubic spline (type 42 or 27)
              case 30:
              {
                warnstream << "Selectivity pattern 30 not valid. Please set up in survey units instead and use pattern 0 for selectivity.";
                write_message (FATAL, 0); // EXIT!
                break;
              }
              default: // Selectivity pattern not found
              {
                warnstream << "Length Selectivity Pattern " << seltype(f, 1) << " not valid.";
                write_message (FATAL, 0); // EXIT!
                break;
              }
            } // end select the selectivity pattern
            sel_l(y, f, gg) = sel; // Store size-selex in year*type array
          } // end direct calc of selex from parameters

          //  SS_Label_Info_22.4 #Do male relative to female selex
          if (gg == 2) // males exist and am now in the male loop
          {
            if (seltype(f, 1) == 4)
            {
              sel_l(y, f, 2) = 0.;
            } // set males to zero for spawning biomass
            else if (seltype(f, 1) == 5) // set males equal to mirrored males
            {
              //          i=int(value(sp(1)));  if(i<=0) i=1;
              //          j=int(value(sp(2)));  if(j<=0) j=nlength;
              sel_l(y, f, 2) = elem_prod(mirror_mask(f), sel_l(y, seltype(f, 4), 2));
            }
            else if (seltype(f, 1) == 15) // set males equal to mirrored males
            {
              sel_l(y, f, 2) = sel_l(y, seltype(f, 4), 2);
            }
            else if (seltype(f, 3) == 1 || seltype(f, 3) == 2) // do gender selex as offset
            {
              //           k=seltype_Nparam(seltype(f,1)) + 1;
              //           if(seltype(f,2)>0) k+=seltype(f,2)*4;   // first gender offset parm (skip over the retention parameters
              //           if(seltype(f,1)==6) k += seltype(f,4);    // for non-parametric in which N parm is stored in special column
              k = Maleselparm(f);
              temp = sp(k);
              temp1 = 1.;
              switch (seltype(f, 3))
              {
                case 1:
                { // do males relative to females
                  for (j = 1; j <= nlength; j++)
                  {
                    if (len_bins_m(j) <= temp)
                    {
                      sel(j) *= mfexp(sp(k + 1) + (len_bins_m(j) - minL_m) / (temp - minL_m) * (sp(k + 2) - sp(k + 1)));
                    }
                    else
                    {
                      sel(j) *= mfexp(sp(k + 2) + (len_bins_m(j) - temp) / (maxL - temp) * (sp(k + 3) - sp(k + 2)));
                    }
                    //                 if(sel(j)>temp1) temp1=sel(j);
                  }
                  sel_l(y, f, 2) = sel;
                  tempvec_a(1) = max(sel_l(y, f, 1));
                  tempvec_a(2) = max(sel_l(y, f, 2));
                  temp1 = max(tempvec_a(1, 2));
                  sel_l(y, f) /= temp1;
                  break;
                }
                case 2:
                { //  do females relative to males
                  sel_l(y, f, 2) = sel;
                  for (j = 1; j <= nlength; j++)
                  {
                    if (len_bins_m(j) <= temp)
                    {
                      sel(j) *= mfexp(sp(k + 1) + (len_bins_m(j) - minL_m) / (temp - minL_m) * (sp(k + 2) - sp(k + 1)));
                    }
                    else
                    {
                      sel(j) *= mfexp(sp(k + 2) + (len_bins_m(j) - temp) / (maxL - temp) * (sp(k + 3) - sp(k + 2)));
                    }
                    //                 if(sel(j)>temp1) temp1=sel(j);
                  }
                  sel_l(y, f, 1) = sel;
                  tempvec_a(1) = max(sel_l(y, f, 1));
                  tempvec_a(2) = max(sel_l(y, f, 2));
                  temp1 = max(tempvec_a(1, 2));
                  sel_l(y, f) /= temp1;
                  break;
                }
              } // end switch
            } // end do gender selex as offset from other gender
            //  SS_Label_Info_22.5 #Calculate size-specific retention and discard mortality
            else if (seltype(f, 3) != 3 && seltype(f, 3) != 4) // where the "3" and "4" option do the male offset as direct parameters, rathen than do selex as offset
            {
              sel_l(y, f, 2) = sel;
            }
          } // end doing males
          if (docheckup == 1)
            echoinput << gg << "  sel-len" << sel_l(y, f, gg) << endl;

        } // end loop of genders

        //  apply 2D_AR adjustment to sex-specific length selectivity
        //  TwoD_AR_def: read:  1-fleet, 2-ymin, 3-ymax, 4-amin, 5-amax, 6-sigma_amax, 7-use_rho, 8-age/len, 9-dev_phase; 10-before_yrs, 11=after_yrs,
        //  calc quantities:  12-N_parm_dev, 13-selparm_location

        if (TwoD_AR_use(f) > 0)
        {
          j = TwoD_AR_use(f); //  get index for this fleet's effect
          if (TwoD_AR_def[j](8) == 1) //  age vs length flag
          {
            z = TwoD_AR_def[j](12); // index of dev vector used
            if (docheckup == 1)
              echoinput << "2dar for fleet: " << f << " 2DAR: " << j << " dev: " << z << endl;

            if (y == styr && (TwoD_AR_before(j) == 3 || TwoD_AR_after(j) == 3)) //  if needed, calculate average dev for each length over the range of years
            {
              TwoD_AR_ave(j).initialize();
              for (int yyy = TwoD_AR_ymin(j); yyy <= TwoD_AR_ymax(j); yyy++)
              {
                k = (yyy - TwoD_AR_ymin(j)) * (TwoD_AR_amax(j) - TwoD_AR_amin(j) + 1); //  index of 1st dev in vector created from year and length index
                for (int ll = TwoD_AR_amin(j); ll <= TwoD_AR_amax(j); ll++)
                {
                  k++;
                  TwoD_AR_ave(j, ll) += parm_dev(z, k); //  sum devs for each length
                }
              }
              TwoD_AR_ave(j) /= (TwoD_AR_ymax(j) - TwoD_AR_ymin(j) + 1.0);
  #ifdef DO_ONCE
              if (do_once == 1)
                echoinput << "mean 2D AR dev for fleet: " << f << " means: " << TwoD_AR_ave(j) << endl;
  #endif
            }

            if (y < TwoD_AR_ymin(j)) //  early years
            {
              if (TwoD_AR_before(j) == 0) //  apply no devs
              {
                k = -2;
              }
              else if (TwoD_AR_before(j) == 1) //  use first year devs
              {
                //          k=(TwoD_AR_ymin(j)-TwoD_AR_ymin(j))*(TwoD_AR_amax(j)-TwoD_AR_amin(j)+1);  //  index of 1st dev in vector created from year and length index
                k = 0;
              }
              else if (TwoD_AR_before(j) == 3) //  use mean length-specific devs
              {
                k = -1;
              }
            }
            else if (y <= TwoD_AR_ymax(j)) //  in year range for annual devs
            {
              k = (y - TwoD_AR_ymin(j)) * (TwoD_AR_amax(j) - TwoD_AR_amin(j) + 1); //  index of 1st dev in vector created from year and length index
            }
            else //  later years
            {
              if (TwoD_AR_after(j) == 0) //  apply no devs
              {
                k = -2;
              }
              else if (TwoD_AR_after(j) == 1) //  use last year devs
              {
                k = (TwoD_AR_ymax(j) - TwoD_AR_ymin(j)) * (TwoD_AR_amax(j) - TwoD_AR_amin(j) + 1);
              } //  index of 1st dev in vector created from year and length index
              else if (TwoD_AR_after(j) == 3) //  use mean length-specific devs
              {
                k = -1;
              }
            }

            if (docheckup == 1)
              echoinput << "K value for first dev to use: " << k << endl;
            if (k > -2)
            {
              a1 = TwoD_AR_def[j](13) - 1; //  parameter number-1  for sigmasel
              dvariable sigmasel;
              for (a = TwoD_AR_amin(j); a <= TwoD_AR_amax(j); a++) // loop lengths, using "a" as index
              {
                if (a <= TwoD_AR_def[j](6)) // so get sigmasel for this length bin
                {
                  a1++;
                  sigmasel = selparm(a1);
                }
                if (k >= 0)
                {
                  k++;
                  if (docheckup == 1)
                    echoinput << a << "  sigmasel: " << sigmasel << endl;
                  sel_l(y, f, 1, a) *= mfexp(sigmasel * parm_dev(z, k));
                  if (gender == 2)
                    sel_l(y, f, 2, a) *= mfexp(sigmasel * parm_dev(z, k));
                }
                else //  use mean devs
                {
                  sel_l(y, f, 1, a) *= mfexp(sigmasel * TwoD_AR_ave(j, a));
                  if (gender == 2)
                    sel_l(y, f, 2, a) *= mfexp(sigmasel * TwoD_AR_ave(j, a));
                }
              }
            }
            if (docheckup == 1)
              echoinput << "len selex after 2D_AR" << endl
                        << sel_l(y, f) << endl;
          }
        }

        //  SS_Label_Info_22.5.1 #Calculate discmort
        // discmort is the size-specific fraction of discarded fish that die
        //  discmort2 is size-specific fraction that die from being retained or are dead discard
        //   = elem_prod(sel,(retain + (1-retain)*discmort)) */

        if (seltype(f, 2) == 0) //  no discard, all retained
        {
          retain(y, f) = 1.0;
          sel_l_r(y, f) = sel_l(y, f);
          discmort(y, f) = 1.0;
          discmort2(y, f) = sel_l(y, f);
          if (gender == 2)
          {
            discmort_M = 1.0;
            retain_M = 1.0;
          }
        }
        else if (seltype(f, 2) == 3) // none retained; all dead
        {
          retain(y, f) = 0.0;
          discmort(y, f) = 1.0;
          sel_l_r(y, f) = 0.0;
          discmort2(y, f) = sel_l(y, f);
          if (gender == 2)
          {
            discmort_M = 1.0;
            retain_M = 0.0;
          }
        }
        else
        {
          if (seltype(f, 2) < 0) // mirror
          {
            k = -seltype(f, 2);
            retain(y, f) = retain(y, k);
            discmort(y, f) = discmort(y, k);
            if (seltype(k, 2) == 1)
            {
              discmort2(y, f) = sel_l(y, f); //  all selected fish are dead;  this statement does both genders implicitly
            }
            else
            {
              discmort2(y, f, 1) = elem_prod(sel_l(y, f, 1), retain(y, f)(1, nlength) + elem_prod((1. - retain(y, f)(1, nlength)), discmort(y, f)(1, nlength)));
            }
          }
          else
          {
            k = RetainParm(f);
            if (sp(k + 2) == -999.)
            {
              temp1 = 0.0;
            }
            else if (sp(k + 2) == 999.)
            {
              temp1 = 1.0;
            }
            else
            {
              temp1 = 1.0 / (1.0 + mfexp(-sp(k + 2)));
            }
            //  where maleoffset is a vector of 2*nbins with 0 in length bins for females and 1 for male bins
            retain(y, f) = temp1 / (1. + mfexp(-(len_bins_m2 - (sp(k) + male_offset * sp(k + 3))) / sp(k + 1))); // males are at end of vector, so automatically get done
            if (seltype(f, 2) == 4)
            {
              // allow for dome-shaped retention in 3.30 only
              retain(y, f) = elem_prod(retain(y, f), (1. - (1. / (1. + mfexp(-(len_bins_m2 - (sp(k + 4) + male_offset * sp(k + 6))) / sp(k + 5))))));
            }
            if (docheckup == 1 && y == styr)
            {
              echoinput << "retention parms start at #: " << k << " infl: " << sp(k) << " slope: " << sp(k + 1) << " male_offset " << sp(k + 3) << " asymptote: " << temp1;
              if (seltype(f, 2) == 4)
              {
                // additional dome-shaped retention parameters
                echoinput << " " << sp(k + 4) << " " << sp(k + 5) << " " << sp(k + 6);
              }
              echoinput << "retention " << retain(y, f) << endl;
            }

            if (seltype(f, 2) == 1) // all discards are dead
            {
              discmort(y, f) = 1.0;
              discmort2(y, f) = sel_l(y, f); //  all selected fish are dead;  this statement does both genders implicitly
            }
            else
            {
              k += N_ret_parm(seltype(f, 2)); // first discard mortality parm
              temp = 1. - sp(k + 2);
              temp1 = posfun(temp, 0.0, CrashPen);
              discmort(y, f) = (1. - temp1 / (1 + mfexp(-(len_bins_m2 - (sp(k) + male_offset * sp(k + 3))) / sp(k + 1)))); // males are at end of vector, so automatically get done
              if (docheckup == 1 && y == styr)
                echoinput << "discmort " << discmort(y, f) << endl;
              discmort2(y, f, 1) = elem_prod(sel_l(y, f, 1), retain(y, f)(1, nlength) + elem_prod((1. - retain(y, f)(1, nlength)), discmort(y, f)(1, nlength)));
            }
          }

          sel_l_r(y, f, 1) = elem_prod(sel_l(y, f, 1), retain(y, f)(1, nlength));
          if (gender == 2)
          {
            discmort_M.shift(nlength1) = discmort(y, f)(nlength1, nlength2);
            retain_M.shift(nlength1) = retain(y, f)(nlength1, nlength2);
            sel_l_r(y, f, 2) = elem_prod(sel_l(y, f, 2), retain_M.shift(1));
            discmort2(y, f, 2) = elem_prod(sel_l(y, f, 2), retain_M.shift(1) + elem_prod((1. - retain_M.shift(1)), discmort_M.shift(1))); // V3.21f
          }
        }
        if (docheckup == 1 && y == styr)
          echoinput << "sel-len-r " << sel_l_r(y, f) << endl;
        if (docheckup == 1 && y == styr)
          echoinput << " dead " << discmort2(y, f) << endl;

      } //  end loop of fleets for size selex and retention and discard mortality

      //  SS_Label_Info_22.6 #Do age-selectivity
      else
      {
        for (gg = 1; gg <= gender; gg++)
        {
          if (gg == 1 || (gg == 2 && seltype(f, 3) >= 3) || (gg == 2 && (seltype(f, 1) == 44 || seltype(f, 1) == 45))) //  in age selex
          {
            //  SS_Label_Logic_22.7 #Switch depending on the age-selectivity pattern selected
            switch (seltype(f, 1))
            {

              //  SS_Label_Info_22.7.0 #Constant age-specific selex for ages 0 to nages
              case 0:
              {
                sel_a(y, fs, 1)(0, nages) = 1.00;
                break;
              }

              //  SS_Label_Info_22.7.10 #Constant age-specific selex for ages 1 to nages
              case 10:
              {
                sel_a(y, fs, 1)(1, nages) = 1.00;
                break;
              }

              //  SS_Label_Info_22.7.11 #Constant age-specific selex for specified age range
              case 11: // selex=1.0 within a range of ages
              {
                //              	echoinput<<f<<" min max "<<sp(1)<<" "<<sp(2)<<endl;
                //                a=int(value(sp(2)));
                //                if(a>nages) {a=nages;}
                //                sel_a(y,fs,1)(int(value(sp(1))),a)=1.;
                sel_a(y, fs, 1) = mirror_mask_a(fs);
                break;
              }

              //  SS_Label_Info_22.7.12 #age selectivity - logistic
              case 12:
              {
                sel_a(y, fs, 1).initialize();
                sel_a(y, fs, 1)(Min_selage(fs), nages) = 1. / (1. + mfexp(neglog19 * (r_ages(Min_selage(fs), nages) - sp(1)) / sp(2)));
                break;
              }

              //  SS_Label_Info_22.7.13 #age selectivity - double logistic
              case 13:
                // 1=peak, 2=init,  3=infl,  4=slope, 5=final, 6=infl2, 7=slope2, 8=plateau
                {
  #ifdef DO_ONCE
                  if (do_once == 1)
                  {
                    warnstream << "Age selectivity pattern 13 used; suggest using pattern 18 instead. ";
                    write_message (SUGGEST, 0);
                  }
  #endif
                  sel_a(y, fs, 1).initialize();
                  t1 = 0. + (1. / (1. + mfexp(-sp(3)))) * (sp(1) - 0.); // INFL
                  t1min = 1. / (1. + mfexp(-sp(4) * (0. - t1))) * 0.9999999; // asc value at minage
                  t1max = 1. / (1. + mfexp(-sp(4) * (sp(1) - t1))) * 1.00001; // asc value at peak
                  t1power = log(0.5) / log((0.5 - t1min) / (t1max - t1min));

                  t2 = (sp(1) + sp(8)) + (1. / (1. + mfexp(-sp(6)))) * (r_ages(nages) - (sp(1) + sp(8))); // INFL
                  t2min = 1. / (1. + mfexp(-sp(7) * (sp(1) + sp(8) - t2))) * 0.9999; // asc value at peak+
                  t2max = 1. / (1. + mfexp(-sp(7) * (r_ages(nages) - t2))) * 1.00001; // asc value at maxage
                  t2power = log(0.5) / log((0.5 - t2min) / (t2max - t2min));
                  final = 1. / (1. + mfexp(-sp(5)));
                  k1 = int(value(sp(1)));
                  k2 = int(value(sp(1) + sp(8)));

                  for (a = Min_selage(fs); a <= nages; a++) //calculate the value over ages
                  {
                    if (a < k1) // ascending limb
                    {
                      sel_a(y, fs, 1, a) = sp(2) + (1. - sp(2)) * pow(((1. / (1. + mfexp(-sp(4) * (r_ages(a) - t1))) - t1min) / (t1max - t1min)), t1power);
                    }
                    else if (a > k2) // descending limb
                    {
                      sel_a(y, fs, 1, a) = 1. + (final - 1.) * pow(((1. / (1. + mfexp(-sp(7) * (r_ages(a) - t2))) - t2min) / (t2max - t2min)), t2power);
                    }
                    else // at the peak
                    {
                      sel_a(y, fs, 1, a) = 1.0;
                    }
                  } // end age loop
                  break;
                } // end double logistic

              //  SS_Label_Info_22.7.14 #age selectivity - separate parm for each age
              case 14:
              {
                temp = 9. - max(sp(1, nages + 1)); //  this forces at least one age to have selex weight equal to 9
                sel_a(y, fs, 1).initialize();
                for (a = Min_selage(fs); a <= nages; a++)
                {
                  if (sp(a + 1) > -999)
                  {
                    sel_a(y, fs, 1, a) = 1. / (1. + mfexp(-(sp(a + 1) + temp)));
                  }
                  else
                  {
                    sel_a(y, fs, 1, a) = sel_a(y, fs, 1, a - 1);
                  }
                }
                break;
              }

              //  SS_Label_Info_22.7.15 #age selectivity - mirror selex for lower numbered fleet
              // must refer to a lower numbered type (f)
              case 15:
              {
                sel_a(y, fs) = sel_a(y, seltype(f, 4));
                break;
              }

              //  SS_Label_Info_22.7.16 #age selectivity: Coleraine - Gaussian
              case 16:
              {
                t1 = 1 / (1 + mfexp(-sp(1))) * nages;
                sel_a(y, fs, 1).initialize();
                for (a = Min_selage(fs); a <= nages; a++)
                {
                  if (a < t1)
                  {
                    sel_a(y, fs, 1, a) = mfexp(-square(r_ages(a) - t1) / mfexp(sp(2)));
                  }
                  else
                  {
                    sel_a(y, fs, 1, a) = 1.0;
                  }
                }
                break;
              }

              //  SS_Label_Info_22.7.17 #age selectivity: each age has parameter as random walk
              // #41 each age has parameter as random walk scaled by average of values at low age through high age
              //    transformation as selex=exp(parm); some special codes */
              case 41:
                scaling_offset = 2;
                [[fallthrough]];
              case 17: //
              {
                lastsel = 0.0; //  value is the change in log(selex);  this is the reference value for age 0
                tempvec_a = -999.;
                tempvec_a(0) = 0.0; //  so do not try to estimate the first value
                int lastage;
                if (seltype(f, 4) == 0)
                {
                  lastage = nages;
                }
                else
                {
                  lastage = abs(seltype(f, 4));
                }
                for (a = 1; a <= lastage; a++)
                {
                  //  with use of -999, lastsel stays constant until changed, so could create a linear change in ln(selex)
                  // use of (a+1) is because the first element, sp(1), is for age zero
                  if (sp(a + 1 + scaling_offset) > -999.)
                  {
                    lastsel = sp(a + 1 + scaling_offset);
                  }
                  tempvec_a(a) = tempvec_a(a - 1) + lastsel; // cumulative log(selex)
//                  warning << a << "SP: " << sp(a + 1 + scaling_offset) << " cumul: " << tempvec_a(a) << endl;
                }
                if (scaling_offset == 0)
                {
                  temp = max(tempvec_a); //  find max so at least one age will have selex=1.
                }
                else
                {
                  int low_bin = int(value(sp(1)));
                  int high_bin = int(value(sp(2)));
                  //  checks and adjustments below should happen in readcontrol
                  if (low_bin < 0)
                  {
                    low_bin = 0;
                    warnstream << "Selex pattern 41; value for low bin is less than 0, so set to 0 ";
                    write_message (ADJUST, 0);
                  }
                  if (high_bin > nages)
                  {
                    high_bin = nages;
                    warnstream << "Selex pattern 41; value for high bin is greater than " << nages << ", so set to " << nages;
                    write_message (ADJUST, 0);
                  }
                  if (high_bin < low_bin)
                    high_bin = low_bin;
                  if (low_bin > high_bin)
                    low_bin = high_bin;
                  sp(1) = low_bin;
                  sp(2) = high_bin;
                  temp = mean(tempvec_a(low_bin, high_bin));
//                  warning << tempvec_a(low_bin, high_bin) << endl;
//                warning << low_bin << " " << high_bin << " mean " << temp << endl;
                }
                sel_a(y, fs, 1) = mfexp(tempvec_a - temp);
                a = 0;
                while (sp(a + 1 + scaling_offset) == -1000) //  reset range of young ages to selex=0.0
                {
                  sel_a(y, fs, 1, a) = 0.0;
                  a++;
                }
                scaling_offset = 0; // reset scaling offset
                if (lastage < nages)
                {
                  for (a = lastage + 1; a <= nages; a++)
                  {
                    if (seltype(f, 4) > 0)
                    {
                      sel_a(y, fs, 1, a) = sel_a(y, fs, 1, a - 1);
                    }
                    else
                    {
                      sel_a(y, fs, 1, a) = 0.0;
                    }
                  }
                }
                break;
              }

              case 44: //  like age selex 17 but with separate parameters for males and with revised controls
              {
                //  sp(1) is first age with non-zero selectivity; can be age 0
                //  seltype(f,4) is number of selectivity change parameters beginning at age=first_age+1
                //  sp(2) is first age for which mean selex=1
                //  sp(3) is last age  for which mean selex=1
                //  sp(4) is male mean selex relative to female mean.
                //  -999 code means to keep the change unchanged from previous age (so keeps same rate of change)
                // -1000 code is only for males and sets the male change to be same as female change
                //  gg is the index for sex, where 1=female, 2=male
                sel_a(y, fs, gg).initialize();
                dvariable seldelta = 0.0; //  value is the change in log(selex)
                tempvec_a.initialize(); //  null value for vector
                //              echoinput<<" sp "<<sp(1,N_selparmvec(f))<<endl;
                int first_age = int(value(sp(1)));
                tempvec_a(first_age) = 0.0; //  start value for random walk across ages
                int last_age = first_age + seltype(f, 4); //  because seltype(f,4) contains the number of changes
                if (gg == 1)
                {
                  scaling_offset = 2 + gender;
                }
                else
                {
                  scaling_offset = 2 + gender + seltype(f, 4);
                } // to get male vs female starting point for parameters
                //               echoinput<<first_age <<" "<< last_age <<" "<< scaling_offset<<endl;
                j = scaling_offset;
                for (a = first_age + 1; a <= last_age; a++)
                {
                  j++;
                  //  with use of -999, lastsel stays constant until changed, so could create a linear change in ln(selex)
                  if (sp(j) > -999.)
                  {
                    seldelta = sp(j);
                  } // so allows for seldelta to remain unchanged
                  else if (gg == 2 && sp(j) == -1000.) //  more options for male selectivity
                  {
                    seldelta = sp(j - seltype(f, 4));
                  } //  use female delta for the male delta at this age
                  tempvec_a(a) = tempvec_a(a - 1) + seldelta; // cumulative log(selex)
                }
                int low_bin = int(value(sp(2)));
                int high_bin = int(value(sp(3)));
  #ifdef DO_ONCE
                if (do_once == 1) //  this should move to readcontrol!
                {
                  if (low_bin < 0)
                  {
                    low_bin = 0;
                    warnstream << "Selex pattern 44; value for low bin is less than 0, so set to 0 ";
                    write_message (ADJUST, 0);
                  }
                  if (high_bin > nages)
                  {
                    high_bin = nages;
                    warnstream << "Selex pattern 44; value for high bin is greater than " << nages << ", so set to " << nages;
                    write_message (ADJUST, 0);
                  }
                  if (high_bin < low_bin)
                    high_bin = low_bin;
                  if (low_bin > high_bin)
                    low_bin = high_bin;
                  sp(2) = low_bin;
                  sp(3) = high_bin;
                }
  #endif
                temp = mean(tempvec_a(low_bin, high_bin));
                sel_a(y, fs, gg)(first_age, last_age) = mfexp(tempvec_a(first_age, last_age) - temp);
                if (gg == 2)
                  sel_a(y, fs, gg)(first_age, last_age) *= mfexp(sp(4)); //  apply male ratio
                if (last_age < nages)
                {
                  sel_a(y, fs, gg)(last_age + 1, nages) = sel_a(y, fs, gg, last_age);
                }
                scaling_offset = 0;
                break;
              }

              case 45: //  like age selex 14 but with separate parameters for males and with revised controls
              {
                //  parameter value is logit(selectivity)
                //  peak selex in logit space is penalized towards value of 8.0, which gives selex near 1.0
                //  sp(1) is first age with non-zero selectivity; can be age 0
                //  seltype(f,4) is number of selectivity parameters beginning at age=first_age
                //  sp(2) is first age in mean for peak selex
                //  sp(3) is last age  in mean for peak selex
                //  sp(4) is male mean selex relative to female mean.
                //  -999 code means to keep the selex same as previous age
                // -1000 code is only for males and sets the male selex to be same as female selex
                //  gg is the index for sex, where 1=female, 2=male
                sel_a(y, fs, gg).initialize();
                tempvec_a.initialize(); //  null value for vector
                int first_age = int(value(sp(1)));
                int last_age = first_age + seltype(f, 4) - 1; //  because seltype(f,4) contains the number of ages with selex parameter
                if (gg == 1)
                {
                  scaling_offset = 2 + gender;
                }
                else
                {
                  scaling_offset = 2 + gender + seltype(f, 4);
                } // to get male vs female starting point for parameters
                j = scaling_offset;
                for (a = first_age; a <= last_age; a++)
                {
                  j++;
                  if (sp(j) > -999)
                  {
                    tempvec_a(a) = sp(j);
                  }
                  else if (gg == 2 && sp(j) == -1000.) //  set male selectivity raw value same as female
                  {
                    tempvec_a(a) = sp(j - seltype(f, 4));
                  } //  use female parameter for males
                  else //  so value is -999 so set to next younger age
                  {
                    tempvec_a(a) = tempvec_a(a - 1);
                  }
                }
                int low_bin = int(value(sp(2)));
                int high_bin = int(value(sp(3)));
  #ifdef DO_ONCE
                if (do_once == 1) //  this should move to readcontrol!
                {
                  if (low_bin < 0)
                  {
                    low_bin = 0;
                    warnstream << "Selex pattern 44; value for low bin is less than 0, so set to 0 ";
                    write_message (ADJUST, 0);
                  }
                  if (high_bin > nages)
                  {
                    high_bin = nages;
                    warnstream << "Selex pattern 44; value for high bin is greater than " << nages << ", so set to " << nages;
                    write_message (ADJUST, 0);
                  }
                  if (high_bin < low_bin)
                    high_bin = low_bin;
                  if (low_bin > high_bin)
                    low_bin = high_bin;
                }
  #endif
                temp = 8. - mean(tempvec_a(low_bin, high_bin));
                //              CrashPen+=temp*temp;
                sel_a(y, fs, gg)(first_age, last_age) = 1. / (1. + mfexp(-(tempvec_a(first_age, last_age) + temp)));
                if (gg == 2)
                {
                  sel_a(y, fs, gg)(first_age, last_age) *= mfexp(sp(4));
                } //  apply male ratio
                if (last_age < nages)
                {
                  sel_a(y, fs, gg)(last_age + 1, nages) = sel_a(y, fs, gg, last_age);
                }
                scaling_offset = 0;
                break;
              }

              //  SS_Label_Info_22.7.18 #age selectivity: double logistic with smooth transition
              case 18:
                // 1=peak, 2=init,  3=infl,  4=slope, 5=final, 6=infl2, 7=slope2
                {

  #ifdef DO_ONCE
                  if (do_once == 1)
                  {
                    warnstream << "Selectivity pattern 20 is recommended over pattern 18 because it has fewer parameters.";
                    write_message (SUGGEST, 0);
                  }
  #endif

                  sel_a(y, fs, 1).initialize();
                  t1 = 0. + (1. / (1. + mfexp(-sp(3)))) * (sp(1) - 0.); // INFL
                  t1min = 1. / (1. + mfexp(-sp(4) * (0. - t1))) * 0.9999; // asc value at minsize
                  t1max = 1. / (1. + mfexp(-sp(4) * (sp(1) - t1))) * 1.00001; // asc value at peak
                  t1power = log(0.5) / log((0.5 - t1min) / (t1max - t1min));

                  t2 = (sp(1) + sp(8)) + (1. / (1. + mfexp(-sp(6)))) * (r_ages(nages) - (sp(1) + sp(8))); // INFL
                  t2min = 1. / (1. + mfexp(-sp(7) * (sp(1) + sp(8) - t2))) * 0.9999; // asc value at peak+
                  t2max = 1. / (1. + mfexp(-sp(7) * (r_ages(nages) - t2))) * 1.00001; // asc value at maxage
                  t2power = log(0.5) / log((0.5 - t2min) / (t2max - t2min));
                  final = 1. / (1. + mfexp(-sp(5)));
                  for (a = Min_selage(fs); a <= nages; a++) //calculate the value over ages
                  {
                    sel_a(y, fs, 1, a) =
                        ((
                             (sp(2) + (1. - sp(2)) * pow(((1. / (1. + mfexp(-sp(4) * (r_ages(a) - t1))) - t1min) / (t1max - t1min)), t1power)) / (1.0 + mfexp(30. * (r_ages(a) - sp(1)))) // scale ascending side
                             +
                             1. / (1. + mfexp(-30. * (r_ages(a) - sp(1)))) // flattop, with scaling
                             ) /
                                (1. + mfexp(30. * (r_ages(a) - (sp(1) + sp(8))))) // scale combo of ascending and flattop
                            +
                            (1. + (final - 1.) * pow(fabs(((1. / (1. + mfexp(-sp(7) * (r_ages(a) - t2))) - t2min) / (t2max - t2min))), t2power)) / (1. + mfexp(-30. * (r_ages(a) - (sp(1) + sp(8))))) // scale descending
                            );
                  } // end age loop
                  break;
                } // end double logistic with smooth transition

              //  SS_Label_Info_22.7.19 #age selectivity: old double logistic
              case 19:
              {
                k1 = int(value(sp(5)));
                sel_a(y, fs, 1)(k1, nages) = elem_prod((1. / (1. + mfexp(-sp(2) * (r_ages(k1, nages) - sp(1))))),
                    (1. - 1. / (1. + mfexp(-sp(4) * (r_ages(k1, nages) - (sp(1) * sp(6) + sp(3)))))));
                sel_a(y, fs, 1)(k1, nages) /= max(sel_a(y, fs, 1)(k1, nages));
                if (k1 > 0)
                  sel_a(y, fs, 1)(0, k1 - 1) = 1.0e-6;
                break;
              }

              //  SS_Label_Info_22.7.20 #age selectivity: double normal with plateau
              case 20: // *******double_normal_plateau
              {
                if (seltype(f, 3) < 3 || (gg == 1 && seltype(f, 3) == 3) || (gg == 2 && seltype(f, 3) == 4))
                {
                  peak = sp(1);
                  upselex = mfexp(sp(3));
                  downselex = mfexp(sp(4));
                  final = sp(6);
                  Apical_Selex = 1.0;
                }
                else
                { // offset male parameters if seltype(f,3)==3
                  peak = sp(1) + sp(Maleselparm(f));
                  upselex = mfexp(sp(3) + sp(Maleselparm(f) + 1));
                  downselex = mfexp(sp(4) + sp(Maleselparm(f) + 2));
                  if (sp(6) > -999.)
                    final = sp(6) + sp(Maleselparm(f) + 3);
                  Apical_Selex = sp(Maleselparm(f) + 4);
                }
                if (sp(5) < -1000.)
                {
                  j = -1001 - int(value(sp(5))); // selex is nil thru age j, so set sp(5) equal to first age with selex (e.g. -1002 to start selex at age 2)
                  sel_a(y, fs, gg)(0, j) = 1.0e-06;
                }
                else
                {
                  j = Min_selage(fs) - 1; // start selex at Min_selage
                  if (sp(5) > -999)
                  {
                    point1 = 1. / (1. + mfexp(-sp(5)));
                    t1min = mfexp(-(square(0. - peak) / upselex)); // fxn at first bin
                  }
                }
                if (sp(6) < -1000.)
                {
                  j2 = -1000 - int(value(sp(6))); // selex is constant beyond this age, so set sp(6) equal to last age with estimated selex
                  //  (e.g. -1008 to be constant beyond age 8)
                }
                else
                {
                  j2 = nages;
                }

                peak2 = peak + 1. + (0.99 * r_ages(j2) - peak - 1.) / (1. + mfexp(-sp(2))); // note, this uses age=j2 as constraint on range of "peak2"
                //              peak2=peak+.1+(0.99*r_ages(j2)-peak-.1)/(1.+mfexp(-sp(2)));        // note, this uses age=j2 as constraint on range of "peak2"
                if (sp(6) > -999)
                {
                  point2 = 1. / (1. + mfexp(-final));
                  t2min = mfexp(-(square(r_ages(nages) - peak2) / downselex)); // fxn at last bin
                }

                for (a = j + 1; a <= j2; a++)
                {
                  t1 = r_ages(a) - peak;
                  t2 = r_ages(a) - peak2;
                  join1 = 1. / (1. + mfexp(-(20. / (1. + fabs(t1))) * t1));
                  join2 = 1. / (1. + mfexp(-(20. / (1. + fabs(t2))) * t2));
                  if (sp(5) > -999)
                  {
                    asc = point1 + (Apical_Selex - point1) * (mfexp(-square(t1) / upselex) - t1min) / (1. - t1min);
                  }
                  else
                  {
                    asc = Apical_Selex * mfexp(-square(t1) / upselex);
                  }
                  if (sp(6) > -999)
                  {
                    dsc = Apical_Selex + (point2 - Apical_Selex) * (mfexp(-square(t2) / downselex) - 1.) / (t2min - 1.);
                  }
                  else
                  {
                    dsc = Apical_Selex * mfexp(-square(t2) / downselex);
                  }
                  sel_a(y, fs, gg, a) = asc * (1. - join1) + join1 * (Apical_Selex * (1. - join2) + dsc * join2);
                }
                if (j2 < nages)
                {
                  sel_a(y, fs, gg)(j2 + 1, nages) = sel_a(y, fs, gg, j2);
                }
                break;
              }

              //  SS_Label_Info_22.7.26 #age selectivity: exponential logistic
              case 26:
              {
                //              peak = r_ages(0) + sp(2)*(r_ages(nages)-r_ages(0));
                sel_a(y, fs, 1).initialize();
                peak = sp(2) * r_ages(nages);
                for (a = Min_selage(fs); a <= nages; a++)
                {
                  sel_a(y, fs, 1, a) = mfexp(sp(3) * sp(1) * (peak - r_ages(a))) / (1.0 - sp(3) * (1.0 - mfexp(sp(1) * (peak - r_ages(a)))));
                }
                break;
              }

              //  SS_Label_Info_22.7.27 #age selectivity: cubic spline
              // #42 cubic spline scaled by average of values at low age through high age
              case 42:
                scaling_offset = 2;
                [[fallthrough]];
              case 27:
              {
                // define vectors which form the basis for cubic spline selectivity
                // IMPORTANT: these vectors might need to be expanded to fit values for multiple fleets
                dvector splineX(1, 200);
                dvar_vector splineY(1, 200);
                splineX.initialize();
                splineY.initialize();
                sel_a(y, fs, 1).initialize();
                k = seltype(f, 4); // n points to include in cubic spline
                for (i = 1; i <= k; i++)
                {
                  splineX(i) = value(sp(i + 3 + scaling_offset)); // "value" required to avoid error, but values should be always fixed anyway
                  splineY(i) = sp(i + 3 + k + scaling_offset);
                }
                // calculate last age before first knot
                z = 0;
                while (r_ages(z) < splineX(1))
                {
                  z++;
                }
                j1 = z - 1; //  last age before first knot

                // calculate first age beyond last knot
                z = nages;
                while (r_ages(z) > splineX(k))
                {
                  z--;
                }
                j2 = z + 1; //  first age beyond last knot

                vcubic_spline_function splinefn = vcubic_spline_function(splineX(1, k), splineY(1, k), sp(2 + scaling_offset), sp(3 + scaling_offset));
                tempvec_a = splinefn(r_ages); // interpolate selectivity at each age
                if (scaling_offset == 0)
                {
                  temp = max(tempvec_a(0, j2));
                  // if spline code on first parameter line is 10, 11, or 12, then
                  // scale only based on interval between knots (unless first knot is at age 0)
                  if ((sp(1) >= 10) & (j1 >= 0))
                  {
                    temp = max(tempvec_a(j1, j2));
                  }
                }
                else
                {
                  int low_bin = int(value(sp(1)));
                  int high_bin = int(value(sp(2)));
                  if (low_bin < Min_selage(fs))
                  {
                    low_bin = Min_selage(fs);
                    warnstream << "Selex pattern 42; value for low bin is less than min_selage, so set to " << Min_selage(fs);
                    write_message (ADJUST, 0);
                  }
                  if (high_bin > nages)
                  {
                    high_bin = nages;
                    warnstream << "Selex pattern 42; value for high bin is greater than " << nages << ", so set to " << nages;
                    write_message (ADJUST, 0);
                  }
                  if (high_bin < low_bin)
                    high_bin = low_bin;
                  if (low_bin > high_bin)
                    low_bin = high_bin;
                  sp(1) = low_bin;
                  sp(2) = high_bin;
                  temp = mean(tempvec_a(low_bin, high_bin));
                }
                tempvec_a -= temp; // rescale to get max of 0.0
                tempvec_a(j2 + 1, nages) = tempvec_a(j2); //  set constant above last knot
                sel_a(y, fs, 1)(Min_selage(fs), nages) = mfexp(tempvec_a)(Min_selage(fs), nages);
                // if spline code on third parameter line is 10, 11, or 12, then
                // set to zero before the first knot (unless first knot is at age 0)
                if ((sp(1 + scaling_offset) >= 10) & (j1 >= 0))
                {
                  sel_a(y, fs, 1)(0, j1) = 0; //  set to 0 before first knot (unless first knot is at 0)
                }
                scaling_offset = 0; // reset scaling offset
                break;
              } // end age-based cubic spline (type 42 or 27)

              default: //  seltype not found.  But really need this check earlier when the N selex parameters are being processed.
              {
                warnstream << "Age selectivity option " << seltype(f, 1) << " not valid.";
                write_message (FATAL, 0); // EXIT!
                break;
              }

            } // end last age selex pattern
          } // end direct calc of selex from parameters

          //  SS_Label_Info_22.8 #age selectivity: one sex selex as offset from other sex
          if (gg == 2) // males exist
          {
            if (seltype(f, 3) == 1 || seltype(f, 3) == 2) // do gender selex as offset
            {
              k = Maleselparm(f); // first male parm
              temp = sp(k) - 0.00001;
              temp1 = 1.;
              switch (seltype(f, 3))
              {
                case 1:
                { // do males relative to females
                  for (a = Min_selage(fs); a <= nages; a++) //
                  {
                    if (r_ages(a) <= temp)
                    {
                      sel_a(y, fs, 2, a) = sel_a(y, fs, 1, a) * mfexp(sp(k + 1) + (r_ages(a) - 0.) / (temp - 0.) * (sp(k + 2) - sp(k + 1)));
                    }
                    else
                    {
                      sel_a(y, fs, 2, a) = sel_a(y, fs, 1, a) * mfexp(sp(k + 2) + (r_ages(a) - temp) / (double(nages) - temp) * (sp(k + 3) - sp(k + 2)));
                    }
                    //              if(sel_a(y,fs,2,a)>temp1) temp1=sel_a(y,fs,2,a);
                  }
                  tempvec_a(1) = max(sel_a(y, fs, 1));
                  tempvec_a(2) = max(sel_a(y, fs, 2));
                  temp1 = max(tempvec_a(1, 2));
                  sel_a(y, fs) /= temp1;
                  break;
                }
                case 2:
                { //  do females relative to males
                  sel_a(y, fs, 2) = sel_a(y, fs, 1);
                  for (a = Min_selage(fs); a <= nages; a++) //
                  {
                    if (r_ages(a) <= temp)
                    {
                      sel_a(y, fs, 1, a) = sel_a(y, fs, 2, a) * mfexp(sp(k + 1) + (r_ages(a) - 0.) / (temp - 0.) * (sp(k + 2) - sp(k + 1)));
                    }
                    else
                    {
                      sel_a(y, fs, 1, a) = sel_a(y, fs, 2, a) * mfexp(sp(k + 2) + (r_ages(a) - temp) / (double(nages) - temp) * (sp(k + 3) - sp(k + 2)));
                    }
                    //              if(sel_a(y,fs,1,a)>temp1) temp1=sel_a(y,fs,1,a);
                  }
                  //            sel_a(y,fs)/=temp1;
                  tempvec_a(1) = max(sel_a(y, fs, 1));
                  tempvec_a(2) = max(sel_a(y, fs, 2));
                  temp1 = max(tempvec_a(1, 2));
                  sel_a(y, fs) /= temp1;

                  break;
                }
              }
            }
            else if (seltype(f, 3) != 3 && seltype(f, 3) != 4 && seltype(f, 1) != 15 && seltype(f, 1) != 44 && seltype(f, 1) != 45)
            {
              sel_a(y, fs, 2) = sel_a(y, fs, 1);
            } // set males = females
            if (docheckup == 1)
              echoinput << " sel-age " << sel_a(y, fs) << endl;
          }
        } //  end gender loop

        //  apply 2D_AR adjustment to sex-specific age selectivity
        //  TwoD_AR_def: read:  1-fleet, 2-ymin, 3-ymax, 4-amin, 5-amax, 6-sigma_amax, 7-use_rho, 8-age/len, 9-dev_phase; 10-before_yrs, 11=after_yrs,
        //  calc quantities:  12-N_parm_dev, 13-selparm_location

        if (TwoD_AR_use(f) > 0)
        {
          j = TwoD_AR_use(f); //  get index for this fleet's effect
          if (TwoD_AR_def[j](8) == 2) //  age (2) vs length (1) flag
          {
            z = TwoD_AR_def[j](12); // index of dev vector used
            if (docheckup == 1)
              echoinput << "age-based 2DAR for fleet: " << f << " 2DAR: " << j << " using dev_vector: " << z << endl;

            if (y == styr && (TwoD_AR_before(j) == 3 || TwoD_AR_after(j) == 3)) //  if needed, calculate average dev for each age over the range of years
            {
              TwoD_AR_ave(j).initialize();
              for (int yyy = TwoD_AR_ymin(j); yyy <= TwoD_AR_ymax(j); yyy++)
              {
                k = (yyy - TwoD_AR_ymin(j)) * (TwoD_AR_amax(j) - TwoD_AR_amin(j) + 1); //  index of 1st dev in vector created from year and age index
                for (int ll = TwoD_AR_amin(j); ll <= TwoD_AR_amax(j); ll++)
                {
                  k++;
                  TwoD_AR_ave(j, ll) += parm_dev(z, k); //  sum devs for each age
                }
              }
              TwoD_AR_ave(j) /= (TwoD_AR_ymax(j) - TwoD_AR_ymin(j) + 1.0);
  #ifdef DO_ONCE
              if (do_once == 1)
                echoinput << "mean 2D AR dev for fleet: " << f << " means: " << TwoD_AR_ave(j) << endl;
  #endif
            }

            if (y < TwoD_AR_ymin(j)) //  early years
            {
              if (TwoD_AR_before(j) == 0) //  apply no devs
              {
                k = -2;
              }
              else if (TwoD_AR_before(j) == 1) //  use first year devs
              {
                //          k=(TwoD_AR_ymin(j)-TwoD_AR_ymin(j))*(TwoD_AR_amax(j)-TwoD_AR_amin(j)+1);  //  index of 1st dev in vector created from year and age index
                k = 0;
              }
              else if (TwoD_AR_before(j) == 3) //  use mean age-specific devs
              {
                k = -1;
              }
            }
            else if (y <= TwoD_AR_ymax(j)) //  in year range for annual devs
            {
              k = (y - TwoD_AR_ymin(j)) * (TwoD_AR_amax(j) - TwoD_AR_amin(j) + 1); //  index of 1st dev in vector created from year and age index
            }
            else //  later years
            {
              if (TwoD_AR_after(j) == 0) //  apply no devs
              {
                k = -2;
              }
              else if (TwoD_AR_after(j) == 1) //  use last year devs
              {
                k = (TwoD_AR_ymax(j) - TwoD_AR_ymin(j)) * (TwoD_AR_amax(j) - TwoD_AR_amin(j) + 1);
              } //  index of 1st dev in vector created from year and age index
              else if (TwoD_AR_after(j) == 3) //  use mean length-specific devs
              {
                k = -1;
              }
            }

            if (docheckup == 1)
              echoinput << "K value for first dev to use: " << k << endl;
            if (k > -2)
            {
              a1 = TwoD_AR_def[j](13) - 1; //  parameter number-1  for sigmasel
              dvariable sigmasel;
              for (a = TwoD_AR_amin(j); a <= TwoD_AR_amax(j); a++) // loop lengths, using "a" as index
              {
                if (a <= TwoD_AR_def[j](6)) // so get sigmasel for this length bin
                {
                  a1++;
                  sigmasel = selparm(a1);
                }
                if (k >= 0)
                {
                  k++;
//                  if (docheckup == 1)
                  temp = sel_a(y, fs, 1, a);
                  sel_a(y, fs, 1, a) *= mfexp(sigmasel * parm_dev(z, k));
                  if (gender == 2)
                    sel_a(y, fs, 2, a) *= mfexp(sigmasel * parm_dev(z, k));
                }
                else //  use mean devs
                {
                  sel_a(y, fs, 1, a) *= mfexp(sigmasel * TwoD_AR_ave(j, a));
                  if (gender == 2)
                    sel_a(y, fs, 2, a) *= mfexp(sigmasel * TwoD_AR_ave(j, a));
                }
              }
            }
            if (docheckup == 1)
              echoinput << "age selex after 2D_AR" << endl
                        << sel_a(y, fs) << endl;
          }
        }

        { //  calculation of age retention and discard mortality here
          //  SS_Label_Info_22.5.1 #Calculate age-specific retention and discmort
          // discmort_a is the fraction of discarded fish that die
          //  discmort2_a is fraction that die from being retained or are dead discard
          //   = elem_prod(sel_a,(retain_a + (1-retain_a)*discmort_a)) */
          if (seltype(f, 2) == 0) //  no discard, all retained
          {
            retain_a(y, fs) = 1.0;
            sel_a_r(y, fs) = sel_a(y, fs);
            discmort_a(y, fs) = 1.0;
            discmort2_a(y, fs) = sel_a(y, fs);
          }
          else if (seltype(f, 2) == 3) // none retained; all dead
          {
            retain_a(y, fs) = 0.0;
            discmort_a(y, fs) = 1.0;
            sel_a_r(y, fs) = 0.0;
            discmort2_a(y, fs) = sel_a(y, fs);
          }
          else
          {
            if (seltype(f, 2) < 0) // mirror
            {
              k = -seltype(f, 2);
              retain_a(y, fs) = retain_a(y, k);
              discmort_a(y, fs) = discmort_a(y, k);
              if (seltype(k, 2) == 1)
              {
                discmort2_a(y, fs) = sel_a(y, fs); //  all selected fish are dead;  this statement does both genders implicitly
              }
              else
              {
                discmort2_a(y, fs, 1) = elem_prod(sel_a(y, fs, 1), retain_a(y, fs, 1) + elem_prod((1. - retain_a(y, fs, 1)), discmort_a(y, fs, 1)));
                if (gender == 2)
                  discmort2_a(y, fs, 2) = elem_prod(sel_a(y, fs, 2), retain_a(y, fs, 2) + elem_prod((1. - retain_a(y, fs, 2)), discmort_a(y, fs, 2)));
              }
            }
            else
            {
              k = RetainParm(fs);
              if (sp(k + 2) == -999.)
              {
                temp1 = 0.0;
              }
              else if (sp(k + 2) == 999.)
              {
                temp1 = 1.0;
              }
              else
              {
                temp1 = 1.0 / (1.0 + mfexp(-sp(k + 2)));
              }

              //          temp=1.-sp(k+2);
              //          temp1=1.-posfun(temp,0.0,CrashPen);

              retain_a(y, fs, 1) = temp1 / (1. + mfexp(-(r_ages - (sp(k))) / sp(k + 1)));
              if (seltype(f, 2) == 4)
              {
                // allow for dome-shaped retention in 3.30 only
                retain_a(y, fs, 1) = elem_prod(retain_a(y, fs, 1), (1. - (1. / (1. + mfexp(-(r_ages - (sp(k + 4))) / sp(k + 5))))));
              }
              if (gender == 2)
              {
                // males
                retain_a(y, fs, 2) = temp1 / (1. + mfexp(-(r_ages - (sp(k) + sp(k + 3))) / sp(k + 1)));
                if (seltype(f, 2) == 4)
                {
                  retain_a(y, fs, 2) = elem_prod(retain_a(y, fs, 2), (1. - (1. / (1. + mfexp(-(r_ages - (sp(k + 4) + sp(k + 6))) / sp(k + 5))))));
                }
              }
              if (docheckup == 1 && y == styr)
              {
                echoinput << "age_retention parms: inflec: " << sp(k) << " width: " << sp(k + 1) << " male_offset: " << sp(k + 3) << " asymptote: " << temp1;
                if (seltype(f, 2) == 4)
                {
                  echoinput << " " << sp(k + 4) << " " << sp(k + 5) << " " << sp(k + 6);
                }
                echoinput << endl
                          << "ages " << r_ages << endl;
                echoinput << "retention " << retain_a(y, fs) << endl;
              }

              if (seltype(f, 2) == 1) // all discards are dead
              {
                discmort_a(y, fs) = 1.0;
                discmort2_a(y, fs) = sel_a(y, fs); //  all selected fish are dead;
              }
              else
              {
                k += N_ret_parm(seltype(f, 2)); // first discard mortality parm
                temp = 1. - sp(k + 2);
                temp1 = posfun(temp, 0.0, CrashPen);
                discmort_a(y, fs, 1) = (1. - temp1 / (1 + mfexp(-(r_ages - (sp(k))) / sp(k + 1))));
                if (gender == 2)
                {
                  // males
                  discmort_a(y, fs, 2) = (1. - temp1 / (1 + mfexp(-(r_ages - (sp(k) + sp(k + 3))) / sp(k + 1))));
                }
                if (docheckup == 1 && y == styr)
                  echoinput << "discmort " << discmort_a(y, fs) << endl;
                discmort2_a(y, fs, 1) = elem_prod(sel_a(y, fs, 1), retain_a(y, fs, 1) + elem_prod((1. - retain_a(y, fs, 1)), discmort_a(y, fs, 1)));
                if (gender == 2)
                  discmort2_a(y, fs, 2) = elem_prod(sel_a(y, fs, 2), retain_a(y, fs, 2) + elem_prod((1. - retain_a(y, fs, 2)), discmort_a(y, fs, 2)));
              }
            }

            sel_a_r(y, fs, 1) = elem_prod(sel_a(y, fs, 1), retain_a(y, fs, 1));
            if (gender == 2)
            {
              sel_a_r(y, fs, 2) = elem_prod(sel_a(y, fs, 2), retain_a(y, fs, 2));
            }
          }
          if (docheckup == 1 && y == styr)
            echoinput << "sel-age-ret " << sel_a_r(y, fs) << endl;
          if (docheckup == 1 && y == styr)
            echoinput << " dead " << discmort2_a(y, fs) << endl;
          //  end age discard
        }
      } // end calc of age selex
    } //  end recalc of selex

    else
    //  SS_Label_Info_22.9 #Carryover selex from last year because not time-varying
    {
      if (f <= Nfleet)
      {
        sel_l(y, f) = sel_l(y - 1, f); // this does both genders
        sel_l_r(y, f) = sel_l_r(y - 1, f);
        retain(y, f) = retain(y - 1, f);
        discmort(y, f) = discmort(y - 1, f);
        discmort2(y, f) = discmort2(y - 1, f);
      }
      else // age
      {
        sel_a(y, fs) = sel_a(y - 1, fs); // does both genders
        retain_a(y, fs) = retain_a(y - 1, fs);
      }
    }

    Ip += N_selparmvec(f);

  } //  end fleet loop for selectivity
  } //  end selectivity FUNCTION

FUNCTION void Make_FishSelex()
  {
  //  Similar to Make_Fecundity, this function does the dot product of length distribution with length selectivity and retention vectors
  //  to calculate equivalent mean quantities at age for each platoon (g)
  //********************************************************************
  /*  SS_Label_FUNCTION 32 Make_FishSelex */
  //  where:
  //  4darray sel_bio(1,nseas,1,gmorph,1,Nfleet,0,nages);  // selected * wt
  //  4darray sel_ret_bio(1,nseas,1,gmorph,1,Nfleet,0,nages);  // selected * retained * wt
  //  4darray sel_num(1,nseas,1,gmorph,1,Nfleet,0,nages);  // selected numbers
  //  4darray sel_ret_num(1,nseas,1,gmorph,1,Nfleet,0,nages);  // selected * retained numbers
  //  4darray sel_dead_num(1,nseas,1,gmorph,1,Nfleet,0,nages);  // sel * (retain + (1-retain)*discmort)
  //  4darray sel_dead_bio(1,nseas,1,gmorph,1,Nfleet,0,nages);  // sel * (retain + (1-retain)*discmort) * wt

  ALK_idx = (s - 1) * N_subseas + mid_subseas; //for midseason
  dvar_matrix ALK_w = ALK(ALK_idx, g); //  shallow copy
  dvar_vector sel_l_r_w(1, nlength); //  temp vector for retained contribution to weight-at-age
  dvar_vector disc_wt(1, nlength);
  int yf;
  int tz;
  gg = sx(g);
  //    if(y>endyr) {yz=endyr; } else {yz=y;}  //  not used
  if (y > endyr + 1 && Fcast_timevary_Selex == 1)  // do means
  {
    yf = endyr + 1;
  }
  else
  {
    yf = y;
  } //  yf stores in endyr+1 the average selex from a range of years if Fcast_timevary_Selex==1
  tz = styr + (y - styr) * nseas + s - 1; // can use y, not yf, because Wt_Age_t values are read in and can extend into forecast
  for (f = 1; f <= Nfleet; f++)
  {
    if (timevary_sel(yf, f) > 0 || timevary_sel(yf, f + Nfleet) > 0 || WTage_rd == 1 || save_for_report > 0)
    {
      makefishsel_yr = yf;
      if (WTage_rd == 1 || (seltype(f, 1) == 0 && seltype(f, 2) == 0)) //  empirical wt-at-age or no size-selectivity; so no size-based calculations
      {
        if (WTage_rd == 1)
        {
          sel_bio(s, f, g) = elem_prod(sel_a(yf, f, gg), Wt_Age_t(tz, f, g)); // selected wt-at-age
        }
        else
        {
          sel_bio(s, f, g) = elem_prod(sel_a(yf, f, gg), Wt_Age_mid(s, g)); // selected wt-at-age
          Wt_Age_t(tz, f, g) = Wt_Age_mid(s, g);
        }
        sel_num(s, f, g) = sel_a(yf, f, gg); //  selected numbers
        int j = seltype(f + Nfleet, 2);
        int k = j;
        if (j < 0)  //  invokes mirror
        {
          j = -j;  //  fleet number being mirrored for retention
          k = seltype(j + Nfleet, 2);  //  discard approach for fleet j
          //  note that retain_a and discmort2_a have already been mirrored earlier in this fxn
        }
        switch (k) //  age-retention function
        {
          case 0:  // no discarding, so just copy the selected quantities
          {
            sel_ret_bio(s, f, g) = sel_bio(s, f, g); //  retained wt-at-age
            sel_ret_num(s, f, g) = sel_num(s, f, g); //  retained numbers
            sel_dead_bio(s, f, g) = sel_bio(s, f, g); //  dead wt
            sel_dead_num(s, f, g) = sel_num(s, f, g); //  dead numbers
            break;
          }
          case 1:  // age-based retention function is used; all discarded fish assumed dead and have same bodywt as retained fish
          {
            sel_ret_bio(s, f, g) = elem_prod(sel_bio(s, f, g), retain_a(y, f, gg)); //  retained wt-at-age
            sel_ret_num(s, f, g) = elem_prod(sel_num(s, f, g), retain_a(y, f, gg)); //  retained numbers
            sel_dead_bio(s, f, g) = sel_ret_bio(s, f, g); //  dead wt
            sel_dead_num(s, f, g) = sel_ret_num(s, f, g); //  dead numbers
            break;
          }
          case 2:  // age-based retention and discard mortality, same body wt as retained fish
          {
            // details of retention and mortality already taken into account with calc of discmort2_a
            sel_ret_bio(s, f, g) = elem_prod(sel_bio(s, f, g), retain_a(y, f, gg)); //  retained wt-at-age
            sel_ret_num(s, f, g) = elem_prod(sel_num(s, f, g), retain_a(y, f, gg)); //  retained numbers
            sel_dead_bio(s, f, g) = elem_prod(Wt_Age_t(tz, f, g), discmort2_a(y, f, gg)); //  dead wt
            sel_dead_num(s, f, g) = discmort2_a(y, f, gg); //  dead numbers
//            if (y == styr) warning << f << " sel_ret " << sel_ret_bio(s, f, g) << endl << " sel_dead " << sel_dead_bio(s, f, g) << endl;
            break;
          }
          case 3: //  all selected fish are dead; use this for a discard only fleet
          {
            sel_ret_bio(s, f, g) = 0.0; //  retained wt-at-age
            sel_ret_num(s, f, g) = 0.0; //  retained numbers
            sel_dead_bio(s, f, g) = sel_bio(s, f, g); //  dead wt
            sel_dead_num(s, f, g) = sel_num(s, f, g); //  dead numbers
            break;
          }
        }
        if (docheckup == 1 && y == styr && do_once == 1)
        {
          echoinput << f << " sel_ret_bio " << sel_ret_bio(s, f, g) << endl
                    << f << "retain_a " << retain_a(y, f, gg) << endl
                    << f << " sel_dead_bio " << sel_dead_bio(s, f, g) << endl;
        }
      }

      else //  size_selectivity and possible size retention
      {
        tempvec_l = elem_prod(sel_l(yf, f, gg), wt_len(s, GP(g))); //  combine size selex and wt_at_len to get selected contribution to weight-at-age
        if (seltype(f, 2) != 0)
          sel_l_r_w = elem_prod(sel_l_r(yf, f, gg), wt_len(s, GP(g)));
        if (seltype(f, 2) >= 2)
          disc_wt = elem_prod(discmort2(yf, f, gg), wt_len(s, GP(g)));
        for (a = 0; a <= nages; a++)
        {
          int llo = 1;
          int lhi = nlength;
          sel_bio(s, f, g, a) = sel_a(yf, f, gg, a) * (ALK_w(a)(llo, lhi) * tempvec_l(llo, lhi));
          sel_num(s, f, g, a) = sel_a(yf, f, gg, a) * (ALK_w(a)(llo, lhi) * sel_l(yf, f, gg)(llo, lhi));
          Wt_Age_t(tz, f, g, a) = (ALK_w(a)(llo, lhi) * tempvec_l(llo, lhi)) / (ALK_w(a)(llo, lhi) * sel_l(yf, f, gg)(llo, lhi));
          if (seltype(f, 2) != 0) //  size discard, so need retention function
          {
            sel_ret_bio(s, f, g, a) = sel_a(yf, f, gg, a) * (ALK_w(a)(llo, lhi) * sel_l_r_w(llo, lhi));
            sel_ret_num(s, f, g, a) = sel_a(yf, f, gg, a) * (ALK_w(a)(llo, lhi) * sel_l_r(yf, f, gg)(llo, lhi));
          }
          else if (a == nages)
          {
            sel_ret_bio(s, f, g) = sel_bio(s, f, g);
            sel_ret_num(s, f, g) = sel_num(s, f, g);
          }

          if (seltype(f, 2) >= 2) //  calc discard mortality
          {
            sel_dead_num(s, f, g, a) = sel_a(yf, f, gg, a) * (ALK_w(a)(llo, lhi) * discmort2(yf, f, gg)(llo, lhi)); //  selected dead by numbers
            sel_dead_bio(s, f, g, a) = sel_a(yf, f, gg, a) * (ALK_w(a)(llo, lhi) * disc_wt(llo, lhi)); // selected dead by weight
          }
          else if (a == nages)
          {
            sel_dead_bio(s, f, g) = sel_bio(s, f, g);
            sel_dead_num(s, f, g) = sel_num(s, f, g);
          }

        } //  end age loop
      }
      if (write_bodywt > 0 && ishadow(GP2(g)) == 0)
      {
        bodywtout << y << " " << s << " " << gg << " " << GP4(g) << " " << Bseas(g)
                  << " " << f << " " << Wt_Age_t(tz, f, g) << " #wt_flt_" << f << endl;
      }
    } // end need to do it
    save_sel_num(t, f, g) = sel_num(s, f, g); //  save sel_num in save_fecundity array for output

  } // end fleet loop for mortality, retention
  } // end Make_FishSelex
// SS_Label_file  #12. **SS_popdyn.tpl**
// SS_Label_file  # * <u>setup_recdevs()</u>
// SS_Label_file  # * <u>get_initial_conditions()</u> // does virgin and initial year by calling <u>SSBpR_Calc()</u> with F=0, then F=init_F
// SS_Label_file  # * <u>get_time_series()</u>  //  loops the years, calling biology, selectivity and spawn-recr functions as needed
// SS_Label_file  # * <u>SSBpR_Calc()</u>  // does per-recruit calculations and returns SSB/R and Y/R
// SS_Label_file  #

FUNCTION void setup_recdevs()
  {
  //  SS_Label_Info_7.1 #Set up recruitment bias_adjustment vector
  sigmaR = SRparm(N_SRparm(SR_fxn) + 1);
  two_sigmaRsq = 2.0 * sigmaR * sigmaR;
  half_sigmaRsq = 0.5 * sigmaR * sigmaR;

  biasadj.initialize();

  if (SR_fxn == 4 || do_recdev == 0)
  {
    // keep all at 0.0 if not using SR fxn
  }
  //    else if (mceval_phase() || initial_params::mc_phase==1 || recdev_adj(5)<0.0)
  else if (mceval_phase() || initial_params::mc_phase == 1)
  {
    //      biasadj=1.0;
    biasadj = recdev_doit; //  sets to 1.0 for the years or initial ages with estimated recruitments
  }
  else
  {
    if (recdev_do_early > 0 && recdev_options(2) >= 0) //  do logic on basis of recdev_options(2), which is read, not recdev_PH which can be reset to a neg. value
    {
      for (i = recdev_early_start; i <= recdev_early_end; i++)
      {
        if (i >= styr - nages)
          biasadj(i) = biasadj_full(i);
      }
    }
    if (do_recdev > 0 && recdev_PH_rd >= 0)
    {
      for (i = recdev_start; i <= recdev_end; i++)
      {
        if (i >= styr - nages)
          biasadj(i) = biasadj_full(i);
      }
    }
    if (Do_Forecast > 0 && recdev_options(3) >= 0)
    {
      for (i = recdev_end + 1; i <= YrMax; i++)
      {
        biasadj(i) = biasadj_full(i);
      }
    }
    if (recdev_read > 0)
    {
      for (j = 1; j <= recdev_read; j++)
      {
        y = recdev_input(j, 1);
        if (y >= recdev_first && y <= YrMax)
          biasadj(y) = biasadj_full(y);
      }
    }
  }
  sd_offset_rec = sum(biasadj) * sd_offset;
  //  SS_Label_Info_7.2 #Copy recdev parm vectors into full time series vector
  if (recdev_do_early > 0)
  {
    recdev(recdev_early_start, recdev_early_end) = recdev_early(recdev_early_start, recdev_early_end);
  }
  if (do_recdev == 1)
  {
    recdev(recdev_start, recdev_end) = recdev1(recdev_start, recdev_end);
  }
  else if (do_recdev >= 2)
  {
    recdev(recdev_start, recdev_end) = recdev2(recdev_start, recdev_end);
  }
  if (Do_Forecast > 0 && do_recdev > 0)
    recdev(recdev_end + 1, YrMax) = Fcast_recruitments(recdev_end + 1, YrMax); // only needed here for reporting
  } //  end setup for recdevs

FUNCTION void get_initial_conditions()
  {
  //*********************************************************************
  /*  SS_Label_Function_23 #get_initial_conditions */
  natage.initialize();
  catch_fleet.initialize();
  annual_catch.initialize();
  annual_F.initialize();
  Recr.initialize();
  save_gparm = 0;  //  index for saving time-varying changes to biology quantities

  if (SzFreq_Nmeth > 0)
    SzFreq_exp.initialize();

  //  SS_Label_Info_23.1 #call biology and selectivity functions for the initial year
  //  SS_Label_Info_23.1.1 #These rate are calculated once in PRELIMINARY_CALCS_SECTION, so only recalculate if active according to MG_active
  y = styr;
  yz = styr;
  t_base = styr - 1;
  recr_dist_unf.initialize();

  //  Create time varying parameters
  //  following call is to routine that does this for all timevary parameters
  //  that are then copied over to replace the base parameter for MG, SRR, Q, Selex, or Tag as needed
  make_timevaryparm(); //  this fills array parm_timevary for all years;   densitydependence must be done year-by-year later
  if (MG_active(0) > 0 || save_for_report > 0)
  {
    get_MGsetup(y);
  }
  #ifdef DO_ONCE
  if (do_once == 1)
    echoinput << " MGsetup OK " << endl;
  #endif
  if (MG_active(2) > 0)
    get_growth1(); // seasonal effects and CV
  #ifdef DO_ONCE
  if (do_once == 1)
    echoinput << " growth1 OK" << endl;
  #endif
  if (MG_active(2) > 0 || do_once == 1)
  {
    ALK_subseas_update = 1; //  to indicate that all ALKs need calculation
    get_growth2(y);
    t = styr - 1;
    for (s = 1; s <= nseas; s++)
    {
      t++;
      for (subseas = 1; subseas <= N_subseas; subseas++) //  do all subseasons in first year
      {
        get_growth3(y, t, s, subseas); //  in case needed for Lorenzen M
        Make_AgeLength_Key(s, subseas);
      }
    }

    //  SS_Label_Info_16.2.4.3  #propagate Ave_Size from early years forward until first year that has time-vary growth
    k = styr + 1;
    do
    {
      for (s = 1; s <= nseas; s++)
      {
        t = styr + (k - styr) * nseas + s - 1;
        Ave_Size(t, 1) = Ave_Size(t - nseas, 1);
      } // end season loop
      k++;
    } while (timevary_MG(k, 2) == 0 && k <= YrMax);
    if (k <= YrMax)
    {
      t = styr + (k - styr) * nseas;
      Ave_Size(t, 1) = Ave_Size(t - nseas, 1); // prep for time-vary next yr
    }
  }
  if (MG_active(3) > 0)
    get_wtlen(); // stores values for all seasons
  get_mat_fec(); //  does just spawn season and subseason using ALK calculated just above
  if (Hermaphro_Option != 0)
    get_Hermaphro();

  if (do_once>0 || MG_active(1) > 0)
  {
    get_natmort();  // gets base M (e.g. M1) by season and stores it in natM(t,0).  Later, pred_M2 is added by area
    for (s = 1; s <= nseas; s++)
    {
      natM(t_base - 2 * nseas + s) = natM(t_base + s);  //  copy to virgin
      natM(t_base - nseas + s) = natM(t_base + s);   //  then to init_conditions year
    }
  }

  #ifdef DO_ONCE
  if (do_once == 1)
    echoinput << "natmort OK" << endl;
  #endif

  if (MG_active(4) > 0)
    get_recr_distribution();
  if (y >= Bmark_Yr(7) && y <= Bmark_Yr(8))
  {
    for (gp = 1; gp <= N_GP; gp++)
      for (p = 1; p <= pop; p++)
        for (settle = 1; settle <= N_settle_timings; settle++)
          if (recr_dist_pattern(gp, settle, p) > 0)
          {
            recr_dist_unf(gp, settle, p) += recr_dist(y, gp, settle, p);
            if (gender == 2)
              recr_dist_unf(gp + N_GP, settle, p) += recr_dist(y, gp + N_GP, settle, p);
          }
  }

  if (MG_active(5) > 0)
    get_migration();
  #ifdef DO_ONCE
  if (do_once == 1)
  {
    echoinput << "migr OK" << endl;
  }
  #endif
  if (MG_active(7) > 0)
  {
    get_catch_mult(y, catch_mult_pointer);
    for (j = styr + 1; j <= YrMax; j++)
    {
      catch_mult(j) = catch_mult(y);
    }
  }

  if (Use_AgeKeyZero > 0)
  {
    if (MG_active(6) > 0)
      get_age_age(Use_AgeKeyZero, AgeKey_StartAge, AgeKey_Linear1, AgeKey_Linear2); //  call function to get the age_age key
    if (save_for_report == 1 && store_agekey_add > 0)
    {
      save_agekey_count = N_ageerr + 1; //  first blank key after the used keys
      age_age(save_agekey_count) = age_age(Use_AgeKeyZero);
      age_err(save_agekey_count) = age_err(Use_AgeKeyZero);
    }
  #ifdef DO_ONCE
    if (do_once == 1)
    {
      echoinput << "age_err key recalc in " << y << endl;
    }
  #endif
  }

  if (save_for_report > 0)
  {
    get_saveGparm();
  }

  //  SS_Label_Info_23.2 #Calculate selectivity in the initial year
  get_selectivity();
  #ifdef DO_ONCE
  if (do_once == 1)
  {
    echoinput << "selectivity OK" << endl;
    echoinput << "Calculate ALK" << endl;
  }
  #endif

  //  SS_Label_Info_23.3 #Loop seasons and subseasons
  t = styr - 1;
  for (s = 1; s <= nseas; s++)
  {
    t++;

    if (WTage_rd > 0)
    {
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          Wt_Age_beg(s, g) = Wt_Age_t(t, 0, g);
          Wt_Age_mid(s, g) = Wt_Age_t(t, -1, g);
          if (s == spawn_seas)
            fec(g) = Wt_Age_t(t, -2, g);
        }
    }
    else if (MG_active(2) > 0 || MG_active(3) > 0 || save_for_report > 0 || do_once == 1)
    {
      //       Make_Fecundity();
      if (s == spawn_seas && spawn_seas == 1)
        get_mat_fec();
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          subseas = 1;
          ALK_idx = (s - 1) * N_subseas + subseas;
          Wt_Age_beg(s, g) = (ALK(ALK_idx, g) * wt_len(s, GP(g))); // wt-at-age at beginning of period
          subseas = mid_subseas;
          ALK_idx = (s - 1) * N_subseas + subseas;
          Wt_Age_mid(s, g) = ALK(ALK_idx, g) * wt_len(s, GP(g)); // use for fisheries with no size selectivity
        }
    }

    Wt_Age_t(t, 0) = Wt_Age_beg(s);
    Wt_Age_t(t, -1) = Wt_Age_mid(s);

    for (g = 1; g <= gmorph; g++)
      if (use_morph(g) > 0)
      {
        //  SS_Label_Info_23.3.3 #for each platoon, combine size_at_age distribution with length selectivity and weight-at-length to get combined selectivity vectors
        Make_FishSelex();
      }

    //  SS_Label_Info_23.3.4 #add predator M2 to M1 to update seasonal, areal natM in styr and calc surv for use in Pope's

      if(N_pred>0)
      {
//  rebase natM to M1, which is stored in the p=0 section of array
        for(p = 1; p <= pop; p++)
        {
          natM(t, p) = natM(t,0);
        }
//  calc M2
        for (f1 = 1; f1 <= N_pred; f1++)
        {
          f = predator(f1);
          pred_M2(f1, t) = mgp_adj(predparm_pointer(f1)); //  base with no seasonal effect
          if (nseas > 1)
            pred_M2(f1, t) *= mgp_adj(predparm_pointer(f1) + s);
          pred_M2(f1, t-nseas) = pred_M2(f1, t);
          pred_M2(f1, t-nseas-nseas) = pred_M2(f1, t);
          p = fleet_area(f);  //  area this predator occurs in

  //  a new array for indexing g and gpi could simplify below
  //        for (gp = 1; gp <= N_GP * gender * N_settle_timings; gp++)
  //  add each M2 to get total M
          for (gp = 1; gp <= N_GP * gender; gp++)
          {
            g = g_Start(gp); //  base platoon
            for (settle = 1; settle <= N_settle_timings; settle++)
            {
              g += N_platoon;
              int gpi = GP3(g); // GP*gender*settlement
              natM(t, p,gpi) += pred_M2(f1, t) * sel_num(s, f, g);
              if (do_once == 1 && p == 1)
                echoinput << "init " << y << " s " << s << " t " << t << " area " << 0 << " gp " << gpi << "  M1: " << natM(t,0, gpi) << endl;
              if (do_once == 1)
                echoinput << "init " << y << " s " << s << " t " << t << " area " << p << " gp " << gpi << "  M1+M2: " << natM(t, p, gpi) << endl;
            }
          }
        }
        natM(t-nseas) = natM(t);  //for initial equilibrium
        natM(t-nseas-nseas) = natM(t);  //  for virgin
      }

      for(p = 1; p <= pop; p++)
      {
        int s1 = (p - 1) * nseas + s;
        surv1(s1) = mfexp( - natM(t,p) * seasdur_half(s));
        surv2(s1) = square(surv1(s1));
      }
  } // end season (s) loop in biology, mortality and selectivity calcs in initial year

  #ifdef DO_ONCE
  if (do_once == 1)
    echoinput << "Begin calculating virgin age struc " << endl;
  #endif
  //  SS_Label_Info_23.4 #calculate unfished (virgin) numbers-at-age
  eq_yr = styr - 2;
  bio_yr = styr;
  Fishon = 0;
  virg_fec = fec;
  Recr.initialize(); //  will store recruitment by area

  //  SPAWN-RECR:   get expected recruitment globally or by area
  if (recr_dist_area == 1 || pop == 1) //  do global spawn_recruitment calculations
  {
    equ_Recr = 1.0;
    SSBpR_Calc(equ_Recr); //  call function to do per recruit calculation.  Returns SPR because R = 1.0
    SSBpR_virgin = SSB_equil; //  spawners per recruit.  Needed for Sr_fxn = 10
    if(SR_fxn == 10)  // B-H with a,b
    {
  //  WHAM based on R = A*S/(1+B*S)
  //  log_SR_a = log(4 * SR_h/(exp(log_SPR0)*(1 - SR_h)));
  //  log_SR_b = log((5*SR_h - 1)/((1-SR_h)*SR_R0*exp(log_SPR0)));
  //  h = a * SPR0 / (4. + a * SPR0)
  //  R0 = 1/b * (a-1/SPR0)

      alpha = mfexp(SRparm(3));
      beta = mfexp(SRparm(4));
      steepness = alpha * SSBpR_virgin / (4. + alpha * SSBpR_virgin);
      Recr_virgin = 1. / beta * (alpha - (1. / SSBpR_virgin));
      SRparm(1) = log(Recr_virgin);
      SRparm(2) = steepness;
    }
    else
    {
      Recr_virgin = mfexp(SRparm(1));
    }
  
  for (int i = 1; i <= N_SRparm2; i++)
  {
    SRparm_byyr(eq_yr, i) = SRparm(i);
    SRparm_virg(i) = SRparm(i);
    SRparm_work(i) = SRparm(i);
  }
//  if (SR_fxn == 3) warning << "tester_A: " << SRparm_work(1) << " base: " << SRparm(1) << endl;
//  if (SR_fxn == 10) warning << "tester_A: " << SRparm_work(4) << " base: " << SRparm(4) << endl;
    equ_Recr = Recr_virgin;
    exp_rec(eq_yr, 1) = Recr_virgin; //  expected Recr from s-r parms
    exp_rec(eq_yr, 2) = Recr_virgin;
    exp_rec(eq_yr, 3) = Recr_virgin;
    exp_rec(eq_yr, 4) = Recr_virgin;
    SSBpR_Calc(equ_Recr); //  call function to do per recruit calculation
    SSB_virgin = SSB_equil;
    if(Do_Benchmark==0)  // assign values that would be created in benchmark section
    {
      SSB_unf = SSB_virgin;
      Mgmt_quant(1) = SSB_unf; //  will be overwritten in benchmark
      Recr_unf = Recr_virgin;  //  will be overwritten in benchmark
      Mgmt_quant(2) = totbio;  //  from Do_Equil_Calc
      Mgmt_quant(3) = smrybio;  //  from Do_Equil_Calc
      Mgmt_quant(4) = Recr_virgin;
    }
    Smry_Table(styr - 2, 1) = totbio; //  from equil calcs
    Smry_Table(styr - 2, 2) = smrybio; //  from equil calcs
    Smry_Table(styr - 2, 3) = smrynum; //  from equil calcs
    SSB_pop_gp(eq_yr) = SSB_equil_pop_gp; // dimensions of pop x N_GP
    if (Hermaphro_Option != 0)
      MaleSSB(eq_yr) = MaleSSB_equil_pop_gp;
    SSB_yr(eq_yr) = SSB_equil;
    SRparm_byyr(eq_yr, N_SRparm2 + 1) = SSB_equil;
    SRparm_virg(N_SRparm2 + 1) = SSB_equil;
    SRparm_work(N_SRparm2 + 1) = SSB_equil;
    t = styr - 2 * nseas - 1;
    for (s = 1; s <= nseas; s++)
      for (p = 1; p <= pop; p++)
      {
        for (g = 1; g <= gmorph; g++)
        {
          if (use_morph(g) > 0)
          {
            natage(t + s, p, g)(0, nages) = equ_numbers(s, p, g)(0, nages);
            Z_rate(t + s, p, g)(0, nages) = equ_Z(s, p, g)(0, nages);
          }
        }
      }
    if (save_for_report > 0)
    {
      SSB_B_yr(eq_yr).initialize();
      SSB_N_yr(eq_yr).initialize();
      for (s = 1; s <= nseas; s++)
        {
          for (p = 1; p <= pop; p++)
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0)
              {
                if (s == spawn_seas && sx(g) == 1)
                {
                  SSB_B_yr(eq_yr) += make_mature_bio(GP4(g)) * natage(t + s, p, g);
                  SSB_N_yr(eq_yr) += make_mature_numbers(GP4(g)) * natage(t + s, p, g);
                }
                Save_PopAge(t + s, p, g) = natage(t + s, p, g);
                Save_PopAge(t + s, p + pop, g) = elem_prod(natage(t + s, p, g), mfexp(-Z_rate(t + s, p, g) * 0.5 * seasdur(s)));
                if (Settle_seas(settle_g(g)) == s)
                  Recr(p, t + 1 + Settle_seas_offset(settle_g(g))) += equ_Recr * recr_dist(y, GP(g), settle_g(g), p) * platoon_distr(GP2(g));
                Save_PopBio(t + s, p, g) = elem_prod(natage(t + s, p, g), Wt_Age_beg(s, g));
                Save_PopBio(t + s, p + pop, g) = elem_prod(Save_PopAge(t + s, p + pop, g), Wt_Age_mid(s, g));
              }
        for (int ff = 1; ff <= N_pred; ff++)
        {
          f = predator(ff);
          for (g = 1; g <= 6; g++)
          {
            catch_fleet(t + s, f, g) = equ_catch_fleet(g, s, f);
          }
          for (g = 1; g <= gmorph; g++)
          {
            catage(t + s, f, g) = equ_catage(s, f, g);
          }
        }
      }
    }
  }
  else //  area-specific spawn-recruitment
  {
  }

//  SS_Label_Info_23.5  #Calculate equilibrium using initial F
  #ifdef DO_ONCE
  if (do_once == 1)
    echoinput << "Begin calculating initial age structure" << endl;
  #endif
  eq_yr = styr - 1;
  bio_yr = styr;
  if (fishery_on_off == 1)
  {
    Fishon = 1;
  }
  else
  {
    Fishon = 0;
  }

  for (f = 1; f <= N_SRparm2; f++)
  {
    if (SRparm_timevary(f) == 0)
    {
      //  no change to SRparm_work
    }
    else
    {
      SRparm_work(f) = parm_timevary(SRparm_timevary(f), eq_yr);
//      warning << "tester_B: " << SRparm_work(f) << " timevary " << " base " << SRparm(f) <<endl;
//      warning << parm_timevary(2) << endl;

    }
    SRparm_byyr(eq_yr, f) = SRparm_work(f);
  }
  for (s = 1; s <= nseas; s++)
  {
    t = styr - nseas - 1 + s;
    for (int ff = 1; ff <= N_catchfleets(0); ff++)
    {
      f = fish_fleet_area(0, ff);
      if (init_F_loc(s, f) > 0)
      {
        Hrate(f, t) = init_F(init_F_loc(s, f));
      }
    }
  }
  //  for the initial equilibrium, R0 and steepness will remain same as for virgin, but a regime shift is allowed
  //  change with 3.30.12 to allow R0 to change according to a timevary effect
  //  exp_rec(eq_yr,1)=Recr_virgin;
  //  R1_exp=Recr_virgin;
  R1_exp = mfexp(SRparm_work(1));
  exp_rec(eq_yr, 1) = R1_exp;
  //  SS_Label_Info_23.5.1  #Apply adjustments to the recruitment level
  //  SPAWN-RECR:   adjust recruitment for the initial equilibrium
  regime_change = 1.0;
  if (SRparm_timevary(N_SRparm2 - 1) > 0) //  timevary regime exists
  {
    regime_change = mfexp(SRparm_work(N_SRparm2 - 1));
  }

  if (init_equ_steepness == 0) // Adjustments do not include spawner-recruitment steepness
  {
    //   R1=Recr_virgin*regime_change;
    R1 = R1_exp * regime_change;
    exp_rec(eq_yr, 2) = R1;
    exp_rec(eq_yr, 3) = R1;
    exp_rec(eq_yr, 4) = R1;
    equ_Recr = R1; //  equ_Recr is used inside of SSBpR_Calc
    SSBpR_Calc(equ_Recr);
    CrashPen += Equ_penalty;
  }
  else
  {
    //  SS_Label_Info_23.5.1.2  #Adjustments  include spawner-recruitment function
    //  do initial equilibrium with R1 based on offset from spawner-recruitment curve, using same approach as the benchmark calculations
    //  first get SPR for this init_F
    //  SPAWN-RECR:   calc initial equilibrium pop, SSB, Recruitment
    //    equ_Recr=Recr_virgin;
//    equ_Recr = R1_exp * regime_change;  //  NOTE:  seems wrong to apply regime here
    equ_Recr = R1_exp;
    SSBpR_Calc(equ_Recr);
    CrashPen += Equ_penalty;
    SSBpR_temp = SSB_equil / equ_Recr; //  spawners per recruit at initial F
    //  get equilibrium SSB and recruitment from SSBpR_temp, Recr_virgin and virgin steepness
    //  this is the initial year, so no time-vary effects available, so uses _virgin quantities for spawner-recruitment
    Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_work, SSB_virgin, Recr_virgin, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
    R1_exp = Equ_SpawnRecr_Result(2); //  set the expected recruitment equal to this equilibrium
    exp_rec(eq_yr, 1) = R1_exp;

    equ_Recr = R1_exp * regime_change;
    exp_rec(eq_yr, 2) = equ_Recr;
    exp_rec(eq_yr, 3) = equ_Recr;
    exp_rec(eq_yr, 4) = equ_Recr;
    R1 = equ_Recr;
    SSBpR_Calc(equ_Recr); // calculated SSB_equil
    CrashPen += Equ_penalty;
  }
  Smry_Table(styr - 1, 1) = totbio; //  from equil calcs
  Smry_Table(styr - 1, 2) = smrybio; //  from equil calcs
  Smry_Table(styr - 1, 3) = smrynum; //  from equil calcs

  SSB_pop_gp(eq_yr) = SSB_equil_pop_gp; // dimensions of pop x N_GP
  if (Hermaphro_Option != 0)
    MaleSSB(eq_yr) = MaleSSB_equil_pop_gp;
  SSB_yr(eq_yr) = SSB_equil;
  SRparm_byyr(eq_yr, N_SRparm2 + 1) = SSB_equil;
  SRparm_work(N_SRparm2 + 1) = SSB_equil;
  SSB_yr(styr) = SSB_equil;
  env_data(styr - 1, -1) = 0.0;
  env_data(styr - 1, -2) = 0.0;
  env_data(styr - 1, -3) = 0.0;
  env_data(styr - 1, -4) = 0.0;

  /*
  // save est_equ_catch which has units (biomass vs numbers) according to that fleet; used in objfun
  for (s = 1; s <= nseas; s++)
    for (int ff = 1; ff <= N_catchfleets(0); ff++)
    {
      f = fish_fleet_area(0, ff);
      if (catchunits(f) == 1)
      {
        est_equ_catch(s, f) = equ_catch_fleet(2, s, f);
      }
      else
      {
        est_equ_catch(s, f) = equ_catch_fleet(5, s, f);
      }
    }
  */
//  if (save_for_report > 0)
  {
    for (s = 1; s <= nseas; s++)
    {
      t = styr - nseas - 1 + s;
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        for (g = 1; g <= 6; g++)
        {
          catch_fleet(t, f, g) = equ_catch_fleet(g, s, f);
          annual_catch(styr - 1, g) += equ_catch_fleet(g, s, f);
        }
        for (g = 1; g <= gmorph; g++)
        {
          catage(t, f, g) = equ_catage(s, f, g);
        }
      }
      for (int ff = 1; ff <= N_pred; ff++)
      {
        f = predator(ff);
        for (g = 1; g <= 6; g++)
        {
          catch_fleet(t, f, g) = equ_catch_fleet(g, s, f);
        }
        for (g = 1; g <= gmorph; g++)
        {
          catage(t, f, g) = equ_catage(s, f, g);
        }
      }
    }
    for (k = 1; k <= 3; k++)
    {
      Smry_Table(styr - 1, k + 3) = annual_catch(styr - 1, k);
    }
  }

  for (s = 1; s <= nseas; s++)
  {
    t = styr - nseas - 1 + s;
    a = styr - 1 + s;
    for (p = 1; p <= pop; p++)
      for (g = 1; g <= gmorph; g++)
      {
        natage(t, p, g)(0, nages) = equ_numbers(s, p, g)(0, nages);
        natage(a, p, g)(0, nages) = equ_numbers(s, p, g)(0, nages);
        Z_rate(t, p, g) = equ_Z(s, p, g);
      }
  }

  if (save_for_report > 0)
  {
    t = styr - nseas - 1;
    SSB_B_yr(eq_yr).initialize();
    SSB_N_yr(eq_yr).initialize();
    for (s = 1; s <= nseas; s++)
      for (p = 1; p <= pop; p++)
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            if (s == spawn_seas && sx(g) == 1)
            {
              SSB_B_yr(eq_yr) += make_mature_bio(GP4(g)) * natage(t + s, p, g);
              SSB_N_yr(eq_yr) += make_mature_numbers(GP4(g)) * natage(t + s, p, g);
            }
            Save_PopAge(t + s, p, g) = natage(t + s, p, g);
            Save_PopAge(t + s, p + pop, g) = elem_prod(natage(t + s, p, g), mfexp(-Z_rate(t + s, p, g) * 0.5 * seasdur(s)));
            Save_PopBio(t + s, p, g) = elem_prod(natage(t + s, p, g), Wt_Age_beg(s, g));
            Save_PopBio(t + s, p + pop, g) = elem_prod(Save_PopAge(t + s, p + pop, g), Wt_Age_mid(s, g));
            if (Settle_seas(settle_g(g)) == s)
              Recr(p, t + 1 + Settle_seas_offset(settle_g(g))) += equ_Recr * recr_dist(y, GP(g), settle_g(g), p) * platoon_distr(GP2(g));
          }
  }

  if (docheckup == 1)
    echoinput << " init equil age comp for styr " << styr << endl
              << natage(styr) << endl
              << endl;

  // if recrdevs start before styr, then use them to adjust the initial agecomp
  //  apply a fraction of the bias adjustment, so bias adjustment gets less linearly as proceed back in time
  if (recdev_first < styr)
  {
    if (do_recdev <= 2 && SR_fxn != 4)
    {
      for (p = 1; p <= pop; p++)
        for (g = 1; g <= gmorph; g++)
          for (a = styr - recdev_first; a >= 1; a--)
          {
            j = styr - a;
            natage(styr, p, g, a) *= mfexp(recdev(j) - biasadj(j) * half_sigmaRsq);
          }
    }
    else
    {
      for (p = 1; p <= pop; p++)
        for (g = 1; g <= gmorph; g++)
          for (a = styr - recdev_first; a >= 1; a--)
          {
            j = styr - a;
            natage(styr, p, g, a) *= mfexp(recdev(j));
          }
    }
  }
  SSB_pop_gp(styr) = SSB_pop_gp(styr - 1); //  placeholder in case not calculated early in styr

  //  note:  the above keeps SSB_pop_gp(styr) = SSB_equil.  It does not adjust for initial agecomp, but probably should
  } //  end initial_conditions

//*********************************************************************
FUNCTION void get_time_series()
  {
  /*  SS_Label_Function_24 get_time_series */
  dvariable crashtemp;
  dvariable crashtemp1;
  dvariable interim_tot_catch;
  dvariable Z_adjuster;

  if (Do_Morphcomp > 0)
    Morphcomp_exp.initialize();

  //  SS_Label_Info_24.0 #Retrieve spawning biomass and recruitment from the initial equilibrium
  //  SPAWN-RECR:   begin of time series, retrieve last SSBio and recruitment
  SSB_current = SSB_yr(styr); //  need these initial assignments in case recruitment distribution occurs before spawnbio&recruits
  if (recdev_doit(styr - 1) > 0)
  {
    Recruits = R1 * mfexp(recdev(styr - 1) - biasadj(styr - 1) * half_sigmaRsq);
  }
  else
  {
    Recruits = R1;
  }

  //  SS_Label_Info_24.1 #Loop the years
  for (y = styr; y <= endyr; y++)
  {
    yz = y;
    if (STD_Yr_Reverse_F(y) > 0)
      F_std(STD_Yr_Reverse_F(y)) = 0.0;
    t_base = styr + (y - styr) * nseas - 1;

    for (f = 1; f <= N_SRparm2; f++)
    {
      if (SRparm_timevary(f) == 0)
      {
        //  no change to SRparm_work
      }
      else
      {
        SRparm_work(f) = parm_timevary(SRparm_timevary(f), y);
//        warning << "tester_C: " << SRparm_work(f) << " timevary_year " << endl;
      }
      SRparm_byyr(y, f) = SRparm_work(f);
    }

      //  SS_Label_Info_24.1.1 #store begin of year quantities for use in density-dependent processes
    {
      env_data(y, -1) = log(SSB_current / SSB_yr(styr - 1));
      if (recdev_doit(y) > 0)
      {
        env_data(y, -2) = recdev(y);
      } //  store so can do density-dependence
      else
      { //  should be 0.0
      }
      t = t_base + 1; // first season
      s = 1;
      if (WTage_rd > 0)
      {
        Wt_Age_beg(s) = Wt_Age_t(t, 0);
        Wt_Age_mid(s) = Wt_Age_t(t, -1);
      }
      else if (timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0 || save_for_report == 1)
      {
        get_growth3(y, t, 1, 1); //  before season loop, used for summary biomass
        ALK_subseas_update(1) = 1; // do 1st subseas of 1st season;  ADD THIS LINE for 3.30.17
        Make_AgeLength_Key(s, 1); //  this will give wt_age_beg before any time-varying parameter changes for this year
        ALK_idx = (s - 1) * N_subseas + 1;
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            Wt_Age_beg(s, g) = (ALK(ALK_idx, g) * wt_len(s, GP(g))); // wt-at-age at beginning of period
          }
      }
      smrybio = 0.0;
      smrynum = 0.0;
      //  do not do totbio here because new recruits have not yet occurred
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (p = 1; p <= pop; p++)
          {
            smrybio += natage(t, p, g)(Smry_Age, nages) * Wt_Age_beg(1, g)(Smry_Age, nages); // calc before recruitment and time-vary biology applied
            smrynum += sum(natage(t, p, g)(Smry_Age, nages)); //sums to accumulate across platoons and settlements
          }
        }
      env_data(y, -3) = log(smrybio / Smry_Table(styr - 1, 2));
      env_data(y, -4) = log(smrynum / Smry_Table(styr - 1, 3));

      Smry_Table(y, 2) = smrybio; //  gets used as demoninator for some F_std options
      Smry_Table(y, 3) = smrynum;
    }

      //  SS_Label_Info_24.1.1 #skip biology updating if y=styr because already done
    if (y > styr)
    {
      if (do_densitydependent == 1)
        make_densitydependent_parm(y); //  call to adjust for density dependence

      //  SS_Label_Info_24.1.1 #Update the time varying biology factors if necessary
      if (timevary_MG(y, 0) > 0 || save_for_report > 0)
        get_MGsetup(y);
      if (timevary_MG(y, 2) > 0)
      {
        ALK_subseas_update = 1; // indicate that all ALKs will need re-estimation
        get_growth2(y); //  propagates growth to each season this year and to begin next year
        get_growth3(y, t, 1, 1); //  cleans up the linear growth range for begin of this year
      }
      if (timevary_MG(y, 3) > 0)
      {
        get_wtlen(); //  stores values for all seasons
        //  note that get_mat_fec() will get called in the season loop because it may need the ALK for a later season
        // but Maunder's M in get_natmort() may use the fecundity vector, so would be using the most recently calculated  Problem??
        if (Hermaphro_Option != 0)
          get_Hermaphro();
      }
      if (timevary_MG(y, 1) > 0)
      {
        get_natmort();
      }
      else
      {
        for (s = 1; s <= nseas; s++)
        {
          natM(t_base + s) = natM(t_base - nseas + s);
        } // set M equal to last year's;
          // does all areas (p), but if there are predators, then add of pred_M2 occurs in season loop below
      }

      if (timevary_MG(y, 4) > 0)
        get_recr_distribution();
      if (y >= Bmark_Yr(7) && y <= Bmark_Yr(8))
      {
        for (gp = 1; gp <= N_GP; gp++)
          for (p = 1; p <= pop; p++)
            for (settle = 1; settle <= N_settle_timings; settle++)
              if (recr_dist_pattern(gp, settle, p) > 0)
              {
                recr_dist_unf(gp, settle, p) += recr_dist(y, gp, settle, p);
                if (gender == 2)
                  recr_dist_unf(gp + N_GP, settle, p) += recr_dist(y, gp + N_GP, settle, p);
              }
      }
      if (timevary_MG(y, 5) > 0)
        get_migration();
      if (timevary_MG(y, 7) > 0)
      {
        get_catch_mult(y, catch_mult_pointer);
      }

      if (Use_AgeKeyZero > 0)
      {
        if (timevary_MG(y, 6) > 0)
        {
          get_age_age(Use_AgeKeyZero, AgeKey_StartAge, AgeKey_Linear1, AgeKey_Linear2); //  call function to get the age_age key
          if (save_for_report == 1 && store_agekey_add > 0)
          {
            save_agekey_count++; //  next blank key after the used keys
            age_age(save_agekey_count) = age_age(Use_AgeKeyZero);
            age_err(save_agekey_count) = age_err(Use_AgeKeyZero);
          }

  #ifdef DO_ONCE
          if (do_once == 1)
            echoinput << " ageerr_key recalc in " << y << endl;
  #endif
        }
      }

      if (save_for_report > 0)
      {
        if (timevary_MG(y, 1) > 0 || timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0)
        {
          get_saveGparm();
        }
      }
    }

    //  SS_Label_Info_24.2  #Loop the seasons
    for (s = 1; s <= nseas; s++)
    {
      if (docheckup == 1)
        echoinput << endl
                  << "************************************" << endl
                  << " year, seas " << y << " " << s << endl;
      //  SS_Label_Info_24.1.2  #Call selectivity, which does its own internal check for time-varying changes
      //  note that Make_Fish_selex is called later after the ALK's have been updated
      if (s == 1 && y > styr)
        get_selectivity();
      t = t_base + s;

      //  SS_Label_Info_24.2.1 #Update the age-length key and the fishery selectivity for this season

      //      if(timevary_MG(y,2)>0 || timevary_MG(y,3)>0 || save_for_report==1 || WTage_rd>0)
      if (timevary_MG(y, 2) > 0 || save_for_report == 1)
      {
        get_growth3(y, t, s, 1); // first subseas of season=s
        Make_AgeLength_Key(s, 1);

        get_growth3(y, t, s, mid_subseas); //  for midseason
        Make_AgeLength_Key(s, mid_subseas);
        //  SPAWN-RECR:   call Make_Fecundity in time series
        if (s == spawn_seas)
        {
          if (spawn_subseas != 1 && spawn_subseas != mid_subseas)
          {
            subseas = spawn_subseas;
            get_growth3(y, t, s, subseas);
            Make_AgeLength_Key(s, subseas); //  spawn subseas
          }
        }
      }
      if (WTage_rd > 0)
      {
        Wt_Age_beg(s) = Wt_Age_t(t, 0);
        Wt_Age_mid(s) = Wt_Age_t(t, -1);
        if (s == spawn_seas)
        {
          fec = Wt_Age_t(t, -2);
        }
      }
      else if (timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0 || save_for_report > 0 || do_once == 1)
      {
        if (s == spawn_seas)
          get_mat_fec();
        //         Make_Fecundity();
        ALK_idx = (s - 1) * N_subseas + 1; //  subseas=1
        int ALK_idx2 = (s - 1) * N_subseas + mid_subseas;
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            Wt_Age_beg(s, g) = (ALK(ALK_idx, g) * wt_len(s, GP(g))); // wt-at-age at beginning of period
            Wt_Age_mid(s, g) = ALK(ALK_idx2, g) * wt_len(s, GP(g)); // use for fisheries with no size selectivity
          }
      }

      Wt_Age_t(t, 0) = Wt_Age_beg(s);
      Wt_Age_t(t, -1) = Wt_Age_mid(s);

      if (y > styr) // because styr is done as part of initial conditions
      {
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            Make_FishSelex();
          }

//  rebase natM to M1
        for(p = 1; p <= pop; p++)
        {
          natM(t, p) = natM(t,0);
        }
        // SS_Label_Info_24.x.x #add predator M2 inside the yr,seas loop
        if(N_pred>0)
        {
    //  add pred_M2 by area
          for (f1 = 1; f1 <= N_pred; f1++)
          {
            f = predator(f1);
            pred_M2(f1, t) = mgp_adj(predparm_pointer(f1)); //  base with no seasonal effect
            if (nseas > 1)
              pred_M2(f1, t) *= mgp_adj(predparm_pointer(f1) + s);
            p = fleet_area(f);  //  area this predator occurs in

    //  a new array for indexing g and gpi could simplify below
    //        for (gp = 1; gp <= N_GP * gender * N_settle_timings; gp++)

            for (gp = 1; gp <= N_GP * gender; gp++)
            {
              g = g_Start(gp); //  base platoon
              for (settle = 1; settle <= N_settle_timings; settle++)
              {
                g += N_platoon;
                int gpi = GP3(g); // GP*gender*settlement
                natM(t, p,gpi) += pred_M2(f1, t) * sel_num(s, f, g);
                 if (do_once == 1 && p == 1)
                    echoinput << y << " s " << s << " t " << t << " area " << 0 << " gp " << gpi << "  M1: " << natM(t,0, gpi) << endl;
                  if (do_once == 1)
                    echoinput << y << " s " << s << " t " << t << " area " << p << " gp " << gpi << "  M1+M2: " << natM(t, p, gpi) << endl;
              }
            }
          }
        }

        for(p = 1; p <= pop; p++)
        {
          int s1 = (p - 1) * nseas + s;
          surv1(s1) = mfexp(-natM(t,p) * seasdur_half(s));
          surv2(s1) = square(surv1(s1));
        }
      }
      //  SS_Label_Info_24.2.2 #Compute spawning biomass if this is spawning season so recruits could occur later this season
      //  SPAWN-RECR:   calc SSB in time series if spawning is at beginning of the season
      if (s == spawn_seas && spawn_time_seas < 0.0001) //  compute spawning biomass if spawning at beginning of season so recruits could occur later this season
      {
        SSB_pop_gp(y).initialize();
        SSB_B_yr(y).initialize();
        SSB_N_yr(y).initialize();
        Smry_Table(y, 15) = 0.0;
        for (p = 1; p <= pop; p++)
        {
          for (g = 1; g <= gmorph; g++)
            if (sx(g) == 1 && use_morph(g) > 0) //  female
            {
              SSB_pop_gp(y, p, GP4(g)) += fracfemale_mult * fec(g) * natage(t, p, g); // accumulates SSB by area and by growthpattern
              SSB_B_yr(y) += fracfemale_mult * make_mature_bio(GP4(g)) * natage(t, p, g);
              SSB_N_yr(y) += fracfemale_mult * make_mature_numbers(GP4(g)) * natage(t, p, g);
              Smry_Table(y, 15) += fracfemale_mult * natage(t, p, g) * elem_prod(fec(g), r_ages);  //  for mean age of female spawners = GenTime
              //            SSB_pop_gp(y,p,GP4(g)) += fec(g)*natage(t,p,g);   // accumulates SSB by area and by growthpattern
              //            SSB_B_yr(y) += make_mature_bio(GP4(g))*natage(t,p,g);
              //            SSB_N_yr(y) += make_mature_numbers(GP4(g))*natage(t,p,g);
            }
        }
        SSB_current = sum(SSB_pop_gp(y));
        SSB_yr(y) = SSB_current;

        if (Hermaphro_Option != 0) // get male biomass
        {
          MaleSSB(y).initialize();
          for (p = 1; p <= pop; p++)
          {
            for (g = 1; g <= gmorph; g++)
              if (sx(g) == 2 && use_morph(g) > 0) //  male; all assumed to be mature
              {
                MaleSSB(y, p, GP4(g)) += Wt_Age_t(t, 0, g) * natage(t, p, g); // accumulates SSB by area and by growthpattern
              }
          }
          if (Hermaphro_maleSSB > 0.0) // add MaleSSB to female SSB
          {
            SSB_current += Hermaphro_maleSSB * sum(MaleSSB(y));
            SSB_yr(y) = SSB_current;
          }
        }

        //  SS_Label_Info_24.2.3 #Get the total recruitment produced by this spawning biomass at the beginning of the season
        //  SPAWN-RECR:   calc recruitment in time series
        if (timevary_SRparm(y) == 0) //  SRparm use virgin values (but regime still could be)
        {
          R0_use = Recr_virgin;
          SSB_use = SSB_virgin;
//          warning << y << " virgin_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;
        }
        else if (timevary_SRparm(y) == 1)  //  update R0_use and SSB_use in this year
                                           //  values will carry forward into subsequent years
        {
          R0_use = mfexp(SRparm_work(1));
          //  timevary steepness is in SRparm_work(2) and will be applied inside of Equil_Spawn_Recr_Fxn() and Spawn_Recr()
          equ_Recr = R0_use;
          Fishon = 0;
          eq_yr = y;
          bio_yr = y;
          SSBpR_Calc(R0_use); //  call function to do per recruit calculation with current year's biology and adjusted R0
          SSB_use = SSB_equil;
//          warning << y << " update_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;

          if (fishery_on_off == 1)
          {
            Fishon = 1;
          }
          else
          {
            Fishon = 0;
          }
        }
        else  //  flag is 2
        {
//          warning << y << " carry_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;
        }
        Recruits = Spawn_Recr(SRparm_work, SSB_use, R0_use, SSB_current); // calls to function Spawn_Recr using either virgin or adjusted R0 and SSB0
//        warning <<"  SSB: " << SSB_current << "  R: " << Recruits << endl;
        if (SR_fxn != 7) apply_recdev(Recruits, R0_use); //  apply recruitment deviation
        // distribute Recruitment of age 0 fish among the current and future settlements; and among areas and morphs
        //  use t offset for each birth event:  Settlement_offset(settle)
        //  so the total number of Recruits will be relative to their numbers at the time of the set of settlement_events.
        //  so need the integer elapsed time (in season count) stored in Birth_offset()
        //  and need the real elapsed time (in fraction of a year) from the beginning of the season to settlement
        //  use NatM to calculate the virtual numbers that would have existed at the beginning of the season of the settlement
        //  need to use natM(t) because natM(t+offset) is not yet known
        //  also need to store the integer age at settlement
        //  NOTE: the settlement is added to natage at the beginning of the season in which the settlement occurs,
        //  so it will be fished and sampled even before its settlement time
        //  this is a shortcoming that might be dealt with in future.
        //   For now, users will need to create finer season structure
        //  NOTE:  the distributed recruits are added into natage because more than one settlement can occur in same season
        //  but each settlement has a unique "g", so maybe additive is not necessary
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            settle = settle_g(g);
            for (p = 1; p <= pop; p++)
            {
              if (y == styr)
                natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) = 0.0; //  to negate the additive code
              natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) +=
                  Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g)) *
                  mfexp(natM(t, p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle));
                Recr(p, t + Settle_seas_offset(settle)) += Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g));
              //  the adjustment for mortality increases recruit value for elapsed time since begin of season because M will then be applied from beginning of season
              if (docheckup == 1)
                echoinput << y << " Recruits, dist, surv, result  " << Recruits << " " << recr_dist(y, GP(g), settle, p) << " " << mfexp(natM(t, p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle)) << " " << natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) << " M "<<natM(t, p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle)<<endl;
            }
          }
      }

      else
      {
        //  spawning biomass and total recruits will be calculated later so they can use Z
      }

      //  SS_Label_Info_24.3 #Loop the areas
      totbio = 0.;
      smrybio = 0.; //  reset to zero happens every season, but accumulation and storage only in season=1; after area loop
      smrynum = 0.;
      for (p = 1; p <= pop; p++)
      {
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            //  SS_Label_Info_24.3.1 #Get middle of season numbers-at-age from M only;
            int s1 = (p - 1) * nseas + s;
            Nmid(g) = elem_prod(natage(t, p, g), surv1(s1, GP3(g))); //  get numbers-at-age(g,a) surviving to middle of time period
            if (docheckup == 1)
              echoinput << p << " " << g << " " << GP3(g) << " area & morph " << endl
                        << "N-at-age " << natage(t, p, g)(0, min(6, nages)) << endl
                        << "survival " << surv1(s, GP3(g))(0, min(6, nages)) << endl;
            if (save_for_report == 1)
            {
              //  SS_Label_Info_24.3.2 #Store some beginning of season quantities
              Save_PopLen(t, p, g) = 0.0;
              Save_PopLen(t, p + pop, g) = 0.0; // later put midseason here
              Save_PopWt(t, p, g) = 0.0;
              Save_PopWt(t, p + pop, g) = 0.0; // later put midseason here
              Save_PopAge(t, p, g) = 0.0;
              Save_PopAge(t, p + pop, g) = 0.0; // later put midseason here
              Save_PopBio(t, p, g) = 0.0;
              Save_PopBio(t, p + pop, g) = 0.0; // later put midseason here
              ALK_idx = (s - 1) * N_subseas + 1;
              for (a = 0; a <= nages; a++)
              {
                Save_PopLen(t, p, g) += value(natage(t, p, g, a)) * value(ALK(ALK_idx, g, a));
                Save_PopWt(t, p, g) += value(natage(t, p, g, a)) * value(elem_prod(ALK(ALK_idx, g, a), wt_len(s, GP(g))));
                Save_PopAge(t, p, g, a) = value(natage(t, p, g, a));
                Save_PopBio(t, p, g, a) = value(natage(t, p, g, a)) * value(Wt_Age_beg(s, g, a));
              } // close age loop
              if (s == 1)
              {
                totbio += natage(t, p, g)(0, nages) * Wt_Age_beg(s, g)(0, nages);
                smrybio += natage(t, p, g)(Smry_Age, nages) * Wt_Age_beg(s, g)(Smry_Age, nages);
                smrynum += sum(natage(t, p, g)(Smry_Age, nages)); //sums to accumulate across platoons and settlements
              }
            }
          }

        //  SS_Label_Info_24.3.3 #Do fishing mortality
        catage_tot.initialize();

        if ((catch_seas_area(t, p, 0) == 1 && fishery_on_off == 1))
        {
          if (F_Method > 1) //  not Pope's
          {
            //  SS_Label_Info_24.3.3.3 #use the hybrid F method by selected fleets
            // hybrid F_method
            k = current_phase();
            if (k < F_PH_time(0, t)) //  some fleet needs hybrid this phase
            {
              //  SS_Label_Info_24.3.3.3.1 #Start by doing a Pope's approximation
              for (int ff = 1; ff <= N_catchfleets(p); ff++)  // loop fleets in this area (p)
              {
                f = fish_fleet_area(p, ff);
                if (k < F_PH_time(f, t)) // do hybrid F for this fleet
                {
                  vbio.initialize();
                  for (g = 1; g <= gmorph; g++)
                    if (use_morph(g) > 0)
                    {
                      if (catchunits(f) == 1)
                      {
                        vbio += Nmid(g) * sel_ret_bio(s, f, g);
                      } // retained catch bio
                      else
                      {
                        vbio += Nmid(g) * sel_ret_num(s, f, g);
                      } // retained catch numbers
                    } //close gmorph loop
                  //  SS_Label_Info_24.3.3.3.2 #Apply constraint so that no fleet's initial calculation of harvest rate would exceed 95%
                  temp = catch_ret_obs(f, t) / (vbio + 0.1 * catch_ret_obs(f, t)); //  Pope's rate  robust
                  join1 = 1. / (1. + mfexp(30. * (temp - 0.95))); // steep logistic joiner at harvest rate of 0.95
                  temp1 = join1 * temp + (1. - join1) * 0.95;
                  //  SS_Label_Info_24.3.3.3.3 #Convert the harvest rate to a starting value for F
                  Hrate(f, t) = -log(1. - temp1) / seasdur(s); // initial estimate of F (even though labelled as Hrate)
                }
              }

              //  SS_Label_Info_24.3.3.3.4 #Do a specified number of loops to tune up these F values to more closely match the observed catch
              for (int tune_F = 1; tune_F <= F_Tune - 1; tune_F++)
              {
                //  SS_Label_Info_24.3.3.3.5 #add F+M to get Z
                for (g = 1; g <= gmorph; g++)
                  if (use_morph(g) > 0)
                  {
                    Z_rate(t, p, g) = natM(t, p, GP3(g));  //  already includes predators
                    for (int ff = 1; ff <= N_catchfleets(p); ff++)
                    {
                      f = fish_fleet_area(p, ff);
                      Z_rate(t, p, g) += sel_dead_num(s, f, g) * Hrate(f, t);
                    }

                    Zrate2(p, g) = elem_div((1. - mfexp(-seasdur(s) * Z_rate(t, p, g))), Z_rate(t, p, g));
                  }

                //  SS_Label_Info_24.3.3.3.6 #Now calc adjustment to Z based on changes to be made to Hrate
                {
                  interim_tot_catch = 0.0; // this is the expected total catch that would occur with the current Hrates and Z
                  // totcatch_byarea(t,p) is now recalculated here just for the fleets doing hybrid in this phase
                  double target_catch = 0.0;
                  for (int ff = 1; ff <= N_catchfleets(p); ff++)
                  {
                    f = fish_fleet_area(p, ff);
                    
                    if (current_phase() < F_PH_time(f, t)) // so still doing hybrid; skips bycatch fleets
                    {
                      for (g = 1; g <= gmorph; g++)
                        if (use_morph(g) > 0)
                        {
                          if (catchunits(f) == 1)
                          {
                            interim_tot_catch += catch_mult(y, f) * Hrate(f, t) * elem_prod(natage(t, p, g), sel_ret_bio(s, f, g)) * Zrate2(p, g); // biomass basis
                          }
                          else
                          {
                            interim_tot_catch += catch_mult(y, f) * Hrate(f, t) * elem_prod(natage(t, p, g), sel_ret_num(s, f, g)) * Zrate2(p, g); //  numbers basis
                          }
                        } //close gmorph loop
                      target_catch += catch_ret_obs(f, t);
                    }
                  } // close fishery
                  Z_adjuster = target_catch / (interim_tot_catch + 0.0001);
                  for (g = 1; g <= gmorph; g++)
                    if (use_morph(g) > 0)
                    {
                      Z_rate(t, p, g) = natM(t, p, GP3(g)) + Z_adjuster * (Z_rate(t, p, g) - natM(t, p, GP3(g))); // find adjusted Z
                      Zrate2(p, g) = elem_div((1. - mfexp(-seasdur(s) * Z_rate(t, p, g))), Z_rate(t, p, g));
                    }

                  for (int ff = 1; ff <= N_catchfleets(p); ff++) //loop over fishing  fleets with input catch
                  {
                    f = fish_fleet_area(p, ff);
//                    if (fleet_type(f) == 1)
                    {
                      if (current_phase() < F_PH_time(f, t)) //  skips bycatch fleets and fixed F values
                      {
                        vbio = 0.; // now use this to calc the selected vulnerable biomass (numbers) to each fishery with the adjusted Zrate2
                        //  since catch = N * F*sel * (1-e(-Z))/Z
                        //  so F = catch / (N*sel * (1-e(-Z)) /Z )
                        for (g = 1; g <= gmorph; g++)
                          if (use_morph(g) > 0)
                          {
                            if (catchunits(f) == 1)
                            {
                              vbio += elem_prod(natage(t, p, g), sel_ret_bio(s, f, g)) * Zrate2(p, g);
                            }
                            else
                            {
                              vbio += elem_prod(natage(t, p, g), sel_ret_num(s, f, g)) * Zrate2(p, g);
                            }
                          } //close gmorph loop
                        temp = catch_ret_obs(f, t) / (catch_mult(y, f) * vbio + 0.0001); //  prototype new F
                        join1 = 1. / (1. + mfexp(30. * (temp - 0.95 * max_harvest_rate)));
                        Hrate(f, t) = join1 * temp + (1. - join1) * max_harvest_rate; //  new F value for this fleet
                      } // close fishery
                    }
                  }
                }
              }
            } //  end hybrid F_Method

            //  SS_Label_Info_24.3.3.2 #Use a parameter for continuoous F
            // continuous F_method
            {
              //  SS_Label_Info_24.3.3.2.1 #For each platoon, loop fleets to calculate Z = M+sum(F)
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  Z_rate(t, p, g) = natM(t, p, GP3(g));  //  already includes predators M2

                  for (int ff = 1; ff <= N_catchfleets(p); ff++)
                  {
                    f = fish_fleet_area(p, ff);
                    if (catch_seas_area(t, p, f) == 1)
                    {
                      Z_rate(t, p, g) += sel_dead_num(s, f, g) * Hrate(f, t);
                    }
                  }
                  Zrate2(p, g) = elem_div((1. - mfexp(-seasdur(s) * Z_rate(t, p, g))), Z_rate(t, p, g));
                }

              //  SS_Label_Info_24.3.3.2.2 #For each fleet, loop platoons and accumulate catch
              for (int ff = 1; ff <= N_catchfleets(0); ff++)
              {
                f = fish_fleet_area(0, ff);
                if (catch_seas_area(t, p, f) == 1)
                {
                  for (g = 1; g <= gmorph; g++)
                    if (use_morph(g) > 0)
                    {
                      catch_fleet(t, f, 1) += Hrate(f, t) * elem_prod(natage(t, p, g), sel_bio(s, f, g)) * Zrate2(p, g);
                      catch_fleet(t, f, 2) += Hrate(f, t) * elem_prod(natage(t, p, g), sel_dead_bio(s, f, g)) * Zrate2(p, g);
                      catch_fleet(t, f, 3) += Hrate(f, t) * elem_prod(natage(t, p, g), sel_ret_bio(s, f, g)) * Zrate2(p, g); // retained bio
                      catch_fleet(t, f, 4) += Hrate(f, t) * elem_prod(natage(t, p, g), sel_num(s, f, g)) * Zrate2(p, g);
                      catch_fleet(t, f, 5) += Hrate(f, t) * elem_prod(natage(t, p, g), sel_dead_num(s, f, g)) * Zrate2(p, g);
                      catch_fleet(t, f, 6) += Hrate(f, t) * elem_prod(natage(t, p, g), sel_ret_num(s, f, g)) * Zrate2(p, g); // retained numbers
                      catage(t, f, g) = Hrate(f, t) * elem_prod(elem_prod(natage(t, p, g), sel_dead_num(s, f, g)), Zrate2(p, g));
                      if (Do_Retain(f) > 0)
                      {
                        disc_age(t, disc_fleet_list(f), g) = Hrate(f, t) * elem_prod(elem_prod(natage(t, p, g), sel_num(s, f, g)), Zrate2(p, g)); //  selected numbers
                        disc_age(t, disc_fleet_list(f) + N_retain_fleets, g) = Hrate(f, t) * elem_prod(elem_prod(natage(t, p, g), sel_ret_num(s, f, g)), Zrate2(p, g)); //  selected numbers
                      }
                    } //close gmorph loop
                }
              } // close fishery
            } //  end continuous F method
          }
          else  //  doing F with Pope's approximation.  Predators cannot be used
          {
            //  SS_Label_Info_24.3.3.1 #Use F_Method=1 for Pope's approximation
            //  SS_Label_Info_24.3.3.1.1 #note that pred_M2 not implemented for Pope's
            for (int ff = 1; ff <= N_catchfleets(p); ff++)
            {
              f = fish_fleet_area(p, ff);
              if (catch_seas_area(t, p, f) == 1)
              {
                dvar_matrix catage_w = catage(t, f); // do shallow copy

                //  SS_Label_Info_24.3.3.1.2 #loop over platoons and calculate the vulnerable biomass for each fleet
                vbio.initialize();
                for (g = 1; g <= gmorph; g++)
                  if (use_morph(g) > 0)
                  {
                    // use sel_l to get total catch and use sel_l_r to get retained vbio
                    // note that vbio in numbers can be used for both survey abund and fishery available "biomass"
                    // vbio is for retained catch only;  harvest rate = retainedcatch/vbio;
                    // then harvestrate*catage_w = total kill by this fishery for this morph

                    if (catchunits(f) == 1)
                    {
                      vbio += Nmid(g) * sel_ret_bio(s, f, g);
                    } // retained catch bio
                    else
                    {
                      vbio += Nmid(g) * sel_ret_num(s, f, g);
                    } // retained catch numbers

                  } //close gmorph loop
                if (docheckup == 1)
                  echoinput << "fleet vbio obs_catch catch_mult vbio*catchmult" << f << " " << vbio << " " << catch_ret_obs(f, t) << " " << catch_mult(y, f) << " " << catch_mult(y, f) * vbio << endl;
                //  SS_Label_Info_24.3.3.1.3 #Calculate harvest rate for each fleet from catch/vulnerable biomass
                crashtemp1 = 0.;
                crashtemp = max_harvest_rate - catch_ret_obs(f, t) / (catch_mult(y, f) * vbio + NilNumbers);
                crashtemp1 = posfun(crashtemp, 0.000001, CrashPen);
                harvest_rate = max_harvest_rate - crashtemp1;
                if (crashtemp < 0. && rundetail >= 2)
                {
                  cout << y << " " << f << " crash vbio*catchmult " << catch_ret_obs(f, t) / (catch_mult(y, f) * (vbio + NilNumbers)) << " " << crashtemp << " " << crashtemp1 << " " << CrashPen << " " << harvest_rate << endl;
                }
                Hrate(f, t) = harvest_rate;

                //  SS_Label_Info_24.3.3.1.4 #Store various catch quantities in catch_fleet
                for (g = 1; g <= gmorph; g++)
                  if (use_morph(g) > 0)
                  {
                    catage_w(g) = harvest_rate * elem_prod(Nmid(g), sel_dead_num(s, f, g)); // total kill numbers at age
                    if (docheckup == 1)
                      echoinput << "killrate " << sel_dead_num(s, f, g)(0, min(6, nages)) << endl;
                    catage_tot(g) += catage_w(g); //catch at age for all fleets
                    catch_fleet(t, f, 2) += Hrate(f, t) * Nmid(g) * sel_dead_bio(s, f, g); // total fishery kill in biomass
                    catch_fleet(t, f, 5) += Hrate(f, t) * Nmid(g) * sel_dead_num(s, f, g); // total fishery kill in numbers
                    catch_fleet(t, f, 1) += Hrate(f, t) * Nmid(g) * sel_bio(s, f, g); //  total fishery encounter in biomass
                    catch_fleet(t, f, 3) += Hrate(f, t) * Nmid(g) * sel_ret_bio(s, f, g); // retained fishery kill in biomass
                    catch_fleet(t, f, 4) += Hrate(f, t) * Nmid(g) * sel_num(s, f, g); // encountered numbers
                    catch_fleet(t, f, 6) += Hrate(f, t) * Nmid(g) * sel_ret_num(s, f, g); // retained fishery kill in numbers
                  } // end g loop
              }
            } // close fishery

            //  SS_Label_Info_24.3.3.1.5 #Check for catch_total across fleets being greater than population numbers
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0)
              {
                for (a = 0; a <= nages; a++) //  check for negative abundance, starting at age 1
                {
                  if (natage(t, p, g, a) > 0.0)
                  {
                    crashtemp = max_harvest_rate - catage_tot(g, a) / (Nmid(g, a) + 0.0000001);
                    crashtemp1 = posfun(crashtemp, 0.000001, CrashPen);
                    if (crashtemp < 0. && rundetail >= 2)
                    {
                      cout << " crash age " << catage_tot(g, a) / (Nmid(g, a) + 0.0000001) << " " << crashtemp << " " << crashtemp1 << " " << CrashPen << " " << (max_harvest_rate - crashtemp1) * Nmid(g, a) << endl;
                    }
                    if (crashtemp < 0. && docheckup == 1)
                    {
                      echoinput << " crash age " << catage_tot(g, a) / (Nmid(g, a) + 0.0000001) << " " << crashtemp << " " << crashtemp1 << " " << CrashPen << " " << (max_harvest_rate - crashtemp1) * Nmid(g, a) << endl;
                    }
                    catage_tot(g, a) = (max_harvest_rate - crashtemp1) * Nmid(g, a);

                    temp = natage(t, p, g, a) * surv2(s, GP3(g), a) - catage_tot(g, a) * surv1(s, GP3(g), a);
                    Z_rate(t, p, g, a) = -log(temp / natage(t, p, g, a)) / seasdur(s);
                  }
                  else
                  {
                    Z_rate(t, p, g, a) = -log(surv2(s, GP3(g), a)) / seasdur(s);
                  }
                }
                if (docheckup == 1)
                  echoinput << y << " " << s << "total catch-at-age for morph " << g << " " << catage_tot(g)(0, min(6, nages)) << " Z: " << Z_rate(t, p, g)(0, min(6, nages)) << endl;
              }
          } //  end Pope's approx
        } //  end have some catch in this seas x area
        else
        {
          //  SS_Label_Info_24.3.3.4 #No catch or fishery turned off, so set Z=M
          for (g = 1; g <= gmorph; g++)
            if (use_morph(g) > 0)
            {
              Z_rate(t, p, g) = natM(t, p, GP3(g));  //  includes predators
              Zrate2(p, g) = elem_div((1. - mfexp(-seasdur(s) * Z_rate(t, p, g))), Z_rate(t, p, g));
            }
        }

      //  SS_Label_Info_24.3.3.4 #save vulnerable biomass and numbers.  Use middle of season
        if (bigsaver == 1)
        {
          vuln_bio(t) = 0.0;
          vuln_num(t) = 0.0;
          for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            for (f = 1; f<= Nfleet; f++)
            {
              vuln_bio(t, f) += sel_bio(s, f, g) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * 0.5 * seasdur(s)));
              vuln_num(t, f) += sel_num(s, f, g) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * 0.5 * seasdur(s)));
            }
          }
        }
        for (f1 = 1; f1 <= N_pred; f1++)
        {
          f = predator(f1);
          for (g = 1; g <= gmorph; g++)
            if (use_morph(g) > 0)
            {
              catch_fleet(t, f, 1) += pred_M2(f1, t) * elem_prod(natage(t, p, g), sel_bio(s, f, g)) * Zrate2(p, g);
              catch_fleet(t, f, 2) += pred_M2(f1, t) * elem_prod(natage(t, p, g), sel_dead_bio(s, f, g)) * Zrate2(p, g);
              catch_fleet(t, f, 3) += pred_M2(f1, t) * elem_prod(natage(t, p, g), sel_ret_bio(s, f, g)) * Zrate2(p, g); // retained bio
              catch_fleet(t, f, 4) += pred_M2(f1, t) * elem_prod(natage(t, p, g), sel_num(s, f, g)) * Zrate2(p, g);
              catch_fleet(t, f, 5) += pred_M2(f1, t) * elem_prod(natage(t, p, g), sel_dead_num(s, f, g)) * Zrate2(p, g);
              catch_fleet(t, f, 6) += pred_M2(f1, t) * elem_prod(natage(t, p, g), sel_ret_num(s, f, g)) * Zrate2(p, g); // retained numbers
              catage(t, f, g) = pred_M2(f1, t) * elem_prod(elem_prod(natage(t, p, g), sel_dead_num(s, f, g)), Zrate2(p, g));
            } //close gmorph loop
        }
      } //close area loop
      if (s == 1 && save_for_report == 1)
      {
        Smry_Table(y, 1) = totbio;
        Smry_Table(y, 2) = smrybio;
        Smry_Table(y, 3) = smrynum;
      }
      //  SS_Label_Info_24.3.4 #Compute spawning biomass if occurs after start of current season
      //  SPAWN-RECR:   calc spawn biomass in time series if after beginning of the season
      if (s == spawn_seas && spawn_time_seas >= 0.0001) //  compute spawning biomass
      {
        SSB_pop_gp(y).initialize();
        SSB_B_yr(y).initialize();
        SSB_N_yr(y).initialize();
        Smry_Table(y, 15) = 0.0;
        for (p = 1; p <= pop; p++)
        {
          for (g = 1; g <= gmorph; g++)
            if (sx(g) == 1 && use_morph(g) > 0) //  female
            {
              SSB_pop_gp(y, p, GP4(g)) += fracfemale_mult * fec(g) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas)); // accumulates SSB by area and by growthpattern
              SSB_B_yr(y) += fracfemale_mult * make_mature_bio(GP4(g)) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas));
              SSB_N_yr(y) += fracfemale_mult * make_mature_numbers(GP4(g)) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas));
              Smry_Table(y, 15) += fracfemale_mult * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas)) * elem_prod(fec(g), r_ages);  //  for mean age of female spawners = GenTime
            }
        }
        SSB_current = sum(SSB_pop_gp(y));
        SSB_yr(y) = SSB_current;
        if (Hermaphro_Option != 0) // get male biomass
        {
          MaleSSB(y).initialize();
          for (p = 1; p <= pop; p++)
          {
            for (g = 1; g <= gmorph; g++)
              if (sx(g) == 2 && use_morph(g) > 0) //  male; all assumed to be mature
              {
                MaleSSB(y, p, GP4(g)) += Wt_Age_t(t, 0, g) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas)); // accumulates SSB by area and by growthpattern
              }
          }
          if (Hermaphro_maleSSB > 0.0) // add MaleSSB to female SSB
          {
            SSB_current += Hermaphro_maleSSB * sum(MaleSSB(y));
            SSB_yr(y) = SSB_current;
          }
        }
        //  SS_Label_Info_24.3.4.1 #Get recruitment from this spawning biomass at some time during the season
        //  SPAWN-RECR:   calc recruitment in time series; need to make this area-specific
        //  SR_fxn
        if (timevary_SRparm(y) == 0) //  SRparm use virgin values (but regime still could be)
        {
          R0_use = Recr_virgin;
          SSB_use = SSB_virgin;
//          warning << y << " virgin_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;
        }
        else if (timevary_SRparm(y) == 1)  //  update R0_use and SSB_use in this year
                                           //  values will carry forward into subsequent years
        {
          R0_use = mfexp(SRparm_work(1));
          //  timevary steepness is in SRparm_work(2) and will be applied inside of Equil_Spawn_Recr_Fxn() and Spawn_Recr()
          equ_Recr = R0_use;
          Fishon = 0;
          eq_yr = y;
          bio_yr = y;
          SSBpR_Calc(R0_use); //  call function to do per recruit calculation with current year's biology and adjusted R0
          SSB_use = SSB_equil;
//          warning << y << " update_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;

          if (fishery_on_off == 1)
          {
            Fishon = 1;
          }
          else
          {
            Fishon = 0;
          }
        }
        else  //  flag is 2
        {
//          warning << y << " carry_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;
        }
        Recruits = Spawn_Recr(SRparm_work, SSB_use, R0_use, SSB_current); // calls to function Spawn_Recr using either virgin or adjusted R0 and SSB0
        if (SR_fxn != 7) apply_recdev(Recruits, R0_use); //  apply recruitment deviation

        // distribute Recruitment among settlements, areas and morphs
        //  note that because SSB_current is calculated at end of season to take into account Z,
        //  this means that recruitment cannot occur until a subsequent season
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            settle = settle_g(g);
            for (p = 1; p <= pop; p++)
            {
              if (y == styr)
                natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) = 0.0; //  to negate the additive code

              natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) += Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g)) *
                  mfexp(natM(t, p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle));
                Recr(p, t + Settle_seas_offset(settle)) += Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g));
              if (docheckup == 1)
                echoinput << y << " Recruits, dist, surv, result" << Recruits << " " << recr_dist(y, GP(g), settle, p) << " " << mfexp(natM(t, p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle)) << " " << natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) << endl;
            }
          }
      }

      //  SS_Label_Info_24.6 #Survival to next season and saving midseason numbers and biomass
      for (p = 1; p <= pop; p++)
      {
        if (s == nseas)
        {
          k = 1;
        }
        else
        {
          k = 0;
        } //      advance age or not
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            settle = settle_g(g);

            {
              j = Settle_age(settle);
              if (s < nseas && Settle_seas(settle) <= s)
              {
                natage(t + 1, p, g, j) = natage(t, p, g, j) * mfexp(-Z_rate(t, p, g, j) * seasdur(s)); // advance new recruits within year
              }
              for (a = j + 1; a < nages; a++)
              {
                natage(t + 1, p, g, a) = natage(t, p, g, a - k) * mfexp(-Z_rate(t, p, g, a - k) * seasdur(s));
              }
              natage(t + 1, p, g, nages) = natage(t, p, g, nages) * mfexp(-Z_rate(t, p, g, nages) * seasdur(s)); // plus group
              if (s == nseas)
                natage(t + 1, p, g, nages) += natage(t, p, g, nages - 1) * mfexp(-Z_rate(t, p, g, nages - 1) * seasdur(s));
              if (save_for_report == 1)
              {
                j = p + pop;
                ALK_idx = (s - 1) * N_subseas + mid_subseas;
                for (a = 0; a <= nages; a++)
                {
                  Save_PopLen(t, j, g) += value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s))) * value(ALK(ALK_idx, g, a));
                  Save_PopWt(t, j, g) += value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s))) * value(elem_prod(ALK(ALK_idx, g, a), wt_len(s, GP(g))));
                  Save_PopAge(t, j, g, a) = value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s)));
                  Save_PopBio(t, j, g, a) = value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s))) * value(Wt_Age_mid(s, g, a));
                } // close age loop
              }
            }
            if (docheckup == 1)
            {
              echoinput << g << " natM:   " << natM(t, p, GP3(g))(0, min(6, nages)) << endl;
              echoinput << g << " Z:      " << Z_rate(t, p, g)(0, min(6, nages)) << endl;
              echoinput << g << " N_surv: " << natage(t + 1, p, g)(0, min(6, nages)) << endl;
            }
          } // close gmorph loop
      }

      //  SS_Label_Info_24.7  #call to Get_expected_values
      Get_expected_values(y, t);
      //  SS_Label_Info_24.8  #hermaphroditism
      if (Hermaphro_Option != 0)
      {
        if (Hermaphro_seas == -1 || Hermaphro_seas == s)
        {
          k = gmorph / 2; //  because first half of the "g" are females
          for (p = 1; p <= pop; p++) //   area
            for (g = 1; g <= k; g++) //  loop females
              if (use_morph(g) > 0)
              {
                if (Hermaphro_Option == 1)
                {
                  for (a = 1; a < nages; a++)
                  {
                    natage(t + 1, p, g + k, a) += natage(t + 1, p, g, a) * Hermaphro_val(GP4(g), a - 1); // increment males with females
                    natage(t + 1, p, g, a) *= (1. - Hermaphro_val(GP4(g), a - 1)); // decrement females
                  }
                }
                else if (Hermaphro_Option == -1)
                {
                  for (a = 1; a < nages; a++)
                  {
                    natage(t + 1, p, g, a) += natage(t + 1, p, g + k, a) * Hermaphro_val(GP4(g + k), a - 1); // increment females with males
                    natage(t + 1, p, g + k, a) *= (1. - Hermaphro_val(GP4(g + k), a - 1)); // decrement males
                  }
                }
              }
        }
      }

      //  SS_Label_Info_24.9  #migration
      //do migration between populations, for each gmorph and age  PROBLEM  need new container so future recruits not wiped out!
      if (do_migration > 0) // movement between areas in time series
      {
        natage_temp = natage(t + 1);
        natage(t + 1) = 0.0;
        for (p = 1; p <= pop; p++) //   source population
          for (p2 = 1; p2 <= pop; p2++) //  destination population
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0)
              {
                k = move_pattern(s, GP4(g), p, p2);
                if (k > 0)
                  natage(t + 1, p2, g) += elem_prod(natage_temp(p, g), migrrate(y, k));
              }
      } //  end migration

      //  SS_Label_Info_24.10  #save selectivity*Hrate for tag-recapture
      if (Do_TG > 0 && t >= TG_timestart)
      {
        for (g = 1; g <= gmorph; g++)
          for (f = 1; f <= Nfleet; f++)
          {
            Sel_for_tag(t, f, g) = sel_ret_num(s, f, g) * Hrate(f, t);
          }
      }

      //  SS_Label_Info_24.11  #calc annual F quantities
      double countN;
      dvariable tempbase;
      dvariable tempM;
      dvariable tempZ;
      if (fishery_on_off == 1 && (bigsaver == 1 || (F_ballpark_yr >= styr)))
      {
        for (int ff = 1; ff <= N_catchfleets(0); ff++)
        {
          f = fish_fleet_area(0, ff);
          for (k = 1; k <= 6; k++)
          {
            annual_catch(y, k) += catch_fleet(t, f, k);
            if (k <= 3)
              Smry_Table(y, k + 3) = annual_catch(y, k);
          }
          if (F_Method == 1)
          {
            annual_F(y, 1) += Hrate(f, t);
          }
          else
          {
            annual_F(y, 1) += Hrate(f, t) * seasdur(s);
          }
        }

        if (s == nseas)
        {
          //  sum across p and g the number of survivors to end of the year
          //  also project from the initial numbers and M, the number of survivors without F
          //  then F = ln(n+1/n)(M+F) - ln(n+1/n)(M only), but ln(n) cancels out, so only need the ln of the ratio of the two ending quantities

          // calculated average F weighted by numbers (option 5 is unweighted)
          if (F_reporting != 5)
          {
            tempbase = 0.0;
            tempM = 0.0;
            tempZ = 0.0;
            annual_F(y, 2) = 0.;
            annual_F(y, 3) = 0.;
            //  accumulate numbers across ages, morphs, sexes, areas
            for (a = F_reporting_ages(1); a <= F_reporting_ages(2); a++) //  should not let a go higher than nages-2 because of accumulator
            {
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  for (p = 1; p <= pop; p++)
                  {
                    tempbase += natage(t - nseas + 1, p, g, a); // sum of numbers at beginning of year
                    tempZ += natage(t + 1, p, g, a + 1); // numbers at beginning of next year
                    temp3 = natage(t - nseas + 1, p, g, a); //  numbers at begin of year
                    for (j = 1; j <= nseas; j++)
                    {
                      temp3 *= mfexp(-seasdur(j) * natM(t - nseas + j, p, GP3(g), a));
                    }
                    tempM += temp3; //  survivors if just M operating
                  }
                }
            }
            annual_F(y, 2) = log(tempM) - log(tempZ); // F=Z-M
            annual_F(y, 3) = log(tempbase) - log(tempM); // M
          } // end if F_reporting!=5

          else
          { // F_reporting==5 (ICES-style arithmetic mean across ages)
            //  like option 4 above, but F is calculated 1 age at a time to get a
            //  unweighted average across ages within each year
            countN = 0.0; // used for count of Fs included in average
            for (a = F_reporting_ages(1); a <= F_reporting_ages(2); a++) //  should not let a go higher than nages-2 because of accumulator
            {
              tempbase = 0.0;
              tempM = 0.0;
              tempZ = 0.0;
              //  accumulate numbers across all morphs, sexes, and areas
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  for (p = 1; p <= pop; p++)
                  {
                    tempbase += natage(t - nseas + 1, p, g, a); // sum of numbers at beginning of year
                    tempZ += natage(t + 1, p, g, a + 1); // numbers at beginning of next year
                    temp3 = natage(t - nseas + 1, p, g, a); //  numbers at begin of year
                    for (j = 1; j <= nseas; j++)
                    {
                      temp3 *= mfexp(-seasdur(j) * natM(t - nseas + j, p, GP3(g), a));
                    }
                    tempM += temp3; //  survivors if just M operating
                  }
                }
              //  calc F and M for this age and add to the total
              countN += 1; // increment count of values included in average
              annual_F(y, 2) += log(tempM) - log(tempZ); // F=Z-M
              annual_F(y, 3) += log(tempbase) - log(tempM); // M
            }
            annual_F(y, 3) /= countN; // M
            annual_F(y, 2) /= countN; // F
          } // end F_reporting==5

          if (STD_Yr_Reverse_F(y) > 0) //  save selected std quantity
          {
            if (F_reporting <= 1)
            {
              F_std(STD_Yr_Reverse_F(y)) = annual_catch(y, 2) / Smry_Table(y, 2); // dead catch biomass/summary biomass
              //  does not exactly correspond to F, which is for total catch
            }
            else if (F_reporting == 2)
            {
              F_std(STD_Yr_Reverse_F(y)) = annual_catch(y, 5) / Smry_Table(y, 3); // dead catch numbers/summary numbers
            }
            else if (F_reporting == 3)
            {
              F_std(STD_Yr_Reverse_F(y)) = annual_F(y, 1);
            }
            else if (F_reporting == 4 || F_reporting == 5)
            {
              F_std(STD_Yr_Reverse_F(y)) = annual_F(y, 2);
            }
          }
        } //  end s==nseas
      }
      if (write_bodywt > 0)
      {
        for (g = 1; g <= gmorph; g++)
        {
          gg = sx(g);

          if (ishadow(GP2(g)) == 0)
          {
            if (s == spawn_seas)
              bodywtout << y << " " << s << " " << gg << " " << GP4(g) << " " << Bseas(g) << " " << -2 << " " << fec(g) << " #fecundity " << endl;
            bodywtout << y << " " << s << " " << gg << " " << GP4(g) << " " << Bseas(g) << " " << 0 << " " << Wt_Age_beg(s, g) << " #popwt_beg " << endl;
            bodywtout << y << " " << s << " " << gg << " " << GP4(g) << " " << Bseas(g) << " " << -1 << " " << Wt_Age_mid(s, g) << " #popwt_mid " << endl;
          }
        }
      }
    } //close season loop
    //  SS_Label_Info_24.12 #End loop of seasons

    //  SS_Label_Info_24.13 #Use current F intensity to calculate the equilibrium SPR for this year
    //    if( (save_for_report>0) || ((sd_phase() || mceval_phase()) && (initial_params::mc_phase==0)) )
    if (bigsaver == 1)
    {
      eq_yr = y;
      equ_Recr = Recr_virgin;
      bio_yr = y;
      Fishon = 0;
      SSBpR_Calc(equ_Recr); //  call function to do per recruit calculation with current year's biology
      Smry_Table(y, 11) = SSB_equil;
      Smry_Table(y, 13) = GenTime;
      if( SR_fxn == 10 )
      {
        temp = SSB_equil / Recr_virgin;  //  current year's SSB/R with current biology at age
        alpha = mfexp(SRparm_work(3));
        beta = mfexp(SRparm_work(4));
        SRparm_byyr(y, 2) =  alpha * temp / (4. + alpha * temp);  //  implied steepness
        SRparm_byyr(y, 1) = log( 1. / beta * (alpha - (1. / temp)));  //  implied ln_R0
      }
      Fishon = 1;
      SSBpR_Calc(equ_Recr); //  call function to do per recruit calculation with current year's biology and F
      if (STD_Yr_Reverse_Ofish(y) > 0)
      {
        SPR_std(STD_Yr_Reverse_Ofish(y)) = SSB_equil / Smry_Table(y, 11);
      }
      Smry_Table(y, 9) = (totbio);
      Smry_Table(y, 10) = (smrybio);
      Smry_Table(y, 12) = (SSB_equil);
      Smry_Table(y, 14) = (YPR_dead);
    }
  } //close year loop

  //  average quantities accumulated during the time series
  if (Do_Benchmark > 0)
  {
    recr_dist(styr - 3) = recr_dist_unf / float(Bmark_Yr(8) - Bmark_Yr(7) + 1);
  }

  if (Do_TG > 0)
    Tag_Recapture();

  } //  end time_series
  #ifdef DO_ONCE
  if (do_once == 1)
  echoinput << " finished time series " << endl;
  #endif

//  SS_Label_Info_24.16  # end of time series function

//********************************************************************
 /*  SS_Label_FUNCTION 30 Do_Equil_Calc */
 // This function does per recruit calculations, so produces an age composition that is in equilibrium with M+F
FUNCTION void SSBpR_Calc(const prevariable& equ_Recr)
  {
  int t_base;
  int t;
  int s;
  dvariable N_mid;
  dvariable N_beg;
  dvariable tempM, countN, tempZ, tempbase, temp3;
  dvariable Fishery_Survival;
  dvariable crashtemp;
  dvariable crashtemp1;
  dvar_matrix Survivors(1, pop, 1, gmorph);
  dvar_matrix Survivors2(1, pop, 1, gmorph);

  t_base = styr + (eq_yr - styr) * nseas - 1;
  GenTime.initialize();
  Equ_penalty.initialize();
  SSB_equil_pop_gp.initialize();
  if (Hermaphro_Option != 0)
    MaleSSB_equil_pop_gp.initialize();
  equ_mat_bio = 0.0;
  equ_mat_num = 0.0;
  equ_catch_fleet.initialize();
  equ_numbers.initialize();
  equ_catage.initialize();
  equ_F_std = 0.0;
  equ_M_std = 0.0;
  totbio = 0.0;
  smrybio = 0.0;
  smryage = 0.0;
  smrynum = 0.0;
  GenTime = 0.0;

  // first seed the recruits; seems redundant
  for (g = 1; g <= gmorph; g++)
  {
    if (use_morph(g) > 0)
    {
      settle = settle_g(g);

      for (p = 1; p <= pop; p++)
      {
        equ_numbers(Settle_seas(settle), p, g, Settle_age(settle)) = equ_Recr * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g)) *
            mfexp(natM(t_base + Settle_seas(settle), p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle));
      }
    }
  }

  for (a = 0; a <= 3 * nages; a++) // go to 3x nages to approximate the infinite tail, then add the infinite tail
  {
    if (a <= nages)
    {
      a1 = a;
    }
    else
    {
      a1 = nages;
    } // because selex and biology max out at nages

    for (s = 1; s <= nseas; s++)
    {
      t = t_base + s;

      for (g = 1; g <= gmorph; g++) //  need to loop g inside of a because of hermaphroditism
        if (use_morph(g) > 0)
        {
          gg = sx(g); // gender
          settle = settle_g(g);

          for (p = 1; p <= pop; p++)
          {
            if (s == Settle_seas(settle) && a == Settle_age(settle))
            {
              equ_numbers(Settle_seas(settle), p, g, Settle_age(settle)) = equ_Recr * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g)) *
                  mfexp(natM(t_base + Settle_seas(settle), p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle));
            }

            if (equ_numbers(s, p, g, a) > 0.0) //  will only be zero if not yet settled
            {
              N_beg = equ_numbers(s, p, g, a);
              if (F_Method == 1) // Pope's approx
              {
                N_mid = N_beg * surv1(s, GP3(g), a1); // numbers at middle of season
                Nsurvive = N_mid; // initial number of fishery survivors
                if (Fishon == 1)
                { //  remove catch this round
                  // check to see if total harves would exceed max_harvest_rate
                  crashtemp = 0.;
                  harvest_rate = 1.0;
                  for (int ff = 1; ff <= N_catchfleets(p); ff++)
                  {
                    f = fish_fleet_area(p, ff);
                    crashtemp += Hrate(f, t) * sel_dead_num(s, f, g, a1);
                  }

                  if (crashtemp > 0.20) // only worry about this if the exploit rate is at all high
                  {
                    join1 = 1. / (1. + mfexp(40.0 * (crashtemp - max_harvest_rate))); // steep joiner logistic curve at limit
                    upselex = 1. / (1. + mfexp(Equ_F_joiner * (crashtemp - 0.2))); //  value of a shallow logistic curve that goes through the limit
                    harvest_rate = join1 + (1. - join1) * upselex / (crashtemp); // ratio by which all Hrates will be adjusted
                  }

                  for (int ff = 1; ff <= N_catchfleets(p); ff++)
                  {
                    f = fish_fleet_area(p, ff);
                    temp = N_mid * Hrate(f, t) * harvest_rate; // numbers that would be caught if fully selected
                    Nsurvive -= temp * sel_dead_num(s, f, g, a1); //  survival from fishery kill
                    equ_catch_fleet(2, s, f) += temp * sel_dead_bio(s, f, g, a1);
                    equ_catch_fleet(5, s, f) += temp * sel_dead_num(s, f, g, a1);
                    equ_catch_fleet(3, s, f) += temp * sel_ret_bio(s, f, g, a1); // retained fishery kill in biomass

                    equ_catch_fleet(1, s, f) += temp * sel_bio(s, f, g, a1); //  total fishery encounter in biomass
                    equ_catch_fleet(4, s, f) += temp * sel_num(s, f, g, a1); // total fishery encounter in numbers
                    equ_catch_fleet(6, s, f) += temp * sel_ret_num(s, f, g, a1); // retained fishery kill in numbers
                    equ_catage(s, f, g, a1) += temp * sel_dead_num(s, f, g, a1); //  dead catch numbers per recruit  (later accumulate N in a1)
                  }
                } // end removing catch

                Nsurvive *= surv1(s, GP3(g), a1); // decay to end of season

                if (a <= a1)
                {
                  equ_Z(s, p, g, a1) = -(log((Nsurvive + 1.0e-13) / (N_beg + 1.0e-10))) / seasdur(s);
                  Fishery_Survival = equ_Z(s, p, g, a1) - natM(t, p, GP3(g), a1);
                }

              } // end Pope's approx

              else // Continuous F for method 2 or 3
              {
                equ_Z(s, p, g, a1) = natM(t, p, GP3(g), a1);
                if (Fishon == 1)
                {
                  if (a1 <= nages)
                  {
                    for (int ff = 1; ff <= N_catchfleets(p); ff++)
                    {
                      f = fish_fleet_area(p, ff);
                      equ_Z(s, p, g, a1) += sel_dead_num(s, f, g, a1) * Hrate(f, t);
                    }
                  }
                }
                Nsurvive = N_beg * mfexp(-seasdur(s) * equ_Z(s, p, g, a1));
              } //  end F method
              Survivors(p, g) = Nsurvive;
            }
            else
            {
              equ_Z(s, p, g, a1) = natM(t, p, GP3(g), a1);
            }
          } // end pop
        } // end morph

      if (Hermaphro_Option != 0)
      {
        if (Hermaphro_seas == -1 || Hermaphro_seas == s)
        {
          for (p = 1; p <= pop; p++)
          {
            k = gmorph / 2;
            for (g = 1; g <= k; g++)
              if (use_morph(g) > 0)
              {
                if (Hermaphro_Option == 1)
                {
                  Survivors(p, g + k) += Survivors(p, g) * Hermaphro_val(GP4(g), a1); // increment males with females
                  Survivors(p, g) *= (1. - Hermaphro_val(GP4(g), a1)); // decrement females
                }
                else if (Hermaphro_Option == -1)
                {
                  Survivors(p, g) += Survivors(p, g + k) * Hermaphro_val(GP4(g + k), a1); // increment females with males
                  Survivors(p, g + k) *= (1. - Hermaphro_val(GP4(g + k), a1)); // decrement males
                }
              }
          }
        }
      }
      if (do_migration > 0) // movement between areas in equil calcs
      {
        Survivors2.initialize();
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            for (p = 1; p <= pop; p++)
              for (p2 = 1; p2 <= pop; p2++)
              {
                k = move_pattern(s, GP4(g), p, p2);
                if (k > 0)
                  Survivors2(p2, g) += Survivors(p, g) * migrrate(bio_yr, k, a1);
              } // end destination pop
          }
        Survivors = Survivors2;
      } // end do migration

      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (p = 1; p <= pop; p++)
          {
            if (s == nseas) // into next age at season 1
            {
              if (a == 3 * nages)
              {
                // end of the cohort
              }
              else if (a == (3 * nages - 1)) // do infinite tail; note that it uses Z from nseas as if it applies annually
              {
                if (F_Method == 1)
                {
                  equ_numbers(1, p, g, a + 1) = Survivors(p, g) / (1. - exp(-equ_Z(nseas, p, g, nages)));
                }
                else
                {
                  equ_numbers(1, p, g, a + 1) = Survivors(p, g) / (1. - exp(-equ_Z(nseas, p, g, nages)));
                }
              }
              else
              {
                equ_numbers(1, p, g, a + 1) = Survivors(p, g);
              }
            }
            else
            {
              equ_numbers(s + 1, p, g, a) = Survivors(p, g); // same age, next season
            }
          }
        }
    } // end season
  } // end age

  // now calc contribution to catch and ssb
  for (g = 1; g <= gmorph; g++)
    if (use_morph(g) > 0)
    {
      gg = sx(g);
      for (s = 1; s <= nseas; s++)
        for (p = 1; p <= pop; p++)
        {
          t = t_base + s;
          Zrate2(p, g) = elem_div((1. - mfexp(-seasdur(s) * equ_Z(s, p, g))), equ_Z(s, p, g));
          equ_numbers(s, p, g, nages) += sum(equ_numbers(s, p, g)(nages + 1, 3 * nages));
          if (Fishon == 1)
          {
            if (F_Method >= 2)
            {
              if (s < Bseas(g))
                Zrate2(p, g, 0) = 0.0;
              for (int ff = 1; ff <= N_catchfleets(p); ff++)
              {
                f = fish_fleet_area(p, ff);
                equ_catch_fleet(2, s, f) += Hrate(f, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_dead_bio(s, f, g)) * Zrate2(p, g); // dead catch bio
                equ_catch_fleet(5, s, f) += Hrate(f, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_dead_num(s, f, g)) * Zrate2(p, g); // deadfish catch numbers
                equ_catch_fleet(3, s, f) += Hrate(f, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_ret_bio(s, f, g)) * Zrate2(p, g); // retained catch bio
                equ_catch_fleet(1, s, f) += Hrate(f, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_bio(s, f, g)) * Zrate2(p, g); // encountered catch bio
                equ_catch_fleet(4, s, f) += Hrate(f, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_num(s, f, g)) * Zrate2(p, g); // encountered catch bio
                equ_catch_fleet(6, s, f) += Hrate(f, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_ret_num(s, f, g)) * Zrate2(p, g); // retained catch numbers
                equ_catage(s, f, g) = Hrate(f, t) * elem_prod(elem_prod(equ_numbers(s, p, g)(0, nages), sel_dead_num(s, f, g)), Zrate2(p, g));
              }
            }
            else // F_method=1
            {
              // already done in the age loop
            }
          }
          
          for (f1 = 1; f1 <= N_pred; f1++)
          {
            f = predator(f1);
            equ_catch_fleet(2, s, f) += pred_M2(f1, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_dead_bio(s, f, g)) * Zrate2(p, g); // dead catch bio
            equ_catch_fleet(5, s, f) += pred_M2(f1, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_dead_num(s, f, g)) * Zrate2(p, g); // deadfish catch numbers
            equ_catch_fleet(3, s, f) += pred_M2(f1, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_ret_bio(s, f, g)) * Zrate2(p, g); // retained catch bio
            equ_catch_fleet(1, s, f) += pred_M2(f1, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_bio(s, f, g)) * Zrate2(p, g); // encountered catch bio
            equ_catch_fleet(4, s, f) += pred_M2(f1, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_num(s, f, g)) * Zrate2(p, g); // encountered catch bio
            equ_catch_fleet(6, s, f) += pred_M2(f1, t) * elem_prod(equ_numbers(s, p, g)(0, nages), sel_ret_num(s, f, g)) * Zrate2(p, g); // retained catch numbers
            equ_catage(s, f, g) = pred_M2(f1, t) * elem_prod(elem_prod(equ_numbers(s, p, g)(0, nages), sel_dead_num(s, f, g)), Zrate2(p, g));
          }

          if (s == 1)
          {
            totbio += equ_numbers(s, p, g)(0, nages) * Wt_Age_beg(s, g)(0, nages);
            smrybio += equ_numbers(s, p, g)(Smry_Age, nages) * Wt_Age_beg(s, g)(Smry_Age, nages);
            smrynum += sum(equ_numbers(s, p, g)(Smry_Age, nages));
            smryage += equ_numbers(s, p, g)(Smry_Age, nages) * r_ages(Smry_Age, nages);
          }
          //  SPAWN-RECR:   calc generation time, etc.
          if (s == spawn_seas)
          {
            if (gg == 1) // compute equilibrium spawning biomass for females
            {
              tempvec_a = elem_prod(equ_numbers(s, p, g)(0, nages), mfexp(-spawn_time_seas * equ_Z(s, p, g)(0, nages)));
              SSB_equil_pop_gp(p, GP4(g)) += fracfemale_mult * tempvec_a * fec(g);
              equ_mat_bio += fracfemale_mult * elem_prod(equ_numbers(s, p, g)(0, nages), mfexp(-spawn_time_seas * equ_Z(s, p, g)(0, nages))) * make_mature_bio(GP4(g));
              equ_mat_num += fracfemale_mult * elem_prod(equ_numbers(s, p, g)(0, nages), mfexp(-spawn_time_seas * equ_Z(s, p, g)(0, nages))) * make_mature_numbers(GP4(g));
              GenTime += fracfemale_mult * tempvec_a * elem_prod(fec(g), r_ages);
              //               SSB_equil_pop_gp(p,GP4(g))+=tempvec_a*fec(g);
              //              equ_mat_bio+=elem_prod(equ_numbers(s,p,g)(0,nages),mfexp(-spawn_time_seas*equ_Z(s,p,g)(0,nages)))*make_mature_bio(GP4(g));
              //               equ_mat_num+=elem_prod(equ_numbers(s,p,g)(0,nages),mfexp(-spawn_time_seas*equ_Z(s,p,g)(0,nages)))*make_mature_numbers(GP4(g));
              //               GenTime+=tempvec_a*elem_prod(fec(g),r_ages);
            }
            else if (Hermaphro_Option != 0 && gg == 2)
            {
              tempvec_a = elem_prod(equ_numbers(s, p, g)(0, nages), mfexp(-spawn_time_seas * equ_Z(s, p, g)(0, nages)));
              MaleSSB_equil_pop_gp(p, GP4(g)) += tempvec_a * Wt_Age_beg(s, g)(0, nages);
            }
          }
        }
    }

  //      MSY_units:  quantity to be maximized: (1) dead catch biomass (status quo); (2) retained catch biomass; or (3) retained catch profits"<<endl;
  YPR_dead = sum(equ_catch_fleet(2)); // dead catch biomass per recruit
  YPR_N_dead = sum(equ_catch_fleet(5)); // dead numbers per recruit
  YPR_enc = sum(equ_catch_fleet(1)); //  encountered biomass per recruit
  YPR_ret = sum(equ_catch_fleet(3)); // retained biomass per recruit
  YPR_opt = 0.0; //dead biomass per recruit except excludes non-optimized bycatch
  // YPR_opt used in F0.1 and in biomass based MSY searches
  YPR_val_vec.initialize(); // retained biomass per recruit as vector, should be same as YPR_ret

  for (int ff = 1; ff <= N_catchfleets(0); ff++)
  {
    f = fish_fleet_area(0, ff);
    for (s = 1; s <= nseas; s++)
    {
      YPR_opt += equ_catch_fleet(2, s, f) * YPR_mask(f); //  using dead catch excluding non-optimized bycatch fleets
      YPR_val_vec(f) += equ_catch_fleet(3, s, f) * YPR_mask(f); //  using retained catch so YPR_mask should be redundant
    }
  }

  if (Fishon == 1)
  {
  //  shortcut.  equ_M_std using M for area 1, gp 1 only
    if (F_reporting <= 1)
    {
      equ_F_std = YPR_dead / smrybio;
      equ_M_std = natM(t_base + 1, 1, 1, int(nages / 2));
    }
    else if (F_reporting == 2)
    {
      equ_F_std = YPR_N_dead / smrynum;
      equ_M_std = natM(t_base + 1, 1, 1, int(nages / 2));
    }
    else if (F_reporting == 3)
    {
      equ_M_std = natM(t_base + 1, 1, 1, int(nages / 2));
      if (F_Method == 1)
      {
        for (s = 1; s <= nseas; s++)
        {
          t = t_base + s;
          for (int ff = 1; ff <= N_catchfleets(0); ff++)
          {
            f = fish_fleet_area(0, ff);
            equ_F_std += Hrate(f, t);
          }
        }
      }
      else
      {
        for (s = 1; s <= nseas; s++)
        {
          t = t_base + s;
          for (int ff = 1; ff <= N_catchfleets(0); ff++)
          {
            f = fish_fleet_area(0, ff);
            equ_F_std += Hrate(f, t) * seasdur(s);
          }
        }
      }
    }
    else if (F_reporting == 4)
    {
      tempbase = 0.0;
      tempM = 0.0;
      tempZ = 0.0;
      //  accumulate numbers across ages, morphs, sexes, areas
      for (a = F_reporting_ages(1); a <= F_reporting_ages(2); a++) //  should not let a go higher than nages-2 because of accumulator
      {
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            for (p = 1; p <= pop; p++)
            {
              tempbase += equ_numbers(1, p, g, a); // sum of numbers at beginning of year
              tempZ += equ_numbers(1, p, g, a + 1); // numbers at beginning of next year
              temp3 = equ_numbers(1, p, g, a); //  numbers at begin of year
              for (int kkk = 1; kkk <= nseas; kkk++)
              {
                temp3 *= mfexp(-seasdur(kkk) * natM(t_base+kkk, p, GP3(g), a));
              }
              tempM += temp3; //  survivors if just M operating
            }
          }
      }
      equ_F_std = log(tempM) - log(tempZ); // F=Z-M
      equ_M_std = log(tempbase) - log(tempM); // M
    }
    else if (F_reporting == 5)
    {
      //  F_reporting==5 (ICES-style arithmetic mean across ages)
      //  like option 4 above, but F is calculated 1 age at a time to get a
      //  unweighted average across ages within each year
      //  Need to put area loop within age loop
      countN = 0.0; // used for count of Fs included in average
      for (a = F_reporting_ages(1); a <= F_reporting_ages(2); a++) //  should not let a go higher than nages-2 because of accumulator
      {
        tempbase = 0.0;
        tempM = 0.0;
        tempZ = 0.0;
        //  accumulate numbers across all morphs, sexes, and areas
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            for (p = 1; p <= pop; p++)
            {
              tempbase += equ_numbers(1, p, g, a); // sum of numbers at beginning of year
              tempZ += equ_numbers(1, p, g, a + 1); // numbers at beginning of next year
              temp3 = equ_numbers(1, p, g, a); //  numbers at begin of year
              for (int kkk = 1; kkk <= nseas; kkk++)
              {
                temp3 *= mfexp(-seasdur(kkk) * natM(t_base+kkk, p, GP3(g), a));
              }
              tempM += temp3; //  survivors if just M operating
            }
          }
        // add F-at-age to tally
        countN += 1.; // increment count of values included in average
        equ_F_std += log(tempM) - log(tempZ); // F=Z-M
        equ_M_std += log(tempbase) - log(tempM); // M
      }
      equ_F_std /= countN;
      equ_M_std /= countN;
    } // end F_reporting==5
  }

  Cost = 0;
  for (f = 1; f <= Nfleet; f++)
  {
    if (YPR_mask(f) == 1)
    {
      for (s = 1; s <= nseas; s++)
      {
        Cost += CostPerF(f) * Hrate(f, t_base + s);
      }
    }
  }

  SSB_equil = sum(SSB_equil_pop_gp);
  GenTime /= SSB_equil;
  smryage /= smrynum;
  if (Hermaphro_maleSSB > 0.0) // add MaleSSB to female SSB
  {
    SSB_equil += Hermaphro_maleSSB * sum(MaleSSB_equil_pop_gp);
  }
  } //  end equil calcs

// SS_Label_file  #13. **SS_recruit.tpl**
// SS_Label_file  # * <u>Spawn_Recr()</u>  //  gets expected mean recruits from input spawning biomass
// SS_Label_file  # * <u>apply_recdev()</u>  //  applies recdev to the expected mean recruits
// SS_Label_file  # * <u>Equil_Spawn_Recr_Fxn()</u>  // gets equilibrium recruitment and spawning biomass from an input SPR

//********************************************************************
 /*  SS_Label_FUNCTION 43 Spawner-recruitment function */
//  SPAWN-RECR:   function: to calc R from S
FUNCTION dvariable Spawn_Recr(const dvar_vector& SRparm_work, const prevariable& SSB_virgin_use, const prevariable& Recr_virgin_use, const prevariable& SSB_current)
  {
  RETURN_ARRAYS_INCREMENT();
  dvariable NewRecruits;
  dvariable SSB_BH1;
  dvariable recdev_offset;
  dvariable steepness;
  dvariable Shepherd_c;
  dvariable Shepherd_c2;
  dvariable Hupper;
  dvariable steep2;
  dvariable SSB_curr_adj;
  dvariable join;
  dvariable SRZ_0;
  dvariable srz_min;
  dvariable SRZ_surv;
//  warning << y << "  Tester_R0 " <<  Recr_virgin_use << " SSB0 " << SSB_virgin_use << " SSB_curr: " << SSB_current << endl;

  //  SS_Label_43.1  add 0.1 to input spawning biomass value to make calculation more rebust
  SSB_curr_adj = SSB_current + 0.100; // robust

  regime_change = SRparm_work(N_SRparm2 - 1); //  this is a persistent deviation off the S/R curve

  //  SS_Label_43.3  calculate expected recruitment from the input spawning biomass and the SR curve
  // functions below use Recr_virgin_use,SSB_virgin_use which could have been adjusted adjusted above from R0,SSB_virgin
  switch (SR_fxn)
  {
    case 1: // previous placement for B-H constrained
    {
      warnstream << "B-H constrained curve is now Spawn-Recr option #6";
      write_message (FATAL, 0); // EXIT!
      break;
    }
    //  SS_Label_43.3.2  Ricker
    case 2: // ricker
    {
      steepness = SRparm_work(2);
      NewRecruits = Recr_virgin_use * SSB_curr_adj / SSB_virgin_use * mfexp(steepness * (1. - SSB_curr_adj / SSB_virgin_use));
      break;
    }
    //  SS_Label_43.3.3  Beverton-Holt
    case 3: // Beverton-Holt
    {
      steepness = SRparm_work(2);
      NewRecruits = (4. * steepness * Recr_virgin_use * SSB_curr_adj) /
          (SSB_virgin_use * (1. - steepness) + (5. * steepness - 1.) * SSB_curr_adj);
      break;
    }

      case 10: // Beverton-Holt with alpha beta  per WHAM:  R = A*S/(1+B*S)
      {
        dvariable alpha = mfexp(SRparm_work(3));
        dvariable beta = mfexp(SRparm_work(4));
        NewRecruits =  (alpha * SSB_curr_adj) / (1.0 + beta * SSB_curr_adj);
        break;
      }

    //  SS_Label_43.3.4  constant expected recruitment
    case 4: // none
    {
      NewRecruits = Recr_virgin_use;
      break;
    }
    //  SS_Label_43.3.5  Hockey stick
    case 5: // hockey stick  where "steepness" is now the fraction of B0 below which recruitment declines linearly
      //  the 3rd parameter allows for a minimum recruitment level
      {
        steepness = SRparm_work(2);
        temp = SRparm_work(3) * Recr_virgin_use + SSB_curr_adj / (steepness * SSB_virgin_use) * (Recr_virgin_use - SRparm_work(3) * Recr_virgin_use); //  linear decrease below steepness*SSB_virgin_use
        NewRecruits = Join_Fxn(0.0 * SSB_virgin_use, SSB_virgin_use, steepness * SSB_virgin_use, SSB_curr_adj, temp, Recr_virgin_use);
        break;
      }

    //  SS_Label_43.3.6  Beverton-Holt, with constraint to have constant R about Bzero
    case 6: //Beverton-Holt constrained
    {
      steepness = SRparm_work(2);
//      dvariable SPR = SSB_virgin_use / Recr_virgin;
//      alpha = ((4.0 * steepness) / (1. - steepness)) / SPR ;
//      beta = (1.0 / Recr_virgin) * (alpha - (1.0 / SPR));
      if (SSB_curr_adj > SSB_virgin_use)
      {
        SSB_BH1 = SSB_virgin_use;
      }
      else
      {
        SSB_BH1 = SSB_curr_adj;
      }
      NewRecruits = (4. * steepness * Recr_virgin_use * SSB_BH1) / (SSB_virgin_use * (1. - steepness) + (5. * steepness - 1.) * SSB_BH1);
      break;
    }

    //  SS_Label_43.3.7  survival based
    case 7: // survival based, so constrained such that recruits cannot exceed fecundity
    {
      // PPR_0=SSB_virgin_use/Recr_virgin_use;  //  pups per recruit at virgin
      // Surv_0=1./PPR_0;   //  recruits per pup at virgin
      // Pups_0=SSB_virgin_use;  //  total population fecundity is the number of pups produced
      // Sfrac=SRparm(2);
      SRZ_0 = log(1.0 / (SSB_virgin_use / Recr_virgin_use));
      steepness = SRparm_work(2);
      srz_min = SRZ_0 * (1.0 - steepness);
      SRZ_surv = mfexp((1. - pow((SSB_curr_adj / SSB_virgin_use), SRparm_work(3))) * (srz_min - SRZ_0) + SRZ_0); //  survival
      NewRecruits = SSB_curr_adj * SRZ_surv;
      exp_rec(y, 1) = NewRecruits; // expected arithmetic mean recruitment
      //  SS_Label_43.3.7.1  Do variation in recruitment by adjusting survival
      //        if(SR_env_target==1) SRZ_surv*=mfexp(SRparm(N_SRparm2-2)* env_data(y,SR_env_link));   // environ effect on survival
      if (recdev_cycle > 0)
      {
        gg = y - (styr + (int((y - styr) / recdev_cycle)) * recdev_cycle) + 1;
        SRZ_surv *= mfexp(recdev_cycle_parm(gg));
      }
      exp_rec(y, 2) = SSB_curr_adj * SRZ_surv;
      exp_rec(y, 2) *= mfexp(regime_change); //  adjust for regime which includes env and block effects; and forecast adjustments
      SRZ_surv *= mfexp(-biasadj(y) * half_sigmaRsq); // bias adjustment
      exp_rec(y, 3) = SSB_curr_adj * SRZ_surv;
      if (y <= recdev_end)
      {
        if (recdev_doit(y) > 0)
          SRZ_surv *= mfexp(recdev(y)); //  recruitment deviation
      }
      else if (Do_Forecast > 0)
      {
        SRZ_surv *= mfexp(Fcast_recruitments(y));
      }
      join = 1. / (1. + mfexp(100 * (SRZ_surv - 1.)));
      SRZ_surv = SRZ_surv * join + (1. - join) * 1.0;
      NewRecruits = SSB_curr_adj * SRZ_surv;
      exp_rec(y, 4) = NewRecruits;
      break;
    }

    //  SS_Label_43.3.8  Shepherd
    case 8: // Shepherd 3-parameter SRR. per Punt & Cope 2017
    {
      Shepherd_c = SRparm_work(3);
      Shepherd_c2 = pow(0.2, SRparm_work(3));
      Hupper = 1.0 / (5.0 * Shepherd_c2);
      steepness = 0.2 + (SRparm_work(2) - 0.2) / (0.8) * (Hupper - 0.2);
      temp = (SSB_curr_adj) / (SSB_virgin_use);
      NewRecruits = (5. * steepness * Recr_virgin_use * (1. - Shepherd_c2) * temp) /
          (1.0 - 5.0 * steepness * Shepherd_c2 + (5. * steepness - 1.) * pow(temp, Shepherd_c));
      break;
    }

    //  SS_Label_43.3.8  Ricker-power
    case 9: // Ricker power 3-parameter SRR.  per Punt & Cope 2017
    {
      steepness = SRparm_work(2);
      dvariable RkrPower = SRparm_work(3);
      temp = SSB_curr_adj / SSB_virgin_use;
      temp2 = posfun(1.0 - temp, 0.0000001, temp3);
      temp = 1.0 - temp2; //  Rick's new line to stabilize recruitment at R0 if B>B0
      dvariable RkrTop = log(5.0 * steepness) * pow(temp2, RkrPower) / pow(0.8, RkrPower);
      NewRecruits = Recr_virgin_use * temp * mfexp(RkrTop);
      break;
    }

  }
  RETURN_ARRAYS_DECREMENT();
  return NewRecruits;
  } //  end spawner_recruitment

FUNCTION void apply_recdev(prevariable& NewRecruits, const prevariable& Recr_virgin_use)
  {
  RETURN_ARRAYS_INCREMENT();
  //  SS_Label_43.4  For non-survival based SRR, get recruitment deviations by adjusting recruitment itself
  exp_rec(y, 1) = NewRecruits; // expected arithmetic mean recruitment
  //    exp_rec(y,2) is with regime shift or other env effect;
  //    exp_rec(y,3) is with bias adjustment
  //    exp_rec(y,4) is with dev
  regime_change = SRparm_work(N_SRparm2 - 1); //  this is a persistent deviation off the S/R curve

  if (recdev_cycle > 0)
  {
    gg = y - (styr + (int((y - styr) / recdev_cycle)) * recdev_cycle) + 1;
    NewRecruits *= mfexp(recdev_cycle_parm(gg));
  }
  NewRecruits *= mfexp(regime_change); //  adjust for regime which includes env and block effects; and forecast adjustments
  exp_rec(y, 2) = NewRecruits; //  adjusted for env and special forecast conditions
  if (SR_fxn != 4)
    NewRecruits *= mfexp(-biasadj(y) * half_sigmaRsq); // bias adjustment
  exp_rec(y, 3) = NewRecruits;

  if (y <= recdev_end)
  {
    if (recdev_doit(y) > 0)
    {
      if (do_recdev >= 3)
      {
        NewRecruits = Recr_virgin_use * mfexp(recdev(y)); //  recruitment deviation
      }
      else if (SR_fxn != 7)
      {
        NewRecruits *= mfexp(recdev(y)); //  recruitment deviation
      }
    }
  }

  else if (Do_Forecast > 0)
  {
    switch (int(Fcast_Loop_Control(3)))
    {
      case 0:
      {
        NewRecruits = exp_rec(y, 2);
        if (SR_fxn != 4)
          NewRecruits *= mfexp(-biasadj(y) * half_sigmaRsq); // bias adjustment
        exp_rec(y, 3) = NewRecruits;
        break;
      }
      case 1:
      {
        exp_rec(y, 2) *= Fcast_Loop_Control(4); //  apply fcast multiplier to the regime-adjusted expected value
        NewRecruits = exp_rec(y, 2);
        if (SR_fxn != 4)
          NewRecruits *= mfexp(-biasadj(y) * half_sigmaRsq); // bias adjustment
        exp_rec(y, 3) = NewRecruits;
        break;
      }
      case 2: //  use multiplier of R0
      {
        exp_rec(y, 2) = Recr_virgin_use * Fcast_Loop_Control(4); //  apply fcast multiplier to the virgin recruitment
        NewRecruits = exp_rec(y, 2);
        if (SR_fxn != 4)
          NewRecruits *= mfexp(-biasadj(y) * half_sigmaRsq); // bias adjustment
        exp_rec(y, 3) = NewRecruits;
        break;
      }
      case 4:
      {
        //  fall through to case 3
        //  case 3 also will do averaging of recr_dist in another section of code
      }
      case 3: //  use recent mean
      {
        //  values going into the mean have already been bias adjusted and had dev applied, so take straight mean
        NewRecruits = 0.0;
        for (j = Fcast_Rec_yr1; j <= Fcast_Rec_yr2; j++)
        {
          NewRecruits += exp_rec(j, 4);
        }
        NewRecruits /= (Fcast_Rec_yr2 - Fcast_Rec_yr1 + 1);
        if(Fcast_Loop_Control(3) == 4) NewRecruits *= Fcast_Loop_Control(4);  //  apply multiplier
        exp_rec(y, 2) = NewRecruits;
        exp_rec(y, 3) = NewRecruits; //  store in the bias-adjusted field
        break;
      }
    }
  // note that if user requests "mean" as base forecast recr, then devs are still applied
  // so, phase for forecast recdevs must be <0 to assure that forecast recr do not get added variability
    if (do_recdev > 0)
      NewRecruits *= mfexp(Fcast_recruitments(y)); //  recruitment deviation
  }
  exp_rec(y, 4) = NewRecruits;
  RETURN_ARRAYS_DECREMENT();
  } //  end spawner_recruitment

//********************************************************************
 /*  SS_Label_FUNCTION 44 Equil_Spawn_Recr_Fxn */
//  SPAWN-RECR:   function  Equil_Spawn_Recr_Fxn
FUNCTION dvar_vector Equil_Spawn_Recr_Fxn(const dvar_vector& SRparm,
    const prevariable& SSB_virgin_use, const prevariable& Recr_virgin_use, const prevariable& SSBpR_current)
  {
  RETURN_ARRAYS_INCREMENT();
  dvar_vector Equil_Spawn_Recr_Calc(1, 2); // values to return 1 is B_equil, 2 is R_equil
  dvariable B_equil;
  dvariable R_equil;
  dvariable temp;
  dvariable steepness;
  dvariable join;
  dvariable Shepherd_c;
  dvariable Shepherd_c2;
  dvariable SRZ_0;
  dvariable srz_min;
  dvariable SRZ_surv;
  dvariable SSBpR_virgin_use;

  SSBpR_virgin_use = SSB_virgin_use / Recr_virgin_use;
  steepness = SRparm(2); //  common usage but some different
  //  SS_Label_44.1  calc equilibrium SpawnBio and Recruitment from input SSBpR_current, which is spawning biomass per recruit at some given F level
  switch (SR_fxn)
  {
    case 1: // previous placement for B-H constrained
    {
      warnstream << "B-H constrained curve is now Spawn-Recr option #6";
      write_message (FATAL, 0); // EXIT!
      break;
    }

    //  SS_Label_44.1.2  Ricker
    case 2: // Ricker
    {
      B_equil = SSB_virgin_use * (1. + (log(Recr_virgin_use / SSB_virgin_use) + log(SSBpR_current)) / steepness);
      R_equil = Recr_virgin_use * B_equil / SSB_virgin_use * mfexp(steepness * (1. - B_equil / SSB_virgin_use));

      break;
    }
      //  SS_Label_44.1.1  Beverton-Holt 
    case 6: //Beverton-Holt with flattop beyond Bzero, but no flattop in equil calcs
    {
    }
  //  SS_Label_44.1.3  Beverton-Holt
    case 3: // same as case 6
    {
  // from WHAM per Tim Miller:
  //  WHAM based on R = A*S/(1+B*S)
  //  log_SR_a = log(4 * SR_h/(exp(log_SPR0)*(1 - SR_h)));
  //  log_SR_b = log((5*SR_h - 1)/((1-SR_h)*SR_R0*exp(log_SPR0)));

  //  SS3 previously used alternative formulation: R = A*S/(B+S)
  //  converting SS3 to align with WHAM
      alpha = 4.0 * steepness / (SSBpR_virgin_use * (1. - steepness));
      beta = (5.0 * steepness - 1.0) / ((1 - steepness) * SSB_virgin_use);
      // " h " << steepness << " derive "  << alpha * SSBpR_virgin / (4. + alpha * SSBpR_virgin) << " " << endl;
      // " R0 " << Recr_virgin_use << " derive "  << 1. / beta * (alpha - 1./SSBpR_virgin) << endl;
//      report5 <<" SSB_unf "<<SSB_virgin_use<<" SSBpR_unf "<<SSBpR_virgin<<" steep: "<<steepness<<" R0: "<<Recr_virgin_use << endl;
//      report5 <<" derive_alpha "<<alpha<<" derive_beta "<<beta << endl;
//      report5 << " deriv_h: " << alpha * SSBpR_virgin / (4. + alpha * SSBpR_virgin) << " derive_R0: " << 1. / beta * (alpha - (1. / SSBpR_virgin))<<endl;
      B_equil = (alpha * SSBpR_current - 1.0) / beta;
      B_equil = posfun(B_equil, 0.0001, temp);
      R_equil = alpha * B_equil / (1.0 + beta * B_equil);
//      report5 << "SPR_input: " << SSBpR_current << " B_equil: " << B_equil << " R_equil: "<<R_equil << endl<<endl;

      break;
    }

    case 10: // Beverton-Holt with alpha and beta parameterization using  R = A*S/(1+B*S) approach; same as WHAM
    {
      dvariable alpha = mfexp(SRparm(3));
      dvariable beta = mfexp(SRparm(4));
      B_equil = (alpha * SSBpR_current - 1.0) / beta;
      B_equil = posfun(B_equil, 0.0001, temp);
      R_equil = alpha * B_equil / (1.0 + beta * B_equil);
//      report5<<SSBpR_current<<" Beq "<<B_equil<<" Req "<<R_equil<<" alpha "<<alpha<<" beta "<<beta<<" SSB_unf "<<SSB_unf<<endl;
      break;
    }

    //  SS_Label_44.1.4  constant recruitment
    case 4: // constant; no bias correction
    {
      B_equil = SSBpR_current * Recr_virgin_use;
      R_equil = Recr_virgin_use;
      break;
    }
    //  SS_Label_44.1.5  Hockey Stick
    case 5: // hockey stick
    {
      dvariable hockey_min = SRparm(3) * Recr_virgin_use; // min recruitment level
      //        temp=SSB_virgin_use/R0*steepness;  // spawners per recruit at inflection
      dvariable hockey_slope = (Recr_virgin_use - hockey_min) / (steepness * SSB_virgin_use); //  slope of recruitment on spawners below the inflection
      B_equil = Join_Fxn(0.0 * SSB_virgin_use / Recr_virgin_use, SSB_virgin_use / Recr_virgin_use, SSB_virgin_use / Recr_virgin_use * steepness, SSBpR_current, hockey_min / ((1. / SSBpR_current) - hockey_slope), SSBpR_current * Recr_virgin_use);
      R_equil = Join_Fxn(0.0 * SSB_virgin_use, SSB_virgin_use, SSB_virgin_use * steepness, B_equil, hockey_min + hockey_slope * B_equil, Recr_virgin_use);
      break;
    }
    //  SS_Label_44.1.7  3 parameter survival based
    case 7: // survival
    {
      SRZ_0 = log(1.0 / (SSB_virgin_use / Recr_virgin_use));
      srz_min = SRZ_0 * (1.0 - steepness);
      B_equil = SSB_virgin_use * (1. - (log(1. / SSBpR_current) - SRZ_0) / pow((srz_min - SRZ_0), (1. / SRparm(3))));
      SRZ_surv = mfexp((1. - pow((B_equil / SSB_virgin_use), SRparm(3))) * (srz_min - SRZ_0) + SRZ_0); //  survival
      R_equil = B_equil * SRZ_surv;
      break;
    }

    //  SS_Label_44.1.8  3 parameter Shepherd
    case 8: // Shepherd
    {
      dvariable Shep_top;
      dvariable Shep_bot;
      dvariable Hupper;
      dvariable Shep_top2;
      //  Andre's FORTRAN
      //        TOP = 5*Steep*(1-0.2**POWER)*SPR/SPRF0-(1-5*Steep*0.2**POWER)
      //      BOT = (5*Steep-1)
      //       REC = (TOP/BOT)**(1.0/POWER)*SPRF0/SPR
      // Power = exp(logC);
      // Hupper = 1.0/(5.0 * pow(0.2,Power));
      Shepherd_c = SRparm(3);
      Shepherd_c2 = pow(0.2, SRparm(3));
      Hupper = 1.0 / (5.0 * Shepherd_c2);
      steepness = 0.2 + (SRparm(2) - 0.2) / (0.8) * (Hupper - 0.2);
      Shep_top = 5.0 * steepness * (1.0 - Shepherd_c2) * (SSBpR_current * Recr_virgin_use) / SSB_virgin_use - (1.0 - 5.0 * steepness * Shepherd_c2);
      Shep_bot = 5.0 * steepness - 1.0;
      Shep_top2 = posfun(Shep_top, 0.001, temp);
      R_equil = (SSB_virgin_use / SSBpR_current) * pow((Shep_top2 / Shep_bot), (1.0 / SRparm(3)));
      B_equil = R_equil * SSBpR_current;
      break;
    }

    //  SS_Label_43.3.8  Ricker-power
    case 9: // Ricker power 3-parameter SRR.  per Punt & Cope 2017
    {
      steepness = SRparm(2);
      dvariable RkrPower = SRparm(3);
      temp = SSB_virgin_use / (SSBpR_current * Recr_virgin_use);
      dvariable RkrTop = pow(0.8, RkrPower) * log(temp) / log(5.0 * steepness);
      RkrTop = posfun(RkrTop, 0.000001, CrashPen);
      R_equil = temp * Recr_virgin_use * (1.0 - pow(RkrTop, 1.0 / RkrPower));
      B_equil = R_equil * SSBpR_current;
      break;
    }

      /*
      case 19:  // re-parameterized Shepherd
      {
        dvariable Shep_top;
        dvariable Shep_bot;
        dvariable Hupper;
        dvariable Shep_top2;
//  Andre's FORTRAN
//        TOP = 5*Steep*(1-0.2**POWER)*SPR/SPRF0-(1-5*Steep*0.2**POWER)
//      BOT = (5*Steep-1)
//       REC = (TOP/BOT)**(1.0/POWER)*SPRF0/SPR
// Power = exp(logC);
// Hupper = 1.0/(5.0 * pow(0.2,Power));
        Shepherd_c=exp(SRparm3);
        Shepherd_c2=pow(0.2,Shepherd_c);
        Hupper=1.0/(5.0*Shepherd_c2);
        steepness=0.20001+((0.8)/(1.0+exp(-SRparm2))-0.2)/(0.8)*(Hupper-0.2);
//        steep2=0.20001+(steepness-0.2)/(0.8)*(Hupper-0.2);
        Shep_top=5.0*steepness*(1.0-Shepherd_c2)*(SSBpR_current*Recr_virgin_use)/SSB_virgin_use-(1.0-5.0*steepness*Shepherd_c2);
        Shep_bot=5.0*steepness-1.0;
        Shep_top2=posfun(Shep_top,0.001,temp);
        R_equil=(SSB_virgin_use/SSBpR_current) * pow((Shep_top2/Shep_bot),(1.0/Shepherd_c));
        B_equil=R_equil*SSBpR_current;
        break;
      }

//  SS_Label_43.3.8  Ricker-power
      case 20:  // Ricker power 3-parameter SRR.  per Punt & Cope 2017
      {
//   Hupper = 10.0;
//   Steep = 0.2 + (Hupper - 0.2)/(1+exp(-1*Steep2))+1.0e-5;
//   Top =  pow(0.8,Power)*log(SPRF0/SPR)/log(5.0*Steep);
//   Top = posfun(Top,0.000001,Penal);
//   Recs = (SPRF0/SPR) * (1.0 - pow(Top,1.0/Power));
//   Recs = posfun(Recs,0.0001,Penal);
//   if (Recs < 0) Rec2 = 0; else Rec2 = Recs;
        steepness = 0.2 + (10.0 - 0.2)/(1+exp(-SRparm_work(2)));
        dvariable RkrPower=exp(SRparm_work(3));
        temp=SSB_virgin/(SSBpR_current*Recr_virgin_use);
        dvariable RkrTop =  pow(0.8,RkrPower)*log(temp)/log(5.0*steepness);
        RkrTop = posfun(RkrTop,0.000001,CrashPen);
        R_equil = temp *Recr_virgin_use * (1.0 - pow(RkrTop,1.0/RkrPower));
        B_equil=R_equil*SSBpR_current;
        break;
      }
   */
  }
  Equil_Spawn_Recr_Calc(1) = B_equil;
  Equil_Spawn_Recr_Calc(2) = R_equil;
  RETURN_ARRAYS_DECREMENT();
  return Equil_Spawn_Recr_Calc;
  } //  end Equil_Spawn_Recr_Fxn
// SS_Label_file  #14. **SS_benchfore.tpl**
// SS_Label_file  # * <u>setup_Benchmark()</u> // calculates average biology and selectivity over specified range of years for use in benchmark
// SS_Label_file  # * <u>get_benchmark()</u>  // searches for Fspr, Fmsy, etc. conditioned on average biology and selectivity conditions
// SS_Label_file  # * <u>get_forecast()</u>  //  calculates forecast quantities, includes all popdy characteristics of the time series, writes forecast-report.sso
// SS_Label_file  #

// Terminology
// SSB refers to spawning stock biomass, calculated from reproductive output at age (fec()) and numbers-at-age at spawn_month in spawn_seas
// SSBpR refers to SSB per recruit calculated with equilibrium age composition in equil_calc
// SPR refers to spawner potential ratio which is the ratio of SSBpR at some level of F to SSBpR with F = 0

// SSBpR_virgin is calculated in popdyn using the start year biology
// SSBpR_virgin  used to get alpha in equil_spawn_recr B-H

FUNCTION void setup_Benchmark()  // and forecast
  {
  //  SS_Label_Info_7.5 #Get averages from selected years to use in forecasts

  if (Do_Forecast > 0)
  {
    if (Fcast_timevary_Selex == 1)
    {
      //  SS_Label_Info_7.5.1 #Calc average selectivity to use in forecast; store in endyr+1
      temp = float(Fcast_Sel_yr2 - Fcast_Sel_yr1 + 1.);
      for (gg = 1; gg <= gender; gg++)
        for (f = 1; f <= Nfleet; f++)
        {
          tempvec_l.initialize();
          for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
          {
            tempvec_l += sel_l(y, f, gg);
          }
          for (y = endyr + 1; y <= YrMax; y++)
          {
            sel_l(y, f, gg) = tempvec_l / temp;
          }

          tempvec_l.initialize();
          for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
          {
            tempvec_l += sel_l_r(y, f, gg);
          }
          for (y = endyr + 1; y <= YrMax; y++)
          {
            sel_l_r(y, f, gg) = tempvec_l / temp;
          }

          tempvec_l.initialize();
          for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
          {
            tempvec_l += discmort2(y, f, gg);
          }
          for (y = endyr + 1; y <= YrMax; y++)
          {
            discmort2(y, f, gg) = tempvec_l / temp;
          }

          if (gg == gender) //  vectors processed here have males stacked after females in same row
          {
            exp_l_temp.initialize();
            for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
            {
              exp_l_temp += retain(y, f);
            }
            for (y = endyr + 1; y <= YrMax; y++)
            {
              retain(y, f) = exp_l_temp / temp;
            }

            exp_l_temp.initialize();
            for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
            {
              exp_l_temp += discmort(y, f);
            }
            for (y = endyr + 1; y <= YrMax; y++)
            {
              discmort(y, f) = exp_l_temp / temp;
            }
          }

          tempvec_a.initialize();
          for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
          {
            tempvec_a += sel_a(y, f, gg);
          }
          for (y = endyr + 1; y <= YrMax; y++)
          {
            sel_a(y, f, gg) = tempvec_a / temp;
          }

          tempvec_a.initialize();
          for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
          {
            tempvec_a += discmort2_a(y, f, gg);
          }
          for (y = endyr + 1; y <= YrMax; y++)
          {
            discmort2_a(y, f, gg) = tempvec_a / temp;
          }
          if (seltype(f + Nfleet, 2) != 0) // using age retention
          {
            tempvec_a.initialize();
            for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
            {
              tempvec_a += retain_a(y, f, gg);
            }
            for (y = endyr + 1; y <= YrMax; y++)
            {
              retain_a(y, f, gg) = tempvec_a / temp;
            }
            tempvec_a.initialize();
            for (y = Fcast_Sel_yr1; y <= Fcast_Sel_yr2; y++)
            {
              tempvec_a += discmort_a(y, f, gg);
            }
            for (y = endyr + 1; y <= YrMax; y++)
            {
              discmort_a(y, f, gg) = tempvec_a / temp;
            }
          }
        }
    }
    t = styr + (endyr + 1 - styr) * nseas + spawn_seas - 1;
//    fec = Wt_Age_t(t, -2);  this will always be overwritten, so deleting

    if (Fcast_Loop_Control(3) == 3) //  using mean recr_dist from range of years
    {
      warnstream << "This option (mean recruitment) may be deprecated; same as forecast option(5), averaging parameters, type 4.";
      write_message(WARN, 0);
      //get average and store in each fcast years
      recr_dist_endyr.initialize();
      for (y = Fcast_Rec_yr1; y <= Fcast_Rec_yr2; y++)
        for (gp = 1; gp <= N_GP * gender; gp++)
        {
          recr_dist_endyr(gp) += recr_dist(y, gp);
        }
      recr_dist_endyr /= float(Fcast_Rec_yr2 - Fcast_Rec_yr1 + 1);
      for (y = endyr + 1; y <= YrMax; y++)
      {
        if (timevary_MG(y, 4) > 0)
        {
          warnstream << "mean recr_dist for forecast is incompatible with timevary recr_dist in forecast yr: " << y << "; user must adjust manually";
          write_message(WARN, 0);
        }
        recr_dist(y) = recr_dist_endyr;
      }
    }
    else  //  provide placeholder
    {
      recr_dist_endyr = recr_dist(endyr);
    }

    // create average of selected MGparms for use in forecast
    for (int parm_type = 1; parm_type <= 12; parm_type++)
	  {
      if(Fcast_MGparm_ave(parm_type, 2) == 1)  //  do averaging of derived factor
      {
      double ave_styr = Fcast_MGparm_ave(parm_type,3);
      double ave_endyr = Fcast_MGparm_ave(parm_type,4);
      double N_ave_yrs = ave_endyr - ave_styr + 1.; //  get denominator
   		switch (parm_type) 
		  {
        case 1:  // 1=Natural mortality (M),
          for (int s = 1; s <= nseas; s++)
            for (int g = 1; g <= gmorph; g++)
            {
              int gpi = GP3(g);
              for (int p = 0; p <= pop; p++)  //  question.  Perhaps only do this for area 0 as others filled in later in code
              {
                tempvec_a.initialize();
                for (y = ave_styr; y <= ave_endyr; y++)
                {
                  t = styr + (y - styr) * nseas - 1 + s;
                  tempvec_a += natM(t, p, gpi);
                }
                tempvec_a /= N_ave_yrs;
                for (int y = endyr + 1; y <= YrMax; y++)
                {
                  t = styr + (y - styr) * nseas - 1 + s;
                  natM(t, p, gpi) = tempvec_a; 
                }
              }
            }
          break;
		  
        case 2: // 2=growth,
          tempvec_a.initialize();
          warnstream << "Growth params averaging is not implemented, execution continues. " ;
          write_message (WARN, 1); 
          break;
		  
        case 3: // 3=wtlen,
          tempvec_a.initialize();
          warnstream << "Weight/Length params averaging is not implemented, execution continues. " ;
          write_message (WARN, 1); 
          break;
		  
        case 4: // 4=recr_dist&femfrac,
          //get average and store in each fcast years
          recr_dist_endyr.initialize();
          for (y = ave_styr; y <= ave_endyr; y++)
            for (gp = 1; gp <= N_GP * gender; gp++)
            {
              recr_dist_endyr(gp) += recr_dist(y, gp);
            }
          recr_dist_endyr /= N_ave_yrs;
          for (y = endyr + 1; y <= YrMax; y++)
          {
            if (timevary_MG(y, 4) > 0)
            {
              warnstream << "mean recr_dist for forecast is incompatible with timevary recr_dist in forecast yr: " << y << "; user must adjust manually";
              write_message(WARN, 0);
            }
            recr_dist(y) = recr_dist_endyr;
          }
          break;
		  
        case 5: // 5=migration,
          for (j = 1; j <= do_migr2; j++)
          {
            tempvec_a.initialize();
            for (y = ave_styr; y <= ave_endyr; y++)
            {
              tempvec_a += migrrate(y, j);
            }
            tempvec_a /= N_ave_yrs;
            for (y = endyr + 1; y <= YrMax; y++)
                migrrate(y, j) = tempvec_a;
          }
          break;
		  
        case 6: // 6=ageerror,
          tempvec_a.initialize();
          warnstream << "Age Error params averaging is not implemented, execution continues. " ;
          write_message (WARN, 1); 
          break;
		  
        case 7: // 7=catchmult,
          tempvec_a.initialize();
          warnstream << "Catch mult params averaging is not implemented, execution continues. " ;
          write_message (WARN, 1); 
          break;
		  
        case 8: // 8=hermaphroditism, and
          tempvec_a.initialize();
          warnstream << "Hermaphroditism params averaging is not implemented, execution continues. " ;
          write_message (WARN, 1); 
          break;
		  
        case 9: // 9=maturity&fecundity
          tempvec_a.initialize();
          warnstream << "Maturity & fecundity params averaging is not implemented, execution continues. " ;
          write_message (WARN, 1); 
          break; 

        case 10: // 9=selectivity
          tempvec_a.initialize();
          break; 

        }
      }
    }

    //  SS_Label_Info_7.5.2 #Set-up relative F among fleets and seasons for forecast
    if (Fcast_RelF_Basis == 1) // set allocation according to range of years
    {
      temp = 0.0;
      Fcast_RelF_Use.initialize();
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
        {
          for (y = Fcast_RelF_yr1; y <= Fcast_RelF_yr2; y++)
            for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              Fcast_RelF_Use(s, f) += Hrate(f, t);
            }
        }
      }
      temp = sum(Fcast_RelF_Use);
      if (temp > 0.0)
      {
        Fcast_RelF_Use /= temp;
        Fcurr_Fmult = temp / float(Fcast_RelF_yr2 - Fcast_RelF_yr1 + 1);
      }
      else
      {
        Fcast_RelF_Use(1, 1) = 1.0;
        Fcurr_Fmult = 0.0;
      }
    }
    else // Fcast_RelF_Basis==2 so set to values that were read
    {
      temp = 0.0;
      for (f = 1; f <= Nfleet; f++)
        for (s = 1; s <= nseas; s++)
        {
          temp += Fcast_RelF_Input(s, f);
          Fcast_RelF_Use(s, f) = Fcast_RelF_Input(s, f);
        }
      // Fcast_RelF_Use=Fcast_RelF_Input/temp;
      Fcast_RelF_Use /= temp;
      Fcurr_Fmult = temp;
    }
    if (N_bycatch > 0)
    {
      for (f = 1; f <= Nfleet; f++)
        for (s = 1; s <= nseas; s++)
        {
          if (Fcast_RelF_Use(s, f) == 0. && bycatch_setup(f, 3) > 0)
          {
            Fcast_RelF_Use(s, f) = 1.0e-6;
            warnstream << "setting positive forecast relF for bycatch fleet: " << f;
            write_message(ADJUST, 0);
          }
        }
    }
    if (N_Fcast_Input_Catches > 0)
    {
      for (f = 1; f <= Nfleet; f++)
        for (s = 1; s <= nseas; s++)
        {
          if (Fcast_RelF_special(s, f) == 1 && Fcast_RelF_Use(s, f) == 0.0)
          {
            Fcast_RelF_Use(s, f) = 1.0e-6;
            warnstream << "setting positive forecast relF for forecast only fleet: " << f;
            write_message(ADJUST, 0);
          }
        }
    }
  } //  end getting quantities for forecasts

  //  SS_Label_Info_7.5.3 #Calc average selectivity to use in benchmarks; store in styr-3
  //  Bmark_Yr(1,6)<<" Benchmark years:  beg-end bio; beg-end selex; beg-end alloc"<<endl;

  if (Do_Benchmark > 0)
  {
    //      if(save_for_report>0 || last_phase() || current_phase()==max_phase || ((sd_phase() || mceval_phase()) && (initial_params::mc_phase==0)))
    {
      //  calc average biology to use in equil; store in styr-3
      temp = float(Bmark_Yr(2) - Bmark_Yr(1) + 1.); //  get denominator
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (s = 0; s <= nseas - 1; s++)  //  note -1 baked into the loop index
          {
            tempvec_a.initialize();
            for (t = Bmark_t(1); t <= Bmark_t(2); t += nseas)
            {
              tempvec_a += Ave_Size(t + s, 1, g);
            }
            Ave_Size(styr - 3 * nseas + s, 1, g) = tempvec_a / temp;
            tempvec_a.initialize();
            for (t = Bmark_t(1); t <= Bmark_t(2); t += nseas)
            {
              tempvec_a += Ave_Size(t + s, mid_subseas, g);
            }
            Ave_Size(styr - 3 * nseas + s, mid_subseas, g) = tempvec_a / temp;

  //  get mean natM
            int gpi=GP3(g);
            for (int p = 0; p <= pop; p++)
            {
              tempvec_a.initialize();
              for (t = Bmark_t(1); t <= Bmark_t(2); t += nseas)
              {
                tempvec_a += natM(t + s, p, gpi);
              }
              natM(styr - 3 * nseas + s, p, gpi) = tempvec_a / temp;
              if(p>0)
              {
                int s1 = (p - 1)*nseas + s + 1;
                surv1(s1, gpi) = mfexp(-natM(styr - 3 * nseas + s, p, gpi) * seasdur_half(s + 1));  //  does all the gpi and ages
                surv2(s1, gpi) = square(surv1(s1, gpi));
              }
            }

            for (int kk = -2; kk <= 0; kk++) //  get mean fecundity and pop body wt
            {
              tempvec_a.initialize();
              for (t = Bmark_t(1); t <= Bmark_t(2); t += nseas)
              {
                tempvec_a += Wt_Age_t(t + s, kk, g);
              }
              Wt_Age_t(styr - 3 * nseas + s, kk, g) = tempvec_a / temp;
            }
            for (f = 1; f <= Nfleet; f++)
            {
              tempvec_a.initialize();
              for (t = Bmark_t(1); t <= Bmark_t(2); t += nseas)
              {
                tempvec_a += save_sel_num(t + s, f, g);
              }
              save_sel_num(styr - 3 * nseas + s, f, g) = tempvec_a / temp;
            }
          }
        }

      if (pop > 0)
      {
        if (do_migration > 0)
        {
          temp = float(Bmark_Yr(8) - Bmark_Yr(7) + 1.); //  get denominator
          for (j = 1; j <= do_migr2; j++)
          {
            tempvec_a.initialize();
            for (y = Bmark_Yr(7); y <= Bmark_Yr(8); y++)
            {
              tempvec_a += migrrate(y, j);
            }
            migrrate(styr - 3, j) = tempvec_a / temp;
          }
        }
        // recr_dist_unf is accumulated while doing the time_series
        // then its mean is calculated in Get_Benchmarks and assigned to recr_dist
        //  the SRparm_bench is calculated from Bmark_yrs 9-10 in benchmark code using values stored in SRparm_byyr
      }

      //  calc average selectivity to use in equil; store in styr-3
      temp = float(Bmark_Yr(4) - Bmark_Yr(3) + 1.); //  get denominator
      for (gg = 1; gg <= gender; gg++)
        for (f = 1; f <= Nfleet; f++)
        {
          tempvec_l.initialize();
          for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
          {
            tempvec_l += sel_l(y, f, gg);
          }
          sel_l(styr - 3, f, gg) = tempvec_l / temp;

          tempvec_l.initialize();
          for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
          {
            tempvec_l += sel_l_r(y, f, gg);
          }
          sel_l_r(styr - 3, f, gg) = tempvec_l / temp;

          if (gg == gender)
          {
            exp_l_temp.initialize(); //  use because dimensioned to nlength2
            for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
            {
              exp_l_temp += retain(y, f);
            }
            retain(styr - 3, f) = exp_l_temp / temp;
            exp_l_temp.initialize();
            for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
            {
              exp_l_temp += discmort(y, f);
            }
            discmort(styr - 3, f) = exp_l_temp / temp;
          }

          tempvec_l.initialize();
          for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
          {
            tempvec_l += discmort2(y, f, gg);
          }
          discmort2(styr - 3, f, gg) = tempvec_l / temp;

          tempvec_a.initialize();
          for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
          {
            tempvec_a += sel_a(y, f, gg);
          }
          sel_a(styr - 3, f, gg) = tempvec_a / temp;

          tempvec_a.initialize();
          for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
          {
            tempvec_a += discmort2_a(y, f, gg);
          }
          discmort2_a(styr - 3, f, gg) = tempvec_a / temp;
          if (seltype(f + Nfleet, 2) != 0) // using age retention
          {
            tempvec_a.initialize();
            for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
            {
              tempvec_a += retain_a(y, f, gg);
            }
            retain_a(styr - 3, f, gg) = tempvec_a / temp;
            tempvec_a.initialize();
            for (y = Bmark_Yr(3); y <= Bmark_Yr(4); y++)
            {
              tempvec_a += discmort_a(y, f, gg);
            }
            discmort_a(styr - 3, f, gg) = tempvec_a / temp;
          }
        }

      //  set-up relative F among fleets and seasons
      if (Bmark_RelF_Basis == 1) // set allocation according to range of years
      {
        temp = 0.0;
        Bmark_RelF_Use.initialize();
        Bmark_HistF.initialize();
        for (y = Bmark_Yr(5); y <= Bmark_Yr(6); y++)
          for (f = 1; f <= Nfleet; f++)
            if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
              for (s = 1; s <= nseas; s++)
              {
                t = styr + (y - styr) * nseas + s - 1;
                Bmark_HistF(s, f) += Hrate(f, t);
                Bmark_RelF_Use(s, f) += Hrate(f, t);
              }
        Bmark_HistF /= float(Bmark_Yr(6) - Bmark_Yr(5) + 1.); //  average F(s,f) across benchmark years
        temp = sum(Bmark_RelF_Use);

        //  note that the relF calculation below is not conditional on whether a fleet is not bycatch and not non-optimized
        //  Fmult later calculated as multiplier times Bmark_relF_use and will compensate automatically
        if (temp > 0.0)
        {
          Bmark_RelF_Use /= temp;
        }
        else
        {
          Bmark_RelF_Use(1, 1) = 1.0;
        }
      }
      else // Bmark_RelF_Basis==2 so set same as forecast
      {
        Bmark_RelF_Use = Fcast_RelF_Use;
      }
    } //  end being in a phase for these calcs
  } //  end getting quantities for benchmarks
  }

FUNCTION void Get_Benchmarks(const int show_MSY)
  {
  //********************************************************************
  /*  SS_Label_FUNCTION 34 Get_Benchmarks(Find Fspr, MSY) */
  int jj;
  int Nloops;
  int Nloops2;
  //  int bio_t;
  int bio_t_base;
  dvariable last_F1;
  dvariable Closer;
  dvariable Vbio1_unfished;
  dvariable SSBpR_unf;
  dvariable Vbio_MSY;
  dvariable Vbio1_MSY;
  dvariable junk;
  dvariable Nmid_c;

  dvariable df;
  dvariable BestYield;
  dvariable BestF1;
  dvariable FF;
  dvariable dyld;
  dvariable dyldp;
  dvariable Fmax;
  dvariable bestF1;
  dvariable bestF2;
  dvariable F01_origin;
  dvariable F01_second;
  dvariable F01_actual;
  dvar_vector F1(1, 3);
  dvar_vector F2(1, 3);
  dvar_vector yld1(1, 3);
  dvar_vector Fmult_save(1, 3);
  write_bodywt_save = write_bodywt;
  write_bodywt = 0;

  Nloops2 = 0;

  y = styr - 3; //  the average biology from specified benchmark years is stored here
  yz = y;
  bio_yr = y;
  eq_yr = y;
  t_base = y + (y - styr) * nseas - 1;
  bio_t_base = styr + (bio_yr - styr) * nseas - 1;
  //  set the Hrate for bycatch fleets so not scaled with other fleets
  //  bycatch_F(f,s) is created here for use in forecast
  for (f = 1; f <= Nfleet; f++)
  {
    if (fleet_type(f) == 2 && bycatch_setup(f, 3) == 2) //  set rate to input value
    {
      for (s = 1; s <= nseas; s++)
      {
        t = bio_t_base + s;
        Hrate(f, t) = bycatch_setup(f, 4);
        bycatch_F(f, s) = bycatch_setup(f, 4);
      }
    }
    else if (fleet_type(f) == 2 && bycatch_setup(f, 3) == 3) //  set rate to historical mean
    {
      for (s = 1; s <= nseas; s++)
      {
        t = bio_t_base + s;
        Hrate(f, t) = 0.0;
        for (int yy = bycatch_setup(f, 4); yy <= bycatch_setup(f, 5); yy++)
        {
          Hrate(f, t) += Hrate(f, styr + (yy - styr) * nseas + s - 1);
        }
        Hrate(f, t) /= (bycatch_setup(f, 5) - bycatch_setup(f, 4) + 1.);
        bycatch_F(f, s) = Hrate(f, t);
      }
    }
    else
    {
      for (s = 1; s <= nseas; s++)
      {
        t = bio_t_base + s;
        Hrate(f, t) = 0.0;
      }
    }
  }

  if (show_MSY == 1)
  {
    report5 << version_info << endl
            << ctime(&start);
    report5 << "Bmark_relF(by_fleet_&seas) (excluding non-scaled bycatch fleets)" << endl
            << Bmark_RelF_Use << endl
            << "#" << endl;
    report5 << "Bmark_histF(by_fleet_&seas)" << endl
            << Bmark_HistF << endl
            << "#" << endl;
    report5 << "Bycatch_F" << endl
            << trans(bycatch_F) << endl
            << "#" << endl;
    report5 << "YPR_mask for including catch: " << endl
            << YPR_mask << endl;
  }
  if (show_MSY == 2)
  {
    //  do not recalc the age-specific vectors
  }
  else // recalc age specific biology and selectivity.  NOTE:  not density-dependent!!
  {
    for (s = 1; s <= nseas; s++)
    {
      t = styr - 3 * nseas + s - 1;
      subseas = 1; //   for begin of season
      ALK_idx = (s - 1) * N_subseas + subseas;
      ALK_subseas_update(ALK_idx) = 1; // new in 3.30.12   force updating
      Make_AgeLength_Key(s, subseas); //  begin season

      subseas = mid_subseas;
      ALK_idx = (s - 1) * N_subseas + subseas;
      ALK_subseas_update(ALK_idx) = 1; // new in 3.30.12   force updating
      Make_AgeLength_Key(s, subseas);

      //  SPAWN-RECR:   call make_fecundity for benchmarks
      //  this means that any calculation of SSB in benchmark will use the updated fec
      if (s == spawn_seas)
      {
        {
          fec = Wt_Age_t(styr - 3 * nseas + s - 1, -2);
        }
      }
      Wt_Age_beg(s) = Wt_Age_t(styr - 3 * nseas + s - 1, 0);
    }
    //  following uses the values of sel_l, sel_a, etc. stored in yr=styr-3
    for (s = 1; s <= nseas; s++)
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          ALK_idx = (s - 1) * N_subseas + mid_subseas; //  for midseason
          Make_FishSelex(); //  including sel_dead_num
        }
    if (show_MSY == 1)
    {
      report5 << version_info << endl
              << ctime(&start);
      report5 << "Bmark_relF(by_fleet_&seas) (excluding non-scaled bycatch fleets)" << endl
              << Bmark_RelF_Use << endl
              << "#" << endl;
      report5 << "Bmark_histF(by_fleet_&seas)" << endl
              << Bmark_HistF << endl
              << "#" << endl;
      report5 << "Bycatch_F" << endl
              << trans(bycatch_F) << endl
              << "#" << endl;
      report5 << "YPR_mask for including catch: " << endl
              << YPR_mask << endl;
      report5 << "Fecundity: " << fec(1) << endl;
      for (f = 1; f <= Nfleet; f++)
      {
        if (fleet_type(f) <= 2)
        {
          for (s = 1; s <= nseas; s++)
          {
            report5 << f << " " << s << " sel_bio: " << sel_bio(s, f, 1) << endl;
            report5 << f << " " << s << " sel_dead_bio: " << sel_dead_bio(s, f, 1) << endl;
          }
        }
      }
      for (f = 1; f <= Nfleet; f++)
      {
        if (fleet_type(f) <= 2)
        {
          for (s = 1; s <= nseas; s++)
            report5 << f << " " << s << " sel_num: " << sel_num(s, f, 1) << endl;
        }
      }
      for (f = 1; f <= Nfleet; f++)
      {
        if (fleet_type(f) <= 2)
        {
          for (s = 1; s <= nseas; s++)
            report5 << f << " " << s << " sel_dead_num: " << sel_dead_num(s, f, 1) << endl;
        }
      }
    }
  }

  maxpossF.initialize();
  for (g = 1; g <= gmorph; g++)
  {
    for (s = 1; s <= nseas; s++)
    {
      tempvec_a.initialize();
      for (f = 1; f <= Nfleet; f++)
      {
        tempvec_a += Bmark_RelF_Use(s, f) * sel_dead_num(s, f, g);
      }
      temp = max(tempvec_a);
      if (temp > maxpossF)
        maxpossF = temp;
    }
  }
  maxpossF = max_harvest_rate / maxpossF; //  applies to any F_method

  //  SPAWN-RECR:   notes regarding virgin vs. benchmark biology usage in spawn-recr
  //  the spawner-recruitment function has Bzero based on virgin biology, not benchmark biology
  //  need to deal with possibility that with time-varying biology, the SSB_virgin calculated from virgin conditions will differ from the SSB_virgin used for benchmark conditions

  //  note that recr_dist(styr-3), updated at end of ss_popdyn.

  for (j = 1; j <= N_SRparm2; j++)
  {
    if (SRparm_timevary(j) == 0)
    {
      SRparm_bench(j) = SRparm(j);
    }
    else
    {
      temp = 0.;
      for (int y = Bmark_Yr(9); y <= Bmark_Yr(10); y++)
      {
        temp += SRparm_byyr(y, j);
      }
      SRparm_bench(j) = temp / (Bmark_Yr(10) - Bmark_Yr(9) + 1.);
    }
  }
  SRparm_bench = SRparm_work;

 /*  
 Flags:
  timevary_MG_firstyr == YrMax  // means that no biology is time-varying
  timevary_SRparm_first > 0 //  means that R0 or h (i.e. any except regime, sigmaR, autocorr) is time-varying, so SSBpR0 gets updated for time series and for bench
  timevary_bio_4SRR is new user selected flag:  0 for legacy, vs 1 for improved use of timevary biology in SRR calcs

 Legacy approach:
 SSBpR0 set at start year using start year biology
 SSBpR0 is not itself saved; instead R0_4_SRR and SSB0_4_SRR are saved and passed to the spawn_recruit functions
 SSBpR0 updated during time series if there is time-varying R0, but does not call equil_spawn_recr_calc
 SSBpR with benchmark biology used in benchmark calculations 
 SSBpR0 for benchmark always uses bench biology, which is incorrect
 SSB_bench (aka SSB_unf) does not call equil_spawn_recr_calc, it is just R * SSBpR, so is incomplete accounting for effect of timevary bio
 Btgttgt is a fraction of SSB_bench (no options)
 Btgttgt2 can be fraction of SSB_MSY or fraction of SSB_virgin, but not SSB_bench
 HCR inflection is a fraction of SSB_bench (no options)
 depletion basis is user-selected as SSB_virgin or SSB_msy
 SSB_msy uses equil_spawn_recr_calc in its creation, but SSB_bench does not.  So they are inconsistent
 none of the above is an issue if there is no timevarying biology
 -------
 Improved approach
 SSBpR0 set at start year using start year biology
 SSBpR0 updated during time series if there is time-varying R0; PLUS NEW: equil_spawn_recr_calc called to get new equilibrium R0, SSB0
 SSBpR0 for benchmark stays at virgin unless timevary_bio_4SRR == 0, or if timevary_SRparm_first > 0
 Btgttgt can now use either frac*SSB_bench or frac*SSB_virgin by using the existing flag for depletion basis
 Btgttgt2 can be fraction of SSB_MSY, of SSB_virgin, or of SSB_bench
 HCR inflection adds option to use SSB_virgin or SSB_bench
 depletion adds option to use SSB_bench
 */
  Recr_unf = Recr_virgin;  // default
  SSB0_4_SRR = SSB_virgin;  // default
  R0_4_SRR = Recr_virgin;
  Fishon = 0;
  SSBpR_Calc(Recr_unf);  // this returns SSB_equil using benchmark biology
  // provides basis for values needed below
  SSB_unf = SSB_equil;
  SSBpR_bench = SSB_equil / Recr_unf;

  if(timevary_SRparm_first == 0)  // no timevary SRR parms
  {
    if( timevary_MG_firstyr == YrMax && WTage_rd == 0)  // no time-varying biology
    {
      R0_4_SRR = Recr_virgin;
      SSB0_4_SRR = SSB_virgin;
      SSB_unf = SSB_virgin;
    }
    else // there is time-varying biology
    {
      R0_4_SRR = Recr_virgin;  // same as Recr_virgin because no timevary SRparms
      if( timevary_bio_4SRR == 0)  // legacy approach;  this switch is read from starter.ss
      {
        SSB_unf = SSB_equil;
        SSB0_4_SRR = SSB_equil;  // this is inaccurate legacy, as it moves equil off the SRR, rather than along the SRR
      }
      else
      {
        //  get new equilibrium point using original SRR and SSBpR_bench
        Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB_virgin, Recr_virgin, SSBpR_bench); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
        SSB_unf = Equ_SpawnRecr_Result(1);
        Recr_unf = Equ_SpawnRecr_Result(2);
        if (show_MSY == 1) report5 << " use virgin SSBpR0 in SRR - SSB: " << SSB_virgin << " Recr: " << Recr_virgin << " SPR: " << SSB_virgin / Recr_virgin << " bench SPR: " << SSBpR_bench << " new equil: " << Equ_SpawnRecr_Result << endl;
      }
      SSBpR_bench = SSB_unf / Recr_unf;
    }
  }
  else // there are timevary SRR parms; use same code regardless of timevary biology.  Legacy approach does not include new equilibrium
  {
    Recr_unf = mfexp(SRparm_bench(1));  // R0 to be used
    // note that steepness will get updated when SRparm_bench is used in Equ_SpawnRecr_Result
    SSBpR_Calc(Recr_unf);  // this returns SSB_equil using benchmark biology
    SSB_unf = SSB_equil;
    SSBpR_bench = SSB_equil / Recr_unf;
    if( timevary_bio_4SRR == 0)  // legacy approach;  this switch is read from starter.ss
    {
      R0_4_SRR = Recr_unf;
      SSB0_4_SRR = SSB_equil;  // this is legacy, but incorrect, as it moves equil off the SRR, rather than along the SRR
    }
    else  // use improved approach with updated SRparms and benchmark biology
    {
      //  get new equilibrium point for the benchmark SRR
      Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB_equil, Recr_unf, SSBpR_bench); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
      SSB_unf = Equ_SpawnRecr_Result(1);
      SSB0_4_SRR = Equ_SpawnRecr_Result(1);
      Recr_unf = Equ_SpawnRecr_Result(2);
      R0_4_SRR = Equ_SpawnRecr_Result(2);

      if (show_MSY == 1) report5 << " use bench SSBpR0 in SRR - SSB: " << SSB_unf << " Recr: " << Recr_unf << " SPR: " << SSBpR_bench << " new equil: " << Equ_SpawnRecr_Result << endl;
    }
  }

  if (show_MSY == 1)
  {
    SRparm_bench(N_SRparm2 + 1) = SSB_unf;
    Mgmt_quant(1) = SSB_unf;
    Mgmt_quant(2) = totbio;  // this is calculated in Do_Equil_Calc
    Mgmt_quant(3) = smrybio;
    Mgmt_quant(4) = Recr_unf;
    report5 << "SRparms for benchmark: " << SRparm_bench << endl
            << "Benchmark biology averaged over years: " << Bmark_Yr(1) << " " << Bmark_Yr(2) << endl << endl;
    Mgmt_quant(19) = SSB_unf;  // placeholder for depletion denominator
    Mgmt_quant(20) = SSB_unf;  //  placeholder to be replaced by SSB_HCR_infl
    Mgmt_quant(21) = R0_4_SRR;
    Mgmt_quant(22) = SSB0_4_SRR;
  }

  // find Fspr             SS_Label_710
  {
    if (show_MSY == 1)
    {
      report5 << "#" << endl
              << "find_target_SPR" << endl;
      report5 << "SPR_is_spawner_potential_ratio=(fishedSSB/R)/(unfishedSSB/R))" << endl;
      report5 << "Iter Fmult ann_F SPR tot_catch";
      for (p = 1; p <= pop; p++)
        for (gp = 1; gp <= N_GP; gp++)
        {
          report5 << " SSB_Area:" << p << "_GP:" << gp;
        }
      report5 << endl;
    }
    Fmult = 0.;
    Nloops = 18;
    Closer = 1.;
    F1(1) = log(1.0e-3);
    last_calc = 0.;
    Fchange = -4.0;

    equ_Recr = 1.0;  // so calls to Do_Equil_Calc will return values of SSBpR
    Fishon = 0;
    dvariable SPR_target100;
    SPR_target100 = SPR_target * 100.;

    SSBpR_Calc(equ_Recr);  //  where equ_Recr has been set to 1.0
    SSBpR_unf = SSB_equil / equ_Recr; //  this corresponds to the biology for benchmark average years, not the virgin SSB_virgin
    Vbio1_unfished = smrybio; // gets value from equil_calc
    if (show_MSY == 1)
    {
      report5 << "0 0 0 1 0";
      for (p = 1; p <= pop; p++)
        for (gp = 1; gp <= N_GP; gp++)
        {
          report5 << " " << SSB_equil_pop_gp(p, gp);
        }
      report5 << endl;
    }

    df = 1.e-5;
    Fishon = 1;
    for (j = 1; j <= Nloops; j++) // loop find Fspr
    {
      if (fabs(Fchange) <= 0.25)
      {
        jj = 3;
        F1(2) = F1(1) + df * .5;
        F1(3) = F1(2) - df;
      }
      else
      {
        jj = 1;
      }

      for (int ii = jj; ii >= 1; ii--)
      {
        Fmult = 40.00 / (1.0 + mfexp(-F1(ii)));

        for (f = 1; f <= Nfleet; f++)
        {
          if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
          {
            for (int s = 1; s <= nseas; s++)
            {
              Hrate(f, bio_t_base + s) = Fmult * Bmark_RelF_Use(s, f);
            }
          }
          //  else  Hrate for bycatch fleets already set
        }

        Fishon = 1;
        SSBpR_Calc(equ_Recr);
        yld1(ii) = 100. * SSB_equil / SSBpR_unf; //  spawning potential ratio
      }
      SPR_actual = yld1(1); //  spawning potential ratio

      if (jj == 3)
      {
        Closer *= 0.5;
        dyld = (yld1(2) - yld1(3)) / df; // First derivative (to find the root of this)
        if (dyld != 0.)
        {
          last_F1 = F1(1);
          F1(1) += (SPR_target100 - SPR_actual) / (dyld + 0.001);
          F1(1) = (1. - Closer) * F1(1) + Closer * last_F1;
        } // averages with last good value to keep from changing too fast
        else
        {
          F1(1) = (F1(1) + last_F1) * 0.5;
        } // go halfway back towards previous value
      }
      else
      {
        //              if((last_calc-SPR_target)*(SPR_actual-SPR_target)<0.0) {Fchange*=-0.5;}   // changed sign, so reverse search direction
        temp = (last_calc - SPR_target100) * (SPR_actual - SPR_target100) / (sfabs(last_calc - SPR_target100) * sfabs(SPR_actual - SPR_target100)); // values of -1 or 1
        temp1 = temp - 1.; // values of -2 or 0
        Fchange *= exp(temp1 / 4.) * temp;
        F1(1) += Fchange;
        last_calc = SPR_actual;
      }

      if (show_MSY == 1)
      {
        report5 << j << " " << Fmult << " " << equ_F_std << " " << SPR_actual / 100. << " " << sum(equ_catch_fleet(2));
        for (p = 1; p <= pop; p++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            report5 << " " << SSB_equil_pop_gp(p, gp);
          }
        report5 << endl;
      }
    } // end search loop

    if (show_MSY == 1)
    {
      if (fabs(SPR_actual - SPR_target100) >= 0.1)
      {
        warnstream << "poor convergence in Fspr search " << SPR_target << " " << SPR_actual / 100.;
        write_message(WARN, 0);
      }
      if (SPR_actual / SPR_target100 >= 1.01)
      {
        warnstream << "Fmult = " << Fmult << " cannot get high enough to achieve low SPR target: " << SPR_target << "; SPR achieved is: " << SPR_actual / 100.;
        write_message(WARN, 0);
      }

      report5 << "seas fleet Hrate encB deadB retB encN deadN retN: " << endl;
      for (s = 1; s <= nseas; s++)
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            report5 << s << " " << f << " " << Hrate(f, bio_t_base + s);
            for (g = 1; g <= 6; g++)
            {
              report5 << " " << equ_catch_fleet(g, s, f);
            }
            report5 << endl;
          }
    }

    //  SPAWN-RECR:   calc equil spawn-recr in YPR; need to make this area-specific
    SSBpR_temp = SSB_equil;  //  based on most recent call to Do_Equil_Calc
    Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB0_4_SRR, R0_4_SRR, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR

    Bspr = Equ_SpawnRecr_Result(1);
    Bspr_rec = Equ_SpawnRecr_Result(2);
    YPR_spr_enc = YPR_enc; //  total encountered yield per recruit
    YPR_spr_dead = YPR_dead; // total dead yield per recruit
    YPR_spr_N_dead = YPR_N_dead;
    YPR_spr_ret = YPR_ret;
    YPR_spr_cost = Cost;
    YPR_spr_revenue = (PricePerF * YPR_val_vec) * Equ_SpawnRecr_Result(2); //  vector*vector*scalar
    YPR_spr_profit = YPR_spr_revenue - Cost;
    SPR_Fmult = Fmult;
    if (rundetail > 0 && mceval_counter == 0 && show_MSY == 1)
    {
      echoinput << "Calculated Fspr " << SPR_Fmult << " " << SPR_actual / 100. << endl;
    }
    Vbio_spr = totbio;
    Vbio1_spr = smrybio;
    Mgmt_quant(10) = equ_F_std;
    Mgmt_quant(9) = Equ_SpawnRecr_Result(1);
    Mgmt_quant(11) = YPR_dead * Equ_SpawnRecr_Result(2);
  } //   end finding Fspr

  if (Do_Benchmark == 2) //  Find F0.1
  {
    equ_Recr = 1.0;
    Fishon = 1;
    //  get slope at origin
    //      Fmult=0.000001;
    Fmult = 0.001;
    for (f = 1; f <= Nfleet; f++)
    {
      if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
      {
        for (int s = 1; s <= nseas; s++)
        {
          Hrate(f, bio_t_base + s) = Fmult * Bmark_RelF_Use(s, f);
        }
      }
      //  else  Hrate for bycatch fleets already set
    }
    SSBpR_Calc(equ_Recr);
    F01_origin = YPR_opt / Fmult;

    BTGT_frac = 0.1; //  now relative to Bmark
    Btgttgt = F01_origin * 0.1;
    if (show_MSY == 1)
    {
      report5 << "#" << endl
              << "#Find_F0.1; slope_at_origin_wrt_Fmult: " << F01_origin << " " << YPR_opt << " " << Hrate(1, bio_t_base + 3) << endl;
      report5 << "Iter  Fmult   ann_F    SPR    YPR    YPR_slope  YPR_curvature" << endl;
    }

    Nloops = 20;
    Closer = 0.75;
    F1(1) = SPR_Fmult * 0.1;
    for (j = 1; j <= Nloops; j++) // loop to find F0.1
    {
      df = 0.01 * F1(1);
      F1(2) = F1(1) + df * .5;
      F1(3) = F1(2) - df;
      for (int ii = 3; ii >= 1; ii--)
      {
        for (f = 1; f <= Nfleet; f++)
        {
          if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
          {
            for (int s = 1; s <= nseas; s++)
            {
              Hrate(f, bio_t_base + s) = F1(ii) * Bmark_RelF_Use(s, f);
            }
          } //  else  Hrate for bycatch fleets set above
        }
        SSBpR_Calc(equ_Recr);
        yld1(ii) = YPR_opt;
      }

      F01_actual = (yld1(2) - yld1(3)) / (F1(2) - F1(3));
      F01_second = ((yld1(2) - yld1(1)) / (F1(2) - F1(1)) - (yld1(1) - yld1(3)) / (F1(1) - F1(3))) / (F1(2) - F1(3));

      last_F1 = F1(1);
      if (show_MSY == 1)
      {
        report5 << j << " " << F1(1) << " " << equ_F_std << " " << SSB_equil / SSBpR_unf << " " << YPR_opt << " " << F01_actual << " " << F01_second << " last F1 " << last_F1 << " Closer " << Closer << " delta " << (F01_origin * 0.1 - F01_actual) / (F01_second) << endl;
      }
      F1(1) += (F01_origin * 0.1 - F01_actual) / (F01_second);
      F1(1) = (1. - Closer) * F1(1) + Closer * last_F1;
      Closer *= 0.75;
    } // end search loop

    if (show_MSY == 1)
    {
      if (sfabs(F01_origin * 0.1 - F01_actual) >= 0.001)
      {
        warnstream << "poor convergence in F0.1 search target= " << F01_origin * 0.1 << "  actual= " << F01_actual;
        write_message(WARN, 0);
      }
      report5 << "seas fleet Hrate encB deadB retB encN deadN retN): " << endl;
      for (s = 1; s <= nseas; s++)
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            report5 << s << " " << f << " " << Hrate(f, bio_t_base + s);
            for (g = 1; g <= 6; g++)
            {
              report5 << " " << equ_catch_fleet(g, s, f);
            }
            report5 << endl;
          }
    }

    Btgt_Fmult = F1(1);
    if (rundetail > 0 && mceval_counter == 0 && show_MSY == 1)
      echoinput << "Calculated F0.1: " << Btgt_Fmult << endl;
    SSBpR_temp = SSB_equil;
    Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB0_4_SRR, R0_4_SRR, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
    Btgt = Equ_SpawnRecr_Result(1);
    Btgt_Rec = Equ_SpawnRecr_Result(2);
    YPR_Btgt_enc = YPR_enc; //  total encountered yield per recruit
    YPR_Btgt_dead = YPR_dead; // total dead yield per recruit
    YPR_Btgt_N_dead = YPR_N_dead; // total dead yield per recruit
    YPR_Btgt_ret = YPR_ret;
    YPR_Btgt_cost = Cost;
    YPR_Btgt_revenue = (PricePerF * YPR_val_vec) * Btgt_Rec; //  vector*vector*scalar
    //    YPR_Btgt_revenue = Price*YPR_ret*Btgt_Rec;
    YPR_Btgt_profit = YPR_Btgt_revenue - Cost;
    SPR_Btgt = SSB_equil / SSBpR_unf;
    Vbio_Btgt = totbio;
    Vbio1_Btgt = smrybio;
    Mgmt_quant(7) = equ_F_std;
    Mgmt_quant(5) = SSB_equil / SSB_unf * Btgt_Rec;
    Mgmt_quant(6) = SSB_equil / SSB_unf;
    Mgmt_quant(8) = YPR_dead * Btgt_Rec;

  } //  end F0.1

  else //  find F giving Btarget      SS_Label_720
  {
    // ******************************************************

    if (depletion_basis == 1 && timevary_bio_4SRR != 0) 
      {Btgttgt = BTGT_frac * SSB_virgin;}
    else
      {Btgttgt = BTGT_frac * SSB_unf;}  //  current SS3 approach uses benchmark biology

      if (show_MSY == 1)
    {
     report5 << "#" << endl;
     if (depletion_basis == 1 && timevary_bio_4SRR != 0)
     {report5 << "Find_target_SSB as fraction: " << BTGT_frac << " of Virgin SSB:" << SSB_virgin << endl;}
     else
     {report5 << "Find_target_SSB as fraction: " << BTGT_frac << " of SSB_unf: "<< SSB_unf << endl;}
     report5  << "Iter Fmult ann_F SPR Catch SSB Recruits SSB/Bzero Tot_catch";

    for (p = 1; p <= pop; p++)
      for (gp = 1; gp <= N_GP; gp++)
      {
        report5 << " SSB_Area:" << p << "_GP:" << gp;
      }
    report5 << endl;
    }

    F1(1) = log(1.0e-3);
    last_calc = 0.;
    Fchange = -4.0;
    df = 1.e-5;
    Closer = 1.;
    dvariable Closer2;
    if (SR_fxn == 5)
    {
      Closer2 = 0.001;
      Nloops = 40;
    }
    else
    {
      Closer2 = 0.10;
      Nloops = 28;
    }

    for (j = 0; j <= Nloops; j++) // loop find Btarget
    {
      if (fabs(Fchange) <= Closer2)
      {
        jj = 3;
        F1(2) = F1(1) + df * .5;
        F1(3) = F1(2) - df;
      }
      else
      {
        jj = 1;
      }
      for (int ii = jj; ii >= 1; ii--)
      {
        if (j == 0)
        {
          Fmult = 0.0;
        }
        else
        {
          Fmult = 40.00 / (1.00 + mfexp(-F1(ii)));
        }
        for (f = 1; f <= Nfleet; f++)
        {
          if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
          {
            for (int s = 1; s <= nseas; s++)
            {
              Hrate(f, bio_t_base + s) = Fmult * Bmark_RelF_Use(s, f);
            }
          }
          //  else  Hrate for bycatch fleets already set
        }
        SSBpR_Calc(equ_Recr); //  where equ_Recr=1.0, so returned SSB_equil is in units of SSB/R,
        SSBpR_temp = SSB_equil;
//        warning << equ_Recr << " " << SSB_equil << " " << SRparm_bench << " " << SSBpR_temp << endl;
        SPR_Btgt = SSBpR_temp / SSBpR_unf;  //  where SSBpR_unf = SSB_unf / Recr_unf so units of SSB/R; so result is SPR_Btgt = (fished SSB/R) / (unfished SSB/R)
        //  SPAWN-RECR:   calc equil spawn-recr for Btarget calcs;  need to make area-specific
        Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB0_4_SRR, R0_4_SRR, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
//        warning << SSB0_4_SRR << " " << R0_4_SRR << Equ_SpawnRecr_Result << endl;
        yld1(ii) = Equ_SpawnRecr_Result(1);
      }

      Btgt = Equ_SpawnRecr_Result(1); //  so uses benchmark average years

      if (jj == 3)
      {
        Closer *= 0.5;
        dyld = (yld1(2) - yld1(3)) / df; // First derivative
        if (dyld != 0.)
        {
          last_F1 = F1(1);
          F1(1) -= (Btgt - Btgttgt) / (dyld + 0.001);
          F1(1) = (1. - Closer) * F1(1) + (Closer)*last_F1;
        } // weighted average with last good value to keep from changing too fast
        else
        {
          F1(1) = (F1(1) + last_F1) * 0.5;
        } // go halfway back towards previous value
      }
      else
      {
        temp = (last_calc - Btgttgt) * (Btgt - Btgttgt) / (sfabs(last_calc - Btgttgt) * sfabs(Btgt - Btgttgt)); // values of -1 or 1
        temp1 = temp - 1.; // values of -2 or 0
        Fchange *= exp(temp1 / 4.) * temp;
        F1(1) += Fchange;
        last_calc = Btgt;
      }

      if (show_MSY == 1)
      {
        report5 << j << " " << Fmult << " " << equ_F_std << " " << SPR_Btgt << " " << YPR_dead * Equ_SpawnRecr_Result(2) << " " << Btgt << " " << Equ_SpawnRecr_Result(2)
                << " " << Btgt / (Btgttgt / BTGT_frac) << " " << sum(equ_catch_fleet(2)) * Equ_SpawnRecr_Result(2);
        for (p = 1; p <= pop; p++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            report5 << " " << SSB_equil_pop_gp(p, gp) * Equ_SpawnRecr_Result(2);
          }
        report5 << endl;
      }
    } // end search loop

    Btgt_Rec = Equ_SpawnRecr_Result(2);

    if (show_MSY == 1)
    {
      if (fabs(log(Btgt / Btgttgt)) >= 0.001)
      {
        warnstream << "poor convergence in Btarget search " << Btgttgt << " " << Btgt;
        write_message (WARN, 0);
      }
      report5 << "seas fleet Hrate encB deadB retB encN deadN retN): " << endl;
      for (s = 1; s <= nseas; s++)
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            report5 << s << " " << f << " " << Hrate(f, bio_t_base + s);
            for (g = 1; g <= 6; g++)
            {
              report5 << " " << Btgt_Rec * equ_catch_fleet(g, s, f);
            }
            report5 << endl;
          }
    }

    Btgt_Fmult = Fmult;
    if (rundetail > 0 && mceval_counter == 0 && show_MSY == 1)
    {
      echoinput << "Calculated Btgt: " << Btgt_Fmult << " " << Btgt / SSB_unf << endl;
    }
    YPR_Btgt_enc = YPR_enc; //  total encountered yield per recruit
    YPR_Btgt_dead = YPR_dead; // total dead yield per recruit
    YPR_Btgt_N_dead = YPR_N_dead; // total dead yield per recruit
    YPR_Btgt_ret = YPR_ret;
    YPR_Btgt_cost = Cost;
    //    YPR_Btgt_revenue = Price*YPR_ret*Btgt_Rec;
    YPR_Btgt_revenue = (PricePerF * YPR_val_vec) * Btgt_Rec;
    YPR_Btgt_profit = YPR_Btgt_revenue - Cost;
    Vbio_Btgt = totbio;
    Vbio1_Btgt = smrybio;
    Mgmt_quant(7) = equ_F_std;
    Mgmt_quant(5) = Btgt;
    Mgmt_quant(6) = SPR_Btgt;
    Mgmt_quant(8) = YPR_dead * Btgt_Rec;
  } //  end finding F for Btarget

  // ******************************************************
  //  start finding Fmsy     SS_Label_730
  if (Do_MSY == 0)
  {
    Fmax = 1.;
    MSY = -1;
    Bmsy = -1;
    Recr_msy = -1;
    MSY_SPR = -1;
    Yield = -1;
    totbio = 1;
    smrybio = 1.;
    MSY_Fmult = -1.; //  use these values if MSY is not calculated
    if (show_MSY == 1)
      report5 << "MSY_not_calculated;_ignore_values" << endl;
  }
  else
  {
    if (F_Method >= 2)
    {
      Fmax = 3.00 * Btgt_Fmult;
    }

    switch (Do_MSY) //  set conditions for the MSY search loops
    {
      case 1: // set Fmsy=Fspr
      {
        Fmult = SPR_Fmult;
        if (F_Method == 1)
        {
          Fmax = SPR_Fmult * 1.1;
        }
        F1(1) = -log(Fmax / SPR_Fmult - 1.);
        last_calc = 0.;
        Fchange = 1.0;
        Closer = 1.;
        Nloops = 0;
        Nloops2 = 0;
        F2(1) = -log(Fmax / SPR_Fmult - 1.);
        break;
      }
      case 3: // set Fmsy=Fbtgt
      {
        Fmult = Btgt_Fmult;
        if (F_Method == 1)
        {
          Fmax = Btgt_Fmult * 1.1;
        }
        F1(1) = -log(Fmax / Btgt_Fmult - 1.);
        last_calc = 0.;
        Fchange = 1.0;
        Closer = 1.0;
        Nloops = 0;
        Nloops2 = 0;
        F2(1) = -log(Fmax / SPR_Fmult - 1.);
        break;
      }
      case 4: //  set fmult for Fmsy to 1
      {
        Fmult = 1;
        Fmax = 1.1;
        F1(1) = -log(Fmax / Fmult - 1.);
        last_calc = 0.;
        Fchange = 1.0;
        Closer = 1.0;
        Nloops = 0;
        Nloops2 = 0;
        F2(1) = -log(Fmax / SPR_Fmult - 1.);
        break;
      }
      case 2: // calc Fmsy
      {
        //  proceed to case 5
      }
      case 5: // calc Fmey
      {
        last_calc = 0.;
        Fchange = 0.51;
        Closer = 1.0;
        if (SR_fxn == 5)
        {
          Nloops2 = 40;
        }
        else
        {
          Nloops2 = 19;
        }
        if (F_Method == 1)
        {
          Fmax = (Btgt_Fmult + SPR_Fmult) * 0.5 * SRparm_bench(2) / 0.05;
        } //  previously /0.18
        F1(1) = -log(Fmax / Btgt_Fmult - 1.);
        F2(1) = -log(Fmax / Btgt_Fmult - 1.);
        break;
      }
    }

    // Compute stats for saving (a bit of a trick)
    if (Do_MSY == 1 || Do_MSY == 3 || Do_MSY == 4) // Fmsy set to existing quantity, so not estimated
    {
      if (show_MSY == 1) //  report some headers
      {
        report5 << "#" << endl
                << MSY_name << endl
                << "Iter Fmult ann_F SPR Catch SSB Recruits SSB/Bzero Gradient Curvature Tot_Ret_Catch";
        for (f = 1; f <= Nfleet; f++)
          report5 << " Ret_Catch:" << f << " ";
        report5 << "Cost Revenue Profit ";
        for (p = 1; p <= pop; p++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            report5 << " Area:" << p << "_GP:" << gp;
          }
        report5 << endl;
      }
      //        Fmult=Fmax/(1.00+mfexp(-F1(1)));  // using the F1 calculated in previous section
      for (f = 1; f <= Nfleet; f++)
      {
        //          if(YPR_mask(f)==1)  // incorrect usage, should use bycatch_setup(f,3) per replacement line below
        if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
        {
          for (int s = 1; s <= nseas; s++)
          {
            Hrate(f, bio_t_base + s) = Fmult * Bmark_RelF_Use(s, f);
          }
        }
        //  else  Hrate for bycatch fleets already set
      }

      SSBpR_Calc(equ_Recr);
      //  SPAWN-RECR:   calc spawn-recr for MSY calcs;  need to make area-specific
      MSY_SPR = SSB_equil / SSBpR_unf;
      SSBpR_temp = SSB_equil;
      Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB0_4_SRR, R0_4_SRR, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
      Bmsy = Equ_SpawnRecr_Result(1);  //  with MSY set to SPR, not directly estimated
      Recr_msy = Equ_SpawnRecr_Result(2);
      yld1(1) = YPR_opt * Recr_msy;
      YPR_msy_enc = YPR_enc;
      YPR_msy_dead = YPR_dead; // total dead yield
      YPR_msy_N_dead = YPR_N_dead; // total dead yield
      YPR_msy_ret = YPR_ret; // total retained yield
      YPR_msy_cost = Cost;
      YPR_msy_revenue = (PricePerF * YPR_val_vec) * Recr_msy; //  vector*vector*scalar
      YPR_msy_profit = YPR_msy_revenue - Cost;
      MSY = yld1(1);
      MSY_Fmult = Fmult;
      if (show_MSY == 1)
      {
        report5 << 1 << " " << Fmult << " " << equ_F_std << " " << MSY_SPR << " " << yld1(1) << " " << Bmsy << " " << Recr_msy << " " << Bmsy / SSB_unf << " "
                << " na "
                << " na " << YPR_msy_ret * Recr_msy;
        report5 << value(equ_catch_fleet(3) * Recr_msy) << " " << Cost << " " << YPR_msy_revenue << " " << Profit << " ";
        for (p = 1; p <= pop; p++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            report5 << " " << SSB_equil_pop_gp(p, gp) * Recr_msy;
          }
        report5 << endl;
      }

      Mgmt_quant(12) = Bmsy;
      Mgmt_quant(13) = MSY_SPR;
      Mgmt_quant(14) = equ_F_std;
      Mgmt_quant(15) = yld1(1);
      Mgmt_quant(16) = YPR_ret * Recr_msy;
      Mgmt_quant(17) = Bmsy / SSB_unf;
      Mgmt_quant(18) = Recr_msy;
      Vbio1_MSY = smrybio;
      Vbio_MSY = totbio;
    }

    else //  (Do_MSY==2 || Do_MSY==5)   // search for FMSY, then optionally for FMEY; FMEY embedded inside this section
    {
      if (show_MSY == 1) //  report some headers
      {
        report5 << endl
                << MSY_name << endl;
        report5 << "Iter Fmult ann_F SPR Opt_Catch_Profit SSB Recruits SSB/Bzero Gradient Curvature Tot_Ret_Catch";
        for (f = 1; f <= Nfleet; f++)
          report5 << " Ret_Catch:" << f << " ";
        report5 << "Cost Revenue Profit ";
        for (p = 1; p <= pop; p++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            report5 << " Area:" << p << "_GP:" << gp;
          }
        report5 << endl;
      }
      bestF1.initialize();
      bestF2.initialize();
      df = 0.050;
      jj = 3;
      Fishon = 1;
      Closer = 1.0;
      for (j = 0; j <= Nloops2; j++) // loop to find Fmsy
      {
        df *= .95;
        Closer *= 0.8;
        F2(2) = F2(1) + df * .5;
        F2(3) = F2(2) - df;
        for (int ii = jj; ii >= 1; ii--)
        {
          Fmult = Fmax / (1.00 + mfexp(-F2(ii)));
          for (f = 1; f <= Nfleet; f++)
          {
            if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
            {
              if (AdjustBenchF(f) == 1)
              {
                for (int s = 1; s <= nseas; s++)
                {
                  Hrate(f, bio_t_base + s) = Fmult * Bmark_RelF_Use(s, f);
                }
              }
              else
              {
                for (int s = 1; s <= nseas; s++)
                {
                  Hrate(f, bio_t_base + s) = Bmark_HistF(s, f);
                }
              }
            } //  else  Hrate for bycatch fleets set above
          }
          SSBpR_Calc(equ_Recr);
          //  SPAWN-RECR:   calc spawn-recr for MSY calcs;  need to make area-specific
          MSY_SPR = SSB_equil / SSBpR_unf;
          SSBpR_temp = SSB_equil;
          Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB0_4_SRR, R0_4_SRR, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
          Bmsy = Equ_SpawnRecr_Result(1);  //  MSY is directly estimated
          Recr_msy = Equ_SpawnRecr_Result(2);
          Profit = (PricePerF * YPR_val_vec) * Recr_msy - Cost;
          if (Do_MSY == 2) //  dead catch without excluded bycatch fleets
          {
            yld1(ii) = YPR_opt * Recr_msy;
          }

          //  else using the bioecon options that depend on MSY_units
          else if (MSY_units == 2) //  retained catch without excluded bycatch fleets, but still with size/age discard
          {
            yld1(ii) = YPR_opt * Recr_msy;
          }
          else if (MSY_units == 1) //  dead catch
          {
            yld1(ii) = YPR_dead * Recr_msy;
          }
          else if (MSY_units == 3) //  retained catch
          {
            yld1(ii) = YPR_ret * Recr_msy;
          }
          else //  profit
          {
            yld1(ii) = (PricePerF * YPR_val_vec) * Recr_msy - Cost;
          }

          bestF1 += F2(ii) * (pow(mfexp(yld1(ii) / 1.0e08), 5) - 1.);
          bestF2 += pow(mfexp(yld1(ii) / 1.0e08), 5) - 1.;
        } //  end gradient calc
        dyld = (yld1(2) - yld1(3)) / df; // First derivative (to find the root of this)
        temp = (yld1(2) + yld1(3) - 2. * yld1(1)) / (.25 * df * df); // Second derivative (for Newton Raphson)
        dyldp = -sqrt(temp * temp + 1.); //  add 1 to keep curvature reasonably large
        last_F1 = F2(1);
        temp = F2(1) - dyld * (1. - Closer) / (dyldp);
        if (show_MSY == 1)
        {
          report5 << j << " " << Fmult << " " << equ_F_std << " " << MSY_SPR << " " << yld1(1) << " " << Bmsy << " " << Recr_msy << " " << Bmsy / SSB_unf << " "
                  << dyld << " " << dyldp << " " << value(sum(equ_catch_fleet(3)) * Recr_msy) << " ";
          report5 << " " << value(colsum(equ_catch_fleet(3)) * Recr_msy) << " " << Cost << " " << PricePerF * YPR_val_vec * Recr_msy << " " << Profit << " ";
          //  colsum above sums across seasons so reports annual catch for each fleet, including survey fleets
          for (p = 1; p <= pop; p++)
            for (gp = 1; gp <= N_GP; gp++)
            {
              report5 << " " << SSB_equil_pop_gp(p, gp) * Recr_msy;
            }
          for (int ff = 1; ff <= N_catchfleets(0); ff++)
          {
            f = fish_fleet_area(0, ff);
            report5 << " " << Hrate(f, bio_t_base + 1) << " ";
          }
          report5 << endl;
        }
        if (j <= 9)
        {
          F2(1) = (1. - Closer) * temp + Closer * (bestF1 / bestF2);
        } // averages with best value to keep from changing too fast
        else
        {
          F2(1) = temp;
        }
      } // end search loop

      YPR_msy_enc = YPR_enc;
      YPR_msy_dead = YPR_dead; // total dead yield
      YPR_msy_N_dead = YPR_N_dead; // total dead yield
      YPR_msy_ret = YPR_ret; // total retained yield
      YPR_msy_cost = Cost;
      YPR_msy_revenue = (PricePerF * YPR_val_vec) * Recr_msy; //  vector*vector*scalar
      YPR_msy_profit = YPR_msy_revenue - Cost;
      MSY = yld1(1);
      MSY_Fmult = Fmult;
      Mgmt_quant(12) = Bmsy;
      Mgmt_quant(13) = MSY_SPR;
      Mgmt_quant(14) = equ_F_std;
      Mgmt_quant(15) = yld1(1);
      Mgmt_quant(16) = YPR_ret * Recr_msy;
      Mgmt_quant(17) = Bmsy / SSB_unf;
      Mgmt_quant(18) = Recr_msy;

      Vbio1_MSY = smrybio;
      Vbio_MSY = totbio;

      if (show_MSY == 1)
      {
        if (fabs(dyld / dyldp) >= 0.001)
        {
          warnstream << "poor convergence in Fmsy, final dy/dy2= " << dyld / dyldp;
          write_message (WARN, 0);
        }
        report5 << "seas fleet Hrate encB deadB retB encN deadN retN): " << endl;
        for (s = 1; s <= nseas; s++)
          for (f = 1; f <= Nfleet; f++)
            if (fleet_type(f) <= 2)
            {
              report5 << s << " " << f << " " << Hrate(f, bio_t_base + s);
              for (g = 1; g <= 6; g++)
              {
                report5 << " " << Recr_msy * equ_catch_fleet(g, s, f);
              }
              report5 << endl;
            }
        report5 << "Equil_N_at_age_at_MSY_each" << endl
                << "Seas Area GP Sex subM" << age_vector << endl;
        for (s = 1; s <= nseas; s++)
          for (p = 1; p <= pop; p++)
            for (g = 1; g <= gmorph; g++)
            {
              if (use_morph(g) > 0)
                report5 << s << " " << p << " " << GP4(g) << " " << sx(g) << " " << GP2(g) << " " << Recr_msy * equ_numbers(s, p, g)(0, nages) << endl;
            }

        report5 << "Equil_N_at_age_at_MSY_sum" << endl
                << "GP Sex N/Z" << age_vector << endl;
        for (gg = 1; gg <= gender; gg++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            tempvec_a.initialize();
            for (p = 1; p <= pop; p++)
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  if (GP4(g) == gp && sx(g) == gg)
                    tempvec_a += value(Recr_msy * equ_numbers(1, p, g)(0, nages));
                }
            if (nseas > 1)
            {
              tempvec_a(0) = 0.;
              for (s = 1; s <= nseas; s++)
                for (p = 1; p <= pop; p++)
                  for (g = 1; g <= gmorph; g++)
                    if (use_morph(g) > 0 && Bseas(g) == s)
                    {
                      if (GP4(g) == gp && sx(g) == gg)
                        tempvec_a(0) += value(Recr_msy * equ_numbers(1, p, g, 0));
                    }
            }
            report5 << gp << " " << gg << " N " << tempvec_a << endl;
            report5 << gp << " " << gg << " Z ";
            for (a = 0; a <= nages - 2; a++)
            {
              report5 << -log(tempvec_a(a + 1) / tempvec_a(a)) << " ";
            }
            report5 << " NA NA" << endl;
          }

        Fishon = 0;
        SSBpR_Calc(equ_Recr);
        report5 << "Equil_N_at_age_M_only_Recr_MSY" << endl
                << "Seas Area GP Sex subM" << age_vector << endl;
        for (s = 1; s <= nseas; s++)
          for (p = 1; p <= pop; p++)
            for (g = 1; g <= gmorph; g++)
            {
              if (use_morph(g) > 0)
                report5 << s << " " << p << " " << GP4(g) << " " << sx(g) << " " << GP2(g) << " " << Recr_msy * equ_numbers(s, p, g)(0, nages) << endl;
            }

        report5 << "Equil_N_at_age_M_only_sum" << endl
                << "GP Sex N/Z " << age_vector << endl;
        for (gg = 1; gg <= gender; gg++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            tempvec_a.initialize();
            for (p = 1; p <= pop; p++)
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  if (GP4(g) == gp && sx(g) == gg)
                    tempvec_a += value(Recr_msy * equ_numbers(1, p, g)(0, nages));
                }
            if (nseas > 1)
            {
              tempvec_a(0) = 0.;
              for (s = 1; s <= nseas; s++)
                for (p = 1; p <= pop; p++)
                  for (g = 1; g <= gmorph; g++)
                    if (use_morph(g) > 0 && Bseas(g) == s)
                    {
                      if (GP4(g) == gp && sx(g) == gg)
                        tempvec_a(0) += value(Recr_msy * equ_numbers(1, p, g, 0));
                    }
            }
            report5 << gp << " " << gg << " N " << tempvec_a << endl;
            report5 << gp << " " << gg << " Z ";
            for (a = 0; a <= nages - 2; a++)
            {
              report5 << -log(tempvec_a(a + 1) / tempvec_a(a)) << " ";
            }
            report5 << " NA NA" << endl;
          }

        Fishon = 1;

        if (Fmult * 3.0 <= SPR_Fmult)
        {
          warnstream << "Fmsy/mey is <1/3 of Fspr are you sure?  check for convergence ";
          write_message (WARN, 0);
        }
        if (Fmult / 3.0 >= SPR_Fmult)
        {
          warnstream << "Fmsy/mey is >3x of Fspr are you sure?  check for convergence ";
          write_message (WARN, 0);
        }
        if (Fmult / 0.98 >= Fmax)
        {
          warnstream << "Fmsy.mey is close to max allowed; check for convergence ";
          write_message (WARN, 0);
        }
        report5 << "end Seach for MSY" << endl;
      } // end Do_MSY = 2
    }
  }

  if (Do_Benchmark == 3) //  find F giving B as fraction of Bmsy
  {
    if (show_MSY == 1)
    {
      report5 << "#" << endl
              << "Find_target_SSB/Blimit; where Blimit is a fraction of Bmsy" << Blim_frac << endl
              << "Iter Fmult ann_F SPR Catch SSB Recruits SSB/Bzero Tot_catch";
      for (p = 1; p <= pop; p++)
        for (gp = 1; gp <= N_GP; gp++)
        {
          report5 << " SSB_Area:" << p << "_GP:" << gp;
        }
      report5 << endl;
    }

    F1(1) = log(1.0e-3);
    last_calc = 0.;
    Fchange = -4.0;
    df = 1.e-5;
    Closer = 1.;
    dvariable Closer2;
    if (SR_fxn == 5)
    {
      Closer2 = 0.001;
      Nloops = 40;
    }
    else
    {
      Closer2 = 0.10;
      Nloops = 28;
    }

    //    Btgttgt=BTGT_frac*SSB_virgin;   //  this is relative to virgin, not to the average biology from benchmark years
    double Blim_report;
    if (Blim_frac > 0.0)
    {
      Btgttgt2 = Blim_frac * Bmsy;
      Blim_report = value(Bmsy);
    }
    else if (depletion_basis == 1)
    {
      Btgttgt2 = -Blim_frac * SSB_virgin;
      Blim_report = value(SSB_virgin);
    }
    else
    {
      Btgttgt2 = -Blim_frac * SSB_unf;
      Blim_report = value(SSB_unf);
    }

    for (j = 0; j <= Nloops; j++) // loop find Btarget
    {
      if (fabs(Fchange) <= Closer2)
      {
        jj = 3;
        F1(2) = F1(1) + df * .5;
        F1(3) = F1(2) - df;
      }
      else
      {
        jj = 1;
      }
      for (int ii = jj; ii >= 1; ii--)
      {
        if (j == 0)
        {
          Fmult = 0.0;
        }
        else
        {
          Fmult = 40.00 / (1.00 + mfexp(-F1(ii)));
        }
        for (f = 1; f <= Nfleet; f++)
        {
          if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
          {
            for (int s = 1; s <= nseas; s++)
            {
              Hrate(f, bio_t_base + s) = Fmult * Bmark_RelF_Use(s, f);
            }
          }
          //  else  Hrate for bycatch fleets already set
        }
        SSBpR_Calc(equ_Recr);
        SPR_Btgt2 = SSB_equil / SSBpR_unf;
        //  SPAWN-RECR:   calc equil spawn-recr for Btarget calcs;  need to make area-specific
        SSBpR_temp = SSB_equil;
        Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench, SSB0_4_SRR, R0_4_SRR, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
        yld1(ii) = Equ_SpawnRecr_Result(1);
      }

      Btgt2 = Equ_SpawnRecr_Result(1); //  so uses benchmark average years

      if (jj == 3)
      {
        Closer *= 0.5;
        dyld = (yld1(2) - yld1(3)) / df; // First derivative
        if (dyld != 0.)
        {
          last_F1 = F1(1);
          F1(1) -= (Btgt2 - Btgttgt2) / (dyld + 0.001);
          F1(1) = (1. - Closer) * F1(1) + (Closer)*last_F1;
        } // weighted average with last good value to keep from changing too fast
        else
        {
          F1(1) = (F1(1) + last_F1) * 0.5;
        } // go halfway back towards previous value
      }
      else
      {
        temp = (last_calc - Btgttgt2) * (Btgt2 - Btgttgt2) / (sfabs(last_calc - Btgttgt2) * sfabs(Btgt2 - Btgttgt2)); // values of -1 or 1
        temp1 = temp - 1.; // values of -2 or 0
        Fchange *= exp(temp1 / 4.) * temp;
        F1(1) += Fchange;
        last_calc = Btgt2;
      }

      if (show_MSY == 1)
      {
        report5 << j << " " << Fmult << " " << equ_F_std << " " << SPR_Btgt2 << " " << YPR_dead * Equ_SpawnRecr_Result(2) << " " << Btgt2 << " " << Equ_SpawnRecr_Result(2)
                << " " << Btgt2 / Blim_report << " " << sum(equ_catch_fleet(2)) * Equ_SpawnRecr_Result(2);
        for (p = 1; p <= pop; p++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            report5 << " " << SSB_equil_pop_gp(p, gp) * Equ_SpawnRecr_Result(2);
          }
        report5 << endl;
      }
    } // end search loop

    Btgt_Rec2 = Equ_SpawnRecr_Result(2);

    if (show_MSY == 1)
    {
      if (fabs(log(Btgt2 / Btgttgt2)) >= 0.001)
      {
        warnstream << "poor convergence in Blimit search " << Btgttgt2 << " " << Btgt2 ;
        write_message (WARN, 0);
      }
      report5 << "seas fleet Hrate encB deadB retB encN deadN retN): " << endl;
      for (s = 1; s <= nseas; s++)
        for (int ff = 1; ff <= N_catchfleets(0); ff++)
        {
          f = fish_fleet_area(0, ff);
          report5 << s << " " << f << " " << Hrate(f, bio_t_base + s);
          for (g = 1; g <= 6; g++)
          {
            report5 << " " << Btgt_Rec2 * equ_catch_fleet(g, s, f);
          }
          report5 << endl;
        }
    }

    Btgt_Fmult2 = Fmult;
    if (rundetail > 0 && mceval_counter == 0 && show_MSY == 1)
      echoinput << "Calculated F_Blimit " << Btgt_Fmult2 << " " << Btgt2 / Blim_report << endl;
    Mgmt_quant(N_STD_Mgmt_Quant - 2) = Btgt2;
    Mgmt_quant(N_STD_Mgmt_Quant - 1) = equ_F_std;
    Mgmt_quant(N_STD_Mgmt_Quant) = sum(equ_catch_fleet(2)) * Equ_SpawnRecr_Result(2);
  } //  end finding F for Blimit

  if (rundetail > 0 && mceval_counter == 0 && show_MSY == 1)
    echoinput << "Calculated Fmsy " << MSY_Fmult << " " << MSY << endl;

  // ***************** show management report   SS_Label_740
  if (show_MSY == 1)
  {
    report5 << "#" << endl
            << "Management_report" << endl;
    report5 << "Virgin: Steepness_Recr_SSB " << SRparm(2) << " " << Recr_virgin << " " << SSB_virgin << endl;
    report5 << "Bench:  Steepness_Recr_SSB " << SRparm_bench(2) << " " << R0_4_SRR << " " << SSB0_4_SRR << endl;
    report5 << "unf  :  Steepness_Recr_SSB " << SRparm_bench(2) << " " << Recr_unf << " " << SSB_unf << endl;
    report5 << "#" << endl
            << "Summary_age: " << Smry_Age << endl;
    report5 << "#_Bmark_years: beg_bio, end_bio, beg_selex, end_selex, beg_relF, end_relF, beg_recr_dist, end_recr_dist, beg_SRparm, end_SRparm" << endl
            << Bmark_Yr << endl;
    if (N_bycatch > 0)
    {
      report5 << "Bycatch_Fleets: " << column(bycatch_setup, 1) << endl;
      report5 << "Fleets_in_optimized_catch: " << YPR_mask << endl;
      report5 << "Bycatch_Fleets_F_scaling: " << column(bycatch_setup, 3) << endl;
    }
    report5 << "#" << endl
            << "Element Value Value/Recr" << endl;
    report5 << "Recr_unfished(Bmark) " << Recr_unf << endl;
    report5 << "SSB_unfished(Bmark) " << SSB_unf << " " << SSB_unf / Recr_unf << endl;
    report5 << "BIO_Smry_unfished(Bmark) " << Vbio1_unfished * Recr_unf << " " << Vbio1_unfished << endl;
    report5 << "#" << endl
            << "Spawner_Potential_Ratio_as_target" << endl;

    report5 << "SPR_target " << SPR_target << endl;
    report5 << "SPR_calc " << SPR_actual / 100. << endl;
    report5 << "Fmult " << SPR_Fmult << endl;
    report5 << "ann_F " << Mgmt_quant(10) << endl;
    report5 << "Exploit(Catch_dead/B_smry) " << YPR_spr_dead / Vbio1_spr << endl;
    report5 << "Recruits " << Bspr_rec << endl;
    report5 << "SSBio " << Bspr << " " << Bspr / Bspr_rec << endl;
    report5 << "Catch_encountered " << YPR_spr_enc * Bspr_rec << " " << YPR_spr_enc << endl;
    report5 << "Catch_dead " << YPR_spr_dead * Bspr_rec << " " << YPR_spr_dead << endl;
    report5 << "Catch_retain " << YPR_spr_ret * Bspr_rec << " " << YPR_spr_ret << endl;
    report5 << "Revenue " << YPR_spr_revenue << endl;
    report5 << "Cost " << YPR_spr_cost << endl;
    report5 << "Profit " << YPR_spr_profit << endl;
    report5 << "Biomass_Smry " << Vbio1_spr * Bspr_rec << " " << Vbio1_spr << endl;

    if (Do_Benchmark == 2) //  F0.1
    {
      report5 << "#" << endl
              << "F0.1_as_target" << endl;
      report5 << "slope_target: " << F01_origin * 0.1 << endl;
      report5 << "slope_calc:   " << F01_actual << endl;
      report5 << "SPR@F0.1 " << SPR_Btgt << endl;
      report5 << "Fmult " << Btgt_Fmult << endl;
      report5 << "ann_F " << Mgmt_quant(7) << endl;
      report5 << "Exploit(Catch_dead/B_smry) " << YPR_Btgt_dead / Vbio1_Btgt << endl;
      report5 << "Recruits@F0.1 " << Btgt_Rec << endl;
      report5 << "SSBio " << Btgt << " " << Btgt / Btgt_Rec << endl;
      report5 << "Catch_encountered " << YPR_Btgt_enc * Btgt_Rec << " " << YPR_Btgt_enc << endl;
      report5 << "Catch_dead " << YPR_Btgt_dead * Btgt_Rec << " " << YPR_Btgt_dead << endl;
      report5 << "Catch_retain " << YPR_Btgt_ret * Btgt_Rec << " " << YPR_Btgt_ret << endl;
      report5 << "Revenue " << YPR_Btgt_revenue << endl;
      report5 << "Cost " << YPR_Btgt_cost << endl;
      report5 << "Profit " << YPR_Btgt_profit << endl;
      report5 << "Biomass_Smry " << Vbio1_Btgt * Btgt_Rec << " " << Vbio1_Btgt << endl;
    }
    else
    {
      report5 << "#" << endl
              << "Ratio_SSB/B0_as_target" << endl;
      report5 << "Ratio_target  " << BTGT_frac << endl;
      report5 << "Ratio_calc " << Btgt / SSB_unf << endl;
      report5 << "SPR@Btgt " << SPR_Btgt << endl;
      report5 << "Fmult " << Btgt_Fmult << endl;
      report5 << "ann_F " << Mgmt_quant(7) << endl;
      report5 << "Exploit(Catch_dead/B_smry) " << YPR_Btgt_dead / Vbio1_Btgt << endl;
      report5 << "Recruits " << Btgt_Rec << endl;
      report5 << "SSBio " << Btgt << " " << Btgt / Btgt_Rec << endl;
      report5 << "Catch_encountered " << YPR_Btgt_enc * Btgt_Rec << " " << YPR_Btgt_enc << endl;
      report5 << "Catch_dead " << YPR_Btgt_dead * Btgt_Rec << " " << YPR_Btgt_dead << endl;
      report5 << "Catch_retain " << YPR_Btgt_ret * Btgt_Rec << " " << YPR_Btgt_ret << endl;
      report5 << "Revenue " << YPR_Btgt_revenue << endl;
      report5 << "Cost " << YPR_Btgt_cost << endl;
      report5 << "Profit " << YPR_Btgt_profit << endl;
      report5 << "Biomass_Smry " << Vbio1_Btgt * Btgt_Rec << " " << Vbio1_Btgt << endl;
    }

    report5 << "#" << endl
            << MSY_name << endl;
    report5 << "SPR@MSY " << MSY_SPR << endl;
    report5 << "Fmult " << MSY_Fmult << endl;
    report5 << "ann_F " << Mgmt_quant(14) << endl;
    report5 << "Exploit(Catch/Bsmry) " << MSY / (Vbio1_MSY * Recr_msy) << endl;
    report5 << "Recruits@MSY " << Recr_msy << endl;
    report5 << "SSBmsy " << Bmsy << " " << Bmsy / Recr_msy << endl;
    report5 << "SSBmsy/SSB_virgin " << Bmsy / SSB_virgin << endl;
    report5 << "SSBmsy/SSB_unfished " << Bmsy / SSB_unf << endl;
    report5 << "MSY_for_optimize " << MSY << " " << MSY / Recr_msy << endl;
    report5 << "MSY_encountered " << YPR_msy_enc * Recr_msy << " " << YPR_msy_enc << endl;
    report5 << "MSY_dead " << YPR_msy_dead * Recr_msy << " " << YPR_msy_dead << endl;
    report5 << "MSY_retain " << YPR_msy_ret * Recr_msy << " " << YPR_msy_ret << endl;
    report5 << "MSY_revenue " << YPR_msy_revenue << endl;
    report5 << "MSY_cost " << YPR_msy_cost << endl;
    report5 << "MSY_profit " << YPR_msy_profit << endl;
    report5 << "Biomass_Smry " << Vbio1_MSY * Recr_msy << " " << Vbio1_MSY << endl
            << "#" << endl;
  }
  else if (show_MSY == 2) //  do brief output
  {
    SS2out << SPR_actual / 100. << " " << SPR_Fmult << " " << Mgmt_quant(10) << " " << YPR_spr_dead / Vbio1_spr << " " << Bspr_rec << " "
           << Bspr << " " << YPR_spr_dead * Bspr_rec << " " << YPR_spr_ret * Bspr_rec
           << " " << Vbio1_spr * Bspr_rec << " # ";

    SS2out << SPR_Btgt << " " << Btgt / SSB_unf << " " << Btgt_Fmult << " " << Mgmt_quant(7) << " " << YPR_Btgt_dead / Vbio1_Btgt << " " << Btgt_Rec << " "
           << Btgt << " " << YPR_Btgt_dead * Btgt_Rec << " " << YPR_Btgt_ret * Btgt_Rec
           << " " << Vbio1_Btgt * Btgt_Rec << " # ";

    SS2out << MSY_SPR << " " << Bmsy / SSB_unf << " " << MSY_Fmult << " " << Mgmt_quant(14) << " " << MSY / (Vbio1_MSY * Recr_msy) << " " << Recr_msy << " "
           << Bmsy << " " << MSY << " " << YPR_msy_dead * Recr_msy << " " << YPR_msy_ret * Recr_msy
           << " " << Vbio1_MSY * Recr_msy << " # " << endl;
  }
  write_bodywt = write_bodywt_save;
//    report5 << "Repro_output_by_age_for_morph_1_after_benchmark: " << fec(1) << endl;
  } //  end benchmarks

FUNCTION void Get_Forecast()
  {
  //********************************************************************
  /*  SS_Label_FUNCTION 35 Get_Forecast */
  t_base = styr + (endyr - styr) * nseas - 1;
  int adv_age;
  dvariable OFL_catch;
  dvariable Fcast_Crash;
  dvariable totcatch;
  dvar_matrix catage_w(1, gmorph, 0, nages);
  dvar_vector tempcatch(1, Nfleet);
  imatrix Do_F_tune(t_base, TimeMax_Fcast_std, 1, Nfleet); //  flag for doing F from catch
  dvar_matrix Fcast_Catch_Store(t_base, TimeMax_Fcast_std, 1, Nfleet);
  dvar_vector Fcast_Catch_Calc_Annual(1, Nfleet);
  dvar_vector Fcast_Catch_Allocation_Group(1, Fcast_Catch_Allocation_Groups);
  dvar_vector Fcast_Catch_ByArea(1, pop);

  dvar_vector H_temp(1, Nfleet);
  dvar_vector C_temp(1, Nfleet);
  dvar_vector H_old(1, Nfleet);
  dvar_vector C_old(1, Nfleet);
  int Tune_F;
  int Tune_F_loops;

  int ABC_Loop_start = 1;
  int ABC_Loop_end = 3;

  Do_F_tune.initialize();

  if (fishery_on_off == 1)
  {
    switch (Do_Forecast)
    {
      case 1:
      {

        Fcast_Fmult = SPR_Fmult;
        if (show_MSY == 1)
          report5 << "1:  Forecast_using_Fspr: " << Fcast_Fmult << endl;
        break;
      }
      case 2:
      {
        Fcast_Fmult = MSY_Fmult;
        if (show_MSY == 1)
          report5 << "2:  Forecast_using_Fmsy: " << Fcast_Fmult << endl;
        break;
      }
      case 3:
      {
        Fcast_Fmult = Btgt_Fmult;
        if (show_MSY == 1)
          report5 << "3:  Forecast_using_F(Btarget): " << Fcast_Fmult << endl;
        break;
      }
      case 4:
      {
        Fcast_Fmult = 0.0;
        for (y = Fcast_RelF_yr1; y <= Fcast_RelF_yr2; y++)
          for (s = 1; s <= nseas; s++)
            for (int ff = 1; ff <= N_catchfleets(0); ff++)
            {
              f = fish_fleet_area(0, ff);
              if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
              {
                t = styr + (y - styr) * nseas + s - 1;
                Fcast_Fmult += Hrate(f, t);
              }
            }
        Fcast_Fmult /= float(Fcast_RelF_yr2 - Fcast_RelF_yr1 + 1);
        Fcurr_Fmult = Fcast_Fmult;
        if (show_MSY == 1)
          report5 << "4:  Forecast_using_ave_F_from:_" << Fcast_RelF_yr1 << "_" << Fcast_RelF_yr2 << " value: " << Fcast_Fmult << endl;
        break;
      }
      case 5:
      {
        Fcast_Fmult = Fcast_Flevel;
        if (show_MSY == 1)
          report5 << "5:  Forecast_using_input_F " << Fcast_Flevel << endl;
        break;
      }
    }
    join1 = 1. / (1. + mfexp(30. * (Fcast_Fmult - max_harvest_rate)));
    Fcast_Fmult = join1 * Fcast_Fmult + (1. - join1) * max_harvest_rate; // new F value for this fleet, constrained by max_harvest_rate
    if (join1 < 0.999)
    {
      warnstream << "Forecast F capped by max possible F from control file" << max_harvest_rate;
      report5 << warnstream.str() << endl;
      write_message (WARN, 0);
    }
  }
  else
  {
    Fcast_Fmult = 0.0;
  }
  if (show_MSY == 1) //  write more headers
  {
    report5 << "Annual_Forecast_Fmult: " << Fcast_Fmult << endl;
    report5 << "Fmultiplier_during_selected_relF_years_was: " << Fcurr_Fmult << endl;
    report5 << "Selectivity_averaged_over_yrs:_" << Fcast_Sel_yr1 << "_to_" << Fcast_Sel_yr2 << endl;

//  Fcast_Loop_Control(3)  need to embellish this to report all options
    if (Fcast_Loop_Control(3) == 1)
    {
      report5 << "Forecast_base_recruitment_from_spawn_recr_with_multiplier: " << Fcast_Loop_Control(4) << endl;
    }
    else if (Fcast_Loop_Control(3) == 2)
    {
      report5 << "Forecast_base_recruitment_is_adjusted_R0_with_multiplier: " << Fcast_Loop_Control(4) << endl;
    }
    else if (Fcast_Loop_Control(3) == 4)
    {
      report5 << "Forecast_base_recruitment_mean_from_yrs:_" << Fcast_Rec_yr1 << "_to_" << Fcast_Rec_yr2 << endl;
    }

    report5 << "Cap_totalcatch_by_fleet " << endl
            << Fcast_MaxFleetCatch << endl;
    report5 << "Cap_totalcatch_by_area " << endl
            << Fcast_MaxAreaCatch << endl;
    report5 << "Assign_fleets_to_allocation_groups_(0_means_not_in_a_group) " << endl
            << Allocation_Fleet_Assignments << endl;
    report5 << "Calculated_number_of_allocation_groups " << Fcast_Catch_Allocation_Groups << endl;
    if (Fcast_Catch_Allocation_Groups > 0)
    {
      report5 << "Year ";
      for (f = 1; f <= Fcast_Catch_Allocation_Groups; f++)
        report5 << " group_" << f;
      report5 << endl;
      for (y = endyr + 1; y <= YrMax; y++)
      {
        report5 << y << " " << Fcast_Catch_Allocation(y - endyr) << endl;
      }
    }
    if (Fcast_Catch_Basis == 2)
    {
      report5 << "2:_Caps_&_Alloc_use_dead_catchbio" << endl;
    }
    else if (Fcast_Catch_Basis == 3)
    {
      report5 << "3:_Caps_&_Alloc_use_retained_catchbio" << endl;
    }
    else if (Fcast_Catch_Basis == 5)
    {
      report5 << "5:_Caps_&_Alloc_use_dead_catchnum" << endl;
    }
    else if (Fcast_Catch_Basis == 6)
    {
      report5 << "6:_Caps_&_Alloc_use_retained_catchnum" << endl;
    }
    if (N_Fcast_Input_Catches > 0)
    {
      report5 << "-1 #Input_fixed_catches_or_F_with_fleet/time_specific_values (3 for retained catch; 2 for dead catch; 99 for F); NOTE: bio vs. num based on fleet's catchunits" << endl;
    }
    report5 << "#_Relative_F_among_fleets" << endl;
    if (Fcast_RelF_Basis == 1)
    {
      report5 << "based_on_years:_" << Fcast_RelF_yr1 << " _to_ " << Fcast_RelF_yr2 << endl;
    }
    else
    {
      report5 << "read_from_input_file" << endl;
    }
    if (F_Method == 1)
    {
      report5 << "Pope's_midseason_exploitation_rate=Fmult*Alloc" << endl;
      report5 << "seas seas_dur ";
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        report5 << " fleet:" << f;
      }
      report5 << endl;
      for (s = 1; s <= nseas; s++)
      {
        report5 << s << " " << seasdur(s);
        for (int ff = 1; ff <= N_catchfleets(0); ff++)
        {
          f = fish_fleet_area(0, ff);
          if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
          {
            report5 << " " << Fcast_Fmult * Fcast_RelF_Use(s, f);
          }
          else if (fleet_type(f) == 2)
          {
            report5 << " " << bycatch_F(f, s);
          }
        }
        report5 << endl;
      }
    }
    else
    {
      report5 << "Seasonal_apicalF=Fmult*Alloc*seas_dur_(can_be>ann_F_because_of_selex)" << endl;
      report5 << "seas seas_dur ";
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        report5 << " " << fleetname(f);
      }
      report5 << endl;
      for (s = 1; s <= nseas; s++)
      {
        report5 << s << " " << seasdur(s);
        for (int ff = 1; ff <= N_catchfleets(0); ff++)
        {
          f = fish_fleet_area(0, ff);
          if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
          {
            report5 << " " << Fcast_Fmult * Fcast_RelF_Use(s, f) * seasdur(s);
          }
          else if (fleet_type(f) == 2)
          {
            report5 << " " << bycatch_F(f, s) * seasdur(s);
          }
        }
        report5 << endl;
      }
    }

    if (Fcast_Loop_Control(5) == 1)
    {HCR_anchor = SSB_virgin;}
    else if (Fcast_Loop_Control(5) == 2)
    {HCR_anchor = SSB_unf;}
    else if (Fcast_Loop_Control(5) == 3)
    {HCR_anchor = Bmsy;}  // so H4010_top_rd should be 1.0;

    if (H4010_top_rd < 0.0)  // legacy approach.  This has already been converted to new approach in readdata
    {
      H4010_top = Bmsy / HCR_anchor;  // convert to fraction of anchor
      if (H4010_bot > 0.25)
      {
        warnstream << "control rule cutoff is large (" << H4010_bot << "); so may not be < calculated Bmsy/SSB_unf (" << H4010_top << ")";
        write_message (WARN, 0);
      }
    }
    else
    {
      H4010_top = H4010_top_rd;
    }
    if (Fcast_Loop_Control(5) == 3 && H4010_top_rd != 1.0)
    {  
      warnstream << "HCR_anchor is BMSY; so H4010_top normally is 1.0; are you sure you want:  " << H4010_top;
      write_message (WARN, 0);
    }

    Mgmt_quant(20) = H4010_top * HCR_anchor;
    report5 << "#" << endl;
    report5 << "N_forecast_yrs: " << N_Fcast_Yrs << endl;
    report5 << "OY_Control_Rule:  Inflection: " << H4010_top << " Intercept: " << H4010_bot << " Scale: " << H4010_scale_vec(endyr + 1) << endl
            << "Control_rule_anchor_approach: " << Fcast_Loop_Control(5) << " HCR_anchor: " << HCR_anchor << endl
            << "intercept(SSB): " << H4010_bot * HCR_anchor << endl
            << "Inflection(SSB): " << H4010_top * HCR_anchor << endl
            << "#" << endl;

    switch (HarvestPolicy)
    {
      case 0: // none
      {
        report5 << "Policy (0): no ramp or buffer; F_ABC=F_limit" << endl;
        break;
      }
      case 1: // west coast
      {
        report5 << "Policy (1): ramp scales catch as f(B) and buffer (H4010_scale) applied to F" << endl;
        break;
      }
      case 2: // Alaska
        //
        {
          report5 << "Policy (2): ramp scales F as f(B) and buffer (H4010_scale) applied to F" << endl;
          break;
        }
      case 3: // west coast
      {
        report5 << "Policy (3): ramp scales catch as f(B) and buffer (H4010_scale) applied to catch after applying ramp" << endl;
        break;
      }
      case 4: // Alaska
      {
        report5 << "Policy (4): ramp scales F as f(B) and buffer (H4010_scale) applied to catch after applying ramp" << endl;
        break;
      }
    }
    }

  int jloop;
  if (fishery_on_off == 1 || Do_Dyn_Bzero > 0)
  {
    jloop = Fcast_Loop_Control(1);
  }
  else
  {
    jloop = 1;
  }
  write_bodywt_save = write_bodywt; //  save initial value so can be restored in last loop

  for (int Fcast_Loop1 = 1; Fcast_Loop1 <= jloop; Fcast_Loop1++) //   for different forecast conditions
  {
//    report5 << Fcast_Loop1 << " y: " << 0 << " Repro_output_by_age_for_morph_1 top_forecast: " << fec(1) << endl;

    switch (Fcast_Loop1) //  select which ABC_loops to use
    {
      case 1: // do OFL only
      {
        ABC_Loop_start = 1;
        ABC_Loop_end = 1;
        if (show_MSY == 1)
          report5 << "FORECAST:_With_Constant_F=Fofl;_No_Input_Catches_or_Adjustments;_Equil_Recr;_No_inpl_error" << endl;
        break;
      }
      case 2: //  for each year:  do 3 calculations:  (1) OFL, (2) calc ABC and apply caps and allocations, (3) get F from catch _impl
      {
        ABC_Loop_start = 1;
        ABC_Loop_end = 3;
        if (show_MSY == 1)
          report5 << "FORECAST:_With_F=Fabc;_With_Input_Catches_and_Catch_Adjustments;_Equil_Recr;_No_inpl_error" << endl;
        break;
      }
      case 3: //  just need to get F from stored adjusted catch (after modifying stored catch by implementation error).
      {
        ABC_Loop_start = 3;
        ABC_Loop_end = 3;
        if (show_MSY == 1)
          report5 << "FORECAST:_With_F_to_match_adjusted_catch;_With_Input_Catches_and_Catch_Adjustments;_Stochastic_Recr;_With_inpl_error" << endl;
        break;
      }
    }
    if (show_MSY == 1)
    {
      if (HarvestPolicy == 0)
        report5 << "pop year ABC_Loop season No_buffer bio-all bio-Smry SpawnBio Depletion recruit-0 ";
      if (HarvestPolicy <= 2)
        report5 << "pop year ABC_Loop season Ramp&Buffer Buffer2 bio-all bio-Smry SpawnBio Depletion recruit-0 ";
      if (HarvestPolicy >= 3)
        report5 << "pop year ABC_Loop season Ramp bio-all bio-Smry SpawnBio Depletion recruit-0 ";
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        report5 << " sel(B):_" << f << " dead(B):_" << f << " retain(B):_" << f << " sel(N):_" << f << " dead(N):_" << f << " retain(N):_" << f << " F:_" << f << " R/C";
      }
      report5 << " Catch_Cap Total_Catch ann_F" << endl;
    }

    //  note that spawnbio and Recruits need to retain their value from calculation in endyr,
    //  so can be used to distribute recruitment in year endyr+1 if recruitment distribution occurs before spawning season
    //  would be better to back up to last mainrecrdev and start with begin of forecast
    SSB_current = SSB_yr(endyr);
    Recruits = exp_rec(endyr, 4);
    //  need to distribute these recruits forward into endyr+1

    //  refresh quantities that might have changed in benchmark.
    //  some of these might be change within forecast also
    //    recr_dist(endyr)=recr_dist_endyr;
    //    natM=natM_endyr;

    y = endyr;
    {
      ALK_subseas_update = 1; //  to indicate that all ALKs need calculation
      //    if(MG_active(2)
      get_growth2(y);
      t = styr + (y - styr) * nseas - 1;

      for (s = 1; s <= nseas; s++)
      {
        t++;
        for (subseas = 1; subseas <= N_subseas; subseas++) //  do all subseasons in first year
        {
          get_growth3(y, t, s, subseas); //  in case needed for Lorenzen M
          Make_AgeLength_Key(s, subseas); //  which also updates Wt_Age_beg, etc.
        }
//        if (s == spawn_seas)  //  
        {
          if (WTage_rd == 1)
          {
            Wt_Age_beg(s) = Wt_Age_t(t, 0); //  used for smrybio
            Wt_Age_mid(s) = Wt_Age_t(t, -1);
            if (s == spawn_seas)
              fec = Wt_Age_t(t, -2);
          }
          else
          {
            get_mat_fec();  // does spawnseas and stores in wt_Age_t(t, -2)
          }
        }
      }
    }
//    report5 << Fcast_Loop1 << " y: " << y << " updated_Repro_output_by_age_for_morph_1 endyr: " << fec(1) << endl;
    for (y = endyr + 1; y <= YrMax; y++)
    {
      t_base = styr + (y - styr) * nseas - 1;
      for (f = 1; f <= N_SRparm2; f++)
      {
        if (SRparm_timevary(f) == 0)
        {
          //  no change to SRparm_work
        }
        else
        {
          SRparm_work(f) = parm_timevary(SRparm_timevary(f), y);
        }
        SRparm_byyr(y, f) = SRparm_work(f);
      }
      env_data(y, -1) = log(SSB_current / SSB_yr(styr - 1)); //  store most recent value for density-dependent effects, NOTE - off by a year if recalc'ed at beginning of season 1
      env_data(y, -2) = recdev(y); //  store for density-dependent effects

      if (timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0 || save_for_report > 0 || WTage_rd > 0)
      {
        s = 1;
        t = t_base + s;
        subseas = 1; //  begin season  note that ALK_idx re-calculated inside get_growth3
        ALK_idx = (s - 1) * N_subseas + subseas; //  redundant with calc inside get_growth3 ????
        get_growth3(y, t, s, subseas); //  not needed because size-at-age already has been propagated to seas 1 subseas 1
        Make_AgeLength_Key(s, subseas); //  this will give wt_age_beg before any time-varying parameter changes for this year
      }

      smrybio = 0.0;
      smrynum = 0.0;
      s = 1;
      t = t_base + 1;
      for (g = 1; g <= gmorph; g++)
      {
        if (use_morph(g) > 0)
        {
          for (p = 1; p <= pop; p++)
          {
            smrybio += natage(t, p, g)(Smry_Age, nages) * Wt_Age_beg(s, g)(Smry_Age, nages);
            smrynum += sum(natage(t, p, g)(Smry_Age, nages)); //sums to accumulate across platoons and settlements
          }
        }
      }
      env_data(y, -3) = log(smrybio / Smry_Table(styr - 1, 2));
      env_data(y, -4) = log(smrynum / Smry_Table(styr - 1, 3));
      Smry_Table(y).initialize();
      Smry_Table(y, 2) = smrybio; // in forecast
      Smry_Table(y, 3) = smrynum; //sums to accumulate across platoons and settlements

      if (Fcast_Loop1 == 3 && Do_Impl_Error > 0) //  apply implementation error, which is a random variable, so adds variance to forecast
      //  in future, could do this a fleet-specific implementation error
      {
        for (s = 1; s <= nseas; s++)
        {
          t = t_base + s;
          for (int ff = 1; ff <= N_catchfleets(0); ff++)
          {
            f = fish_fleet_area(0, ff);
            Fcast_Catch_Store(t, f) *= mfexp(Fcast_impl_error(y)); //  should this be bias adjusted?
          }
        }
      }

      //  do biology for this year
      //      yz=endyr+1;  //  biology year for parameters
      yz = y;
      if (do_densitydependent == 1)
        make_densitydependent_parm(y); //  call to adjust for density dependence

      if (timevary_MG(y, 0) > 0 || save_for_report > 0)
        get_MGsetup(y);
      if (timevary_MG(y, 2) > 0)
      {
        ALK_subseas_update = 1;
        get_growth2(y);
      }
  //	"MG_type: 1=M, 2=growth, 3=wtlen, 4=recr_dist&femfrac, 5=migration, 6=ageerror, 7=catchmult, 8=hermaphroditism" << endl
      if (Fcast_MGparm_ave(1, 2) == 1)
      {
        //  array has been filled with averages already
      }
      else if (timevary_MG(y, 1) > 0 || N_pred > 0)
      {
        get_natmort();
      }
      else
      {
        t_base = styr + (y - styr) * nseas - 1;
        for (s = 1; s <= nseas; s++)
        {
          natM(t_base + s) = natM(t_base - nseas + s);
        }
      }
      if (timevary_MG(y, 3) > 0)
      {
        get_wtlen();
        if (Hermaphro_Option != 0)
          get_Hermaphro();
      }
      if (Fcast_Loop_Control(3) == 3 || Fcast_MGparm_ave(4, 1) == 1)
      {
        //  already filled with averages
      }
      else if (timevary_MG(y, 4) > 0 || timevary_MG(endyr + 1, 4) > 0)
      {
        get_recr_distribution();
      }
      if (Fcast_MGparm_ave(5, 2) == 1)
      {
        //  already filled with averages
      }
      else if (timevary_MG(y, 5) > 0)
        get_migration();
      if (timevary_MG(y, 7) > 0)
        get_catch_mult(y, catch_mult_pointer);

      if (save_for_report > 0 && Fcast_Loop1 == Fcast_Loop_Control(1))
      {
        if (timevary_MG(y, 1) > 0 || timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0)
        {
          get_saveGparm();
        }
      }
      //  SS_Label_Info_24.1.2  #Call selectivity, which does its own internal check for time-varying changes
      if (Fcast_timevary_Selex == 0)
        get_selectivity();

      // ABC_loop:  1=get OFL; 2=get_ABC, use input catches; 3=recalc with caps and allocations
      for (int ABC_Loop = ABC_Loop_start; ABC_Loop <= ABC_Loop_end; ABC_Loop++)
      {
        totcatch = 0.;
        if (ABC_Loop == 1)
          Mgmt_quant(Fcast_catch_start + N_Fcast_Yrs + y - endyr) = 0.0; // for OFL
        Mgmt_quant(Fcast_catch_start + y - endyr) = 0.0; //  for ABC
        if (max(Do_Retain) > 0)
          Mgmt_quant(Fcast_catch_start + 2 * N_Fcast_Yrs + y - endyr) = 0.0; // for retained ABC
        if (STD_Yr_Reverse_F(y) > 0)
          F_std(STD_Yr_Reverse_F(y)) = 0.0;
        //  consider move get_growth2 here so it can be responsive to mortality within the plus group as F changes between ABCloops
        for (s = 1; s <= nseas; s++)
        {
          t = t_base + s;
          if (ABC_Loop == ABC_Loop_start) // do seasonal ALK and fishery selex
          {
            if (timevary_MG(y, 2) > 0 || save_for_report > 0)
            {
              subseas = 1; //   for begin of season   ALK_idx calculated within Make_AgeLength_Key
              get_growth3(y, t, s, subseas);
              Make_AgeLength_Key(s, subseas); //  begin season

              subseas = mid_subseas;
              get_growth3(y, t, s, subseas);
              Make_AgeLength_Key(s, subseas); //  for middle of season (begin of 3rd quarter)

              //  SPAWN-RECR:   call Make_Fecundity in forecast
              if (s == spawn_seas)
              {
                subseas = spawn_subseas;
                if (spawn_subseas != 1 && spawn_subseas != mid_subseas)
                {
                  get_growth3(y, t, s, subseas);
                  Make_AgeLength_Key(s, subseas); //  spawn subseas
                }
              }
            }

            if (WTage_rd == 1)
            {
              Wt_Age_beg(s) = Wt_Age_t(t, 0);
              Wt_Age_mid(s) = Wt_Age_t(t, -1);
              if (s == spawn_seas)
                fec = Wt_Age_t(t, -2);
            }
            else if (timevary_MG(y, 2) > 0 || timevary_MG(y, 3) > 0 || bigsaver == 1)
            {
              //               Make_Fecundity();
              get_mat_fec(); //  does just spawn season and subseason using ALK calculated just above
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  subseas = 1;
                  ALK_idx = (s - 1) * N_subseas + subseas;
                  Wt_Age_beg(s, g) = (ALK(ALK_idx, g) * wt_len(s, GP(g))); // wt-at-age at beginning of period

                  subseas = mid_subseas;
                  ALK_idx = (s - 1) * N_subseas + subseas;
                  Wt_Age_mid(s, g) = ALK(ALK_idx, g) * wt_len(s, GP(g)); // use for fisheries with no size selectivity
                }
            }
//    report5 << Fcast_Loop1 << " y: " << y << " updated_Repro_output_by_age_for_morph_1 annual: " << fec(1) << endl;
            Wt_Age_t(t, 0) = Wt_Age_beg(s);
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0)
              {
                Make_FishSelex(); // calcs fishery selex by current season, all fleets, current gmorph
              }
      if(N_pred>0)
      {
//  rebase natM to M1
        for(p = 1; p <= pop; p++)
        {
          natM(t, p) = natM(t, 0);
        }
        for (f1 = 1; f1 <= N_pred; f1++)
        {
          f = predator(f1);
          pred_M2(f1, t) = mgp_adj(predparm_pointer(f1)); //  base with no seasonal effect
          if (nseas > 1)
            pred_M2(f1, t) *= mgp_adj(predparm_pointer(f1) + s);
          p = fleet_area(f);  //  area this predator occurs in

  //  a new array for indexing g and gpi could simplify below
  //        for (gp = 1; gp <= N_GP * gender * N_settle_timings; gp++)

          for (gp = 1; gp <= N_GP * gender; gp++)
          {
            g = g_Start(gp); //  base platoon
            for (settle = 1; settle <= N_settle_timings; settle++)
            {
              g += N_platoon;
              int gpi = GP3(g); // GP*gender*settlement
              natM(t, p, gpi) += pred_M2(f1, t) * sel_num(s, f, g);
            }
          }
        }
      }

      for(p = 1; p <= pop; p++)
      {
        int s1 = (p - 1) * nseas + s;
        surv1(s1) = mfexp(-natM(t, p) * seasdur_half(s));
        surv2(s1) = square(surv1(s1));
      }

          } //  end of seasonal biology

          if (s == nseas)
          {
            adv_age = 1;
          }
          else
          {
            adv_age = 0;
          } //      advance age or not when doing survivorship

          //  SPAWN-RECR:   calc area-specific spawning biomass in forecast
          if (s == spawn_seas && spawn_time_seas < 0.0001) //  get spawnbio in a forecast year
          {
            SSB_pop_gp(y).initialize();
            SSB_B_yr(y).initialize();
            SSB_N_yr(y).initialize();
            Smry_Table(y, 15) = 0.0;
            for (p = 1; p <= pop; p++)
            {
              for (g = 1; g <= gmorph; g++)
                if (sx(g) == 1 && use_morph(g) > 0) //  female
                {
                  //                SSB_pop_gp(y,p,GP4(g)) += fec(g)*elem_prod(natage(t,p,g),mfexp(-Z_rate(t,p,g)*spawn_time_seas));   // accumulates SSB by area and by growthpattern
                  //                SSB_B_yr(y) += make_mature_bio(GP4(g))*elem_prod(natage(t,p,g),mfexp(-Z_rate(t,p,g)*spawn_time_seas));
                  //                SSB_N_yr(y) += make_mature_numbers(GP4(g))*elem_prod(natage(t,p,g),mfexp(-Z_rate(t,p,g)*spawn_time_seas));
                  natage(t, p, g, 0) = 0.0; // these fish should not exist at beginning of year.  They are created after spawning.  Are here in array only due to Fcast_Loop1
                  SSB_pop_gp(y, p, GP4(g)) += fracfemale_mult * fec(g) * natage(t, p, g); // accumulates SSB by area and by growthpattern
                  SSB_B_yr(y) += fracfemale_mult * make_mature_bio(GP4(g)) * natage(t, p, g);
                  SSB_N_yr(y) += fracfemale_mult * make_mature_numbers(GP4(g)) * natage(t, p, g);
                  Smry_Table(y, 15) += fracfemale_mult * natage(t, p, g) * elem_prod(fec(g), r_ages);  //  for mean age of female spawners = GenTime
                }
            }
            SSB_current = sum(SSB_pop_gp(y));
            SSB_yr(y) = SSB_current;

            if (Hermaphro_Option != 0) // get male biomass
            {
              MaleSSB(y).initialize();
              for (p = 1; p <= pop; p++)
              {
                for (g = 1; g <= gmorph; g++)
                  if (sx(g) == 2 && use_morph(g) > 0) //  male; all assumed to be mature
                  {
                    natage(t, p, g, 0) = 0.0; // these fish do not yet exist
                    MaleSSB(y, p, GP4(g)) += Wt_Age_t(t, 0, g) * natage(t, p, g); // accumulates SSB by area and by growthpattern
                  }
              }
              if (Hermaphro_maleSSB > 0.0) // add MaleSSB to female SSB
              {
                SSB_current += Hermaphro_maleSSB * sum(MaleSSB(y));
                SSB_yr(y) = SSB_current;
              }
            }
            //  SPAWN-RECR:   get recruitment in at beginning of a season in forecast;
        if (timevary_SRparm(y) == 0) //  SRparm use virgin values (but regime still could be)
        {
          R0_use = Recr_virgin;
          SSB_use = SSB_virgin;
//          warning << y << " virgin_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;
        }
        else if (timevary_SRparm(y) == 1)  //  update R0_use and SSB_use in this year
                                           //  values will carry forward into subsequent years
        {
          R0_use = mfexp(SRparm_work(1));
          //  timevary steepness is in SRparm_work(2) and will be applied inside of Equil_Spawn_Recr_Fxn() and Spawn_Recr()
          equ_Recr = R0_use;
          Fishon = 0;
          eq_yr = y;
          bio_yr = y;
          SSBpR_Calc(R0_use); //  call function to do per recruit calculation with current year's biology and adjusted R0
          SSB_use = SSB_equil;
//          warning << y << " update_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;

          // test that this stays on equilibrium.  It does.
//          SSBpR_temp = SSB_use / R0_use;  // get unfished SSBpR
//          Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_work, SSB_use, R0_use, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
//          warning << y << " pR only "<<SSB_use<<" "<<R0_use<<"  steep " << SRparm_work(2)<< " equil: "<<Equ_SpawnRecr_Result;
//          R0_use = Equ_SpawnRecr_Result(2);
//          SSB_use = Equ_SpawnRecr_Result(1);
          if (fishery_on_off == 1)
          {
            Fishon = 1;
          }
          else
          {
            Fishon = 0;
          }
        }
        else  //  flag is 2
        {
//          warning << y << " carry_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;
        }
        Recruits = Spawn_Recr(SRparm_work, SSB_use, R0_use, SSB_current); // calls to function Spawn_Recr using either virgin or adjusted R0 and SSB0

            if (SR_fxn != 7) apply_recdev(Recruits, R0_use); //  apply recruitment deviation
            if (Fcast_Loop1 < Fcast_Loop_Control(2)) //  use expected recruitment  this should include environ effect - CHECK THIS
            {
              Recruits = exp_rec(y, 2);
              exp_rec(y, 4) = exp_rec(y, 2); // within the spawn_recr function this has value with recrdev, so need to reset here
            }

            //  SPAWN-RECR: distribute Recruitment among settlements, areas and morphs
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0)
              {
                settle = settle_g(g); //  get settlement event
                for (p = 1; p <= pop; p++)
                {
                  //                  if(y==endyr+1) natage(t+Settle_seas_offset(settle),p,g,Settle_age(settle))=0.0;  //  to negate the additive code
                  natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) = Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g)) *
                      mfexp(natM(t, p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle));
                  if (Fcast_Loop1 == jloop && ABC_Loop == ABC_Loop_end)
                  {
//                    if (Settle_seas(settle) == s)  // delete because logic is flawed
                      Recr(p, t + Settle_seas_offset(settle)) += Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g));
                  }
                  //  the adjustment for mortality increases recruit value for elapsed time since begin of season because M will then be applied from beginning of season
                }
              }
          } //  end of spawner-recruitment calculations
          //  SPAWN-RECR:  total spawn bio used in F policy.  Make this area-specific too?
          if (ABC_Loop == 1) //  doing OFL this loop
          {
            ABC_buffer(y) = 1.0;
          }
          else if (ABC_Loop == 2 && s == 1) // Calc the buffer in season 1, will use last year's spawnbio if multiseas and spawnseas !=1
          {

            join1 = 1. / (1. + mfexp(100. * (SSB_current - H4010_bot * HCR_anchor)));
            join2 = 1. / (1. + mfexp(100. * (SSB_current - H4010_top * HCR_anchor)));

            switch (HarvestPolicy)
            {
              case 0:
              {
                ABC_buffer(y) = 1.0;
                break;
              }
              case 1: // west coast
                // ramp scales catch as f(B) and buffer (H4010_scale) applied to F
                {
                  ABC_buffer(y) = H4010_scale_vec(y) *
                          ((0.0001 * SSB_current / (H4010_bot * HCR_anchor)) * (join1) // low
                                      + (0.0001 + (1.0 - 0.0001) * (H4010_top * HCR_anchor / SSB_current) * (SSB_current - H4010_bot * HCR_anchor) / (H4010_top * HCR_anchor - H4010_bot * HCR_anchor)) * (1.0 - join1) // curve
                                      ) *
                          (join2) // scale combo
                      +
                      (H4010_scale_vec(y)) * (1.0 - join2); // scale right side
                  break;
                }
              case 2: // Alaska
                // ramp scales F as f(B) and buffer (H4010_scale) applied to F
                {
                  ABC_buffer(y) = H4010_scale_vec(y) *
                          ((0.0001 * SSB_current / (H4010_bot * HCR_anchor)) * (join1) // low
                                      + (0.0001 + (1.0 - 0.0001) * (SSB_current - H4010_bot * HCR_anchor) / (H4010_top * HCR_anchor - H4010_bot * HCR_anchor)) * (1.0 - join1) // curve
                                      ) *
                          (join2) // scale combo
                      +
                      (H4010_scale_vec(y)) * (1.0 - join2); // scale right side
                  break;
                }
              case 3: // west coast
                // ramp scales catch as f(B) and buffer (H4010_scale) applied to catch
                {
                  ABC_buffer(y) = 1.0 *
                          ((0.0001 * SSB_current / (H4010_bot * HCR_anchor)) * (join1) // low
                                      + (0.0001 + (1.0 - 0.0001) * (H4010_top * HCR_anchor / SSB_current) * (SSB_current - H4010_bot * HCR_anchor) / (H4010_top * HCR_anchor - H4010_bot * HCR_anchor)) * (1.0 - join1) // curve
                                      ) *
                          (join2) // scale combo
                      +
                      (1.0) * (1.0 - join2); // scale right side
                  break;
                }
              case 4: // Alaska
                // ramp scales F as f(B) and buffer (H4010_scale) applied to catch
                {
                  ABC_buffer(y) = 1.0 *
                          ((0.0001 * SSB_current / (H4010_bot * HCR_anchor)) * (join1) // low
                                      + (0.0001 + (1.0 - 0.0001) * (SSB_current - H4010_bot * HCR_anchor) / (H4010_top * HCR_anchor - H4010_bot * HCR_anchor)) * (1.0 - join1) // curve
                                      ) *
                          (join2) // scale combo
                      +
                      (1.0) * (1.0 - join2); // scale right side
                  break;
                }
            }
          } // end calc of ABC buffer
          else
          { //  ABC buffer remains at previously calculated value
          }

          totbio.initialize();
          for (p = 1; p <= pop; p++) //  loop areas
          {
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0)
              {
                gg = sx(g);

                if (save_for_report > 0)
                {
                  totbio += natage(t, p, g) * Wt_Age_beg(s, g);
                  Save_PopLen(t, p, g) = 0.0;
                  Save_PopLen(t, p + pop, g) = 0.0; // later put midseason here
                  Save_PopWt(t, p, g) = 0.0;
                  Save_PopWt(t, p + pop, g) = 0.0; // later put midseason here
                  Save_PopAge(t, p, g) = value(natage(t, p, g));
                  for (a = 0; a <= nages; a++)
                  {
                    Save_PopLen(t, p, g) += value(natage(t, p, g, a)) * value(ALK(ALK_idx, g, a));
                    Save_PopWt(t, p, g) += value(natage(t, p, g, a)) * value(elem_prod(ALK(ALK_idx, g, a), wt_len(s, GP(g))));
                    Save_PopBio(t, p, g, a) = value(natage(t, p, g, a)) * value(Wt_Age_beg(s, g, a));
                  } // close age loop
                }
              }
            Tune_F_loops = 1;

              int s1 = (p - 1) * nseas + s;  //  stacks season inside area (p) for use with surv1

            for (int ff = 1; ff <= N_catchfleets(0); ff++)
            {
              f = fish_fleet_area(0, ff); //  calc the Hrates given the HarvestPolicy, and find which catches are fixed or adjustable
              switch (ABC_Loop)
              {
                case 1: //  apply Fmsy and get OFL
                {
                  if (bycatch_setup(f, 3) <= 1)
                  {
                    Hrate(f, t) = Fcast_Fmult * Fcast_RelF_Use(s, f);
                  }
                  else
                  {
                    Hrate(f, t) = bycatch_F(f, s);
                  }
                  break; // no action, keep Hrate
                }
                case 2: //  apply ABC control rule and store catches
                {
                  if (bycatch_setup(f, 3) <= 1)
                  {
                    Hrate(f, t) = ABC_buffer(y) * Fcast_Fmult * Fcast_RelF_Use(s, f);
                  }
                  else
                  {
                    Hrate(f, t) = bycatch_F(f, s);
                  }
                  //  if HarvestPolicy==3 or 4, then H4010_scale is not in ABC_buffer and will need to be applied to catch in first stage of the tuning process below
                  if (N_Fcast_Input_Catches > 0)
                    if (Fcast_InputCatch(t, f, 1) > -1.0) //  have an input
                    {
                      if (Fcast_InputCatch(t, f, 2) <= 3) //  input is catch
                      {
                        if (Fcast_InputCatch(t, f, 1) == 0.0)
                        {
                          Hrate(f, t) = 0.0;
                          Do_F_tune(t, f) = 0;
                        }
                        else
                        {
                          Tune_F_loops = 8;
                          if (Fcast_RelF_Use(s, f) > 0.0)
                            Do_F_tune(t, f) = 1;
                        }
                      }
                      else
                      {
                        Hrate(f, t) = Fcast_InputCatch(t, f, 1);
                      } // input is as Hrate (F), but do not need tuning
                    }
                  break;
                }
                case 3: //  always get F to match catch when in ABC_Loop==3
                {
                  Tune_F_loops = 8;
                  if (Fcast_RelF_Use(s, f) > 0.0)
                    Do_F_tune(t, f) = 1;
                  break;
                }
              }
            }

            if (F_Method == 1) //  calculate catch, survival and F using Fmethod==1 (Pope's)
            {
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  Nmid(g) = elem_prod(natage(t, p, g), surv1(s1, GP3(g)));
                }

              for (Tune_F = 1; Tune_F <= Tune_F_loops; Tune_F++)
              {
                for (int ff = 1; ff <= N_catchfleets(p); ff++) // get calculated catch
                {
                  f = fish_fleet_area(p, ff);
                  temp = 0.0;
                  if (Do_F_tune(t, f) == 1)
                  {
                    if (ABC_Loop == 2 && N_Fcast_Input_Catches > 0) //  tune to input catch if in ABC_loop 2
                    {
                      for (g = 1; g <= gmorph; g++)
                        if (use_morph(g) > 0)
                        {
                          if (catchunits(f) == 1) //  catch in weight
                          {
                            if (Fcast_InputCatch(t, f, 2) == 2)
                            {
                              temp += Nmid(g) * sel_dead_bio(s, f, g);
                            } // dead catch bio
                            else if (Fcast_InputCatch(t, f, 2) == 3)
                            {
                              temp += Nmid(g) * sel_ret_bio(s, f, g);
                            } // retained catch bio
                          }
                          else //  catch in numbers
                          {
                            if (Fcast_InputCatch(t, f, 2) == 2)
                            {
                              temp += Nmid(g) * sel_dead_num(s, f, g);
                            } // deadfish catch numbers
                            else if (Fcast_InputCatch(t, f, 2) == 3)
                            {
                              temp += Nmid(g) * sel_ret_num(s, f, g);
                            } // retained catch numbers
                          }
                        } //close gmorph loop
                      temp1 = Fcast_InputCatch(t, f, 1) / (temp + NilNumbers);
                      join1 = 1. / (1. + mfexp(30. * (temp1 - max_harvest_rate)));
                      Hrate(f, t) = join1 * temp1 + (1. - join1) * max_harvest_rate; // new F value for this fleet, constrained by max_harvest_rate
                    }
                    else if (fishery_on_off == 1) //  tune to adjusted catch calculated from ABC_Loop=2
                    {
                      for (g = 1; g <= gmorph; g++)
                        if (use_morph(g) > 0)
                        {
                          if (Fcast_Catch_Basis == 2)
                          {
                            temp += Nmid(g) * sel_dead_bio(s, f, g);
                          } // dead catch bio
                          else if (Fcast_Catch_Basis == 3)
                          {
                            temp += Nmid(g) * sel_ret_bio(s, f, g);
                          } // retained catch bio
                          else if (Fcast_Catch_Basis == 5)
                          {
                            temp += Nmid(g) * sel_dead_num(s, f, g);
                          } // deadfish catch numbers
                          else if (Fcast_Catch_Basis == 6)
                          {
                            temp += Nmid(g) * sel_ret_num(s, f, g);
                          } // retained catch numbers
                        } //close gmorph loop
                      temp1 = Fcast_Catch_Store(t, f) / (temp + NilNumbers);
                      join1 = 1. / (1. + mfexp(30. * (temp1 - max_harvest_rate)));
                      Hrate(f, t) = join1 * temp1 + (1. - join1) * max_harvest_rate; // new F value for this fleet, constrained by max_harvest_rate
                    }
                  } // end have fixed catch to be matched
                } // end fishery loop
              } //  end finding the Hrates

              //  now get catch details and survivorship
              Nsurv = Nmid; //  initialize the number of survivors
              for (int ff = 1; ff <= N_catchfleets(p); ff++) // get calculated catch
              {
                f = fish_fleet_area(p, ff);
                catch_fleet(t, f).initialize();
                //                if(ABC_Loop==2 && bycatch_setup(f,3)<=1 && HarvestPolicy>=3)   // fleet has scalable catch and policy applies to catch, not F
                //                {Hrate(f,t)*=H4010_scale;}
                // here for Pope's, ok to do scale adjustment to Hrate; will have to be on catch for continuous F

                temp = Hrate(f, t);
                for (g = 1; g <= gmorph; g++)
                  if (use_morph(g) > 0)
                  {
                    catch_fleet(t, f, 1) += Nmid(g) * sel_bio(s, f, g); // encountered catch bio
                    catch_fleet(t, f, 2) += Nmid(g) * sel_dead_bio(s, f, g); // dead catch bio
                    catch_fleet(t, f, 3) += Nmid(g) * sel_ret_bio(s, f, g); // retained catch bio
                    catch_fleet(t, f, 4) += Nmid(g) * sel_num(s, f, g); // encountered catch numbers
                    catch_fleet(t, f, 5) += Nmid(g) * sel_dead_num(s, f, g); // deadfish catch numbers
                    catch_fleet(t, f, 6) += Nmid(g) * sel_ret_num(s, f, g); // retained catch numbers
                    catage_w(g) = temp * elem_prod(Nmid(g), sel_dead_num(s, f, g));
                    Nsurv(g) -= catage_w(g);
                    if (Do_Retain(f) > 0)
                      {
                        disc_age(t, disc_fleet_list(f), g) = Hrate(f, t) * elem_prod(elem_prod(natage(t, p, g), sel_num(s, f, g)), Zrate2(p, g)); //  selected numbers
                        disc_age(t, disc_fleet_list(f) + N_retain_fleets, g) = Hrate(f, t) * elem_prod(elem_prod(natage(t, p, g), sel_ret_num(s, f, g)), Zrate2(p, g)); //  selected numbers
                      }
                  } //close gmorph loop
                catch_fleet(t, f) *= temp;
              } // close fishery

              //  calculate survival within area within season with Fmethod ==1
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  settle = settle_g(g); //  get settlement event
                  j = Settle_age(settle);
                  if (s < nseas && Settle_seas(settle) <= s)
                  {
                    natage(t + 1, p, g, j) = Nsurv(g, j) * surv1(s1, GP3(g), j);
                  } // advance age zero within year
                  for (a = j + 1; a < nages; a++)
                  {
                    natage(t + 1, p, g, a) = Nsurv(g, a - adv_age) * surv1(s1, GP3(g), a - adv_age);
                    Z_rate(t, p, g, a) = -log(natage(t + 1, p, g, a) / natage(t, p, g, a - adv_age)) / seasdur(s);
                  }
                  natage(t + 1, p, g, nages) = Nsurv(g, nages) * surv1(s1, GP3(g), nages); // plus group
                  if (s == nseas)
                    natage(t + 1, p, g, nages) += Nsurv(g, nages - 1) * surv1(s1, GP3(g), nages - 1);
                  if (save_for_report > 0)
                  {
                    j = p + pop;
                    for (a = 0; a <= nages; a++)
                    {
                      Save_PopLen(t, j, g) += value(0.5 * (Nmid(g, a) + Nsurv(g, a))) * value(ALK(ALK_idx, g, a));
                      Save_PopWt(t, j, g) += value(0.5 * (Nmid(g, a) + Nsurv(g, a))) * value(elem_prod(ALK(ALK_idx, g, a), wt_len(s, GP(g))));
                      Save_PopAge(t, j, g, a) = value(0.5 * (Nmid(g, a) + Nsurv(g, a)));
                      Save_PopBio(t, j, g, a) = value(0.5 * (Nmid(g, a) + Nsurv(g, a))) * value(Wt_Age_beg(s, g, a));
                    } // close age loop
                  }
                }
            } //  end Fmethod=1 pope

            else //calculate catch, survival and F using Fmethod== 2 or 3;  continuous F
            {
              for (Tune_F = 1; Tune_F <= Tune_F_loops; Tune_F++) //  tune F to match catch
              {
                for (g = 1; g <= gmorph; g++) //loop over fishing fleets to get Z=M+sum(F)
                  if (use_morph(g) > 0)
                  {
                    Z_rate(t, p, g) = natM(t, p, GP3(g));
                    for (int ff = 1; ff <= N_catchfleets(p); ff++) // get calculated catch
                    {
                      f = fish_fleet_area(p, ff);
                      if (Fcast_RelF_Use(s, f) > 0.0)
                      {
                        Z_rate(t, p, g) += sel_dead_num(s, f, g) * Hrate(f, t);
                      }
                    }
                    Zrate2(p, g) = elem_div((1. - mfexp(-seasdur(s) * Z_rate(t, p, g))), Z_rate(t, p, g));
                  } //  end morph

                for (int ff = 1; ff <= N_catchfleets(p); ff++) // get calculated catch
                {
                  f = fish_fleet_area(p, ff);
                  C_temp(f) = 0.0; //  will hold fleet's calculated catch
                  if (Do_F_tune(t, f) == 1) // have an input catch or in ABC_loop 3, so get expected catch from F and Z
                  {

                    if (ABC_Loop == 2) //  tune to input catch in ABCloop 2;  Do_F_tune(t,f) is only turned on if there is input catch
                    {
                      for (g = 1; g <= gmorph; g++)
                        if (use_morph(g) > 0)
                        {
                          if (catchunits(f) == 1) //  catch in weight
                          {
                            if (Fcast_InputCatch(t, f, 2) == 2)
                            {
                              C_temp(f) += elem_prod(natage(t, p, g), sel_dead_bio(s, f, g)) * Zrate2(p, g);
                            } // dead catch bio
                            else if (Fcast_InputCatch(t, f, 2) == 3)
                            {
                              C_temp(f) += elem_prod(natage(t, p, g), sel_ret_bio(s, f, g)) * Zrate2(p, g);
                            } // retained catch bio
                          }
                          else //  catch in numbers
                          {
                            if (Fcast_InputCatch(t, f, 2) == 2)
                            {
                              C_temp(f) += elem_prod(natage(t, p, g), sel_dead_num(s, f, g)) * Zrate2(p, g);
                            } // deadfish catch numbers
                            else if (Fcast_InputCatch(t, f, 2) == 3)
                            {
                              C_temp(f) += elem_prod(natage(t, p, g), sel_ret_num(s, f, g)) * Zrate2(p, g);
                            } // retained catch numbers
                          }
                        } //close gmorph loop
                      C_temp(f) *= Hrate(f, t); //  where temp was the available biomass or numbers calculated above and convert to catch here
                      H_temp(f) = Hrate(f, t);
                      temp = Hrate(f, t);
                      if (Tune_F < 3)
                      {
                        temp *= (Fcast_InputCatch(t, f, 1) + 1.0) / (C_temp(f) + 1.0); //  apply adjustment using ratio of target to calculated catch
                      }
                      else
                      {
                        temp = H_old(f) + (H_temp(f) - H_old(f)) / (C_temp(f) - C_old(f) + 1.0e-6) * (Fcast_InputCatch(t, f, 1) - C_old(f));
                      }
                      join1 = 1. / (1. + mfexp(30. * (temp - 0.95 * max_harvest_rate)));
                      Hrate(f, t) = join1 * temp + (1. - join1) * max_harvest_rate; // new F value for this fleet, constrained by max_harvest_rate
                      C_old(f) = C_temp(f);
                      H_old(f) = H_temp(f);
                    }
                    else if (fishery_on_off == 1) //  tune to adjusted catch calculated in ABC_Loop=2 (note different basis for catch)
                    {
                      C_temp(f) = 0.0;
                      for (g = 1; g <= gmorph; g++)
                        if (use_morph(g) > 0)
                        {
                          if (Fcast_Catch_Basis == 2)
                          {
                            C_temp(f) += elem_prod(natage(t, p, g), sel_dead_bio(s, f, g)) * Zrate2(p, g);
                          } // dead catch bio
                          else if (Fcast_Catch_Basis == 3)
                          {
                            C_temp(f) += elem_prod(natage(t, p, g), sel_ret_bio(s, f, g)) * Zrate2(p, g);
                          } // retained catch bio
                          else if (Fcast_Catch_Basis == 5)
                          {
                            C_temp(f) += elem_prod(natage(t, p, g), sel_dead_num(s, f, g)) * Zrate2(p, g);
                          } // deadfish catch numbers
                          else if (Fcast_Catch_Basis == 6)
                          {
                            C_temp(f) += elem_prod(natage(t, p, g), sel_ret_num(s, f, g)) * Zrate2(p, g);
                          } // retained catch numbers
                        } //close gmorph loop
                      C_temp(f) *= Hrate(f, t);
                      H_temp(f) = Hrate(f, t);
                      temp = Hrate(f, t);
                      if (Tune_F < 3)
                      {
                        temp *= (Fcast_Catch_Store(t, f) + 1.0) / (C_temp(f) + 1.0); //  adjust Hrate using catch stored from ABCloop2
                      }
                      else
                      {
                        temp = (H_old(f) + (H_temp(f) - H_old(f)) / (C_temp(f) - C_old(f) + 1.0e-6) * (Fcast_Catch_Store(t, f) - C_old(f)));
                      }
                      join1 = 1. / (1. + mfexp(30. * (temp - 0.95 * max_harvest_rate)));
                      Hrate(f, t) = join1 * temp + (1. - join1) * max_harvest_rate; // new F value for this fleet, constrained by max_harvest_rate
                      C_old(f) = C_temp(f);
                      H_old(f) = H_temp(f);
                    }
                  } // end have fixed catch to be matched
                } // end fishery loop
              } //  done tuning F

              for (int ff = 1; ff <= N_catchfleets(p); ff++)
              {
                f = fish_fleet_area(p, ff);
                catch_fleet(t, f).initialize();
                for (g = 1; g <= gmorph; g++)
                  if (use_morph(g) > 0)
                  {
                    tempvec_a = Hrate(f, t) * Zrate2(p, g);
                    catch_fleet(t, f, 1) += tempvec_a * elem_prod(natage(t, p, g), sel_bio(s, f, g)); // encountered catch bio
                    catch_fleet(t, f, 2) += tempvec_a * elem_prod(natage(t, p, g), sel_dead_bio(s, f, g)); // dead catch bio
                    catch_fleet(t, f, 3) += tempvec_a * elem_prod(natage(t, p, g), sel_ret_bio(s, f, g)); // retained catch bio
                    catch_fleet(t, f, 4) += tempvec_a * elem_prod(natage(t, p, g), sel_num(s, f, g)); // encountered catch numbers
                    catch_fleet(t, f, 5) += tempvec_a * elem_prod(natage(t, p, g), sel_dead_num(s, f, g)); // deadfish catch numbers
                    catch_fleet(t, f, 6) += tempvec_a * elem_prod(natage(t, p, g), sel_ret_num(s, f, g)); // retained catch numbers
                    catage(t, f, g) = elem_prod(elem_prod(natage(t, p, g), sel_dead_num(s, f, g)), tempvec_a);
                    if (Do_Retain(f) > 0)
                      {
                        disc_age(t, disc_fleet_list(f), g) = Hrate(f, t) * elem_prod(elem_prod(natage(t, p, g), sel_num(s, f, g)), Zrate2(p, g)); //  selected numbers
                        disc_age(t, disc_fleet_list(f) + N_retain_fleets, g) = Hrate(f, t) * elem_prod(elem_prod(natage(t, p, g), sel_ret_num(s, f, g)), Zrate2(p, g)); //  selected numbers
                      }
                  } //close gmorph loop
              } // close fishery

              //  calculate survival within area within season with Fmethod >=2
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  settle = settle_g(g); //  get settlement event
                  j = Settle_age(settle);
                  if (s < nseas && Settle_seas(settle) <= s)
                  {
                    natage(t + 1, p, g, j) = natage(t, p, g, j) * mfexp(-Z_rate(t, p, g, j) * seasdur(s));
                  } // advance new recruits within year
                  for (a = j + 1; a < nages; a++)
                  {
                    natage(t + 1, p, g, a) = natage(t, p, g, a - adv_age) * mfexp(-Z_rate(t, p, g, a - adv_age) * seasdur(s));
                  }

                  natage(t + 1, p, g, nages) = natage(t, p, g, nages) * mfexp(-Z_rate(t, p, g, nages) * seasdur(s)); // plus group
                  if (s == nseas)
                    natage(t + 1, p, g, nages) += natage(t, p, g, nages - 1) * mfexp(-Z_rate(t, p, g, nages - 1) * seasdur(s));
                  if (save_for_report > 0)
                  {
                    j = p + pop;
                    for (a = 0; a <= nages; a++)
                    {
                      Save_PopLen(t, j, g) += value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s))) * value(ALK(ALK_idx, g, a));
                      Save_PopWt(t, j, g) += value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s))) * value(elem_prod(ALK(ALK_idx, g, a), wt_len(s, GP(g))));
                      Save_PopAge(t, j, g, a) = value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s)));
                      Save_PopBio(t, j, g, a) = value(natage(t, p, g, a) * mfexp(-Z_rate(t, p, g, a) * 0.5 * seasdur(s))) * value(Wt_Age_mid(s, g, a));
                    } // close age loop
                  }
                } // end morph loop
            } // end continuous F

            //  SS_Label_106  call to Get_expected_values
            write_bodywt = 0;
            if (ABC_Loop == ABC_Loop_end && Fcast_Loop1 == Fcast_Loop_Control(1))
            {
              write_bodywt = write_bodywt_save;
            }
            if (show_MSY == 1)
            {
              report5 << p << " " << y << " " << ABC_Loop << " " << s << " " << ABC_buffer(y) << " " << H4010_scale_vec(y) << " " << totbio << " " << smrybio << " ";
              if (s == spawn_seas)
              {
                report5 << SSB_current << " ";
                report5 << SSB_current / SSB_unf << " " << Recruits;
              }
              else
              {
                report5 << 0 << " " << 0 << " " << 0;
              }
              for (int ff = 1; ff <= N_catchfleets(0); ff++)
              {
                f = fish_fleet_area(0, ff);
                if (fleet_area(f) == p)
                {
                  if (F_Method == 1)
                  {
                    report5 << " " << catch_fleet(t, f)(1, 6) << " " << Hrate(f, t);
                  }
                  else
                  {
                    report5 << " " << catch_fleet(t, f)(1, 6) << " " << Hrate(f, t) * seasdur(s);
                  }
                }
                else
                {
                  report5 << " - - - - - - - ";
                }

                if (N_Fcast_Input_Catches == 0)
                {
                  report5 << " R ";
                }
                else
                {
                  if (Fcast_InputCatch(t, f, 1) < 0.0)
                  {
                    report5 << " R ";
                  }
                  else
                  {
                    report5 << " C ";
                  }
                }
              }
              if (s == nseas && Fcast_MaxAreaCatch(p) > 0.)
              {
                report5 << " " << Fcast_MaxAreaCatch(p);
              }
              else
              {
                report5 << " NA ";
              } //  a max catch has been set for this area
            }
            if (p < pop && show_MSY == 1)
              report5 << endl;
          } //  end loop of areas
          if (s == 1 && Fcast_Loop1 == Fcast_Loop_Control(1))
          {
            Smry_Table(y, 1) = totbio;
          }

          if (ABC_Loop == ABC_Loop_end && Fcast_Loop1 == Fcast_Loop_Control(1))
          {
            if (y < endyr + 50)
              Get_expected_values(y, t);
          }

          //  SS_Label_Info_24.3.4 #Compute spawning biomass if occurs after start of current season
          //  SPAWN-RECR:   calc spawn biomass in time series if after beginning of the season
          if (s == spawn_seas && spawn_time_seas >= 0.0001) //  compute spawning biomass
          {
            SSB_pop_gp(y).initialize();
            SSB_B_yr(y).initialize();
            SSB_N_yr(y).initialize();
            Smry_Table(y, 15) = 0.0;
            for (p = 1; p <= pop; p++)
            {
              for (g = 1; g <= gmorph; g++)
                if (sx(g) == 1 && use_morph(g) > 0) //  female
                {
                  SSB_pop_gp(y, p, GP4(g)) += fracfemale_mult * fec(g) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas)); // accumulates SSB by area and by growthpattern
                  SSB_B_yr(y) += fracfemale_mult * make_mature_bio(GP4(g)) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas));
                  SSB_N_yr(y) += fracfemale_mult * make_mature_numbers(GP4(g)) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas));
                  Smry_Table(y, 15) += fracfemale_mult * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas)) * elem_prod(fec(g), r_ages);  //  for mean age of female spawners = GenTime
                }
            }
            SSB_current = sum(SSB_pop_gp(y));
            SSB_yr(y) = SSB_current;

            if (Hermaphro_Option != 0) // get male biomass
            {
              MaleSSB(y).initialize();
              for (p = 1; p <= pop; p++)
              {
                for (g = 1; g <= gmorph; g++)
                  if (sx(g) == 2 && use_morph(g) > 0) //  male; all assumed to be mature
                  {
                    MaleSSB(y, p, GP4(g)) += Wt_Age_t(t, 0, g) * elem_prod(natage(t, p, g), mfexp(-Z_rate(t, p, g) * spawn_time_seas)); // accumulates SSB by area and by growthpattern
                  }
              }
              if (Hermaphro_maleSSB > 0.0) // add MaleSSB to female SSB
              {
                SSB_current += Hermaphro_maleSSB * sum(MaleSSB(y));
                SSB_yr(y) = SSB_current;
              }
            }
            //  SS_Label_Info_24.3.4.1 #Get recruitment from this spawning biomass after start of the season
            //  SPAWN-RECR
            if (timevary_SRparm(y) == 0) //  SRparm use virgin values (but regime still could be)
            {
              R0_use = Recr_virgin;
              SSB_use = SSB_virgin;
            }
            else if (timevary_SRparm(y) == 1)  //  update R0_use and SSB_use in this year
                                               //  values will carry forward into subsequent years
            {
              R0_use = mfexp(SRparm_work(1));
              //  timevary steepness is in SRparm_work(2) and will be applied inside of Equil_Spawn_Recr_Fxn() and Spawn_Recr()
              equ_Recr = R0_use;
              Fishon = 0;
              eq_yr = y;
              bio_yr = y;
              SSBpR_Calc(R0_use); //  call function to do per recruit calculation with current year's biology and adjusted R0
              SSB_use = SSB_equil;
//              warning << y << " update_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;

              if (fishery_on_off == 1)
              {
                Fishon = 1;
              }
              else
              {
                Fishon = 0;
              }
            }
            else  //  flag is 2
            {
//              warning << y << " carry_SRR; SSB_use: "<<SSB_use<<"  R0_use: "<<R0_use <<"  steep: " << SRparm_work(2) << endl;
            }
            Recruits = Spawn_Recr(SRparm_work, SSB_use, R0_use, SSB_current); // calls to function Spawn_Recr using either virgin or adjusted R0 and SSB0
                if (SR_fxn != 7) apply_recdev(Recruits, R0_use); //  apply recruitment deviation
            // distribute Recruitment  among the settlements, areas and morphs
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0)
              {
                settle = settle_g(g);
                for (p = 1; p <= pop; p++)
                {
                  //                  if(y==endyr+1) natage(t+Settle_seas_offset(settle),p,g,Settle_age(settle))=0.0;  //  to negate the additive code
                  //                  natage(t+Settle_seas_offset(settle),p,g,Settle_age(settle)) += Recruits*recr_dist(y,GP(g),settle,p)*platoon_distr(GP2(g))*
                  natage(t + Settle_seas_offset(settle), p, g, Settle_age(settle)) = Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g)) *
                      mfexp(natM(t, p, GP3(g), Settle_age(settle)) * Settle_timing_seas(settle));
                  if (Fcast_Loop1 == jloop && ABC_Loop == ABC_Loop_end)
                  {
//                    if (Settle_seas(settle) == s)  // delete because logic is flawed
                      Recr(p, t + Settle_seas_offset(settle)) += Recruits * recr_dist(y, GP(g), settle, p) * platoon_distr(GP2(g));
                  }
                }
              }
          }
          if (Hermaphro_Option != 0) //hermaphroditism
          {
            if (Hermaphro_seas == -1 || Hermaphro_seas == s)
            {
              k = gmorph / 2;
              for (p = 1; p <= pop; p++)
                for (g = 1; g <= k; g++) //  loop females
                  if (use_morph(g) > 0)
                  {
                    if (Hermaphro_Option == 1)
                    {
                      for (a = 1; a < nages; a++)
                      {
                        natage(t + 1, p, g + k, a) += natage(t + 1, p, g, a) * Hermaphro_val(GP4(g), a - 1); // increment males with females
                        natage(t + 1, p, g, a) *= (1. - Hermaphro_val(GP4(g), a - 1)); // decrement females
                      }
                    }
                    else if (Hermaphro_Option == -1)
                    {
                      for (a = 1; a < nages; a++)
                      {
                        natage(t + 1, p, g, a) += natage(t + 1, p, g + k, a) * Hermaphro_val(GP4(g + k), a - 1); // increment females with males
                        natage(t + 1, p, g + k, a) *= (1. - Hermaphro_val(GP4(g + k), a - 1)); // decrement males
                      }
                    }
                  }
            }
          }
          if (do_migration > 0) // movement between areas in forecast
          {
            natage_temp = natage(t + 1);
            natage(t + 1).initialize();
            for (p = 1; p <= pop; p++) //   source population
              for (p2 = 1; p2 <= pop; p2++) //  destination population
                for (g = 1; g <= gmorph; g++)
                  if (use_morph(g) > 0)
                  {
                    k = move_pattern(s, GP4(g), p, p2);
                    if (k > 0)
                      natage(t + 1, p2, g) += elem_prod(natage_temp(p, g), migrrate(bio_yr, k));
                  }
          }
          if (bigsaver == 1)
          {

            if ((Fcast_Loop1 == 2 || Fcast_Loop_Control(1) == 1) && ABC_Loop == 1) // get variance in OFL
            {
              for (int ff = 1; ff <= N_catchfleets(0); ff++)
              {
                f = fish_fleet_area(0, ff);
                if (fleet_type(f) == 1)
                {
                  Mgmt_quant(Fcast_catch_start + N_Fcast_Yrs + y - endyr) += catch_fleet(t, f, 2);
                }
                else if (bycatch_setup(f, 2) == 1) //  bycatch
                {
                  Mgmt_quant(Fcast_catch_start + N_Fcast_Yrs + y - endyr) += catch_fleet(t, f, 2);
                }
              }
            }

            if (Fcast_Loop1 == Fcast_Loop_Control(1) && ABC_Loop == ABC_Loop_end) //  in final loop, so do variance quantities
            {
              double countN;
              dvariable tempbase;
              dvariable tempM;
              dvariable tempZ;
              if (F_reporting != 5 && s == nseas)
              {
                tempbase = 0.0;
                tempM = 0.0;
                tempZ = 0.0;
                //  accumulate numbers across ages, morphs, sexes, areas
                for (a = F_reporting_ages(1); a <= F_reporting_ages(2); a++) //  should not let a go higher than nages-2 because of accumulator
                {
                  for (g = 1; g <= gmorph; g++)
                    if (use_morph(g) > 0)
                    {
                      for (p = 1; p <= pop; p++)
                      {
                        tempbase += natage(t - nseas + 1, p, g, a); // sum of numbers at beginning of year
                        tempZ += natage(t + 1, p, g, a + 1); // numbers at beginning of next year
                        temp3 = natage(t - nseas + 1, p, g, a); //  numbers at begin of year
                        for (j = 1; j <= nseas; j++)
                        {
                          temp3 *= mfexp(-seasdur(j) * natM(t - nseas + j, p, GP3(g), a));
                        }
                        tempM += temp3; //  survivors if just M operating
                      }
                    }
                }
                annual_F(y, 2) += log(tempM) - log(tempZ); // F=Z-M
                annual_F(y, 3) += log(tempbase) - log(tempM); // M
              }

              if (F_reporting == 5 && s == nseas)
              { // F_reporting==5 (ICES-style arithmetic mean across ages)
                //  like option 4 above, but F is calculated 1 age at a time to get a
                //  unweighted average across ages within each year
                countN = 0.0; // used for count of Fs included in average
                for (a = F_reporting_ages(1); a <= F_reporting_ages(2); a++) //  should not let a go higher than nages-2 because of accumulator
                {
                  tempbase = 0.0;
                  tempM = 0.0;
                  tempZ = 0.0;
                  //  accumulate numbers across all morphs, sexes, and areas
                  for (g = 1; g <= gmorph; g++)
                    if (use_morph(g) > 0)
                    {
                      for (p = 1; p <= pop; p++)
                      {
                        tempbase += natage(t - nseas + 1, p, g, a); // sum of numbers at beginning of year
                        tempZ += natage(t + 1, p, g, a + 1); // numbers at beginning of next year
                        temp3 = natage(t - nseas + 1, p, g, a); //  numbers at begin of year
                        for (j = 1; j <= nseas; j++)
                        {
                          temp3 *= mfexp(-seasdur(j) * natM(t - nseas + j, p, GP3(g), a));
                        }
                        tempM += temp3; //  survivors if just M operating
                      }
                    }
                  //  calc F and M for this age and add to the total
                  countN += 1; // increment count of values included in average
                  annual_F(y, 2) += log(tempM) - log(tempZ); // F=Z-M
                  annual_F(y, 3) += log(tempbase) - log(tempM); // M
                }
                annual_F(y, 3) /= countN; // M
                annual_F(y, 2) /= countN; // F
              } // end F_reporting==5

              if (STD_Yr_Reverse_F(y) > 0)
              {
                if (F_reporting <= 1)
                {
                  for (int ff = 1; ff <= N_catchfleets(0); ff++)
                  {
                    f = fish_fleet_area(0, ff);
                    if (fleet_type(f) == 1)
                    {
                      F_std(STD_Yr_Reverse_F(y)) += catch_fleet(t, f, 2);
                    } // add up dead catch biomass
                    else if (bycatch_setup(f, 2) == 1) //  bycatch
                    {
                      F_std(STD_Yr_Reverse_F(y)) += catch_fleet(t, f, 2);
                    } // add up dead catch biomass
                  }
                  if (s == nseas)
                    F_std(STD_Yr_Reverse_F(y)) /= Smry_Table(y, 2);
                }
                else if (F_reporting == 2)
                {
                  for (int ff = 1; ff <= N_catchfleets(0); ff++)
                  {
                    f = fish_fleet_area(0, ff);
                    if (fleet_type(f) == 1)
                    {
                      F_std(STD_Yr_Reverse_F(y)) += catch_fleet(t, f, 5);
                    } // add up dead catch numbers
                    else if (bycatch_setup(f, 2) == 1) //  bycatch
                    {
                      F_std(STD_Yr_Reverse_F(y)) += catch_fleet(t, f, 5);
                    } // add up dead catch numbers
                  }
                  if (s == nseas)
                    F_std(STD_Yr_Reverse_F(y)) /= Smry_Table(y, 3);
                }
                else if (F_reporting == 3)
                {
                  if (F_Method == 1)
                  {
                    for (int ff = 1; ff <= N_catchfleets(0); ff++)
                    {
                      f = fish_fleet_area(0, ff);
                      F_std(STD_Yr_Reverse_F(y)) += Hrate(f, t);
                    }
                  }
                  else
                  {
                    for (int ff = 1; ff <= N_catchfleets(0); ff++)
                    {
                      f = fish_fleet_area(0, ff);
                      F_std(STD_Yr_Reverse_F(y)) += Hrate(f, t) * seasdur(s);
                    }
                  }
                }
                else
                {
                  F_std(STD_Yr_Reverse_F(y)) = annual_F(y, 2);
                }

              }
              for (int ff = 1; ff <= N_catchfleets(0); ff++)
              {
                f = fish_fleet_area(0, ff);
                if (fleet_type(f) == 1)
                {
                  Mgmt_quant(Fcast_catch_start + y - endyr) += catch_fleet(t, f, 2);
                  if (max(Do_Retain) > 0)
                    Mgmt_quant(Fcast_catch_start + 2 * N_Fcast_Yrs + y - endyr) += catch_fleet(t, f, 3);
                }
                else if (bycatch_setup(f, 2) == 1) //  bycatch
                {
                  Mgmt_quant(Fcast_catch_start + y - endyr) += catch_fleet(t, f, 2);
                  if (max(Do_Retain) > 0)
                    Mgmt_quant(Fcast_catch_start + 2 * N_Fcast_Yrs + y - endyr) += catch_fleet(t, f, 3);
                }
              }
              if (write_bodywt > 0)
              {
                for (g = 1; g <= gmorph; g++)
                {
                  gg = sx(g);

                  if (ishadow(GP2(g)) == 0)
                  {
                    if (s == spawn_seas)
                      bodywtout << y << " " << s << " " << gg << " " << GP4(g) << " " << Bseas(g) << " " << -2 << " " << fec(g) << " #fecundity " << endl;
                    bodywtout << y << " " << s << " " << gg << " " << GP4(g) << " " << Bseas(g) << " " << 0 << " " << Wt_Age_beg(s, g) << " #popwt_beg " << endl;
                    bodywtout << y << " " << s << " " << gg << " " << GP4(g) << " " << Bseas(g) << " " << -1 << " " << Wt_Age_mid(s, g) << " #popwt_mid " << endl;
                  }
                }
              }
            }
          }

          for (int ff = 1; ff <= N_catchfleets(0); ff++)
          {
            f = fish_fleet_area(0, ff);
            if (fleet_type(f) == 1)
            {
              if (ABC_Loop == 2 && HarvestPolicy >= 3)  //  alternative ABC_buffer approach
              {
                catch_fleet(t, f) *= H4010_scale_vec(y);
              }
              //              if(Fcast_InputCatch(t,f,2)==2 ||  Fcast_InputCatch(t,f,2)==3)  //  have input catch
              //              {Fcast_Catch_Store(t,f)=Fcast_InputCatch(t,f,1);} //  copy input catch to stored catch
              //              else
              {
                Fcast_Catch_Store(t, f) = catch_fleet(t, f, Fcast_Catch_Basis);
              } //  copy calculated catch to stored catch
              totcatch += Fcast_Catch_Store(t, f);
            }
            else //  bycatch
            {
              if (ABC_Loop == 2 && HarvestPolicy >= 3 && bycatch_setup(f, 3) <= 1)
              {
                catch_fleet(t, f) *= H4010_scale_vec(y);
              }
              //              if(Fcast_InputCatch(t,f,2)==2 ||  Fcast_InputCatch(t,f,2)==3)  //  have input catch
              //              {Fcast_Catch_Store(t,f)=Fcast_InputCatch(t,f,1);}  //  copy input catch to stored catch
              //                else
              {
                Fcast_Catch_Store(t, f) = catch_fleet(t, f, Fcast_Catch_Basis);
              } //  copy calculated catch to stored catch
              if (bycatch_setup(f, 2) == 1)
                totcatch += Fcast_Catch_Store(t, f);
            }
          }

          if (show_MSY == 1)
          {
            if (s == nseas)
            {
              report5 << " " << totcatch << " ";
            }
            else
            {
              report5 << " NA ";
            }
            if (s == nseas && STD_Yr_Reverse_F(y) > 0)
            {
              report5 << F_std(STD_Yr_Reverse_F(y));
            }
            else
            {
              report5 << " NA ";
            }
            //            report5<<" numbers "<<natage(t,p,g)<<"  Zrate "<<Z_rate(t,p,g);
            report5 << endl;
          }

        } //  end loop of seasons

        if (ABC_Loop == 2) //  apply caps and store catches to allow calc of adjusted F to match this catch when doing ABC_loop=3, and then when doing Fcast_loop1=3
        {
          // calculate annual catch for each fleet
          Fcast_Catch_Calc_Annual.initialize();
          for (int ff = 1; ff <= N_catchfleets(0); ff++)
          {
            f = fish_fleet_area(0, ff);
            for (s = 1; s <= nseas; s++)
            {
              t = t_base + s;
              Fcast_Catch_Calc_Annual(f) += catch_fleet(t, f, Fcast_Catch_Basis); //  accumulate annual catch according to catch basis (2=deadbio, 3=ret bio, 5=dead num, 6=ret num)
            }
          }
          if (Fcast_Do_Fleet_Cap > 0 && y >= Fcast_Cap_FirstYear) //  adjust ABC catch to fleet caps
          {
            for (int ff = 1; ff <= N_catchfleets(0); ff++)
            {
              f = fish_fleet_area(0, ff);
              if (Fcast_MaxFleetCatch(f) > 0.)
              {
                temp = Fcast_Catch_Calc_Annual(f) / Fcast_MaxFleetCatch(f);
                join1 = 1. / (1. + mfexp(1000. * (temp - 1.0))); // steep logistic joiner at adjustment of 1.0
                temp1 = join1 * 1.0 + (1. - join1) * temp;
                Fcast_Catch_Calc_Annual(f) /= temp1;
                for (s = 1; s <= nseas; s++)
                {
                  Fcast_Catch_Store(t_base + s, f) /= temp1;
                }
              }
            }
          }
          if (Fcast_Do_Area_Cap > 0 && y >= Fcast_Cap_FirstYear) // scale down if Totcatch exceeds Fcast_MaxAreaCatch (in this area)
          {
            if (pop == 1) // one area
            {
              Fcast_Catch_ByArea(1) = sum(Fcast_Catch_Calc_Annual(1, Nfleet));
            }
            else
            {
              Fcast_Catch_ByArea = 0.0;
              for (int ff = 1; ff <= N_catchfleets(0); ff++)
              {
                f = fish_fleet_area(0, ff);
                Fcast_Catch_ByArea(fleet_area(f)) += Fcast_Catch_Calc_Annual(f);
              }
            }
            for (p = 1; p <= pop; p++)
              if (Fcast_MaxAreaCatch(p) > 0.0)
              {
                temp = Fcast_Catch_ByArea(p) / Fcast_MaxAreaCatch(p);
                join1 = 1. / (1. + mfexp(1000. * (temp - 1.0))); // steep logistic joiner at adjustment of 1.0
                temp1 = join1 * 1.0 + (1. - join1) * temp;
                for (int ff = 1; ff <= N_catchfleets(p); ff++)
                {
                  f = fish_fleet_area(p, ff);
                  Fcast_Catch_Calc_Annual(f) /= temp1; // adjusts total for the year
                  for (s = 1; s <= nseas; s++)
                  {
                    Fcast_Catch_Store(t_base + s, f) /= temp1;
                  }
                }
              }
            //            report5<<Tune_F<<" tune_area"<<Fcast_Catch_Calc_Annual<<endl;
          }
          if (Fcast_Catch_Allocation_Groups > 0 && y >= Fcast_Cap_FirstYear) // adjust to get a specific fleet allocation
          {
            Fcast_Catch_Allocation_Group.initialize();
            for (g = 1; g <= Fcast_Catch_Allocation_Groups; g++)
              for (int ff = 1; ff <= N_catchfleets(0); ff++)
              {
                f = fish_fleet_area(0, ff);
                if (Allocation_Fleet_Assignments(f) == g)
                {
                  Fcast_Catch_Allocation_Group(g) += Fcast_Catch_Calc_Annual(f);
                }
              }
            temp = sum(Fcast_Catch_Allocation_Group); // total catch for all fleets that are part of the allocation scheme
            temp1 = sum(Fcast_Catch_Allocation(y - endyr)); // total of all allocation fractions for all fleets that are part of the allocation scheme
            for (g = 1; g <= Fcast_Catch_Allocation_Groups; g++)
            {
              temp2 = (Fcast_Catch_Allocation(y - endyr, g) / temp1) / (Fcast_Catch_Allocation_Group(g) / temp);

              for (int ff = 1; ff <= N_catchfleets(0); ff++)
              {
                f = fish_fleet_area(0, ff);
                if (Allocation_Fleet_Assignments(f) == g)
                {
                  Fcast_Catch_Calc_Annual(f) *= temp2;
                  for (s = 1; s <= nseas; s++)
                  {
                    Fcast_Catch_Store(t_base + s, f) *= temp2;
                  }
                }
              }
            }
          } //  end allocation among groups
        }
      } //  end ABC_Loop

      if ((Fcast_Loop1 == Fcast_Loop_Control(1) && (save_for_report > 0)) || ((sd_phase() || mceval_phase()) && (initial_params::mc_phase == 0)))
      {
        Smry_Table(y, 4) = Mgmt_quant(Fcast_catch_start + y - endyr);
        eq_yr = y;
        equ_Recr = Recr_unf;
        bio_yr = y;
        Fishon = 0;
        SSBpR_Calc(equ_Recr); //  call function to do per recruit calculation

        Smry_Table(y, 11) = SSB_equil;
        Smry_Table(y, 13) = GenTime;
        if( SR_fxn == 10 )
        {
          temp = SSB_equil / equ_Recr;  //  current year's SSB/R with current biology at age
          alpha = mfexp(SRparm_work(3));
          beta = mfexp(SRparm_work(4));
          SRparm_byyr(y, 2) =  alpha * temp / (4. + alpha * temp);  //  implied steepness
          SRparm_byyr(y, 1) = log( 1. / beta * (alpha - (1. / temp)));  //  implied ln_R0
        }
        Fishon = 1;
        SSBpR_Calc(equ_Recr); //  call function to do per recruit calculation
        if (STD_Yr_Reverse_Ofish(y) > 0)
          {SPR_std(STD_Yr_Reverse_Ofish(y)) = SSB_equil / Smry_Table(y, 11);}
        Smry_Table(y, 9) = totbio;
        Smry_Table(y, 10) = smrybio;
        Smry_Table(y, 12) = SSB_equil;
        Smry_Table(y, 14) = YPR_dead;
      }
    } //  end year loop
  } //  end Fcast_Loop1  for the different stages of the forecast
  }
//  end forecast function
// SS_Label_file  #15. **SS_expval.tpl**
// SS_Label_file  # * <u>Get_expected_values()</u>  // for a specified season and subseason that has data, updates the ALK for that time and calculates expected values for any type of data from any fleet/survey
// SS_Label_file  #

//********************************************************************
 /*  SS_Label_FUNCTION 46  Get_expected_values:  check for data */
FUNCTION void Get_expected_values(const int y, const int t);
  {
  dvariable temp1;
  dvar_vector age_exp(0, nages2);
  for (subseas = 1; subseas <= N_subseas; subseas++)
  {
    //  make age-length key if needed
    ALK_idx = (s - 1) * N_subseas + subseas;
    ALK_time = (y - styr) * nseas * N_subseas + (s - 1) * N_subseas + subseas;
    if (ALK_subseas_update(ALK_idx) == 1 || have_data(ALK_time, 0, 0, 0) > 0) //  need ALK update for growth reasons or for data reasons
    {
      get_growth3(y, t, s, subseas);
      Make_AgeLength_Key(s, subseas);
    }
    for (f = 1; f <= Nfleet; f++)
    {
      if (have_data(ALK_time, f, 0, 0) > 0)
      {
        p = fleet_area(f);
        timing = data_time(ALK_time, f, 2) * seasdur(s); // within season elapsed time  same for all datatypes of this fleet x time
        //  make selected age-length sample for this fleet and with this timing
        {
          exp_AL.initialize();
          exp_AL_ret.initialize();
          for (g = 1; g <= gmorph; g++)
            if (use_morph(g) > 0)
            {
              gg = sx(g);
              if (gg == 2)
              {
                L1 = nlength1;
                L2 = nlength2;
                A2 = nages + 1;
              } //  move over on length dimension to store males
              else
              {
                L1 = 1;
                L2 = nlength;
                A2 = 0;
              }

              /*
            if(F_Method==1 && surveytime(f)<0.0) //  Pope's approximation
            {tempvec_a=elem_prod(Nmid(g),sel_a(y,f,gg));}  //  CHECK   Nmid may not exist correctly unless still within the area loop
            else if(surveytime(f)<0.0) // mimic fishery catch, but without Hrate so gets available numbers
            {tempvec_a=elem_prod(natage(t,p,g),elem_prod(Zrate2(p,g),sel_a(y,f,gg)));}
            else  //  explicit timing
            {tempvec_a=elem_prod(natage(t,p,g),elem_prod(mfexp(-Z_rate(t,p,g)*timing),sel_a(y,f,gg)));}
   */
              if (timing >= 0.0)
              {
                tempvec_a = elem_prod(natage(t, p, g), elem_prod(mfexp(-Z_rate(t, p, g) * timing), sel_a(y, f, gg)));
              } //  explicit timing
              else
              {
                if (F_Method > 1) // mimic fishery catch,  so gets mean available numbers
                {
                  tempvec_a = elem_prod(natage(t, p, g), elem_prod(Zrate2(p, g), sel_a(y, f, gg)));
                }
                else //  Pope's approximation
                {
                  Nmid(g) = elem_prod(natage(t, p, g), surv1(s, GP3(g))); //   numbers-at-age(g,a) surviving to middle of time period
                  tempvec_a = elem_prod(Nmid(g), sel_a(y, f, gg));
                }
              }
              tempvec_a = elem_prod(tempvec_a, keep_age(g, ALK_idx));

              if (Do_Retain(f) == 0)
              {
                if (dolen(f) == 1)
                {
                  for (a = 0; a <= nages; a++)
                  {
                    temp = tempvec_a(a);
                    for (z = 1; z <= nlength; z++)
                    {
                      exp_AL(a + A2, L1 - 1 + z) += temp * ALK(ALK_idx, g, a, z) * sel_l(y, f, gg, z);
                      ; //  note that A2 and L1 depend on what sex g is
                    }
                  }
                }
                else
                {
                  for (a = 0; a <= nages; a++)
                  {
                    temp = tempvec_a(a);
                    for (z = 1; z <= nlength; z++)
                    {
                      exp_AL(a + A2, L1 - 1 + z) += temp * ALK(ALK_idx, g, a, z);
                    }
                  }
                }
                exp_AL_ret = exp_AL; //  in case user has retain code 2 rather than 0
              }
              else //  need retain matrix
              {
                if (dolen(f) == 1) //  need retention and length
                {
                  for (a = 0; a <= nages; a++)
                  {
                    temp = tempvec_a(a);
                    temp1 = tempvec_a(a) * retain_a(y, f, gg, a);
                    for (z = 1; z <= nlength; z++)
                    {
                      exp_AL(a + A2, L1 - 1 + z) += temp * ALK(ALK_idx, g, a, z) * sel_l(y, f, gg, z); //  note that A2 and L1 depend on what sex g is
                      exp_AL_ret(a + A2, L1 - 1 + z) += temp1 * ALK(ALK_idx, g, a, z) * sel_l(y, f, gg, z) * retain(y, f, L1 - 1 + z); //  note that A2 and L1 depend on what sex g is
                    }
                  }
                }
                else //  need retention, but no length selex
                {
                  for (a = 0; a <= nages; a++)
                  {
                    temp = tempvec_a(a);
                    temp1 = tempvec_a(a) * retain_a(y, f, gg, a);
                    for (z = 1; z <= nlength; z++)
                    {
                      exp_AL(a + A2, L1 - 1 + z) += temp * ALK(ALK_idx, g, a, z);
                      exp_AL_ret(a + A2, L1 - 1 + z) += temp1 * ALK(ALK_idx, g, a, z) * retain(y, f, L1 - 1 + z);
                    }
                  }
                }
              }

              //  code below once erroneously built up catch by morph from exp_AL
              //  that approach is incorrect, because exp_AL already accumulates the morphs!!!!!
              //  putting a morph accumulation into the code above would slow computations for everyone in order to have this rarely used feature
              //  so instead, replicate the above to store directly into morphcomp_exp, rather than into the exp_AL matrix
              //  note that partition is read with morphcomp data, but it is not used
              //  fleets with no defined retention function base morphcomp off total catch
              //  fleets with retention defined, use retained catch
              if (have_data(ALK_time, f, 8, 0) > 0) //  morphcomp observation
              {
                int j = have_data(ALK_time, f, 8, 1); //  observation number
                //             	{Morphcomp_exp(j,5+GP4(g))+=sum(exp_AL);

                if (Do_Retain(f) == 0)
                {
                  if (dolen(f) == 1) //  uses length selectivity
                  {
                    for (a = 0; a <= nages; a++)
                    {
                      temp = tempvec_a(a);
                      for (z = 1; z <= nlength; z++)
                      {
                        Morphcomp_exp(j, 5 + GP4(g)) += temp * ALK(ALK_idx, g, a, z) * sel_l(y, f, gg, z);
                        ; //  note that A2 and L1 depend on what sex g is
                      }
                    }
                  }
                  else
                  {
                    for (a = 0; a <= nages; a++)
                    {
                      temp = tempvec_a(a);
                      for (z = 1; z <= nlength; z++)
                      {
                        Morphcomp_exp(j, 5 + GP4(g)) += temp * ALK(ALK_idx, g, a, z);
                      }
                    }
                  }
                }
                else //  must base sample on retained catch from a fleet that has retention defined
                {
                  if (dolen(f) == 1) //  need retention and length
                  {
                    for (a = 0; a <= nages; a++)
                    {
                      temp = tempvec_a(a);
                      temp1 = tempvec_a(a) * retain_a(y, f, gg, a);
                      for (z = 1; z <= nlength; z++)
                      {
                        Morphcomp_exp(j, 5 + GP4(g)) += temp1 * ALK(ALK_idx, g, a, z) * sel_l(y, f, gg, z) * retain(y, f, L1 - 1 + z); //  note that A2 and L1 depend on what sex g is
                      }
                    }
                  }
                  else //  need retention, but no length selex
                  {
                    for (a = 0; a <= nages; a++)
                    {
                      temp = tempvec_a(a);
                      temp1 = tempvec_a(a) * retain_a(y, f, gg, a);
                      for (z = 1; z <= nlength; z++)
                      {
                        Morphcomp_exp(j, 5 + GP4(g)) += temp1 * ALK(ALK_idx, g, a, z) * retain(y, f, L1 - 1 + z);
                      }
                    }
                  }
                }
                if (g == gmorph)
                {
                  k = 5 + Morphcomp_nmorph;
                  Morphcomp_exp(j)(6, k) /= sum(Morphcomp_exp(j)(6, k));
                  Morphcomp_exp(j)(6, k) += Morphcomp_mincomp;
                  Morphcomp_exp(j)(6, k) /= 1. + Morphcomp_mincomp * Morphcomp_nmorph;
                }
              }
            } //close gmorph loop

          exp_l_temp = colsum(exp_AL); //  total size composition
          agetemp = rowsum(exp_AL); //  total age composition
  #ifdef DO_ONCE
          if (do_once == 1)
            echoinput << "yr " << y << ", seas: " << s << ", fleet:" << f << endl
                      << " sampled  size " << exp_l_temp << endl
                      << " sampled  age  " << agetemp << endl;
  #endif
          if (Do_Retain(f) > 0)
          {
            exp_l_temp_ret = colsum(exp_AL_ret);
            exp_truea_ret = rowsum(exp_AL_ret);
  #ifdef DO_ONCE
            if (do_once == 1)
              echoinput << " retained size " << exp_l_temp_ret << endl
                        << " retained age " << exp_truea_ret << endl;
            ;
  #endif
          }
          else
          {
            exp_truea_ret = agetemp; //  covers cases where retention not used, but observations have partition=2
            exp_l_temp_ret = exp_l_temp;
          }

          //          end creation of selected A-L
        }

        if (sum(exp_l_temp) < 1.0e-8)
        {
          if (do_once == 1)
          {
            warnstream << current_phase() << " " << niter
                 << "warn in first call: Nil selected fish for year, seas, fleet " << y << " " << s << " " << f
                 << "; SS may recover; suggest check initial parm. values for selectivity and growth";
            write_message (WARN, 0);
          }
          exp_l_temp += 1.0e-09;
        }
        for (data_type = 1; data_type <= 9; data_type++)
        {
          switch (data_type)
          {
            case (1): //  surveyindex
            {
              /* SS_Label_46.1 expected abundance index */
              // NOTE that the Q scaler is factored in later on
              j = have_data(ALK_time, f, data_type, 0); //  number of observations for this time,f,type
              if (j > 0)
              {
                j = have_data(ALK_time, f, data_type, 1); //  for now, only one observations is allowed for surveys
                switch (Svy_units(f))
                {
                  case 1: //  biomass
                  {
                    if (WTage_rd == 1) //  using empirical wt-at-age;  note that this cannot use GP specific bodyweights
                    //  should sum over all g, but the g is already subsummed when agetemp is created by gender
                    {
                      vbio = 0.0;
//                      warning<<f<<" "<<y<<" "<<s<<" "<<t<<" y_wts "<<Wt_Age_t(y, f, 1)<<endl;
//                      warning<<f<<" "<<y<<" "<<s<<" "<<t<<" t_wts "<<Wt_Age_t(t, f, 1)<<endl;
                      if (Do_Retain(f) == 0) //  all retained
                      {
                        for (a = 0; a <= nages; a++)
                          vbio += Wt_Age_t(t, f, 1, a) * agetemp(a);
                        if (gender == 2)
                        {
                          for (a = 0; a <= nages; a++)
                            vbio += Wt_Age_t(t, f, 2, a) * agetemp(a + nages + 1);
                        }
                      }
                      else
                      {
                        for (a = 0; a <= nages; a++)
                          vbio += Wt_Age_t(t, f, 1, a) * exp_truea_ret(a);
                        if (gender == 2)
                        {
                          for (a = 0; a <= nages; a++)
                            vbio += Wt_Age_t(t, f, 2, a) * exp_truea_ret(a + nages + 1);
                        }
                      }
                    }
                    else
                    {
                      if (Do_Retain(f) == 0)
                      {
                        vbio = exp_l_temp * wt_len2(s, 1); // biomass  TEMPORARY CODE.  Using gp=1 wt at length
                      }
                      else
                      {
                        vbio = exp_l_temp_ret * wt_len2(s, 1);
                      }
                    }
                    break;
                  }
                  case 0: //  numbers
                  {
                    if (Do_Retain(f) == 0)
                    {
                      vbio = sum(exp_l_temp);
                    }
                    else
                    {
                      vbio = sum(exp_l_temp_ret);
                    }
                    break;
                  }
                  case 2: //  F rate
                  {
                    if (fleet_type(f) < 4)
                    {
                      vbio = Hrate(f, t);
                    }
                    else
                    {
                      vbio = pred_M2(predator_rev(f), t);
                    }
                    break;
                  }
                  case 30: // spawning biomass  #30
                  {
                    if (pop == 1 || fleet_area(f) == 0)
                    {
                      vbio = SSB_current;
                    }
                    else
                    {
                      vbio = sum(SSB_pop_gp(y, fleet_area(f)));
                    }
                    break;
                  }
                  case 31: // exp(recruitment deviation)  #31
                  {
                    vbio = mfexp(recdev(y));
                    break;
                  }
                  case 36: // recruitment deviation  #36
                  {
                    vbio = recdev(y);
                    break;
                  }
                  case 32: // recruitment without density-dependence (for pre-recruit survey) #32
                  {
                    vbio = SSB_current * mfexp(recdev(y));
                    break;
                  }
                  case 33: // recruitment  #33
                  {
                    vbio = Recruits;
                    break;
                  }

                  case 34: // spawning biomass depletion
                  {
                    if (pop == 1 || fleet_area(f) == 0)
                    {
                      vbio = (SSB_current + 1.0e-06) / (SSB_virgin + 1.0e-06);
                    }
                    else
                    {
                      vbio = (sum(SSB_pop_gp(y, fleet_area(f))) + 1.0e-06) / (SSB_virgin + 1.0e-06);
                    }
                    break;
                  }
                  case 35: // parm deviation  #35
                  {
                    k = Q_setup(f, 2); //  specify which parameter's time-vary vector will be compared to this survey

                    if (y >= parm_dev_minyr(k) && y <= parm_dev_maxyr(k))
                    {
                      vbio = parm_dev(k, y);
                      //  can the mean dev for years with surveys be calculated here?
                    }
                    else
                    {
                      vbio = 0.0;
                    }
                    break;
                  }
                }
                Svy_selec_abund(f, j) = vbio;  //  e.g. the abundance that has been selected through selectivity or other assignment process

                //  get catchability
                //  for "float" q, the calculations cannot be done on a year-by-year basis.  The calc is done for the whole time series in SS_objfunc.tpl
                if (Q_setup(f, 1) == 2) // mirror Q from lower numbered survey
                {
                  Svy_log_q(f, j) = Svy_log_q(Q_setup(f, 2), 1);
                  Q_parm(Q_setup_parms(f, 1)) = Svy_log_q(f, 1); // base Q  So this sets parameter equal to the scaling coefficient and can then have a prior
                }
                else if (Q_setup(f, 1) == 4)  // mirror Q plus an offset
                {
                  Svy_log_q(f, j) = Svy_log_q(Q_setup(f, 2), 1) + Q_parm(Q_setup_parms(f, 1) + 1);
                  Q_parm(Q_setup_parms(f, 1)) = Svy_log_q(f, 1); // base Q  So this sets parameter equal to the scaling coefficient and can then have a prior
                }
                else //  Q from parameter
                {
                  if (Qparm_timevary(Q_setup_parms(f, 1)) == 0) //  not time-varying
                  {
                    Svy_log_q(f, j) = Q_parm(Q_setup_parms(f, 1)); //  set to base parameter value
                  }
                  else
                  {
                    Svy_log_q(f, j) = parm_timevary(Qparm_timevary(Q_setup_parms(f, 1)), Svy_yr(f, j));
                  }
                }

                // SS_Label_Info_25.1.3 #log or not
                if (Svy_errtype(f) == -1) // normal
                {
                  Svy_q(f) = Svy_log_q(f); //  q already in  arithmetic space
                }
                else if (Svy_errtype(f) >= 0 ) // lognormal, or T-dist
                {
                  Svy_q(f) = mfexp(Svy_log_q(f)); // get q in arithmetic space
                }

                // Q transformations and offsets
                // option 5:  add offset, useful when survey units are deviations
                // option 3:  use power function
                // option 6:  add offset, then use power function
                if (Q_setup(f, 1) == 5 || Q_setup(f, 1) == 6 ) //  add offset
                {
                  vbio += Q_parm(Q_setup_parms(f, 1) + 1);
                }
                if (Q_setup(f, 1) == 3) //  link is power function
                {
                  vbio = pow(vbio, 1.0 + Q_parm(Q_setup_parms(f, 1) + 1));
                }
                if (Q_setup(f, 1) == 6 ) //  link is power function
                {
                  vbio = pow(vbio, 1.0 + Q_parm(Q_setup_parms(f, 1) + 2));  // note that this is 2nd parameter after q
                }

                if (Svy_errtype(f) >= 0) //  lognormal or T-distribution
                {
                  Svy_est(f, j) = log(vbio + 0.000001);
                }
                else
                {
                  Svy_est(f, j) = vbio;
                }

                //  apply catchability, except if float is used.
                //  With float, catchability is calculated in ss_objfun after all obs have a value for svy_selec_abund
                if (Q_setup(f, 5) == 0 || y > endyr) // apply Q if float is not used
                // except if y is in forecast, then float Q has already been calculated so can be applied here
                {
                  if (Svy_errtype(f) >= 0) //  lognormal or T-dist
                  {
                    Svy_est(f, j) += Svy_log_q(f, j);
                  }
                  else
                  {
                    Svy_est(f, j) *= Svy_q(f, j);
                  }
                }
              }
              break;
            } //  end survey index

            case (2): //  DISCARD_OUTPUT
              /* SS_Label_46.2 expected discard amount */
              {
                if (have_data(ALK_time, f, data_type, 0) > 0) //  number of observations
                {
                  j = have_data(ALK_time, f, data_type, 1); //  only getting first observation for now
                  if (fleet_type(f) <= 2)
                  {
                    if (catch_ret_obs(f, t) > 0.0 || y > endyr)
                    {
                      if (disc_units(f) == 3) // numbers regardless of catchunits for retained catch
                      {
                        exp_disc(f, j) = catch_fleet(t, f, 4) - catch_fleet(t, f, 6);
                      }
                      else if (catchunits(f) == 1) // biomass units for retained and discarded catch
                      {
                        exp_disc(f, j) = catch_fleet(t, f, 1) - catch_fleet(t, f, 3); // discard in biomass
                        if (disc_units(f) == 2)
                          exp_disc(f, j) /= (catch_fleet(t, f, 1) + 0.0000001);
                      }
                      else // numbers for retained and discarded catch
                      {
                        exp_disc(f, j) = catch_fleet(t, f, 4) - catch_fleet(t, f, 6); // discard in numbers
                        if (disc_units(f) == 2)
                          exp_disc(f, j) /= (catch_fleet(t, f, 4) + 0.0000001);
                      }
                      if (exp_disc(f, j) < 0.0)
                      {
                        warnstream << "negative discard occurred for fleet: " << f << "; obs: " << j << "; usually ephemeral issue with bad iteration";
                        write_message (WARN, 0);
                      }
                    }
                    else
                    {
                      exp_disc(f, j) = -1.;
                    }
                  }
                  else if (fleet_type(f) == 4) //  predator consumption stored in discard
                  {
                    if (disc_units(f) == 3) // numbers
                    {
                      exp_disc(f, j) = catch_fleet(t, f, 4); // consumption in numbers
                    }
                    else
                    {
                      exp_disc(f, j) = catch_fleet(t, f, 1); // consumption in biomass
                    }
                  }
                  else
                  {
                    exp_disc(f, j) = -1.;
                  }
                }
                break;
              } //  end discard

            case (3): // mean body weight
              /* SS_Label_46.3 expected mean body weight */
              {
                if (have_data(ALK_time, f, data_type, 0) > 0) //  number of observations
                {
                  for (int reps = 1; reps <= have_data(ALK_time, f, data_type, 0); reps++)
                  {
                    j = have_data(ALK_time, f, data_type, reps); //  observation number in overall list
                    z = mnwtdata(5, j); //  type 1=length, 2=weight
                    int parti = mnwtdata(4, j); //  parrtition:  0=all, 1=discard, 2=retained
                    switch (parti)
                    {
                      case 0:
                      {
                        if (z == 2)
                        {
                          exp_mnwt(j) = (exp_l_temp * wt_len2(s, 1)) / sum(exp_l_temp);
                        } // total sample
                        else
                        {
                          exp_mnwt(j) = (exp_l_temp * len_bins_m2) / sum(exp_l_temp);
                        }
                        break;
                      }
                      case 1:
                      {
                        if (z == 2)
                          exp_mnwt(j) = (exp_l_temp - exp_l_temp_ret) * wt_len2(s, 1) / (sum(exp_l_temp) - sum(exp_l_temp_ret)); // discard sample
                        else
                        {
                          exp_mnwt(j) = (exp_l_temp - exp_l_temp_ret) * len_bins_m2 / (sum(exp_l_temp) - sum(exp_l_temp_ret));
                        }
                        break;
                      }
                      case 2:
                      {
                        if (z == 2)
                          exp_mnwt(j) = (exp_l_temp_ret * wt_len2(s, 1)) / sum(exp_l_temp_ret); // retained only
                        else
                        {
                          exp_mnwt(j) = (exp_l_temp_ret * len_bins_m2) / sum(exp_l_temp_ret);
                        }
                        break;
                      }
                    }
                  }
                }
                break;
              }

            case (4): //  length composition
              /* SS_Label_46.4  length composition */
              {
                if (have_data(ALK_time, f, data_type, 0) > 0)
                {
                  for (j = 1; j <= have_data(ALK_time, f, data_type, 0); j++) // loop all obs of this type
                  {
                    i = have_data(ALK_time, f, data_type, j);
                    if (LenBin_option > 1)
                    {
                      if (mkt_l(f, i) == 0)
                      {
                        exp_l(f, i) = make_len_bin * exp_l_temp;
                      } // expected size comp  MAtrix * vector = vector
                      else if (mkt_l(f, i) == 1)
                      {
                        exp_l(f, i) = make_len_bin * (exp_l_temp - exp_l_temp_ret);
                      } // discard sample
                      else
                      {
                        exp_l(f, i) = make_len_bin * exp_l_temp_ret;
                      } // retained only
                    }
                    else //  using data_bins same as pop_bins
                    {
                      if (mkt_l(f, i) == 0)
                      {
                        exp_l(f, i) = exp_l_temp;
                      } // expected size comp  MAtrix * vector = vector
                      else if (mkt_l(f, i) == 1)
                      {
                        exp_l(f, i) = (exp_l_temp - exp_l_temp_ret);
                      } // discard sample
                      else
                      {
                        exp_l(f, i) = exp_l_temp_ret;
                      } // retained only
                    }
                    if (docheckup == 1)
                      echoinput << " len obs " << mkt_l(f, i) << " " << tails_l(f, i) << endl
                                << obs_l(f, i) << endl
                                << exp_l(f, i) << endl;
                    //  code for tail compression, etc in the likelihood section to allow for superyear combinations                                                                      // mkt=0 Do nothing
                  } // end lengthcomp loop
                }
                break;
              } // end  length composition

            case (5): //  age composition
              /* SS_Label_46.5  age composition */
              {
                if (have_data(ALK_time, f, data_type, 0) > 0)
                {
                  for (j = 1; j <= have_data(ALK_time, f, data_type, 0); j++) // loop all obs of this type
                  {
                    i = have_data(ALK_time, f, data_type, j);
                    k = ageerr_type_a(f, i); //  age-err type
                    if (use_Lbin_filter(f, i) == 0)
                    { // sum across all length bins
                      if (mkt_a(f, i) == 0)
                        age_exp = agetemp;
                      if (mkt_a(f, i) == 1)
                        age_exp = agetemp - exp_truea_ret; // discard sample
                      if (mkt_a(f, i) == 2)
                        age_exp = exp_truea_ret; // retained only
                    }
                    else
                    { // only use ages from specified range of size bins
                      // Lbin_filter is a vector with 0 for unselected size bins and 1 for selected bins
                      if (mkt_a(f, i) == 0)
                        age_exp = exp_AL * Lbin_filter(f, i);
                      if (mkt_a(f, i) == 1)
                        age_exp = (exp_AL - exp_AL_ret) * Lbin_filter(f, i); // discard sample
                      if (mkt_a(f, i) == 2)
                        age_exp = exp_AL_ret * Lbin_filter(f, i); // retained only
                    }
                    exp_a(f, i) = age_age(k) * age_exp;
                    if (docheckup == 1)
                      echoinput << "Lbin " << Lbin_filter(f, i) << endl
                                << " obs " << obs_a(f, i) << endl
                                << "expected " << age_exp << endl
                                << "exp with ageerr " << exp_a(f, i) << endl;
                    //  add code here to store exp_a_true(f,i)=age_exp
                    //  then in data generation the sample can be from true age before ageing error is applied

                    //              if(docheckup==1) echoinput<<" real age "<<age_exp<<endl<<"Lbin "<<Lbin_filter(f,i)<<endl<<" obs "<<obs_a(f,i)<<endl<<" exp with ageerr "<<exp_a(f,i)<<endl;

                  } // end agecomp loop within fleet/time
                }
                break;
              } // end age composition

            case (6): //  weight composition (generalized size composition)
              /* SS_Label_46.6  weight composition (generalized size composition) */
              {
                if (SzFreq_Nmeth > 0) //  have some sizefreq data
                {

                  if (have_data(ALK_time, f, data_type, 0) > 0)
                  {
                    for (j = 1; j <= have_data(ALK_time, f, data_type, 0); j++) // loop all obs of this type
                    {
                      iobs = have_data(ALK_time, f, data_type, j); //  observation index
                      SzFreqMethod = SzFreq_obs_hdr(iobs, 6);
                      SzFreqMethod_seas = nseas * (SzFreqMethod - 1) + s; // index that combines sizefreqmethod and season and used in SzFreqTrans
                      if (SzFreq_obs_hdr(iobs, 9) > 0) // first occurrence of this method at this time is with fleet = f
                      {
                        if (do_once == 1 || (MG_active(3) > 0 && (timevary_MG(y, 3) > 0))) // calc  matrix because wtlen parameters have changed
                        {
                          for (gg = 1; gg <= gender; gg++)
                          {
                            if (gg == 1)
                            {
                              z1 = 1;
                              z2 = nlength;
                              ibin = 0;
                              ibinsave = 0;
                            } // female
                            else
                            {
                              z1 = nlength1;
                              z2 = nlength2;
                              ibin = 0;
                              ibinsave = SzFreq_Nbins(SzFreqMethod);
                            } // male
                            topbin = 0.;
                            botbin = 0.;

                            //  NOTE:  wt_len_low is  calculated separately for each growth pattern (GPat)
                            //  but the code below still just uses GPat=1 for calculation of the sizefreq transition matrix

                            switch (SzFreq_units(SzFreqMethod)) // biomass vs. numbers are accumulated in the bins
                            {
                              case (1): // units are biomass, so accumulate body weight into the bins;  Assume that bin demarcations are also in biomass
                              {
                                if (SzFreq_Omit_Small(SzFreqMethod) == 1)
                                {
                                  while (wt_len_low(s, 1, z1 + 1) < SzFreq_bins(SzFreqMethod, 1) && z1 < z2)
                                  {
                                    z1++;
                                  }
                                } // ignore tiny fish
                                if (z1 + 1 >= z2)
                                {
                                  warnstream << "max population size " << wt_len_low(s, 1, z1) << " is less than first data bin " << SzFreq_bins(SzFreqMethod, 1) << " for SzFreqMethod " << SzFreqMethod;
                                  write_message (FATAL, 0); // EXIT!
                                }

                                if (wt_len_low(s, 1, nlength2) < SzFreq_bins(SzFreqMethod, SzFreq_Nbins(SzFreqMethod)))
                                {
                                  warnstream << "max population size " << wt_len_low(s, 1, nlength2) << " is less than max data bin " << SzFreq_bins(SzFreqMethod, SzFreq_Nbins(SzFreqMethod)) << " for SzFreqMethod " << SzFreqMethod;
                                  write_message (FATAL, 0); // EXIT!
                                }

                                for (z = z1; z <= z2; z++)
                                {
                                  if (ibin == SzFreq_Nbins(SzFreqMethod))
                                  {
                                    SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = wt_len2(s, 1, z);
                                  }
                                  else
                                  {
                                    if (wt_len_low(s, 1, z) >= topbin)
                                    {
                                      ibin++;
                                      ibinsave++;
                                    }
                                    if (ibin > 1)
                                    {
                                      botbin = SzFreq_bins2(SzFreqMethod, ibin);
                                    }
                                    if (ibin == SzFreq_Nbins(SzFreqMethod))
                                    {
                                      SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = wt_len2(s, 1, z);
                                      topbin = 99999.;
                                    }
                                    else
                                    {
                                      topbin = SzFreq_bins2(SzFreqMethod, ibin + 1);
                                      if (wt_len_low(s, 1, z) >= botbin && wt_len_low(s, 1, z + 1) <= topbin)
                                      {
                                        SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = wt_len2(s, 1, z);
                                      }
                                      else
                                      {
                                        temp = (wt_len_low(s, 1, z + 1) - topbin) / wt_len_fd(s, 1, z); // frac in pop bin above (data bin +1)
                                        temp1 = wt_len_low(s, 1, z) + (1. - temp * 0.5) * wt_len_fd(s, 1, z); // approx body wt for these fish
                                        temp2 = wt_len_low(s, 1, z) + (1. - temp) * 0.5 * wt_len_fd(s, 1, z); // approx body wt for  fish below
                                        SzFreqTrans(SzFreqMethod_seas, z, ibinsave + 1) = temp * temp1;
                                        SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = (1. - temp) * temp2;
                                      }
                                    }
                                  }
                                }
                                if (SzFreq_scale(SzFreqMethod) == 2 && gg == gender) // convert to pounds
                                {
                                  SzFreqTrans(SzFreqMethod_seas) /= 0.4536;
                                }
                                break;
                              } //  end of units in biomass
                              // NOTE: even though  the transition matrix is currently in units of biomass distribution, there is no need to
                              // normalize to sum to 1.0 here because the normalization will occur after it gets used to create SzFreq_exp

                              case (2): // units are numbers
                              {
                                if (SzFreq_scale(SzFreqMethod) <= 2) //  bin demarcations are in weight units (1=kg, 2=lbs), so uses wt_len to compare to bins
                                {
                                  if (SzFreq_Omit_Small(SzFreqMethod) == 1)
                                  {
                                    while (wt_len_low(s, 1, z1 + 1) < SzFreq_bins(SzFreqMethod, 1) && z1 < z2)
                                    {
                                      z1++;
                                    }
                                  } // ignore tiny fish
                                  if (z1 + 1 >= z2)
                                  {
                                    warnstream << "max population size " << wt_len_low(s, 1, z1) << " is less than first data bin " << SzFreq_bins(SzFreqMethod, 1) << " for SzFreqMethod " << SzFreqMethod;
                                    write_message (FATAL, 0); // EXIT!
                                  }
                                  if (wt_len_low(s, 1, nlength2) < SzFreq_bins(SzFreqMethod, SzFreq_Nbins(SzFreqMethod)))
                                  {
                                    warnstream << "max population size " << wt_len_low(s, 1, nlength2) << " is less than max data bin " << SzFreq_bins(SzFreqMethod, SzFreq_Nbins(SzFreqMethod)) << " for SzFreqMethod " << SzFreqMethod;
                                    write_message (FATAL, 0); // EXIT!
                                  }

                                  for (z = z1; z <= z2; z++)
                                  {
                                    if (ibin == SzFreq_Nbins(SzFreqMethod))
                                    {
                                      SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1.;
                                    } //checkup<<" got to last ibin, so put rest of popbins here"<<endl;
                                    else
                                    {
                                      if (wt_len_low(s, 1, z) >= topbin)
                                      {
                                        ibin++;
                                        ibinsave++;
                                      } //checkup<<" incr ibin "<<z<<" "<<ibin<<" "<<len_bins(z)<<" "<<len_bins_dat(ibin);
                                      if (ibin > 1)
                                      {
                                        botbin = SzFreq_bins2(SzFreqMethod, ibin);
                                      }
                                      if (ibin == SzFreq_Nbins(SzFreqMethod)) // checkup<<" got to last ibin, so put rest of popbins here"<<endl;
                                      {
                                        SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1.;
                                        topbin = 99999.;
                                      }
                                      else
                                      {
                                        topbin = SzFreq_bins2(SzFreqMethod, ibin + 1);
                                        if (wt_len_low(s, 1, z) >= botbin && wt_len_low(s, 1, z + 1) <= topbin) //checkup<<" pop inside dat, put here"<<endl;
                                        {
                                          SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1.;
                                        }
                                        else // checkup<<" overlap"<<endl;
                                        {
                                          SzFreqTrans(SzFreqMethod_seas, z, ibinsave + 1) = (wt_len_low(s, 1, z + 1) - topbin) / wt_len_fd(s, 1, z);
                                          SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1. - SzFreqTrans(SzFreqMethod_seas, z, ibinsave + 1);
                                        }
                                      }
                                    }
                                  }
                                }

                                else //  bin demarcations are in length unit (3=cm, 4=inch) so uses population len_bins to compare to data bins
                                {
                                  if (SzFreq_Omit_Small(SzFreqMethod) == 1)
                                  {
                                    while (len_bins2(z1 + 1) < SzFreq_bins(SzFreqMethod, 1))
                                    {
                                      z1++;
                                    }
                                    //  echoinput<<"accumulate starting at bin: "<<z1<<endl;
                                  } // ignore tiny fish

                                  if (len_bins2(nlength2) < SzFreq_bins(SzFreqMethod, SzFreq_Nbins(SzFreqMethod)))
                                  {
                                    warnstream << "max population len bin " << len_bins2(nlength2) << " is less than max data bin " << SzFreq_bins(SzFreqMethod, SzFreq_Nbins(SzFreqMethod)) << " for SzFreqMethod " << SzFreqMethod;
                                    write_message (FATAL, 0); // EXIT!
                                  }

                                  for (z = z1; z <= z2; z++)
                                  {
                                    if (ibin == SzFreq_Nbins(SzFreqMethod))
                                    {
                                      SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1.;
                                    } //checkup<<" got to last ibin, so put rest of popbins here"<<endl;
                                    else
                                    {
                                      if (len_bins2(z) >= topbin)
                                      {
                                        ibin++;
                                        ibinsave++;
                                      } //checkup<<" incr ibin "<<z<<" "<<ibin<<" "<<len_bins(z)<<" "<<len_bins_dat(ibin);
                                      if (ibin > 1)
                                      {
                                        botbin = SzFreq_bins2(SzFreqMethod, ibin);
                                      }
                                      if (ibin == SzFreq_Nbins(SzFreqMethod)) // checkup<<" got to last ibin, so put rest of popbins here"<<endl;
                                      {
                                        SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1.;
                                        topbin = 99999.;
                                      }
                                      else
                                      {
                                        topbin = SzFreq_bins2(SzFreqMethod, ibin + 1);
                                        if (len_bins2(z) >= botbin && len_bins2(z + 1) <= topbin) //checkup<<" pop inside dat, put here"<<endl;
                                        {
                                          SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1.;
                                        }
                                        else // checkup<<" overlap"<<endl;
                                        {
                                          SzFreqTrans(SzFreqMethod_seas, z, ibinsave + 1) = (len_bins2(z + 1) - topbin) / (len_bins2(z + 1) - len_bins2(z));
                                          SzFreqTrans(SzFreqMethod_seas, z, ibinsave) = 1. - SzFreqTrans(SzFreqMethod_seas, z, ibinsave + 1);
                                        }
                                      }
                                    }
                                  }
                                }
                                break;
                              } //  end of units in numbers
                            }
                            if (docheckup == 1 && gg == gender)
                              echoinput << " sizefreq trans_matrix: method/season " << SzFreqMethod << " / " << s << endl
                                        << trans(SzFreqTrans(SzFreqMethod_seas)) << endl;
                          } // end gender loop
                        } //  end needing to calc the matrix because it may have changed
                      } // done calculating the SzFreqTransition matrix for this method

                      switch (SzFreq_obs_hdr(iobs, 5)) // discard/retained partition
                      {
                        case (0):
                        {
                          SzFreq_exp(iobs) = trans(SzFreqTrans(SzFreqMethod_seas)) * exp_l_temp;
                          break;
                        }
                        case (1):
                        {
                          SzFreq_exp(iobs) = trans(SzFreqTrans(SzFreqMethod_seas)) * (exp_l_temp - exp_l_temp_ret);
                          break;
                        }
                        case (2):
                        {
                          SzFreq_exp(iobs) = trans(SzFreqTrans(SzFreqMethod_seas)) * exp_l_temp_ret;
                          break;
                        }
                      }
  #ifdef DO_ONCE
                      if (do_once == 1)
                        echoinput << y << " " << f << " szfreq_exp_initial  " << SzFreq_exp(iobs) << endl;
  #endif

                      if (gender == 2)
                      {
                        k = SzFreq_obs_hdr(iobs, 8); // max bins for this method
                        switch (SzFreq_obs_hdr(iobs, 4)) //  combine, select or each gender
                        {
                          case (0): // combine genders
                          {
                            for (ibin = 1; ibin <= k; ibin++)
                              SzFreq_exp(iobs, ibin) += SzFreq_exp(iobs, k + ibin);
                            SzFreq_exp(iobs)(k + 1, 2 * k) = 0.0;
                            SzFreq_exp(iobs)(1, k) /= sum(SzFreq_exp(iobs)(1, k));
                            if (SzFreq_mincomp(SzFreqMethod) > 0.0)
                            {
                              SzFreq_exp(iobs)(1, k) += SzFreq_mincomp(SzFreqMethod);
                              SzFreq_exp(iobs)(1, k) /= sum(SzFreq_exp(iobs)(1, k));
                            }
                            break;
                          }
                          case (1): // female only
                          {
                            SzFreq_exp(iobs)(k + 1, 2 * k) = 0.0; //  zero out the males so will not interfere with data generation
                            SzFreq_exp(iobs)(1, k) /= sum(SzFreq_exp(iobs)(1, k));
                            if (SzFreq_mincomp(SzFreqMethod) > 0.0)
                            {
                              SzFreq_exp(iobs)(1, k) += SzFreq_mincomp(SzFreqMethod);
                              SzFreq_exp(iobs)(1, k) /= sum(SzFreq_exp(iobs)(1, k));
                            }
                            break;
                          }
                          case (2): //   male only
                          {
                            ibin = SzFreq_obs_hdr(iobs, 7);
                            SzFreq_exp(iobs)(1, ibin - 1) = 0.0; //  zero out the females so will not interfere with data generation
                            SzFreq_exp(iobs)(ibin, k) /= sum(SzFreq_exp(iobs)(ibin, k));
                            if (SzFreq_mincomp(SzFreqMethod) > 0.0)
                            {
                              SzFreq_exp(iobs)(ibin, k) += SzFreq_mincomp(SzFreqMethod);
                              SzFreq_exp(iobs)(ibin, k) /= sum(SzFreq_exp(iobs)(ibin, k));
                            }
                            break;
                          }
                          case (3): //  each gender
                          {
                            SzFreq_exp(iobs) /= sum(SzFreq_exp(iobs));
                            if (SzFreq_mincomp(SzFreqMethod) > 0.0)
                            {
                              SzFreq_exp(iobs) += SzFreq_mincomp(SzFreqMethod);
                              SzFreq_exp(iobs) /= sum(SzFreq_exp(iobs));
                            }
                            break;
                          }
                        } //  end gender switch
                      } // end have 2 genders
                      else
                      {
                        k = SzFreq_obs_hdr(iobs, 8); // max bins for this method
                        SzFreq_exp(iobs)(1, k) /= sum(SzFreq_exp(iobs)(1, k));
                        if (SzFreq_mincomp(SzFreqMethod) > 0.0)
                        {
                          SzFreq_exp(iobs)(1, k) += SzFreq_mincomp(SzFreqMethod);
                          SzFreq_exp(iobs)(1, k) /= sum(SzFreq_exp(iobs)(1, k));
                        }
                      }
  #ifdef DO_ONCE
                      if (do_once == 1)
                        echoinput << y << " " << f << " szfreq_exp_final  " << SzFreq_exp(iobs) << endl;
  #endif
                    } // end loop of obs for fleet = f
                  } //  end having some obs for this method in this fleet
                } //  end use of generalized size freq data
                break;
              } //  end generalized size composition

            case (7): //  mean size-at-age
              /* SS_Label_46.7  mean size at age */
              {
                if (have_data(ALK_time, f, data_type, 0) > 0)
                {
                  for (j = 1; j <= have_data(ALK_time, f, data_type, 0); j++) // loop all obs of this type
                  {
                    i = have_data(ALK_time, f, data_type, j);
                    k = abs(ageerr_type_ms(f, i)); //  age-err type  where the sign selects length vs. weight
                    if (ageerr_type_ms(f, i) > 0) // values are length at age
                    {
                      if (mkt_ms(f, i) == 0) //  total catch
                      {
                        exp_a_temp = age_age(k) * agetemp; //  numbers at binned age
                        exp_ms(f, i) = age_age(k) * (exp_AL * len_bins_m2); // numbers * length
                        exp_ms_sq(f, i) = age_age(k) * (exp_AL * len_bins_sq); // numbers * length^2
                      }
                      if (mkt_ms(f, i) == 1) //  discard
                      {
                        //                 exp_a_temp = age_age(k) * (exp_AL * (1-retain(y,f)));             //  numbers at binned age = age_age(bins,age) * sum(age)
                        //                 exp_ms(f,i) = age_age(k) * (exp_AL * elem_prod((1-retain(y,f)),len_bins_m2));  // numbers * length
                        //                 exp_ms_sq(f,i) = age_age(k) * (exp_AL * elem_prod((1-retain(y,f)),len_bins_sq));  // numbers * length^2
                        exp_a_temp = age_age(k) * (agetemp - exp_truea_ret);
                        exp_ms(f, i) = age_age(k) * ((exp_AL - exp_AL_ret) * len_bins_m2); // numbers * length
                        exp_ms_sq(f, i) = age_age(k) * ((exp_AL - exp_AL_ret) * len_bins_sq); // numbers * length^2
                      }
                      if (mkt_ms(f, i) == 2) //  retained
                      {
                        exp_a_temp = age_age(k) * exp_truea_ret; //  numbers at binned age = age_age(bins,age) * sum(age)
                        exp_ms(f, i) = age_age(k) * (exp_AL_ret * len_bins_m2); // numbers * length
                        exp_ms_sq(f, i) = age_age(k) * (exp_AL_ret * len_bins_sq); // numbers * length^2
                      }
                    }
                    else // values are weight at age
                    {
                      if (mkt_ms(f, i) == 0)
                      {
                        exp_a_temp = age_age(k) * agetemp; //  numbers at binned age = age_age(bins,age) * sum(age)
                        exp_ms(f, i) = age_age(k) * (exp_AL * wt_len2(s, 1)); // numbers * bodywt
                        exp_ms_sq(f, i) = age_age(k) * (exp_AL * wt_len2_sq(s, 1)); // numbers * bodywt^2
                      }
                      if (mkt_ms(f, i) == 1)
                      {
                        exp_a_temp = age_age(k) * (agetemp - exp_truea_ret); //  numbers at binned age = age_age(bins,age) * sum(age)
                        exp_ms(f, i) = age_age(k) * ((exp_AL - exp_AL_ret) * wt_len2(s, 1)); // numbers * bodywt
                        exp_ms_sq(f, i) = age_age(k) * ((exp_AL - exp_AL_ret) * wt_len2_sq(s, 1)); // numbers * bodywt^2
                      }
                      if (mkt_ms(f, i) == 2)
                      {
                        exp_a_temp = age_age(k) * exp_truea_ret; //  numbers at binned age = age_age(bins,age) * sum(age)
                        exp_ms(f, i) = age_age(k) * (exp_AL_ret * wt_len2(s, 1)); // numbers * bodywt
                        exp_ms_sq(f, i) = age_age(k) * (exp_AL_ret * wt_len2_sq(s, 1)); // numbers * bodywt^2
                      }
                    }
                    exp_ms(f, i) += 1.0e-6;
                    exp_a_temp += 1.0e-6;
                    exp_ms_sq(f, i) += 1.0e-6;
                    exp_ms_sq(f, i) = sqrt(
                                          elem_div(
                                              (exp_ms_sq(f, i) - elem_div(elem_prod(exp_ms(f, i), exp_ms(f, i)), exp_a_temp)),
                                              exp_a_temp)) +
                        0.000001; //std.err. of size at binned age = sqrt( (P2-P1*P1/P0) / P0 )
                    exp_ms(f, i) = elem_div(exp_ms(f, i), exp_a_temp); //  mean size at binned age
                  }
                } // endl size-at-age
                break;
              } //  end mean size-at-age

          } // end switch(data_type)
        } //  end loop for types of data
      }
    } //  end loop of fleets
  } //  end loop of subseasons
  return;
  } //  end function
// SS_Label_file  #16. **SS_objfunc.tpl**
// SS_Label_file  # * <u>evaluate_the_objective_function()</u>
// SS_Label_file  # * <u>Process_STDquant()</u>  //  move info like SSB  to the sd_vectors
// SS_Label_file  # * <u>Check_Parm()</u> // check parameter against its bounds and do jitter if requested
// SS_Label_file  # * <u>Get_Prior()</u>  // calc the prior likelihood for a parameter
// SS_Label_file  # * <u>get_posteriors()</u>  //  writes posteriors.sso and other MCMC relevant outputs
// SS_Label_file  #

//********************************************************************
// FUNCTIONS in file: SS_objfunc.tpl
// evaluate_the_objective_function
// Process_STDquant
// Check_Parm
// Get_Prior
// get_posteriors

 /*  SS_Label_FUNCTION 25 evaluate_the_objective_function */
FUNCTION void evaluate_the_objective_function()
  {
  surv_like.initialize();
  Svy_like_I.initialize();
  Q_dev_like.initialize();
  disc_like.initialize();
  length_like.initialize();
  age_like.initialize();
  sizeage_like.initialize();
  parm_like.initialize();
  parm_dev_like.initialize();
  noBias_recr_like.initialize();
  mnwt_like.initialize();
  equ_catch_like.initialize();
  recr_like.initialize();
  Fcast_recr_like.initialize();
  catch_like.initialize();
  Morphcomp_like.initialize();
  TG_like1.initialize();
  TG_like2.initialize();
  length_like_tot.initialize();
  age_like_tot.initialize();
  regime_like.initialize();
  obj_fun = 0.0;
  SoftBoundPen = 0.0;

  int k_phase = current_phase();
  if (k_phase > max_lambda_phase)
    k_phase = max_lambda_phase;

  //Q_setup for 3.30
  // 1:  link type
  // 2:  extra input for link, i.e. mirror fleet
  // 3:  0/1 to select extra sd parameter
  // 4:  0/1 for biasadj or not
  // 5:  0/1 to float  k=4;

  //  Link types
  //  1  simple q, 1 parm
  //  2  mirror simple q, 1 mirrored parameter
  //  3  q and power, 2 parm

  if (Svy_N > 0)
  {
    for (f = 1; f <= Nfleet; f++)
    {
      if (Svy_N_fleet(f) > 0)
      {
        Svy_se_use(f) = Svy_se(f);
        if (Q_setup(f, 3) > 0)
        {
          Svy_se_use(f) += Q_parm(Q_setup_parms(f, 2)); // add extra stderr
        }
        // SS_Label_Info_25.1.1 #combine for super-periods
        for (j = 1; j <= Svy_super_N(f); j++)
        {
          temp = 0.0;
          for (i = Svy_super_start(f, j); i <= Svy_super_end(f, j); i++)
          {
            temp += Svy_est(f, i) * Svy_super_weight(f, i);
          } // combine across range of observations
          //  sampwt sums to 1.0, so temp contains the weighted average
          for (i = Svy_super_start(f, j); i <= Svy_super_end(f, j); i++)
          {
            Svy_est(f, i) = temp;
          } // assign average to each obs
        }

        // SS_Label_Info_25.1.2 #apply catchability, Q
        if (Q_setup(f, 5) > 0) //  do float Q
        { //  NOTE:  cannot use float option if error type is normal
          temp = 0.;
          temp1 = 0.;
          temp2 = 0.;
          Svy_log_q(f) = 0.0;
          Svy_q(f) = 0.0;
          if (Svy_N_fleet_use(f) > 0) //  be sure that some observation is being used
          {
            for (i = 1; i <= Svy_N_fleet(f); i++)
            {
              if (Svy_use(f, i) > 0)
              {
                Svy_est(f, i) = log( Svy_selec_abund(f, i) );  //  before q is applied
                temp2 += (Svy_obs_log(f, i) - Svy_est(f, i)) / square(Svy_se_use(f, i));
                temp += 1.0 / square(Svy_se_use(f, i));
                temp1 += 1.;
              }
            }

            //  calc q and apply to all obs
            if (Q_setup(f, 4) == 0) // mean q, with no bias adjustment
            {
              Svy_log_q(f) = temp2 / temp;
              Svy_est(f) += temp2 / temp;
            }
            else // any value mean q with variance bias adjustment
            {
              Svy_log_q(f) = (temp2 + temp1 * 0.5) / temp;
              Svy_est(f) += (temp2 + temp1 * 0.5) / temp;
            }
            Svy_q(f) = mfexp(Svy_log_q(f)); // get q in arithmetic space
            Q_parm(Q_setup_parms(f, 1)) = Svy_log_q(f, 1); // base Q  So this sets parameter equal to the scaling coefficient and can then have a prior
          }
          else //  no observations
          {
            Q_parm(Q_setup_parms(f, 1)) = Svy_log_q(f, 1);
          }
        }

        // SS_Label_Info_25.1.4 #calc the logL
        for (i = 1; i <= Svy_N_fleet(f); i++) {
          if (Svy_use(f, i) > 0)
          {
            if (Svy_errtype(f) == 0) {  // lognormal
              Svy_like_I(f,i) = 0.5 * square((Svy_obs_log(f, i) - Svy_est(f, i)) / Svy_se_use(f, i))
                              + sd_offset * log(Svy_se_use(f, i));
             }
            else if (Svy_errtype(f) == 1) {  // lognormal with bias adjustment
              Svy_like_I(f,i) = 0.5 * square((Svy_obs_log(f, i) - Svy_est(f, i) + 0.5 * square(Svy_se_use(f, i))) / Svy_se_use(f, i))
                              + sd_offset * log(Svy_se_use(f, i));
              }
            else if (Svy_errtype(f) > 1) {  // T-dist
              dvariable df = Svy_errtype(f);
              Svy_like_I(f,i) = ((df + 1.) / 2.) * log((1. + square((Svy_obs_log(f, i) - Svy_est(f, i))) / (df * square(Svy_se_use(f, i)))))
                              + sd_offset * log(Svy_se_use(f, i));
              }
            else if (Svy_errtype(f) == -1) {  // normal
              Svy_like_I(f,i) =  0.5 * square((Svy_obs(f, i) - Svy_est(f, i)) / Svy_se_use(f, i))
                              + sd_offset * log(Svy_se_use(f, i));
            }
            else if (Svy_errtype(f) == -2) {
              // gamma option will go here
            }
            else {
              // values <-2 are trapped in readdata
            }
          }
        }  // end loop of obs
        surv_like(f) = sum(Svy_like_I(f));
      } // end having obs for this survey
    }
    if (do_once == 1)
      echoinput << "Finished survey obj_fun " << surv_like << endl;
  }

  //  SS_Label_Info_25.2 #Fit to discard
  if (nobs_disc > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      if (disc_lambda(f, k_phase) > 0.0 || save_for_report > 0)
      {
        if (disc_N_fleet(f) > 0)
        {
          for (j = 1; j <= N_suprper_disc(f); j++) // do super years
          {
            temp = 0.0;
            for (i = suprper_disc1(f, j); i <= suprper_disc2(f, j); i++)
            {
              temp += exp_disc(f, i) * suprper_disc_sampwt(f, i);
            } // combine across range of observations
            for (i = suprper_disc1(f, j); i <= suprper_disc2(f, j); i++)
            {
              exp_disc(f, i) = temp;
            } // assign back to each obs
          }

          if (disc_errtype(f) >= 1) // T -distribution
          {
            for (i = 1; i <= disc_N_fleet(f); i++)
              if (yr_disc_use(f, i) >= 0.0)
              {
                disc_like(f) += 0.5 * (disc_errtype(f) + 1.) * log((1. + square(obs_disc(f, i) - exp_disc(f, i)) / (disc_errtype(f) * square(sd_disc(f, i))))) + sd_offset * log(sd_disc(f, i));
              }
          }
          else if (disc_errtype(f) == 0) // normal error, with input CV
          {
            for (i = 1; i <= disc_N_fleet(f); i++)
              if (yr_disc_use(f, i) >= 0.0)
              {
                disc_like(f) += 0.5 * square((obs_disc(f, i) - exp_disc(f, i)) / sd_disc(f, i)) + sd_offset * log(sd_disc(f, i));
              }
          }
          else if (disc_errtype(f) == -1) // normal error with input se
          {
            for (i = 1; i <= disc_N_fleet(f); i++)
              if (yr_disc_use(f, i) >= 0.0)
              {
                disc_like(f) += 0.5 * square((obs_disc(f, i) - exp_disc(f, i)) / sd_disc(f, i)) + sd_offset * log(sd_disc(f, i));
              }
          }
          else if (disc_errtype(f) == -2) // lognormal  where input cv_disc must contain se in log space
          {
            for (i = 1; i <= disc_N_fleet(f); i++)
              if (yr_disc_use(f, i) >= 0.0)
              {
                disc_like(f) += 0.5 * square(log(obs_disc(f, i) / exp_disc(f, i)) / sd_disc(f, i)) + sd_offset * log(sd_disc(f, i));
              }
          }
          else if (disc_errtype(f) == -3) // trunc normal error, with input CV
          {
            for (i = 1; i <= disc_N_fleet(f); i++)
              if (yr_disc_use(f, i) >= 0.0)
              {
                disc_like(f) += 0.5 * square((obs_disc(f, i) - exp_disc(f, i)) / sd_disc(f, i)) - log(cumd_norm((1 - exp_disc(f, i)) / sd_disc(f, i)) - cumd_norm((0 - exp_disc(f, i)) / sd_disc(f, i)));
              }
          }
          else
          {
            warnstream << "discard error type for fleet " << f << " = " << disc_errtype(f) << " should be -3, -2, -1, 0, or >=1";
            write_message (FATAL, 0); // EXIT!
          }
        }
      }
    if (do_once == 1)
    {
      echoinput << "Finished discard obj_fun " << disc_like << endl;
    }
  }

  //  SS_Label_Info_25.3 #Fit to mean body wt
  if (nobs_mnwt > 0)
  {
    for (i = 1; i <= nobs_mnwt; i++)
      if (mnwtdata(3, i) > 0.)
      {
        mnwt_like(mnwtdata(3, i)) += 0.5 * (DF_bodywt + 1.) * log(1. + square(mnwtdata(6, i) - exp_mnwt(i)) / mnwtdata(9, i)) + mnwtdata(10, i);
      }
    if (do_once == 1)
      echoinput << " Finished meanwt obj_fun " << mnwt_like << endl;
  }

  //  SS_Label_Info_25.4 #Fit to length comp
  if (Nobs_l_tot > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      if (length_lambda(f, k_phase) > 0.0 || save_for_report > 0)
      {
        if (Nobs_l(f) >= 1)
        {

          for (j = 1; j <= N_suprper_l(f); j++) // do each super period
          {
            exp_l_temp_dat.initialize();
            for (i = suprper_l1(f, j); i <= suprper_l2(f, j); i++)
            {
              exp_l_temp_dat += exp_l(f, i) * suprper_l_sampwt(f, i); // combine across range of observations
            }
            //       exp_l_temp_dat/=sum(exp_l_temp_dat);   // normalize not needed because converted to proportions later
            for (i = suprper_l1(f, j); i <= suprper_l2(f, j); i++)
            {
              exp_l(f, i) = exp_l_temp_dat; // assign back to all obs
            }
          }

          for (i = 1; i <= Nobs_l(f); i++)
          {
            length_like(f, i) = -offset_l(f, i); //  so a perfect fit will approach 0.0
            int parti = mkt_l(f, i);  //  discard vs retained
            if (gender == 2)
            {
              if (gen_l(f, i) == 0)
              {
                for (z = 1; z <= nlen_bin; z++)
                {
                  exp_l(f, i, z) += exp_l(f, i, z + nlen_bin);
                }
                exp_l(f, i)(nlen_binP, nlen_bin2) = 0.00;
              }
              else if (gen_l(f, i) == 1) // female only
              {
                exp_l(f, i)(nlen_binP, nlen_bin2) = 0.00;
              }
              else if (gen_l(f, i) == 2) // male only
              {
                exp_l(f, i)(1, nlen_bin) = 0.00;
              }
              else if (gen_l(f, i) == 3 && CombGender_L(parti, f) > 0)
              {
                for (z = 1; z <= CombGender_L(parti, f); z++)
                {
                  exp_l(f, i, z) += exp_l(f, i, z + nlen_bin);
                  exp_l(f, i, z + nlen_bin) = 0.00;
                }
              }
            }
            exp_l(f, i) /= sum(exp_l(f, i));
            tails_w = ivector(tails_l(f, i));

            if (gen_l(f, i) != 2)
            {
              if (tails_w(1) > 1)
              {
                exp_l(f, i, tails_w(1)) = sum(exp_l(f, i)(1, tails_w(1)));
                exp_l(f, i)(1, tails_w(1) - 1) = 0.;
              }
              if (tails_w(2) < nlen_bin)
              {
                exp_l(f, i, tails_w(2)) = sum(exp_l(f, i)(tails_w(2), nlen_bin));
                exp_l(f, i)(tails_w(2) + 1, nlen_bin) = 0.;
              }
              exp_l(f, i)(tails_w(1), tails_w(2)) += min_comp_L(mkt_l(f, i), f);
            }

            if (gender == 2 && gen_l(f, i) >= 2)
            {
              if (tails_w(3) > nlen_binP)
              {
                exp_l(f, i, tails_w(3)) = sum(exp_l(f, i)(nlen_binP, tails_w(3)));
                exp_l(f, i)(nlen_binP, tails_w(3) - 1) = 0.;
              }
              if (tails_w(4) < nlen_bin2)
              {
                exp_l(f, i, tails_w(4)) = sum(exp_l(f, i)(tails_w(4), nlen_bin2));
                exp_l(f, i)(tails_w(4) + 1, nlen_bin2) = 0.;
              }
              exp_l(f, i)(tails_w(3), tails_w(4)) += min_comp_L(mkt_l(f, i), f);
            }
            exp_l(f, i) /= sum(exp_l(f, i));

            if (header_l(f, i, 3) > 0 || save_for_report == 1)
            {
              if (Comp_Err_L(parti, f) == 0) // multinomial
              {
                // get female or combined sex logL
                //  logL functions are at end of file SS_miscfxn.tpl
                if (gen_l(f, i) != 2)
                  length_like(f, i) += Comp_logL_multinomial( nsamp_l(f, i), obs_l(f, i)(tails_w(1), tails_w(2)), exp_l(f, i)(tails_w(1), tails_w(2)) );
                //  add male logL
                if (gen_l(f, i) >= 2 && gender == 2)
                  length_like(f, i) += Comp_logL_multinomial( nsamp_l(f, i), obs_l(f, i)(tails_w(3), tails_w(4)), exp_l(f, i)(tails_w(3), tails_w(4)) );
              }
             else if( (Comp_Err_L(parti, f)==1) || (Comp_Err_L(parti, f)==2) ) //  dirichlet
              {
                /* from Thorson:  NLL -= gammln(A) - gammln(ninput_t(t)+A) + sum(gammln(ninput_t(t)*extract_row(pobs_ta,t) + A*extract_row(pexp_ta,t))) - sum(lgamma(A*extract_row(pexp_ta,t))) \
                in option 1, dirichlet_Parm = Theta*n from equation (10) of Thorson et al. 2016
                in option 2, dirichlet_Parm = Beta from equation (4) of Thorson et al. 2016 */
                dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_L2(parti, f),1)));
                if (Comp_Err_L(parti, f) == 1)
                  dirichlet_Parm *= nsamp_l(f, i);

                // note: first term in equations (4) and (10) is calculated
                // as offset_l in SS_prelim.tpl and already included in length_like
                // now add second term which is only dependent on parameters and sample size
                temp = gammln(dirichlet_Parm) - gammln(nsamp_l(f, i) + dirichlet_Parm);
                // get female or combined sex logL
                // third and final term in equations (4) and (10)
                if (gen_l(f, i) != 2) {   //  so not male only
                  temp += Comp_logL_Dirichlet( nsamp_l(f, i), dirichlet_Parm, obs_l(f, i)(tails_w(1), tails_w(2)), exp_l(f, i)(tails_w(1), tails_w(2)) );
                }
                //  add male logL
                if (gen_l(f, i) >= 2 && gender == 2) {
                  temp += Comp_logL_Dirichlet( nsamp_l(f, i), dirichlet_Parm, obs_l(f, i)(tails_w(3), tails_w(4)), exp_l(f, i)(tails_w(3), tails_w(4)) );
                }
                length_like(f, i) -= temp;
              } else  //  multivariate-Tweedie
			  {
				dvariable tweedie_Phi;
				dvariable tweedie_power;
				// Exponentiate [PARAMETER_1]
				int k1 = Comp_Err_parmloc(Comp_Err_L2(parti, f),1);
				tweedie_Phi = mfexp(selparm(k1));
				// One plus logistic-transform [PARAMETER_1]
				tweedie_power = 1.0 + mfexp(selparm(k1+1)) / (1.0+mfexp(selparm(k1+1)));
				if(gen_l(f,i) !=2) //  so not male only
				{
				  // dtweedie( Type y, Type mu, Type phi, Type p, int give_log=0 )
				  for (int tail_index=tails_w(1); tail_index<=tails_w(2); tail_index++){
					temp += 1.;  // dtweedie( nsamp_l(f,i)*obs_l(f,i)(tail_index), nsamp_l(f,i)*exp_l(f,i)(tail_index), tweedie_Phi, tweedie_power, true );
				  }
				}
				//  add male logL
				if(gen_l(f,i) >=2 && gender==2)
				{
				  // dtweedie( Type y, Type mu, Type phi, Type p, int give_log=0 )
				  for (int tail_index=tails_w(3); tail_index<=tails_w(4); tail_index++){
					temp += 1.;  // dtweedie( nsamp_l(f,i)*obs_l(f,i)(tail_index), nsamp_l(f,i)*exp_l(f,i)(tail_index), tweedie_Phi, tweedie_power, true );
				  }
				}
				length_like(f,i)-=temp;
              }
              if (header_l(f, i, 3) > 0)
                length_like_tot(f) += length_like(f, i);
            }
          }
        }
      }
    if (do_once == 1)
      echoinput << "Finished lencomp obj_fun " << length_like_tot << endl;
  }

  //  SS_Label_Info_25.5 #Fit to age composition
  if (Nobs_a_tot > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      if (age_lambda(f, k_phase) > 0.0 || save_for_report > 0)
      {
        if (Nobs_a(f) >= 1)
        {
          for (j = 1; j <= N_suprper_a(f); j++) // do super years  Max of 20 allowed per type(f)
          {
            exp_a_temp.initialize();
            for (i = suprper_a1(f, j); i <= suprper_a2(f, j); i++)
            {
              exp_a_temp += exp_a(f, i) * suprper_a_sampwt(f, i); // combine across range of observations
            }
            //          exp_a_temp/=(1.0e-15+sum(exp_a_temp));                                        // normalize
            for (i = suprper_a1(f, j); i <= suprper_a2(f, j); i++)
              exp_a(f, i) = exp_a_temp; // assign back to each original obs
          }

          for (i = 1; i <= Nobs_a(f); i++)
          {
            age_like(f, i) = -offset_a(f, i); //  so a perfect fit will approach 0.0
            if (gender == 2)
            {
              if (gen_a(f, i) == 0) // combined sex observation
              {
                for (z = 1; z <= n_abins; z++)
                {
                  exp_a(f, i, z) += exp_a(f, i, z + n_abins);
                }
                exp_a(f, i)(n_abins1, n_abins2) = 0.00;
              }
              else if (gen_a(f, i) == 1) // female only
              {
                exp_a(f, i)(n_abins1, n_abins2) = 0.00;
              }
              else if (gen_a(f, i) == 2) // male only
              {
                exp_a(f, i)(1, n_abins) = 0.00;
              }
              else if (gen_a(f, i) == 3 && CombGender_A(f) > 0)
              {
                for (z = 1; z <= CombGender_A(f); z++)
                {
                  exp_a(f, i, z) += exp_a(f, i, z + n_abins);
                  exp_a(f, i, z + n_abins) = 0.00;
                }
              }
            }
            exp_a(f, i) /= (1.0e-15 + sum(exp_a(f, i))); // proportion at binned age

            tails_w = ivector(tails_a(f, i));
            if (gen_a(f, i) != 2)
            {
              if (tails_w(1) > 1)
              {
                exp_a(f, i, tails_w(1)) = sum(exp_a(f, i)(1, tails_w(1)));
                exp_a(f, i)(1, tails_w(1) - 1) = 0.;
              }
              if (tails_w(2) < n_abins)
              {
                exp_a(f, i, tails_w(2)) = sum(exp_a(f, i)(tails_w(2), n_abins));
                exp_a(f, i)(tails_w(2) + 1, n_abins) = 0.;
              }
              exp_a(f, i)(tails_w(1), tails_w(2)) += min_comp_A(f);
            }

            if (gender == 2 && gen_a(f, i) >= 2)
            {
              if (tails_w(3) > n_abins1)
              {
                exp_a(f, i, tails_w(3)) = sum(exp_a(f, i)(n_abins1, tails_w(3)));
                exp_a(f, i)(n_abins1, tails_w(3) - 1) = 0.;
              }
              if (tails_w(4) < n_abins2)
              {
                exp_a(f, i, tails_w(4)) = sum(exp_a(f, i)(tails_w(4), n_abins2));
                exp_a(f, i)(tails_w(4) + 1, n_abins2) = 0.;
              }
              exp_a(f, i)(tails_w(3), tails_w(4)) += min_comp_A(f);
            }

            exp_a(f, i) /= (1.0e-15 + sum(exp_a(f, i)));

            if (header_a(f, i, 3) > 0 || save_for_report == 1)
            {
              if (Comp_Err_A(f) == 0) //  multinomial
              {
                if (gen_a(f, i) != 2)
                 age_like(f, i) += Comp_logL_multinomial( nsamp_a(f, i), obs_a(f, i)(tails_w(1), tails_w(2)), exp_a(f, i)(tails_w(1), tails_w(2)) );
//                  age_like(f, i) -= nsamp_a(f, i) *
//                      obs_a(f, i)(tails_w(1), tails_w(2)) * log(exp_a(f, i)(tails_w(1), tails_w(2)));
                if (gen_a(f, i) >= 2 && gender == 2)
                 age_like(f, i) += Comp_logL_multinomial( nsamp_a(f, i), obs_a(f, i)(tails_w(3), tails_w(4)), exp_a(f, i)(tails_w(3), tails_w(4)) );
//                  age_like(f, i) -= nsamp_a(f, i) *
//                      obs_a(f, i)(tails_w(3), tails_w(4)) * log(exp_a(f, i)(tails_w(3), tails_w(4)));
              }
             else if( (Comp_Err_A(f)==1) || (Comp_Err_A(f)==2) ) //  dirichlet
              {
                /* from Thorson:  NLL -= gammln(A) - gammln(ninput_t(t)+A) + sum(gammln(ninput_t(t)*extract_row(pobs_ta,t) + A*extract_row(pexp_ta,t))) - sum(lgamma(A*extract_row(pexp_ta,t))) \
                in option 1, dirichlet_Parm = Theta*n from equation (10) of Thorson et al. 2016
                in option 2, dirichlet_Parm = Beta from equation (4) of Thorson et al. 2016
                */
                dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_A2(f),1)));
                if (Comp_Err_A(f) == 1)
                  dirichlet_Parm *= nsamp_a(f, i);
                // note: first term in equations (4) and (10) is calculated
                // as offset_a in SS_prelim.tpl and already included in age_like
                // now add second term which is only dependent on parameters and sample size
                // second term in equations (4) and (10) which is only dependent on parameters and sample size
                temp = gammln(dirichlet_Parm) - gammln(nsamp_a(f, i) + dirichlet_Parm);
                // get female or combined sex logL
                // final term in equations (4) and (10)
                if (gen_a(f, i) != 2) {  //  so not male only
                  temp += Comp_logL_Dirichlet( nsamp_a(f, i), dirichlet_Parm, obs_a(f, i)(tails_w(1), tails_w(2)), exp_a(f, i)(tails_w(1), tails_w(2)) );
                }
                //  add male logL
                if (gen_a(f, i) >= 2 && gender == 2) {
                  temp += Comp_logL_Dirichlet( nsamp_a(f, i), dirichlet_Parm, obs_a(f, i)(tails_w(3), tails_w(4)), exp_a(f, i)(tails_w(3), tails_w(4)) );
                }
                age_like(f, i) -= temp;
              }
            }
            else  //  MV_Tweedie
            {
            }
            if (header_a(f, i, 3) > 0)
              age_like_tot(f) += age_like(f, i);
          }
        }
      }
    if (do_once == 1)
      echoinput << "Finished agecomp obj_fun " << age_like_tot << endl;
  }

  //  SS_Label_Info_25.6 #Fit to mean size@age
  if (nobs_ms_tot > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      if ((Nobs_ms(f) > 0 && sizeage_lambda(f, k_phase) > 0.0) || save_for_report > 0)
      {
        for (j = 1; j <= N_suprper_ms(f); j++)
        {
          exp_a_temp.initialize();
          for (i = suprper_ms1(f, j); i <= suprper_ms2(f, j); i++)
          {
            exp_a_temp += exp_ms(f, i) * suprper_ms_sampwt(f, i);
          } // combine across range of observations
          for (i = suprper_ms1(f, j); i <= suprper_ms2(f, j); i++)
            exp_ms(f, i) = exp_a_temp; // assign back to each original obs
        }

        for (i = 1; i <= Nobs_ms(f); i++)
          if (header_ms(f, i, 3) > 0)
          {
            for (b = 1; b <= n_abins2; b++)
            {
              if (obs_ms_n(f, i, b) > 0 && obs_ms(f, i, b) > 0)
              {
                sizeage_like(f) += 0.5 * square((obs_ms(f, i, b) - exp_ms(f, i, b)) / (exp_ms_sq(f, i, b) / obs_ms_n(f, i, b))) + sd_offset * log(exp_ms_sq(f, i, b) / obs_ms_n(f, i, b));
                //  where:        obs_ms_n(f,i,b)=sqrt(var_adjust(6,f)*obs_ms_n(f,i,b));
              }
            }
          }
      }
    if (do_once == 1)
      echoinput << "Finished meanlength obj_fun " << sizeage_like << endl;
  }

  //  SS_Label_Info_25.7 #Fit to generalized Size composition
  dvariable temp_logL;
  if (SzFreq_Nmeth > 0) //  have some sizefreq data
  {
    // create super-period expected values
    for (j = 1; j <= N_suprper_SzFreq; j++)
    {
      a = suprper_SzFreq_start(j); // get observation index
      SzFreq_exp(a) *= suprper_SzFreq_sampwt(a); //  start creating weighted average
      for (iobs = a + 1; iobs <= suprper_SzFreq_end(j); iobs++)
      {
        SzFreq_exp(a) += SzFreq_exp(iobs) * suprper_SzFreq_sampwt(iobs);
      } //  combine into the first obs of this superperiod
      for (iobs = a + 1; iobs <= suprper_SzFreq_end(j); iobs++)
      {
        SzFreq_exp(iobs) = SzFreq_exp(a);
      } //  assign back to all obs
    }

    SzFreq_like = -offset_Sz_tot; // initializes for each Sz_Method
    for (iobs = 1; iobs <= SzFreq_totobs; iobs++)
    {
      if (SzFreq_obs_hdr(iobs, 3) > 0)
      {
        k = SzFreq_obs_hdr(iobs, 6);
        f = abs(SzFreq_obs_hdr(iobs, 3));
        z1 = SzFreq_obs_hdr(iobs, 7);
        z2 = SzFreq_obs_hdr(iobs, 8);
        int Sz_method = SzFreq_obs1(iobs, 1);  //  sizecomp method
        int logL_method = Comp_Err_Sz(Sz_method);
        temp_logL = 0.0;
        switch (logL_method)
        {
          case 0:  //  multinomial
          {
            temp_logL += Comp_logL_multinomial( SzFreq_sampleN(iobs), SzFreq_obs(iobs)(z1, z2), SzFreq_exp(iobs)(z1, z2));
            break;
          }
          case 1:  // dirichlet with theta*n
          {
             dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(Sz_method),1))) * SzFreq_sampleN(iobs);  //  theta * n
             temp_logL -= gammln(dirichlet_Parm) - gammln( SzFreq_sampleN(iobs) + dirichlet_Parm );
             temp_logL -= Comp_logL_Dirichlet( SzFreq_sampleN(iobs), dirichlet_Parm, SzFreq_obs(iobs)(z1, z2), SzFreq_exp(iobs)(z1, z2));
             break;
          }
          case 2:  // dirichlet with beta
          {
             dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(Sz_method),1)));  //  beta
             temp_logL -= gammln(dirichlet_Parm) - gammln( SzFreq_sampleN(iobs) + dirichlet_Parm );
             temp_logL -= Comp_logL_Dirichlet( SzFreq_sampleN(iobs), dirichlet_Parm, SzFreq_obs(iobs)(z1, z2), SzFreq_exp(iobs)(z1, z2));
             break;
          }
          case 3:  // MV  Tweedie
          {
            break;
          }
        }
        SzFreq_like(SzFreq_LikeComponent(f, k)) += temp_logL;
        SzFreq_eachlike(iobs) = value(temp_logL) - SzFreq_each_offset(iobs);
      }
    }

    if (do_once == 1)
      echoinput << " did sizefreq obj_fun: " << SzFreq_like << "  base: " << offset_Sz_tot << endl;
  }

  //  SS_Label_Info_25.8 #Fit to morph composition
  if (Do_Morphcomp > 0)
  {
    for (iobs = 1; iobs <= Morphcomp_nobs; iobs++)
    {
      k = 5 + Morphcomp_nmorph;
      if (Morphcomp_obs(iobs, 3) > 0.)
        Morphcomp_like -= Morphcomp_obs(iobs, 5) * Morphcomp_obs(iobs)(6, k) * log(elem_div(Morphcomp_exp(iobs)(6, k), Morphcomp_obs(iobs)(6, k)));
    }
    if (do_once == 1)
      echoinput << "Finished morphcomp obj_fun " << Morphcomp_like << endl;
  }

  //  SS_Label_Info_25.9 #Fit to tag-recapture
  if (Do_TG > 0)
  {
    k = 1 + 2 * N_TG;
    for (TG = 1; TG <= N_TG; TG++)
    {
      if (TG_use(TG) >= TG_min_recap)
      {
        j = TG + 2 * N_TG;
        if (TG_parm_PH(j) == -1000.)
        {
        } //  do nothing keep k at same value
        else
        {
          if (TG_parm_PH(j) > -1000.)
          {
            k = j;
          }
          else
          {
            k = -1000 - TG_parm_PH(j) + 2 * N_TG;
          }
        }
        overdisp = TG_parm(k);
        for (TG_t = TG_mixperiod; TG_t <= TG_endtime(TG); TG_t++)
        {
          TG_recap_exp(TG, TG_t)(1, Nfleet) += 1.0e-6; // add a tiny amount
          TG_recap_exp(TG, TG_t, 0) = sum(TG_recap_exp(TG, TG_t)(1, Nfleet));
          TG_recap_exp(TG, TG_t)(1, Nfleet) /= TG_recap_exp(TG, TG_t, 0);
          if (Nfleet > 1)
            TG_like1(TG) -= TG_recap_obs(TG, TG_t, 0) * (TG_recap_obs(TG, TG_t)(1, Nfleet) * log(TG_recap_exp(TG, TG_t)(1, Nfleet)));
          TG_like2(TG) -= log_negbinomial_density(TG_recap_obs(TG, TG_t, 0), TG_recap_exp(TG, TG_t, 0), overdisp);
        }
      }
    }
    if (do_once == 1)
      echoinput << "Finished tag obj_fun " << TG_like1 << endl
           << TG_like2 << endl;
  }

  /*
  //  SS_Label_Info_25.10 #Fit to initial equilibrium catch
  for (s = 1; s <= nseas; s++)
    for (f = 1; f <= Nfleet; f++)
    {
      if (fleet_type(f) == 1 && obs_equ_catch(s, f) > 0.0 && (init_equ_lambda(f, k_phase) > 0.0 || save_for_report > 0))
      {
        equ_catch_like(f) += 0.5 * square((log(1.1 * obs_equ_catch(s, f)) - log(est_equ_catch(s, f) * catch_mult(styr - 1, f) + 0.1 * obs_equ_catch(s, f))) / catch_se(styr - 1, f));
      }
    }
  if (do_once == 1)
    echoinput << " initequ_catch -log(L) " << equ_catch_like << endl;
  */

  //  SS_Label_Info_25.11 #Fit to catch by fleet/season
  if (F_Method > 1)  // so not doing Pope's
  {
    for (int ff = 1; ff <= N_catchfleets(0); ff++)
    {
      f = fish_fleet_area(0, ff);
      if (fleet_type(f) == 1)  //  fleet has retained catch, so bypassing bycatch and predator fleets
      {
        i = 3 * catchunits(f);  //  because catchunits is 1 for bio and 2 for numbers
        for (y = styr-1; y <= endyr; y++)
        for (s = 1; s <= nseas; s++)
        {
          t = styr + (y - styr) * nseas - 1 + s;
          if (catch_ret_obs(f, t) > 0.0)
          {
            //          catch_like(f) += 0.5*square( (log(catch_ret_obs(f,t)) -log(catch_fleet(t,f,i)+0.000001)) / catch_se(t,f));
            temp = 0.5 * square((log(1.1 * catch_ret_obs(f, t)) - log(catch_fleet(t, f, i) * catch_mult(y, f) + 0.1 * catch_ret_obs(f, t))) / catch_se(t, f));
            if (y == styr - 1)
            {equ_catch_like(f) += temp;}
            else
            {catch_like(f) += temp;}
//            echoinput<<f<<" y:"<<y<<" s:"<<s<<" c:"<<catch_ret_obs(f, t)<<" ec:"<<catch_fleet(t, f, i)<<" mul:"<<catch_mult(y, f)<<" temp:"<<temp<<" equL:"<<equ_catch_like(f)<<" catL:"<<catch_like(f)<<endl;
          }
        }
      }
    }
    if (do_once == 1)
    {
      echoinput << " initequ_catch -log(L) " << equ_catch_like << endl;
      echoinput << " catch -log(L) " << catch_like << endl;
    }
  }

  //  SS_Label_Info_25.12 #Likelihood for the recruitment deviations
  //The recruitment prior is assumed to be a lognormal pdf with expected
  // value equal to the deterministic stock-recruitment curve          // SS_Label_260
  //  R1 deviation is weighted by ave_age because R1 represents a time series of recruitments
  //  SRparm(N_SRparm+1) is sigmaR
  //  SRparm(N_SRparm+4) is rho, the autocorrelation coefficient
  //  POP code from Ianelli
  //  if (rho>0)
  //    for (i=styr_rec+1;i<=endyr;i++)
  //      rec_like(1) += square((chi(i)- rho*chi(i-1)) /(sqrt(1.-rho*rho))) / (2.*sigmaRsq) + log(sigr);
  //  else
  //    rec_like(1)    = (norm2( chi +  sigmaRsq/2. ) / (2*sigmaRsq)) / (2.*sigmaRsq) + size_count(chi)*log(sigr);

  if ((recrdev_lambda(k_phase) > 0.0 || save_for_report > 0) && (do_recdev > 0 || recdev_do_early > 0))
  {
    recr_like = sd_offset_rec * log(sigmaR);
    // where sd_offset_rec takes account for the number of recruitment years fully estimated
    // this is calculated as the sum of the biasadj vector
    if (do_recdev < 3)
    {
      if (SR_autocorr == 0)
      {
        recr_like += norm2(recdev(recdev_first, recdev_end)) / two_sigmaRsq;
      }
      else
      {
        rho = SRparm(N_SRparm2);
        recr_like += square(recdev(recdev_first)) / two_sigmaRsq;
        for (y = recdev_first + 1; y <= recdev_end; y++)
        {
          recr_like += square(recdev(y) - rho * recdev(y - 1)) / ((1.0 - rho * rho) * two_sigmaRsq);
        }
      }
      sum_recdev = sum(recdev);
    }
    else
    {
      rho = SRparm(N_SRparm2);
      dvariable dev;
      dvariable dev_last;
      if (recdev_first >= styr)
      {
        dev_last = log(exp_rec(recdev_first, 4) / exp_rec(recdev_first, 3));
      }
      else
      {
        dev_last = recdev(recdev_first); // so use devs for initial agecomp directly
      }
      recr_like += square(dev_last) / two_sigmaRsq;
      sum_recdev = dev_last;
      for (y = recdev_first + 1; y <= recdev_end; y++)
      {
        if (y >= styr)
        {
          dev = log(exp_rec(y, 4) / exp_rec(y, 3));
        }
        else
        {
          dev = recdev(y); // so use devs for initial agecomp directly
        }
        recr_like += square(dev - rho * dev_last) / ((1.0 - rho * rho) * two_sigmaRsq);
        dev_last = dev;
        sum_recdev += dev; //  get sum of devs
      }
    }
    noBias_recr_like = recr_like - sd_offset_rec * log(sigmaR) + (recdev_end - recdev_first + 1.) * log(sigmaR);
    regime_like = 0.5 * square(log(R1 / R1_exp) / (sigmaR / ave_age));
    if (do_recdev == 4)
      regime_like += square(sum_recdev);
    if (do_once == 1)
      echoinput << "Finished recruitdev obj_fun " << recr_like << " " << sd_offset_rec << " " << two_sigmaRsq << endl;
  }
  if (Do_Forecast > 0 && do_recdev > 0)
  {
    if (recdev_end < endyr)
    {
      Fcast_recr_like = Fcast_recr_lambda * (norm2(Fcast_recruitments(recdev_end + 1, endyr))) / two_sigmaRsq;
      //        Fcast_recr_like += sd_offset_fore*log(sigmaR);  this is now part of the recr_liker logL calculated above
    }
    if (SR_autocorr == 0)
    {
      Fcast_recr_like += (norm2(Fcast_recruitments(endyr + 1, YrMax))) / two_sigmaRsq;
    }
    else
    {
      Fcast_recr_like += square(Fcast_recruitments(recdev_end + 1) - rho * recdev(recdev_end)) / ((1.0 - rho * rho) * two_sigmaRsq); //  for the transition year
      for (y = recdev_end + 2; y <= YrMax; y++)
      {
        Fcast_recr_like += square(Fcast_recruitments(y) - rho * Fcast_recruitments(y - 1)) / ((1.0 - rho * rho) * two_sigmaRsq);
      }
    }
  }
  if (Do_Impl_Error > 0)
    Fcast_recr_like += (norm2(Fcast_impl_error(endyr + 1, YrMax))) / (2.0 * Impl_Error_Std * Impl_Error_Std); // implementation error

  //  SS_Label_Info_25.13 #Penalty for the parameter priors
  dvariable mu;
  dvariable tau;
  dvariable Aprior;
  dvariable Bprior;
  dvariable Pconst;
  Pconst = 0.0001;

  if (parm_prior_lambda(k_phase) > 0.0 || Do_all_priors > 0 || save_for_report > 0)
  {
    for (i = 1; i <= N_MGparm2; i++)
      if (MGparm_PRtype(i) > 0 && (active(MGparm(i)) || Do_all_priors > 0))
      {
        MGparm_Like(i) = Get_Prior(MGparm_PRtype(i), MGparm_LO(i), MGparm_HI(i), MGparm_PR(i), MGparm_CV(i), MGparm(i));
        parm_like += MGparm_Like(i);
      }
    for (i = 1; i <= N_init_F; i++)
      if (init_F_PRtype(i) > 0 && (active(init_F(i)) || Do_all_priors > 0))
      {
  init_F_Like(i) = Get_Prior(init_F_PRtype(i), init_F_LO(i), init_F_HI(i), init_F_PR(i), init_F_CV(i), init_F(i));
        parm_like += init_F_Like(i);
      }

    for (i = 1; i <= Q_Npar2; i++)
      if (Q_parm_PRtype(i) > 0 && (active(Q_parm(i)) || Do_all_priors > 0))
      {
        Q_parm_Like(i) = Get_Prior(Q_parm_PRtype(i), Q_parm_LO(i), Q_parm_HI(i), Q_parm_PR(i), Q_parm_CV(i), Q_parm(i));
        parm_like += Q_parm_Like(i);
      }

    for (i = 1; i <= N_selparm2; i++)
      if (selparm_PRtype(i) > 0 && (active(selparm(i)) || Do_all_priors > 0))
      {
        selparm_Like(i) = Get_Prior(selparm_PRtype(i), selparm_LO(i), selparm_HI(i), selparm_PR(i), selparm_CV(i), selparm(i));
        parm_like += selparm_Like(i);
      }
    if (Do_TG > 0)
    {
      k = 3 * N_TG + 2 * Nfleet1;
      for (i = 1; i <= k; i++)
        if (TG_parm2(i, 5) > 0 && (active(TG_parm(i)) || Do_all_priors > 0))
        {
          TG_parm_Like(i) = Get_Prior(TG_parm2(i, 6), TG_parm_LO(i), TG_parm_HI(i), TG_parm2(i, 4), TG_parm2(i, 5), TG_parm(i));
          parm_like += TG_parm_Like(i);
        }
    }

    for (i = 1; i <= N_SRparm3; i++)
      if (SRparm_PRtype(i) > 0 && (active(SRparm(i)) || Do_all_priors > 0))
      {
        SRparm_Like(i) = Get_Prior(SRparm_PRtype(i), SRparm_LO(i), SRparm_HI(i), SRparm_PR(i), SRparm_CV(i), SRparm(i));
        parm_like += SRparm_Like(i);
      }
    //  SS_Label_Info_25.14 #logL for recdev_cycle
    if (recdev_cycle > 0)
    {
      temp = 0.0;
      temp1 = 0.0;
      for (i = 1; i <= recdev_cycle; i++)
      {
        if (recdev_cycle_parm_RD(i, 5) > 0 && (active(recdev_cycle_parm(i)) || Do_all_priors > 0))
        {
          recdev_cycle_Like(i) = Get_Prior(recdev_cycle_parm_RD(i, 6), recdev_cycle_parm_RD(i, 1), recdev_cycle_parm_RD(i, 2), recdev_cycle_parm_RD(i, 4), recdev_cycle_parm_RD(i, 5), recdev_cycle_parm(i));
          parm_like += recdev_cycle_Like(i);
          temp += mfexp(recdev_cycle_parm(i)); //  accumulate values that should each be near 1.0 if there is no cycle effect
          temp1 += 1.0; //  accumulate N
        }
      }
      temp -= temp1; //  should be near zero
      parm_like += 10000. * temp * temp; //  similar to ADMB's approach to getting zero-centered dev_vectors
    }
  }
  //  SS_Label_Info_25.15 #logL for parameter process errors (devs)
  {
    for (i = 1; i <= N_parm_dev; i++)
    {
      if (parm_dev_lambda(k_phase) > 0.0 || save_for_report > 0)
      {
        if (parm_dev_type(i) == 1) //  in timevary the adjusted parm is: p'=p+dev*se;  so assumes that the devs are distributed as unit normal
        {
          dvariable temp;
          if (parm_dev_use_rho(i) == 0) //  no rho
          {
            temp = 0.5; // temp=1.00 / (2.000*square(1.0));
            parm_dev_like(i, 1) = square(parm_dev(i, parm_dev_minyr(i))); //  first year
            for (j = parm_dev_minyr(i) + 1; j <= parm_dev_maxyr(i); j++)
            {
              parm_dev_like(i, 1) += square(parm_dev(i, j));
            }
          }
          else
          {
            temp = 0.5 / ((1.0 - parm_dev_rho(i) * parm_dev_rho(i))); // temp=1.00 / (2.000*(1.0-parm_dev_rho(i)*parm_dev_rho(i))*square(1.0));
            parm_dev_like(i, 1) += square(parm_dev(i, parm_dev_minyr(i))); //  first year
            for (j = parm_dev_minyr(i) + 1; j <= parm_dev_maxyr(i); j++)
            {
              parm_dev_like(i, 1) += square(parm_dev(i, j) - parm_dev_rho(i) * (parm_dev(i, j - 1)));
            }
          }
          parm_dev_like(i, 1) *= temp;
          parm_dev_like(i, 2) = 0.0; //  += float(parm_dev_maxyr(i)-parm_dev_minyr(i)+1.)*log(1.0);
          //          parm_dev_like(i,2), is included in the total parm_dev_like by user setting: sd_offset=1.0
        }
        else if (parm_dev_type(i) == 3) //  for testing only and compatibility with 3.30.12 and earlier 3.30
        {
          dvariable temp;
          temp = 1.00 / (2.000 * (1.0 - parm_dev_rho(i) * parm_dev_rho(i)) * square(1.00));
          parm_dev_like(i, 1) += square(parm_dev(i, parm_dev_minyr(i))); //  first year
          for (j = parm_dev_minyr(i) + 1; j <= parm_dev_maxyr(i); j++)
          {
            parm_dev_like(i, 1) += square(parm_dev(i, j) - parm_dev_rho(i) * parm_dev(i, j - 1));
          }
          parm_dev_like(i, 1) *= temp;
          parm_dev_like(i, 2) += float(parm_dev_maxyr(i) - parm_dev_minyr(i) + 1.) * log(parm_dev_stddev(i));
          //  include parm_dev_like(i,2) in the total, or not, using sd_offset
        }
        else if (parm_dev_type(i) == 4) //  for testing only
        {
          dvariable temp;
          temp = 0.5 / ((1.0 - parm_dev_rho(i) * parm_dev_rho(i))); // temp=1.00 / (2.000*(1.0-parm_dev_rho(i)*parm_dev_rho(i))*square(1.0));
          parm_dev_like(i, 1) += square(parm_dev(i, parm_dev_minyr(i))); //  first year
          for (j = parm_dev_minyr(i) + 1; j <= parm_dev_maxyr(i); j++)
          {
            parm_dev_like(i, 1) += square(parm_dev(i, j) - parm_dev_rho(i) * (parm_dev(i, j - 1)));
          }
          parm_dev_like(i, 1) *= temp;
          parm_dev_like(i, 2) = square(10. * (1.0 - (sumsq(parm_dev(i) + 1.0e-9) / float(parm_dev_maxyr(i) - parm_dev_minyr(i) + 1.))));
        }
        else //  2D_AR devs
        {
//  TwoD_AR_def:  1-fleet, 2-ymin, 3-ymax, 4-amin, 5-amax, 6-sigma_amax, 7-use_rho, 8-age/len, 9-dev_phase
//  10-mindimension, 11=maxdim, 12-N_parm_dev, 13-selparm_location
          
          f = parm_dev_info(i); //  pointer from list of devvectors to 2DAR list
          dvariable sigmasel = selparm(TwoD_AR_def[f](13));
          parm_dev_stddev(i) = sigmasel;
          parm_dev_rho(i) = 0.0;
          parm_dev_like(i, 1) -= -0.5 * log(det_cor(f));
          if (TwoD_AR_def[f](6) <= TwoD_AR_def[f](4)) //  only one sigmasel by age
          {
            //  nll -= - 0.5*log(det(cor)) - 0.5*nages*nyears*log(2.0*PI ) - 0.5*S_hat_vec*inv(cor)*S_hat_vec/pow(sigmaS,2) - 0.5*2*nages*nyears*log(sigmaS);
            if (TwoD_AR_def[f](7) == 0) // do not use rho
            {
              parm_dev_like(i, 1) -= -0.5 * TwoD_AR_degfree(f) * log(2.0 * PI) - 0.5 * sumsq(parm_dev(i)) / pow(sigmasel, 2);
              parm_dev_like(i, 2) -= -TwoD_AR_degfree(f) * log(sigmasel);
            }
            else
            {
              parm_dev_like(i, 1) -= -0.5 * TwoD_AR_degfree(f) * log(2.0 * PI) - 0.5 * parm_dev(i) * inv_cor(f) * parm_dev(i) / pow(sigmasel, 2);
              parm_dev_like(i, 2) -= -TwoD_AR_degfree(f) * log(sigmasel);
            }
          }
          else //  some age-specific sigmasel
          //  note that devs are organized as list with age nested within year
          {
            int devcnt;
            for (a = TwoD_AR_def[f](4); a <= TwoD_AR_def[f](5); a++)
            {
              dvariable sigmasel = selparm(TwoD_AR_def[f](13) + min(a, TwoD_AR_def[f](6)) - TwoD_AR_def[f](4));
              dvariable degfree = TwoD_AR_degfree(f) / (TwoD_AR_def[f](5) - TwoD_AR_def[f](4) + 1.0); //  df per age
              //                if(TwoD_AR_def[f](7)==0)  // do not use rho
              {
                parm_dev_like(i, 1) -= -0.5 * degfree * log(2.0 * PI);
                parm_dev_like(i, 2) -= -degfree * log(sigmasel);
                temp = 0.0;
                devcnt = a - TwoD_AR_def[f](4) + 1.0; //  dev counter in first year
                j = TwoD_AR_def[f](5) - TwoD_AR_def[f](4) + 1; //  n ages
                for (int y = TwoD_AR_def[f](2); y <= TwoD_AR_def[f](3); y++)
                {
                  temp += square(parm_dev(i, devcnt)); //  ignore rho for now; need indexing for inv_cor()
                  devcnt += j;
                }
                parm_dev_like(i, 1) -= -0.5 * temp / (sigmasel * sigmasel);
              }
            }
            //  nll -= - 0.5*log(det(cor)) - 0.5*nages*nyears*log(2.0*PI ) - 0.5*S_hat_vec*inv(cor)*S_hat_vec/pow(sigmaS,2) - 0.5*2*nages*nyears*log(sigmaS);
          }
        }
      }
    }
  }

  for (f = 1; f <= Nfleet; f++)
    if (Q_setup(f, 4) == 3)
    {
      //      parm_dev_like += Q_dev_like(f,1); // mean component for dev approach (var component is already in the parm priors)
      //  do not include for randwalk (Qsetup==4)
    }

  //  SS_Label_Info_25.16 #Penalty for F_ballpark
  if (F_ballpark_yr >= styr)
  {
    if (F_Method == 1)
    {
      temp = annual_F(F_ballpark_yr, 1);
    }
    else
    {
      temp = annual_F(F_ballpark_yr, 2);
    }
    //  in future, could allow specification of a range of years for averaging the F statistic
    F_ballpark_like = 0.5 * square(log((F_ballpark + 1.0e-6) / (temp + 1.0e-6)) / 1.0) + sd_offset * log(1.0);
  }
  else
  {
    F_ballpark_like = 0.0;
  }

  //  SS_Label_Info_25.17 #Penalty for soft boundaries, uses the symmetric beta prior code
  if (SoftBound > 0)
  {
    for (i = 1; i <= N_selparm2; i++)
    {
      if (selparm_PH_soft(i) > 0)
      {
        SoftBoundPen += Get_Prior(1, selparm_LO(i), selparm_HI(i), 1., 0.001, selparm(i));
      }
    }
  }

  //  SS_Label_Info_25.18 #Crash penalty
  //   CrashPen = square(1.0+CrashPen)-1.0;   this was used until V3.00L  7/10/2008
  CrashPen = square(1.0 + (1000. * CrashPen / (1000. + CrashPen))) - 1.0;
  //  SS_Label_Info_25.19 #Sum the likelihood components weighted by lambda factors
  //   cout<<" obj_fun start "<<obj_fun<<endl;
  obj_fun = column(surv_lambda, k_phase) * surv_like;
  //   cout<<" obj_fun surv "<<obj_fun<<surv_like<<endl;
  obj_fun += column(disc_lambda, k_phase) * disc_like;
  //   cout<<" obj_fun disc "<<obj_fun<<endl;
  obj_fun += column(mnwt_lambda, k_phase) * mnwt_like;
  //   cout<<" obj_fun mnwt "<<obj_fun<<endl;
  obj_fun += column(length_lambda, k_phase) * length_like_tot;
  //   cout<<" obj_fun len "<<obj_fun<<endl;
  obj_fun += column(age_lambda, k_phase) * age_like_tot;
  //   cout<<" obj_fun age "<<obj_fun<<endl;
  obj_fun += column(sizeage_lambda, k_phase) * sizeage_like;
  //   cout<<" obj_fun ms "<<obj_fun<<endl;

  obj_fun += equ_catch_like * column(init_equ_lambda, k_phase);
  //   cout<<" obj_fun equ_cat "<<obj_fun<<endl;
  obj_fun += column(catch_lambda, k_phase) * catch_like;
  //            catch_like(f) += 0.5*square( (log(1.1*catch_ret_obs(f,t)) -log(catch_fleet(t,f,i)*catch_mult(y,f)+0.1*catch_ret_obs(f,t))) / catch_se(t,f));
  //   cout<<" obj_fun catch "<<obj_fun<<catch_like<<endl;
  obj_fun += recr_like * recrdev_lambda(k_phase);
  obj_fun += regime_like * regime_lambda(k_phase);

  //   cout<<" obj_fun recr "<<obj_fun<<endl;
  obj_fun += parm_like * parm_prior_lambda(k_phase);
  //   cout<<" obj_fun parm "<<obj_fun<<endl;
  obj_fun += (sum(parm_dev_like)) * parm_dev_lambda(k_phase);
  //   cout<<" obj_fun parmdev "<<obj_fun<<endl;
  obj_fun += F_ballpark_like * F_ballpark_lambda(k_phase);
  //   cout<<" obj_fun Fballpark "<<obj_fun<<endl;
  obj_fun += CrashPen_lambda(k_phase) * CrashPen;
  //   cout<<" obj_fun crash "<<obj_fun<<endl;
  obj_fun += square(dummy_datum - dummy_parm);
  //   cout<<" obj_fun dummy "<<obj_fun<<endl;
  obj_fun += Fcast_recr_like; //  lambda already factored in
  //   cout<<" obj_fun forerecr "<<obj_fun<<endl;
  obj_fun += SoftBoundPen;
  //   cout<<" obj_fun soft "<<obj_fun<<endl;
  if (SzFreq_Nmeth > 0)
    obj_fun += SzFreq_like * column(SzFreq_lambda, k_phase);
  //   cout<<" obj_fun sizefreq "<<obj_fun<<endl;
  if (Do_Morphcomp > 0)
    obj_fun += Morphcomp_lambda(k_phase) * Morphcomp_like;
  if (Do_TG > 0 && Nfleet > 1)
    obj_fun += TG_like1 * column(TG_lambda1, k_phase);
  if (Do_TG > 0)
    obj_fun += TG_like2 * column(TG_lambda2, k_phase);
  //   cout<<" obj_fun final "<<obj_fun<<endl;
  JT_obj_fun = obj_fun - recr_like * recrdev_lambda(k_phase) + noBias_recr_like * recrdev_lambda(k_phase);

  if (do_once == 1)
  {
    echoinput << " OK with obj_func " << obj_fun << endl;
    if (SSB_yr(endyr) < 0.01 * SSB_yr(styr))
    {
      warnstream << "1st iteration warning: ssb(endyr)/ssb(styr)= " << SSB_yr(endyr) / SSB_yr(styr) << "; suggest start with larger R0 to get near 0.4; or use depletion fleet option";
      write_message (WARN, 0);
    }
    if (annual_F(endyr, 3) > 2.0)
    {
      warnstream << "1st iteration warning: annual F in endyr > 2.0; check configuration; suggest start with larger R0";
      write_message (WARN, 0);
    }
    if (sum(catch_like) > 0.5 * obj_fun && F_Method != 2)
    {
      warnstream << "1st iteration warning: catch logL > 50% total logL; check configuration; suggest start with larger R0";
      write_message (WARN, 0);
    }
    do_once = 0;
  }
  } //  end objective_function

//********************************************************************
 /*  SS_Label_FUNCTION 26 Process_STDquant */
FUNCTION void Process_STDquant()
  {
  for (y = styr - 2; y <= YrMax; y++)
  {
    if (STD_Yr_Reverse(y) > 0)
    {
      SSB_std(STD_Yr_Reverse(y)) = SSB_yr(y);
      recr_std(STD_Yr_Reverse(y)) = exp_rec(y, 4);
    }
    if (STD_Yr_Reverse_Dep(y) > 0)
    {
      depletion(STD_Yr_Reverse_Dep(y)) = SSB_yr(y);
    }
  }

  switch (SPR_reporting)
  {
    case 0: // no scaling.  this option skips SPR_reporting
    {
      break;
    }
    case 1: // compare to SPR
    {
      //          SPR_std = (1.-SPR_std)/(1.-SPR_actual);
      SPR_std = (1. - SPR_std) / (1. - SPR_target);
      break;
    }
    case 2: // compare to SPR_MSY
    {
      SPR_std = (1. - SPR_std) / (1. - MSY_SPR);
      break;
    }
    case 3: // compare to SPR_Btarget
    {
      SPR_std = (1. - SPR_std) / (1. - SPR_Btgt);
      break;
    }
    case 4:  //  1-%SPR
    {
      SPR_std = 1. - SPR_std;
      break;
    }
    case 5:  //  raw %SPR
    {
      break;
    }
  }

  switch (depletion_basis)
  {
    case 0:
    {
      depletion /= SSB_virgin;
      break;
    }
    case 1:
    {
      depletion /= (depletion_level * SSB_virgin);
      Mgmt_quant(19) = SSB_virgin;
      break;
    }
    case 2:
    {
      depletion /= (depletion_level * Bmsy);
      Mgmt_quant(19) = Bmsy;
      break;
    }
    case 3:
    {
      depletion /= (depletion_level * SSB_yr(styr));
      Mgmt_quant(19) = SSB_yr(styr);
      break;
    }
    case 4:
    {
      depletion /= (depletion_level * SSB_yr(endyr));
      Mgmt_quant(19) = SSB_yr(endyr);
      break;
    }
    case 5:  //  dynamic Bzero
    {
      for (y = first_catch_yr; y <= YrMax; y++)
      if (STD_Yr_Reverse_Dep(y) > 0)
      {
//        warning<<y<<" "<<STD_Yr_Reverse_Dep(y) <<" Ind "<<Do_Dyn_Bzero<<" "<< Do_Dyn_Bzero+ y - (styr - 2)<<" num: "<<depletion(STD_Yr_Reverse_Dep(y))<<" denom: "<<Extra_Std(Do_Dyn_Bzero + y - (styr -2))<<" depl ";
        depletion(STD_Yr_Reverse_Dep(y)) /= ( depletion_level * Extra_Std(Do_Dyn_Bzero + y - (styr - 2)));
//        warning<<depletion(STD_Yr_Reverse_Dep(y))<<endl;
      }
      Mgmt_quant(19) = 1.;
      break;
    }
    case 6:  // depletion based on benchmark unfished SSB
    {
      depletion /= (depletion_level * SSB0_4_SRR);
      Mgmt_quant(19) = SSB0_4_SRR;
      break;
    }
  }
  if (depletion_log == 1)
    depletion = log(depletion);

  //  Do multi-year average of depletion_std if requested;  assumes that depletion_std is NOT custom, so exists for all years
  //  otherwise, would need to check for positive value for STD_Yr_Reverse_F(y) and need to deal with averaging across not-reporting years = MESSY
  //  note that averaging starts in endyr, not endyr+N_forecast;  otherwise the averaging could span endyr.

  if (depletion_multi > 1)
  {
    for (y = endyr; y >= first_catch_yr + 1; y--)
    {
      temp = depletion(STD_Yr_Reverse_Dep(y)); //  initialize
      for (y1 = y - 1; y1 > max(first_catch_yr, y - depletion_multi); y1--)
      {
        temp += depletion(STD_Yr_Reverse_Dep(y1));
      }
      depletion(STD_Yr_Reverse_Dep(y)) = temp / (y - y1);
    }
  }

  //  Use the selected F method for the forecast as the denominator for the F_std ratio
  switch (F_std_basis)
  {
    case 0: // keep as raw value
    {
      break;
    }
    case 1: // compare to SPR
    {
      F_std /= Mgmt_quant(10);
      break;
    }
    case 2: // compare to SPR_MSY
    {
      F_std /= Mgmt_quant(14);
      break;
    }
    case 3: // compare to SPR_Btarget
    {
      F_std /= Mgmt_quant(7);
      break;
    }
  }
  if (F_std_log == 1)
    F_std = log(F_std);

  //  Do multi-year average of F_std if requested;  assumes that F_std is NOT custom, so exists for all years
  //  otherwise, would need to check for positive value for STD_Yr_Reverse_F(y) and need to deal with averaging across not-reporting years = MESSY
  //  note that averaging starts in endyr, not endyr+N_forecast;  otherwise the averaging could span endyr.
  if (F_std_multi > 1)
  {
    for (y = endyr; y >= styr + 1; y--)
    {
      temp = F_std(STD_Yr_Reverse_F(y)); //  initialize
      for (y1 = y - 1; y1 > max(styr, y - F_std_multi); y1--)
      {
        temp += F_std(STD_Yr_Reverse_F(y1));
      }
      F_std(STD_Yr_Reverse_F(y)) = temp / (y - y1);
    }
  }

  //  SS_Label_7.8  get extra std quantities
  // selectivity
  //  f = Do_Selex_Std
  if (Selex_Std_Cnt > 0)
  {
    for (i = 1; i <= Selex_Std_Cnt; i++)
    {
      j = Selex_Std_Pick(i);
      if (Selex_Std_AL == 1)
      {
        Extra_Std(i) = sel_l(Selex_Std_Year, Do_Selex_Std, 1, j);
        if (gender == 2)
          Extra_Std(i + Selex_Std_Cnt) = sel_l(Selex_Std_Year, Do_Selex_Std, 2, j);
      }
      else if (Selex_Std_AL == 2)
      {
        Extra_Std(i) = sel_a(Selex_Std_Year, Do_Selex_Std, 1, j);
        if (gender == 2)
          Extra_Std(i + Selex_Std_Cnt) = sel_a(Selex_Std_Year, Do_Selex_Std, 2, j);
      }
      else if (Selex_Std_AL == 3)
      {
        //  4darray sel_num(1,nseas,1,gmorph,1,Nfleet,0,nages);  // selected numbers
        //  4darray save_sel_num(styr-3*nseas,TimeMax_Fcast_std+nseas,0,Nfleet,1,gmorph,0,nages)  //  save sel_num (Asel_2) and save fecundity for output;  +nseas covers no forecast setups

        int t_write = styr + (Selex_Std_Year - styr) * nseas; //  season 1 of selected year
        g = g_Start(1) + N_platoon; //  mid morph for first GP for females
        Extra_Std(i) = save_sel_num(t_write, Do_Selex_Std, g, j);
        if (gender == 2)
        {
          g = g_Start(1 + N_GP) + N_platoon; //  mid morph for first GP for males
          Extra_Std(i + Selex_Std_Cnt) = save_sel_num(t_write, Do_Selex_Std, g, j);
        }
      }
    }
  }

  // growth
  if (Growth_Std_Cnt > 0)
  {
    int t_write = styr + (endyr - styr) * nseas; //  season 1 of endyr
    for (i = 1; i <= Growth_Std_Cnt; i++)
    {
      j = Growth_Std_Pick(i); // selected age
      k = g_finder(Do_Growth_Std, 1); // selected GP and gender  gp3
      Extra_Std(gender * Selex_Std_Cnt + i) = Ave_Size(t_write, mid_subseas, k, j);
      if (gender == 2)
      {
        k = g_finder(Do_Growth_Std, 2); // selected GP and gender  gp3
        Extra_Std(gender * Selex_Std_Cnt + Growth_Std_Cnt + i) = Ave_Size(t_write, mid_subseas, k, j);
      }
    }
  }

  // numbers at age
  if (NatAge_Std_Cnt > 0)
  {
    if (Do_NatAge_Std < 0) // sum all areas
    {
      p1 = 1;
      p2 = pop;
    }
    else // selected area
    {
      p1 = Do_NatAge_Std;
      p2 = Do_NatAge_Std;
    }
    y = NatAge_Std_Year;
    t = styr + (y - styr) * nseas; // first season of selected year
    for (i = 1; i <= NatAge_Std_Cnt; i++)
    {
      a = NatAge_Std_Pick(i); // selected age
      temp = 0.;
      for (p = p1; p <= p2; p++)
      {
        for (g = 1; g <= gmorph; g++)
          if (sx(g) == 1 && use_morph(g) > 0)
          {
            temp += natage(t, p, g, a); //  note, uses season 1 only
          }
      }
      Extra_Std(gender * (Selex_Std_Cnt + Growth_Std_Cnt) + i) = temp;
      if (gender == 2)
      {
        temp = 0.;
        for (p = p1; p <= p2; p++)
        {
          for (g = 1; g <= gmorph; g++)
            if (sx(g) == 2 && use_morph(g) > 0)
            {
              temp += natage(t, p, g, a); //  note, uses season 1 only
            }
        }
        Extra_Std(gender * (Selex_Std_Cnt + Growth_Std_Cnt) + NatAge_Std_Cnt + i) = temp;
      }
    }
  }

  // NatM
  //  shortcut  natM( doing area 1 only
  if (NatM_Std_Cnt > 0)
  {
    t = styr + (endyr - styr) * nseas; // first season of selected year
    for (i = 1; i <= NatM_Std_Cnt; i++)
    {
      j = NatM_Std_Pick(i); // selected age
      k = g_finder(Do_NatM_Std, 1); // selected GP and gender  gp3
      Extra_Std(gender * (Selex_Std_Cnt + Growth_Std_Cnt + NatAge_Std_Cnt) + i) = natM(t, 1, k, j);
      if (gender == 2)
      {
        k = g_finder(Do_NatM_Std, 2); // selected GP and gender  gp3
        Extra_Std(gender * (Selex_Std_Cnt + Growth_Std_Cnt + NatAge_Std_Cnt) + NatM_Std_Cnt + i) = natM(t, 1, k, j);
      }
    }
  }

  // ln(SSB)
  Extra_Std(Do_se_LnSSB) = log(SSB_yr(styr));
  Extra_Std(Do_se_LnSSB + 1) = log(SSB_yr(int((styr + endyr) / 2)));
  Extra_Std(Do_se_LnSSB + 2) = log(SSB_yr(endyr));

  if (Do_se_smrybio > 0) //  do stderr of SmryBio
  {
    k = Do_se_smrybio;
    for (j = styr - 2; j <= YrMax; j++)
    {
      Extra_Std(k) = Smry_Table(j, 2);
      k++;
    }
  }

  if (Svy_N > 0)
  {
    int Svy_sdreport_counter = 1;
    for (f = 1; f <= Nfleet; f++)
    {
      if (Svy_sdreport(f) > 0)
      {
        for (i = 1; i <= Svy_N_fleet(f); i++)
        {
          Svy_sdreport_est(Svy_sdreport_counter) = Svy_est(f, i);
          ++Svy_sdreport_counter;
        }
      }
    }
  }
  }

//********************************************************************
 /*  SS_Label_FUNCTION 27 Check_Parm */
FUNCTION dvariable Check_Parm(const int iparm, const int& PrPH, const double& Pmin, const double& Pmax, const int& Prtype, const double& Pr, const double& Psd, const double& jitter, const prevariable& Pval)
  {
  RETURN_ARRAYS_INCREMENT();
  const double bound = 0.001;
  const dvariable zmin = inv_cumd_norm(bound); // z value for Pmin
  const dvariable zmax = inv_cumd_norm((1.0 - bound)); // z value for Pmax
  const dvariable Pmean = (Pmin + Pmax) / 2.0;
  dvariable NewVal;
  // dvariable temp;
  dvariable Psigma, zval, kval, kjitter, zjitter, temp;

  NewVal = Pval;
  if (Pval > -900)
  {
    if (Pmin > Pmax)
    {
      warnstream << "parameter min > parameter max " << Pmin << " > " << Pmax << " for parm: " << iparm;
      write_message(FATAL, 1); // EXIT!
    }
    else if (Pmin == Pmax && PrPH >= 0)
    {
      warnstream << "parameter min is same as parameter max: " << Pmin << " = " << Pmax << " for parm: " << iparm ;
      write_message (WARN, 1);
    }
    else if (Pval < Pmin)
    {
      warnstream << "parameter init value is less than parameter min " << Pval << " < " << Pmin << " for parm: " << iparm;
      write_message (WARN, 1);
      if (Prtype > 0)
        exit(1);
    }
    else if (Pval > Pmax)
    {
      warnstream << "parameter init value is greater than parameter max " << Pval << " > " << Pmax << " for parm: " << iparm;
      write_message (WARN, 1);
      if (Prtype > 0)
        exit(1);
    }

    if (jitter > 0.0 && PrPH >= 0)
    {
      if ((Pmin <= -99 || Pmax >= 999))
      {
        warnstream << "jitter not done unless parameter min & max are in reasonable parameter range " << Pmin << " " << Pmax;
        write_message (WARN, 0);
      }
      else
      {
        // generate jitter value from cumulative normal given Pmin and Pmax
        Psigma = (Pmax - Pmean) / zmax; // Psigma should also be equal to (Pmin - Pmean) / zmin;
        if (Psigma < 0.00001) // how small a sigma is too small?
        {
          warnstream << "in Check_Parm jitter:  Psigma < 0.00001 " << Psigma;
          write_message (FATAL, 0); // EXIT!
        }
        zval = (Pval - Pmean) / Psigma; //  current parm value converted to zscore
        kval = cumd_norm(zval);
        temp = randu(radm);
        kjitter = kval + (jitter * ((2.00 * temp) - 1.)); // kjitter is between kval - jitter and kval + jitter
        if (kjitter < bound)
        {
          NewVal = Pmin + 0.1 * (Pval - Pmin);
        }
        else if (kjitter > (1.0 - bound))
        {
          NewVal = Pmax - 0.1 * (Pmax - Pval);
        }
        else
        {
          zjitter = inv_cumd_norm(kjitter);
          NewVal = (Psigma * zjitter) + Pmean;
        }
        echoinput << "jitter (min, max, old, new):  " << Pmin << " " << Pmax << " " << Pval << " " << NewVal << endl;
      }
    }
    //  now check prior
    if (Prtype > 0)
    {
      if (Psd <= 0.0)
      {
        warnstream << "A prior is selected but prior sd is zero. Prtype: " << Prtype << " Prior: " << Pr << " Pr_sd: " << Psd << " for parm: " << iparm << " ; see echoinput for parm_type";
        write_message (FATAL, 0); // EXIT!
      }
      if (PrPH < 0)
      {
        prior_ignore_warning++;
      }
    }
  }
  else
  {
    //  checking ignored for inputs that are special codes
  }

  RETURN_ARRAYS_DECREMENT();
  return NewVal;
  }

//********************************************************************
 /*  SS_Label_FUNCTION 29 Get_Prior */
FUNCTION dvariable Get_Prior(const int T, const double& Pmin, const double& Pmax, const double& Pr, const double& Psd, const prevariable& Pval)
  {
  RETURN_ARRAYS_INCREMENT();
  dvariable Prior_Like = 0.;
  dvariable mu;
  dvariable tau;
  dvariable Pconst = 0.0001;
  dvariable Bprior;
  dvariable Aprior;
  switch (T)
  {
    case 0: // none
    {
      Prior_Like = 0.;
      break;
    }
    case 6: // normal
    {
      Prior_Like = 0.5 * square((Pval - Pr) / Psd);
      break;
    }
    case 1: // symmetric beta    value of Psd must be >0.0
    {
      mu = -(Psd * (log((Pmax + Pmin) * 0.5 - Pmin))) - (Psd * (log(0.5)));
      Prior_Like = -(mu + (Psd * (log(Pval - Pmin + Pconst))) + (Psd * (log(1. - ((Pval - Pmin - Pconst) / (Pmax - Pmin))))));
      break;
    }
    case 2: // CASAL's Beta;  check to be sure that Aprior and Bprior are OK before running SS2!
    {
      mu = (Pr - Pmin) / (Pmax - Pmin); // CASAL's v
      tau = (Pr - Pmin) * (Pmax - Pr) / square(Psd) - 1.0;
      Bprior = tau * mu;
      Aprior = tau * (1.0 - mu); // CASAL's m and n
      if (Bprior <= 1.0 || Aprior <= 1.0)
      {
        warnstream << "Bad Beta prior " << Pval << " " << Pr;
        write_message (WARN, 0);
      }
      Prior_Like = (1.0 - Bprior) * log(Pconst + Pval - Pmin) + (1.0 - Aprior) * log(Pconst + Pmax - Pval) - (1.0 - Bprior) * log(Pconst + Pr - Pmin) - (1.0 - Aprior) * log(Pconst + Pmax - Pr);
      break;
    }
    case 3: // lognormal without bias correction
    {
      if (Pmin > 0.0)
      {
        Prior_Like = 0.5 * square((log(Pval) - Pr) / Psd);
      }
      else
      {
        warnstream << "Cannot do prior in log space for parm with min <=0.0" ;
        write_message (WARN, 0);
      }
      break;
    }
    case 4: //lognormal with bias correction (from Larry Jacobson)
    {
      if (Pmin > 0.0)
        Prior_Like = 0.5 * square((log(Pval) - Pr + 0.5 * square(Psd)) / Psd);
      else
      {
        warnstream << "Cannot do prior in log space for parm with min <=0.0";
        write_message (WARN, 0);
      }
      break;
    }
    case 5: //gamma  (from Larry Jacobson)
    {
      double warnif = 1e-15;
      if (Pmin < 0.0)
      {
        warnstream << "Lower bound for gamma prior must be >=0.  Suggest " << warnif * 10.0;
        write_message (WARN, 0);
      }
      else
      {
        //Gamma is defined over [0,+inf) but x=zero causes trouble for some mean/variance combos.
        if (Pval < warnif)
        {
          warnstream << "Pval too close to zero in gamma prior - can not guarantee reliable calculations.  Suggest rescaling data (e.g. * 1000)? ";
          write_message (WARN, 0);
        }
        else
        {
          dvariable scale = square(Psd) / Pr; // gamma parameters by method of moments
          dvariable shape = Pr / scale;
          Prior_Like = -1 * (-shape * log(scale) - gammln(shape) + (shape - 1.0) * log(Pval) - Pval / scale);
        }
      }
      break;
    }
  }
  RETURN_ARRAYS_DECREMENT();
  return Prior_Like;
  }

FUNCTION void get_posteriors()
  {
  //********************************************************************
  /*  SS_Label_FUNCTION 33 get_posteriors  (MCMC eval) */
  if (rundetail > 1)
  {
    cout << "mceval counter: " << mceval_counter << endl;
  }
  if (rundetail == 0 && double(mceval_counter) / 200. == double(mceval_counter / 200.))
  {
    cout << "mceval counter: " << mceval_counter << endl;
  }
  if (mceval_header == 0 && mceval_phase()) // first pass through the mceval phase
  {
    // delete any old mcmc output files
    // will generate a warning if no files exist
    // but will play through just fine
    // NOTE:  "del" works on Windows only; use "rm" on other operating systems
    //  solution here is to open file to the first record
    rebuilder.open(sso_pathname + "rebuild.sso", ios::out);
    posts.open(sso_pathname + "posteriors.sso", ios::out);
    der_posts.open(sso_pathname + "derived_posteriors.sso", ios::out);
    post_vecs.open(sso_pathname + "posterior_vectors.sso", ios::out);
    post_obj_func.open(sso_pathname + "posterior_obj_func.sso", ios::out);
  }
  else
  {
    // define the mcmc output files;
    rebuilder.open(sso_pathname + "rebuild.sso", ios::app);
    posts.open(sso_pathname + "posteriors.sso", ios::app);
    der_posts.open(sso_pathname + "derived_posteriors.sso", ios::app);
    post_vecs.open(sso_pathname + "posterior_vectors.sso", ios::app);
    post_obj_func.open(sso_pathname + "posterior_obj_func.sso", ios::app);
  }

  if (mceval_header == 0) // first pass through the mceval phase
  {
    mceval_header = 1;
    // produce the appropriate headers for the posteriors.rep
    // and derived_posteriors.rep files
    // parameters.rep matches "PARAMETERS" section in Report.SSO file
    posts << "Iter Objective_function ";
    for (i = 1; i <= active_count; i++)
    {
      posts << " " << ParmLabel(active_parm(i));
    }
    posts << endl;

    // derived quantities
    // derived_parameters.rep matches "DERIVED_PARAMETERS" section in Report.SSO file
    NP = ParCount;
    der_posts << "Iter Objective_function ";
    for (j = 1; j <= N_STD_Yr; j++) // spawning biomass
    {
      NP++;
      der_posts << ParmLabel(NP) << " ";
    }
    for (j = 1; j <= N_STD_Yr; j++) // recruitment
    {
      NP++;
      der_posts << ParmLabel(NP) << " ";
    }
    for (j = 1; j <= N_STD_Yr_Ofish; j++) // SPRratio
    {
      NP++;
      der_posts << ParmLabel(NP) << " ";
    }
    for (j = 1; j <= N_STD_Yr_F; j++) // F
    {
      NP++;
      der_posts << ParmLabel(NP) << " ";
    }
    for (j = 1; j <= N_STD_Yr_Dep; j++) // depletion (Bratio)
    {
      NP++;
      der_posts << ParmLabel(NP) << " ";
    }
    for (j = 1; j <= N_STD_Mgmt_Quant; j++) // Management quantities
    {
      NP++;
      der_posts << ParmLabel(NP) << " ";
    }
    for (j = 1; j <= Extra_Std_N; j++)
    {
      NP++;
      der_posts << ParmLabel(NP) << " ";
    }
    der_posts << endl;
    if (depletion_basis != 2)
      post_vecs << "depletion_basis_is_not_=2;_so_info_below_is_not_B/Bmsy" << endl;
    if (F_std_basis != 2)
      post_vecs << "F_std_basis_is_not_=2;_so_info_below_is_not_F/Fmsy" << endl;
    post_vecs << "Endyr+1= " << endyr + 1 << endl;
    post_vecs << "run mceval objfun Numbers Area Sex Ages:" << age_vector << endl;
    post_vecs << "run mceval objfun F_yr ";
    for (y = styr - 1; y <= YrMax; y++)
    {
      if (STD_Yr_Reverse_F(y) > 0)
        post_vecs << y << " ";
    }
    post_vecs << endl;
    post_vecs << "run mceval objfun B_yr ";
    for (y = styr - 1; y <= YrMax; y++)
    {
      if (STD_Yr_Reverse_Dep(y) > 0)
        post_vecs << y << " ";
    }
    post_vecs << endl;

    if (mcmc_output_detail > 0)
    {
      std::stringstream iter_labels;
      std::stringstream lambda_labels;

      iter_labels << "Iter | Objective_function";
      lambda_labels << "---- | Lambdas";

      if (F_Method > 1)
      {
        iter_labels << " | Catch";
        lambda_labels << " | " << column(catch_lambda, max_lambda_phase);
      }

      iter_labels << " | Equil_catch";
      lambda_labels << " | " << column(init_equ_lambda, max_lambda_phase);

      if (Svy_N > 0)
      {
        iter_labels << " | Survey";
        lambda_labels << " | " << column(surv_lambda, max_lambda_phase);
      }
      if (nobs_disc > 0)
      {
        iter_labels << " | Discard";
        lambda_labels << " | " << column(disc_lambda, max_lambda_phase);
      }
      if (nobs_mnwt > 0)
      {
        iter_labels << " | Mean_body_wt";
        lambda_labels << " | " << column(mnwt_lambda, max_lambda_phase);
      }
      if (Nobs_l_tot > 0)
      {
        iter_labels << " | Length_comp";
        lambda_labels << " | " << column(length_lambda, max_lambda_phase);
      }
      if (Nobs_a_tot > 0)
      {
        iter_labels << " | Age_comp";
        lambda_labels << " | " << column(age_lambda, max_lambda_phase);
      }
      if (nobs_ms_tot > 0)
      {
        iter_labels << " | Size_at_age";
        lambda_labels << " | " << column(sizeage_lambda, max_lambda_phase);
      }
      if (SzFreq_Nmeth > 0)
      {
        iter_labels << " | SizeFreq";
        lambda_labels << " | " << column(SzFreq_lambda, max_lambda_phase);
      }
      if (Do_Morphcomp > 0)
      {
        iter_labels << " | Morphcomp";
        lambda_labels << " | " << Morphcomp_lambda(max_lambda_phase);
      }
      if (Do_TG > 0)
      {
        iter_labels << " | Tag_comp | Tag_negbin";
        lambda_labels << " | " << column(TG_lambda1, max_lambda_phase) << " | " << column(TG_lambda2, max_lambda_phase);
      }

      iter_labels << " | Recruitment";
      lambda_labels << " | " << recrdev_lambda(max_lambda_phase);

      iter_labels << " | Forecast_Recruitment";
      lambda_labels << " | " << Fcast_recr_lambda;

      iter_labels << " | Parm_priors";
      lambda_labels << " | " << parm_prior_lambda(max_lambda_phase);

      if (SoftBound > 0)
      {
        iter_labels << " | Parm_softbounds";
        lambda_labels << " | NA";
      }

      iter_labels << " | Parm_devs";
      lambda_labels << " | " << parm_dev_lambda(max_lambda_phase);

      if (F_ballpark_yr > 0)
      {
        iter_labels << " | F_Ballpark";
        lambda_labels << " | " << F_ballpark_lambda(max_lambda_phase);
      }

      iter_labels << " | Crash_Pen ";
      lambda_labels << " | " << CrashPen_lambda(max_lambda_phase);

      post_obj_func << iter_labels.str() << endl;
      post_obj_func << lambda_labels.str() << endl;
    }
  }; //  end writing headers for mceval_counter==1

  // produce standard output of all estimated parameters
  posts << mceval_counter << " " << obj_fun << " ";
  for (j = 1; j <= N_MGparm2; j++)
  {
    if (active(MGparm(j)))
      posts << MGparm(j) << " ";
  }
  for (i = 1; i <= N_SRparm3; i++)
  {
    if (active(SRparm(i)))
      posts << SRparm(i) << " ";
  }

  if (recdev_cycle > 0)
  {
    for (i = 1; i <= recdev_cycle; i++)
    {
      if (active(recdev_cycle_parm(i)))
        posts << recdev_cycle_parm(i) << " ";
    }
  }
  if (recdev_do_early > 0)
  {
    for (i = recdev_early_start; i <= recdev_early_end; i++)
    {
      if (active(recdev_early))
        posts << recdev(i) << " ";
    }
  }
  if (do_recdev > 0)
  {
    for (i = recdev_start; i <= recdev_end; i++)
    {
      if (active(recdev1) || active(recdev2))
        posts << recdev(i) << " ";
    }
    if (Do_Forecast > 0 && active(Fcast_recruitments))
    {
      for (i = recdev_end + 1; i <= YrMax; i++)
      {
        posts << Fcast_recruitments(i) << " ";
      }
    }
  }
  if (Do_Impl_Error > 0)
  {
    for (i = endyr + 1; i <= YrMax; i++)
    {
      posts << Fcast_impl_error(i) << " ";
    }
  }
  for (i = 1; i <= N_init_F; i++)
  {
    if (active(init_F(i)))
      posts << init_F(i) << " ";
  }
  if (N_Fparm > 0)
  {
    for (i = 1; i <= N_Fparm; i++)
    {
      if (active(F_rate(i)))
        posts << F_rate(i) << " ";
    }
  }
  for (i = 1; i <= Q_Npar2; i++)
  {
    if (active(Q_parm(i)))
      posts << Q_parm(i) << " ";
  }
  for (j = 1; j <= N_selparm2; j++)
  {
    if (active(selparm(j)))
      posts << selparm(j) << " ";
  }
  if (Do_TG > 0)
  {
    k = 3 * N_TG + 2 * Nfleet1;
    for (j = 1; j <= k; j++)
    {
      if (active(TG_parm(j)))
        posts << TG_parm(j) << " ";
    }
  }
  if (N_parm_dev > 0)
  {
    for (i = 1; i <= N_parm_dev; i++)
      for (j = parm_dev_minyr(i); j <= parm_dev_maxyr(i); j++)
      {
        if (parm_dev_PH(i) > 0)
          posts << parm_dev(i, j) << " ";
      }
  }
  posts << endl;

  // derived quantities
  der_posts << mceval_counter << " " << obj_fun << " ";
  for (j = 1; j <= N_STD_Yr; j++) // spawning biomass
  {
    der_posts << SSB_std(j) << " ";
  }
  for (j = 1; j <= N_STD_Yr; j++) // recruitment
  {
    der_posts << recr_std(j) << " ";
  }
  for (j = 1; j <= N_STD_Yr_Ofish; j++) // SPRratio
  {
    der_posts << SPR_std(j) << " ";
  }
  for (j = 1; j <= N_STD_Yr_F; j++) // F
  {
    der_posts << F_std(j) << " ";
  }
  for (j = 1; j <= N_STD_Yr_Dep; j++) // depletion (Bratio)
  {
    der_posts << depletion(j) << " ";
  }
  for (j = 1; j <= N_STD_Mgmt_Quant; j++) // Management quantities
  {
    der_posts << Mgmt_quant(j) << " ";
  }
  for (j = 1; j <= Extra_Std_N; j++)
  {
    der_posts << Extra_Std(j) << " ";
  }

  der_posts << endl;

  if (Do_Rebuilder == 1)
    write_rebuilder_output();

  // derived vectors quantities
  t = styr + (endyr + 1 - styr) * nseas;
  for (p = 1; p <= pop; p++)
  {
    for (gg = 1; gg <= gender; gg++)
    {
      tempvec_a.initialize();
      for (g = 1; g <= gmorph; g++)
        if (sx(g) == gg && use_morph(g) > 0)
        {
          tempvec_a += natage(t, p, g);
        }
      post_vecs << runnumber << " " << mceval_counter << " " << obj_fun << " N_at_Age "
                << " " << p << " " << gg << " " << tempvec_a << endl;
    }
  }
  post_vecs << runnumber << " " << mceval_counter << " " << obj_fun << " F/Fmsy " << F_std << endl;
  post_vecs << runnumber << " " << mceval_counter << " " << obj_fun << " B/Bmsy " << depletion << endl;

  // output objective function components
  if (mcmc_output_detail > 0)
  {
    post_obj_func << mceval_counter << " | " << obj_fun;

    if (F_Method > 1)
      post_obj_func << " | " << catch_like;
    post_obj_func << " | " << sum(equ_catch_like);
    if (Svy_N > 0)
      post_obj_func << " | " << surv_like;
    if (nobs_disc > 0)
      post_obj_func << " | " << disc_like;
    if (nobs_mnwt > 0)
      post_obj_func << " | " << mnwt_like;
    if (Nobs_l_tot > 0)
      post_obj_func << " | " << length_like_tot;
    if (Nobs_a_tot > 0)
      post_obj_func << " | " << age_like_tot;
    if (nobs_ms_tot > 0)
      post_obj_func << " | " << sizeage_like;
    if (SzFreq_Nmeth > 0)
      post_obj_func << " | " << SzFreq_like;
    if (Do_Morphcomp > 0)
      post_obj_func << " | " << Morphcomp_like;
    if (Do_TG > 0)
      post_obj_func << " | " << TG_like1 << " | " << TG_like2;
    post_obj_func << " | " << recr_like + regime_like;
    post_obj_func << " | " << Fcast_recr_like;
    post_obj_func << " | " << parm_like;
    if (SoftBound > 0)
      post_obj_func << " | " << SoftBoundPen;
    post_obj_func << " | " << (sum(parm_dev_like));
    if (F_ballpark_yr > 0)
      post_obj_func << " | " << F_ballpark_like;
    post_obj_func << " | " << CrashPen;

    post_obj_func << endl;
  }
  posts.close();
  der_posts.close();
  post_vecs.close();
  post_obj_func.close();
  } //  end get_posteriors
// SS_Label_file  #17. **SS_write.tpl**
// SS_Label_file  # * <u>write_summaryoutput()</u>  //  append writes to *cumreport.sso*
// SS_Label_file  # * <u>write_SS_summary()</u>  //  writes *ss_summary.sso*
// SS_Label_file  # * <u>write_rebuilder_output()</u> // special output
// SS_Label_file  # * <u>write_SIStable()</u>  //  deprecated, see new r4ss routines
// SS_Label_file  # * <u>write_Bzero_output()</u>  //
// SS_Label_file  # * <u>Report_Parm()</u>  //  used by write_big_report in writing *report.sso*
// SS_Label_file  #

 /*  SS_Label_FUNCTION 36 write_summaryoutput; Writes in append mode to cumreport.sso */
FUNCTION void write_summaryoutput()
  {
  random_number_generator radm(long(time(&finish)));
  time(&finish);
  elapsed_time = difftime(finish, start);
  report2 << runnumber << " -logL: " << obj_fun << " SSB(Vir_Start_End): " << SSB_yr(styr - 2) << " " << SSB_yr(styr) << " " << SSB_yr(endyr) << endl;
  report2 << runnumber << " Files: " << datfilename << " " << ctlfilename;
  if (readparfile >= 1)
    report2 << " Start_from_ss.par";
  report2 << endl
          << runnumber << " N_iter: " << niter << " runtime(sec): " << elapsed_time << " starttime: " << ctime(&start);
  report2 << runnumber << version_info(1) << version_info(2) << version_info(3) << endl;
  report2 << runnumber << " F_Method: " << F_Method << " Retro_YR: " << retro_yr << " Forecast_Type: " << Do_Forecast << " MSY_Type: " << Do_MSY << endl;
  if (N_SC > 0)
  {
    for (j = 1; j <= N_SC; j++)
      report2 << runnumber << " Comment S_" << j << " " << Starter_Comments(j) << endl;
  }
  if (N_DC > 0)
  {
    for (j = 1; j <= N_DC; j++)
      report2 << runnumber << " Comment D_" << j << " " << Data_Comments(j) << endl;
  }
  if (N_CC > 0)
  {
    for (j = 1; j <= N_CC; j++)
      report2 << runnumber << " Comment C_" << j << " " << Control_Comments(j) << endl;
  }
  if (N_FC > 0)
  {
    for (j = 1; j <= N_FC; j++)
      report2 << runnumber << " Comment F_" << j << " " << Forecast_Comments(j) << endl;
  }
  k = current_phase();
  if (k > max_lambda_phase)
    k = max_lambda_phase;
  report2 << runnumber << " Like_Emph Total 1 " << endl
          << runnumber << " Like_Value Total " << obj_fun << endl;
  if (Svy_N > 0)
    report2 << runnumber << " Like_Emph Indices All " << column(surv_lambda, k) << endl
            << runnumber << " Like_Value Indices " << surv_like * column(surv_lambda, k) << " " << surv_like << endl;
  if (nobs_disc > 0)
    report2 << runnumber << " Like_Emph Discard All " << column(disc_lambda, k) << endl
            << runnumber << " Like_Value Discard " << disc_like * column(disc_lambda, k) << " " << disc_like << endl;
  if (nobs_mnwt > 0)
    report2 << runnumber << " Like_Emph MeanBodyWt All " << column(mnwt_lambda, k) << endl
            << runnumber << " Like_Value MeanBodyWt " << mnwt_like * column(mnwt_lambda, k) << " " << mnwt_like << endl;
  if (Nobs_l_tot > 0)
    report2 << runnumber << " Like_Emph LenComp All " << column(length_lambda, k) << endl
            << runnumber << " Like_Value LenComp " << length_like_tot * column(length_lambda, k) << " " << length_like_tot << endl;
  if (Nobs_a_tot > 0)
    report2 << runnumber << " Like_Emph AgeComp All " << column(age_lambda, k) << endl
            << runnumber << " Like_Value AgeComp " << age_like_tot * column(age_lambda, k) << " " << age_like_tot << endl;
  if (nobs_ms_tot > 0)
    report2 << runnumber << " Like_Emph MeanLAA All " << column(sizeage_lambda, k) << endl
            << runnumber << " Like_Value MeanLAA " << sizeage_like * column(sizeage_lambda, k) << " " << sizeage_like << endl;

  if (F_Method > 1)
    report2 << runnumber << " Like_Emph Catch All " << column(catch_lambda, k) << endl
            << runnumber << " Like_Value Catch " << catch_like * column(catch_lambda, k) << " " << catch_like << endl;

  report2 << runnumber << " Like_Emph init_equ All " << column(init_equ_lambda, k) << endl
          << runnumber << " Like_Value Init_Equ " << equ_catch_like * column(init_equ_lambda, k) << " " << catch_like << endl;

  if (SzFreq_Nmeth > 0)
    report2 << runnumber << " Like_Emph WeightFreq All " << column(SzFreq_lambda, k) << endl
            << runnumber << " Like_Value WeightFreq " << SzFreq_like * column(SzFreq_lambda, k) << " " << SzFreq_like << endl;
  if (Do_Morphcomp > 0)
    report2 << runnumber << " Like_Emph Morphcomp All " << Morphcomp_lambda(k) << endl
            << runnumber << " Like_Value Morphcomp " << Morphcomp_like * Morphcomp_lambda(k) << " " << Morphcomp_like << endl;
  if (Do_TG > 0)
    report2 << runnumber << " Like_Emph Tag_comp All " << column(TG_lambda1, k) << endl
            << runnumber << " Like_Value Tag_comp " << TG_like1 * column(TG_lambda1, k) << " " << TG_like1 << endl;
  if (Do_TG > 0)
    report2 << runnumber << " Like_Emph Tag_negbin All " << column(TG_lambda2, k) << endl
            << runnumber << " Like_Value Tag_negbin " << TG_like2 * column(TG_lambda2, k) << " " << TG_like2 << endl;

  report2 << runnumber << " Like_Comp Recruits Regime Fcast_Recr Biasadj Priors ParmDevs CrashPen" << endl;
  report2 << runnumber << " Like_Emph " << recrdev_lambda(k) << " " << regime_lambda(k) << " " << Fcast_recr_lambda << " "
          << parm_prior_lambda(k) << " " << parm_dev_lambda(k) << " " << CrashPen_lambda(k) << endl;
  report2 << runnumber << " Like_Value*Emph " << recr_like * recrdev_lambda(k) << " " << regime_like * regime_lambda(k) << " "
          << Fcast_recr_like << " " << parm_like * parm_prior_lambda(k) << " " << sum(parm_dev_like) * parm_dev_lambda(k) << " " << CrashPen * CrashPen_lambda(k) << endl;

  report2 << runnumber << " TimeSeries Yr Vir Equ " << years << " ";
  k = YrMax;
  if (k == endyr)
    k = endyr + 1;
  for (y = endyr + 1; y <= k; y++)
  {
    report2 << y << "F ";
  }
  report2 << endl;
  report2 << runnumber << " Timeseries SpawnBio " << SSB_yr(styr - 2, YrMax) << endl;
  report2 << runnumber << " Timeseries Recruit " << column(exp_rec, 4) << endl;
  report2 << runnumber << " Timeseries TotBio " << column(Smry_Table, 1) << endl;
  report2 << runnumber << " Timeseries SmryBio-" << Smry_Age << " " << column(Smry_Table, 2) << endl;
  report2 << runnumber << " Timeseries TotCatch " << column(Smry_Table, 4) << endl;
  report2 << runnumber << " Timeseries RetCatch " << column(Smry_Table, 5) << endl;
  j = 0;
  if (max(Do_Retain) > 0)
    j = 1;
  if (Do_Benchmark > 0)
    report2 << runnumber << " Mgmt_Quant " << Mgmt_quant(1, 6 + j) << endl;

  report2 << runnumber << " Parm Labels ";
  for (i = 1; i <= ParCount; i++)
  {
    report2 << " " << ParmLabel(i);
  }
  report2 << endl;
  report2 << runnumber << " Parm Values ";
  report2 << " " << MGparm << " ";
  if (N_parm_dev > 0)
  {
    for (j = 1; j <= N_parm_dev; j++)
      report2 << parm_dev(j) << " ";
  }
  report2 << SRparm << " ";
  if (recdev_cycle > 0)
    report2 << recdev_cycle_parm << " ";
  if (recdev_do_early > 0)
    report2 << recdev_early << " ";
  if (do_recdev == 1)
  {
    report2 << recdev1 << " ";
  }
  if (do_recdev == 2)
  {
    report2 << recdev2 << " ";
  }
  if (Do_Forecast > 0)
    report2 << Fcast_recruitments << " ";
  if (Do_Impl_Error > 0)
    report2 << Fcast_impl_error << " ";
  if (N_init_F > 0)
    report2 << init_F << " ";
  if (N_Fparm > 0)
    report2 << " " << F_rate;
  if (Q_Npar2 > 0)
    report2 << Q_parm << " ";
  if (N_selparm2 > 0)
    report2 << selparm << " ";
  //  if(N_selparm_dev>0) report2<<selparm_dev<<" ";
  if (Do_TG > 0)
    report2 << TG_parm << " ";
  report2 << endl;

  NP = 0; // count of number of parameters
  report2 << runnumber << " MG_parm ";
  for (j = 1; j <= N_MGparm2; j++)
  {
    NP++;
    report2 << " " << ParmLabel(NP);
  }
  report2 << endl
          << runnumber << " MG_parm " << MGparm << endl;

  if (N_parm_dev > 0)
  {
    report2 << runnumber << " MG_parm_dev ";
    for (i = 1; i <= N_parm_dev; i++)
    {
      for (j = parm_dev_minyr(i); j <= parm_dev_maxyr(i); j++)
      {
        NP++;
        report2 << " " << ParmLabel(NP);
      }
      report2 << endl
              << runnumber << " MG_parm_dev " << parm_dev(i) << endl;
    }
  }

  report2 << runnumber << " SRparm ";
  for (i = 1; i <= N_SRparm3 + recdev_cycle; i++)
  {
    NP++;
    report2 << " " << ParmLabel(NP);
  }
  report2 << endl
          << runnumber << " SRparm " << SRparm << " ";
  if (recdev_cycle > 0)
    report2 << recdev_cycle_parm;
  report2 << endl;

  if (recdev_do_early > 0)
  {
    report2 << runnumber << " Recr_early ";
    for (i = recdev_early_start; i <= recdev_early_end; i++)
    {
      NP++;
      report2 << " " << ParmLabel(NP);
    }
    report2 << endl
            << runnumber << " Recr_early ";
    for (i = recdev_early_start; i <= recdev_early_end; i++)
      report2 << " " << recdev(i);
    report2 << endl;
  }

  if (do_recdev > 0)
  {
    report2 << runnumber << " Recr_main ";
    for (i = recdev_start; i <= recdev_end; i++)
    {
      NP++;
      report2 << " " << ParmLabel(NP);
    }
    report2 << endl
            << runnumber << " Recr_main ";
    for (i = recdev_start; i <= recdev_end; i++)
      report2 << " " << recdev(i);
    report2 << endl;
  }

  if (Do_Forecast > 0)
  {
    if (do_recdev > 0)
    {
      report2 << runnumber << " Recr_fore ";
      for (i = recdev_end + 1; i <= YrMax; i++)
      {
        NP++;
        report2 << " " << ParmLabel(NP);
      }
      report2 << endl
              << runnumber << " Recr_fore ";
      for (i = recdev_end + 1; i <= YrMax; i++)
        report2 << " " << recdev(i);
      report2 << endl;
    }
    if (Do_Impl_Error > 0)
    {
      report2 << runnumber << " Impl_err ";
      for (i = endyr + 1; i <= YrMax; i++)
      {
        NP++;
        report2 << " " << ParmLabel(NP);
      }
      report2 << endl
              << runnumber << " Impl_err ";
      for (i = endyr + 1; i <= YrMax; i++)
        report2 << " " << Fcast_impl_error(i);
      report2 << endl;
    }
  }

  report2 << runnumber << " init_F ";
  for (i = 1; i <= N_init_F; i++)
  {
    NP++;
    report2 << " " << ParmLabel(NP);
  }
  report2 << endl
          << runnumber << " init_F ";
  for (i = 1; i <= N_init_F; i++)
    report2 << " " << init_F(i);
  report2 << endl;

  if (N_Fparm > 0)
  {
    report2 << runnumber << " F_rate ";
    for (i = 1; i <= N_Fparm; i++)
    {
      NP++;
      report2 << " " << ParmLabel(NP);
    }
    report2 << endl
            << runnumber << " F_rate ";
    for (i = 1; i <= N_Fparm; i++)
      report2 << " " << F_rate(i);
    report2 << endl;
  }

  if (Q_Npar2 > 0)
  {
    report2 << runnumber << " Q_parm ";
    for (i = 1; i <= Q_Npar2; i++)
    {
      NP++;
      report2 << " " << ParmLabel(NP);
    }
    report2 << endl
            << runnumber << " Q_parm ";
    for (i = 1; i <= Q_Npar2; i++)
      report2 << " " << Q_parm(i);
    report2 << endl;
  }

  if (N_selparm2 > 0)
  {
    report2 << runnumber << " Sel_parm ";
    for (i = 1; i <= N_selparm2; i++)
    {
      NP++;
      report2 << " " << ParmLabel(NP);
    }
    report2 << endl
            << runnumber << " Sel_parm " << selparm << endl;
  }

  if (Do_TG > 0)
  {
    report2 << runnumber << " Tag_parm ";
    for (f = 1; f <= 3 * N_TG + 2 * Nfleet1; f++)
    {
      NP++;
      report2 << " " << ParmLabel(NP);
    }
    report2 << endl
            << runnumber << " Tag_parm " << TG_parm << endl;
  }

  if (Do_CumReport == 2)
  {
    if (Svy_N > 0)
      for (f = 1; f <= Nfleet; f++)
        if (Svy_N_fleet(f) > 0)
        {
          report2 << runnumber << " Index:" << f << " Yr ";
          for (i = 1; i <= Svy_N_fleet(f); i++)
          {
            ALK_time = Svy_ALK_time(f, i);
            report2 << data_time(ALK_time, f, 3) << " ";
          }
          report2 << endl
                  << runnumber << " Index:" << f << " OBS " << Svy_obs(f) << endl;
          if (Svy_errtype(f) >= 0) // lognormal or lognormal T-dist
          {
            report2 << runnumber << " Index:" << f << " EXP " << mfexp(Svy_est(f)) << endl;
          }
          else // normal error
          {
            report2 << runnumber << " Index:" << f << " EXP " << Svy_est(f) << endl;
          }
        }

    data_type = 4;
    for (f = 1; f <= Nfleet; f++)
      if (Nobs_l(f) > 0)
      {
        report2 << runnumber << " Len:" << f << " YR ";
        for (i = 1; i <= Nobs_l(f); i++)
        {
          t = Len_time_t(f, i);
          ALK_time = Len_time_ALK(f, i);
          report2 << data_time(ALK_time, f, 3) << " ";
        }
        report2 << endl
                << runnumber << " Len:" << f << " effN " << neff_l(f) << endl;
      }

    data_type = 5;
    for (f = 1; f <= Nfleet; f++)
      if (Nobs_a(f) > 0)
      {
        report2 << runnumber << " Age:" << f << " YR ";
        for (i = 1; i <= Nobs_a(f); i++)
        {
          t = Age_time_t(f, i);
          ALK_time = Age_time_ALK(f, i);
          report2 << data_time(ALK_time, f, 3) << " ";
        }
        report2 << endl
                << runnumber << " Age:" << f << " effN " << neff_a(f) << endl;
      }
  }
  report2 << endl;
  cout << " finished appending to cumreport.sso " << endl;
  }

FUNCTION void write_SS_summary()
  {
  SS_smry.open(sso_pathname + "ss_summary.sso");
  SS_smry << version_info(1) << version_info(2) << version_info(3) << endl;
  SS_smry << datfilename << " #_DataFile " << endl;
  SS_smry << ctlfilename << " #_Control " << endl;
  SS_smry << "Run_Date: " << ctime(&start);
  SS_smry << "Final_phase: " << current_phase() << "  N_iterations: " << niter << endl;
  k = current_phase();
  if (k > max_lambda_phase)
    k = max_lambda_phase;
  SS_smry << "#_LIKELIHOOD " << endl;
  SS_smry << "Label logL*Lambda" << endl;
  SS_smry << "TOTAL_LogL " << obj_fun << endl;
  if (F_Method > 1)
  {
    SS_smry << "Catch " << catch_like * column(catch_lambda, k) << endl;
  }
  if (N_init_F > 0)
    SS_smry << "Equil_catch " << equ_catch_like * column(init_equ_lambda, k) << endl;
  if (Svy_N > 0)
    SS_smry << "Survey " << surv_like * column(surv_lambda, k) << endl;
  if (nobs_disc > 0)
    SS_smry << "Discard " << disc_like * column(disc_lambda, k) << endl;
  if (nobs_mnwt > 0)
    SS_smry << "Mean_body_wt " << mnwt_like * column(mnwt_lambda, k) << endl;
  if (Nobs_l_tot > 0)
    SS_smry << "Length_comp " << length_like_tot * column(length_lambda, k) << endl;
  if (Nobs_a_tot > 0)
    SS_smry << "Age_comp " << age_like_tot * column(age_lambda, k) << endl;
  if (nobs_ms_tot > 0)
    SS_smry << "Size_at_age " << sizeage_like * column(sizeage_lambda, k) << endl;
  if (SzFreq_Nmeth > 0)
    SS_smry << "Gen_Size_Comp " << SzFreq_like * column(SzFreq_lambda, k) << endl;
  if (Do_Morphcomp > 0)
    SS_smry << "Morphcomp " << Morphcomp_lambda(k) * Morphcomp_like << endl;
  if (Do_TG > 0)
  {
    SS_smry << "Tag_Data_1 " << TG_like1 * column(TG_lambda1, k) << endl;
    SS_smry << "Tag_Data_2 " << TG_like2 * column(TG_lambda2, k) << endl;
  }
  SS_smry << "Recruitment " << recr_like * recrdev_lambda(k) << endl;
  SS_smry << "InitEQ_regime " << regime_like * regime_lambda(k) << endl;
  SS_smry << "Sum_recdevs " << sum_recdev << endl;
  SS_smry << "Forecast_Recruitment " << Fcast_recr_like << endl;
  SS_smry << "Parm_priors " << parm_like * parm_prior_lambda(k) << endl;
  SS_smry << "Parm_softbounds " << SoftBoundPen << endl;
  SS_smry << "Parm_devs " << sum(parm_dev_like) * parm_dev_lambda(k) << endl;
  SS_smry << "F_Ballpark " << F_ballpark_lambda(k) * F_ballpark_like << endl;
  SS_smry << "Crash_Pen " << CrashPen_lambda(k) * CrashPen << endl;

  SS_smry << "#_PARAMETERS" << endl
          << "#label value se active? range" << endl;
  NP = 0; // count of number of parameters
  active_count = 0;
  SS_smry << "#_BIOLOGY" << endl;
  for (j = 1; j <= N_MGparm2; j++)
  {
    NP++;
    SS_smry << ParmLabel(NP) << " " << MGparm(j) << " ";
    if (active(MGparm(j)))
    {
      active_count++;
      SS_smry << CoVar(active_count, 1) << " Act ";
    }
    else
    {
      SS_smry << 0.0 << " Fix ";
    }
    SS_smry << (MGparm(j) - MGparm_LO(j)) / (MGparm_HI(j) - MGparm_LO(j) + 1.0e-6) << endl;
  }
  SS_smry << "#_SPAWN_RECR" << endl;
  for (j = 1; j <= N_SRparm3; j++)
  {
    NP++;
    SS_smry << ParmLabel(NP) << " " << SRparm(j) << " ";
    if (active(SRparm(j)))
    {
      active_count++;
      SS_smry << CoVar(active_count, 1) << " Act ";
    }
    else
    {
      SS_smry << 0.0 << " Fix ";
    }
    SS_smry << (SRparm(j) - SRparm_LO(j)) / (SRparm_HI(j) - SRparm_LO(j) + 1.0e-6) << endl;
  }

  if (recdev_cycle > 0)
  {
    for (j = 1; j <= recdev_cycle; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << recdev_cycle_parm(j) << " ";
      if (active(recdev_cycle_parm(j)))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (recdev_cycle_parm(j) - recdev_cycle_LO(j)) / (recdev_cycle_HI(j) - recdev_cycle_LO(j) + 1.0e-6) << endl;
    }
  }

  if (recdev_do_early > 0)
  {
    for (j = recdev_early_start; j <= recdev_early_end; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << recdev(j) << " ";
      if (active(recdev_early))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (recdev(j) - recdev_LO) / (recdev_HI - recdev_LO + 1.0e-6) << endl;
    }
  }

  if (do_recdev > 0)
  {
    for (j = recdev_start; j <= recdev_end; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << recdev(j) << " ";
      if (active(recdev1) || active(recdev2))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (recdev(j) - recdev_LO) / (recdev_HI - recdev_LO + 1.0e-6) << endl;
    }
  }

  if (Do_Forecast > 0 && do_recdev > 0)
  {
    for (j = recdev_end + 1; j <= YrMax; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << Fcast_recruitments(j) << " ";
      if (active(Fcast_recruitments))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (Fcast_recruitments(j) - recdev_LO) / (recdev_HI - recdev_LO + 1.0e-6) << endl;
    }

    if (Do_Impl_Error > 0)
    {
      for (j = endyr + 1; j <= YrMax; j++)
      {
        NP++;
        SS_smry << ParmLabel(NP) << " " << Fcast_impl_error(j) << " ";
        if (active(Fcast_impl_error))
        {
          active_count++;
          SS_smry << CoVar(active_count, 1) << " Act ";
        }
        else
        {
          SS_smry << 0.0 << " Fix ";
        }
        SS_smry << (Fcast_impl_error(j) - (-1.)) / (1.0 - (-1.0) + 1.0e-6) << endl;
      }
    }
  }

  if (N_init_F > 0)
  {
    SS_smry << "#_Init_F" << endl;
    for (j = 1; j <= N_init_F; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << init_F(j) << " ";
      if (active(init_F(j)))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (init_F(j) - init_F_LO(j)) / (init_F_HI(j) - init_F_LO(j) + 1.0e-6) << endl;
    }
  }

  if (N_Fparm > 0)
  {
    SS_smry << "#_F" << endl;
    for (j = 1; j <= N_Fparm; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << F_rate(j) << " ";
      if (active(F_rate(j)))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (F_rate(j) - 0.) / (max_harvest_rate - 0 + 1.0e-6) << endl;
    }
  }

  if (Q_Npar2 > 0)
  {
    SS_smry << "#_Catchability" << endl;
    for (j = 1; j <= Q_Npar2; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << Q_parm(j) << " ";
      if (active(Q_parm(j)))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (Q_parm(j) - Q_parm_LO(j)) / (Q_parm_HI(j) - Q_parm_LO(j) + 1.0e-6) << endl;
    }
  }

  SS_smry << "#_Selectivity" << endl;
  if (N_selparm2 > 0)
    for (j = 1; j <= N_selparm2; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << selparm(j) << " ";
      if (active(selparm(j)))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (selparm(j) - selparm_LO(j)) / (selparm_HI(j) - selparm_LO(j) + 1.0e-6) << endl;
    }

  if (Do_TG > 0)
  {
    SS_smry << "#_Tag_Recapture" << endl;
    for (j = 1; j <= 3 * N_TG + 2 * Nfleet1; j++)
    {
      NP++;
      SS_smry << ParmLabel(NP) << " " << TG_parm(j) << " ";
      if (active(TG_parm(j)))
      {
        active_count++;
        SS_smry << CoVar(active_count, 1) << " Act ";
      }
      else
      {
        SS_smry << 0.0 << " Fix ";
      }
      SS_smry << (TG_parm(j) - TG_parm_LO(j)) / (TG_parm_HI(j) - TG_parm_LO(j) + 1.0e-6) << endl;
    }
  }

  if (N_parm_dev > 0)
  {
    SS_smry << "#_Parm_Dev" << endl;
    for (i = 1; i <= N_parm_dev; i++)
      for (j = parm_dev_minyr(i); j <= parm_dev_maxyr(i); j++)
      {
        NP++;
        SS_smry << ParmLabel(NP) << " " << parm_dev(i, j) << " ";
        if (parm_dev_PH(i) > 0)
        {
          active_count++;
          SS_smry << CoVar(active_count, 1) << " ACT ";
        }
        else
        {
          SS_smry << 0.0 << " FIX ";
        }
        SS_smry << (parm_dev(i, j) - (-10.)) / (10. - (-10) + 1.0e-6) << endl;
      }
  }

  SS_smry << "#_Derived_Quantities" << endl;
  SS_smry << "#_Spawn_Bio" << endl;
  for (j = 1; j <= N_STD_Yr; j++)
  {
    NP++;
    active_count++;
    SS_smry << ParmLabel(NP) << " " << SSB_std(j) << " " << CoVar(active_count, 1) << endl;
  }

  SS_smry << "#_Recruitment" << endl;
  for (j = 1; j <= N_STD_Yr; j++)
  {
    NP++;
    active_count++;
    SS_smry << ParmLabel(NP) << " " << recr_std(j) << " " << CoVar(active_count, 1) << endl;
  }

  SS_smry << "#_SPR Basis= " << SPR_report_label << endl;
  for (j = 1; j <= N_STD_Yr_Ofish; j++)
  {
    NP++;
    active_count++;
    SS_smry << ParmLabel(NP) << " " << SPR_std(j) << " " << CoVar(active_count, 1) << endl;
  }

  SS_smry << "#_F Basis= " << F_report_label << endl;
  for (j = 1; j <= N_STD_Yr_F; j++)
  {
    NP++;
    active_count++;
    SS_smry << ParmLabel(NP) << " " << F_std(j) << " " << CoVar(active_count, 1) << endl;
  }

  SS_smry << "#_Depletion Basis= " << depletion_basis_label << endl;
  for (j = 1; j <= N_STD_Yr_Dep; j++)
  {
    NP++;
    active_count++;
    SS_smry << ParmLabel(NP) << " " << depletion(j) << " " << CoVar(active_count, 1) << endl;
  }

  SS_smry << "#_Mgmt_Quantity" << endl;
  for (j = 1; j <= N_STD_Mgmt_Quant; j++)
  {
    NP++;
    active_count++;
    SS_smry << ParmLabel(NP) << " " << Mgmt_quant(j) << " " << CoVar(active_count, 1) << endl;
  }

  SS_smry << "#_Extra_stdev" << endl;
  for (j = 1; j <= Extra_Std_N; j++)
  {
    NP++;
    active_count++;
    SS_smry << ParmLabel(NP) << " " << Extra_Std(j) << " " << CoVar(active_count, 1) << endl;
  }

  if (Do_se_smrybio == 0)
  {
    SS_smry << "SmryBio_Virgin " << Smry_Table(styr - 2, 2) << " 0.0" << endl;
    SS_smry << "SmryBio_Initial " << Smry_Table(styr - 1, 2) << " 0.0" << endl;
    for (y = styr; y <= YrMax; y++)
    {
      SS_smry << "SmryBio_" << y << " " << Smry_Table(y, 2) << " 0.0" << endl;
    }
  }

  SS_smry << "#_survey_stdev " << Svy_N_sdreport << endl;
  if (Svy_N_sdreport > 0)
  {
    k = 0;
    for (f = 1; f <= Nfleet; ++f)
    {
      if (Svy_sdreport(f) > 0)
      {
        for (j = 1; j <= Svy_N_fleet(f); j++)
        {
          active_count++;
          k++;
          NP++;
          if (Svy_errtype(f) == -1)
          {
            SS_smry << ParmLabel(NP) << " " << Svy_sdreport_est(k) << " " << CoVar(active_count, 1) << " #: " << Svy_est(f, j) << " q: " << Svy_q(f, j) << endl;
          }
          else
          {
            SS_smry << ParmLabel(NP) << " " << Svy_sdreport_est(k) << " " << CoVar(active_count, 1) << " #exp(): " << mfexp(Svy_est(f, j)) << " q: " << Svy_q(f, j) << endl;
          }
        }
      }
    }
  }

  SS_smry << "#_Biomass" << endl;
  SS_smry << "TotBio_Virgin " << Smry_Table(styr - 2, 1) << " 0.0" << endl;
  SS_smry << "TotBio_Initial " << Smry_Table(styr - 1, 1) << " 0.0" << endl;
  for (y = styr; y <= YrMax; y++)
  {
    SS_smry << "TotBio_" << y << " " << Smry_Table(y, 1) << " 0.0" << endl;
  }

  SS_smry << "TotCatch_Virgin " << Smry_Table(styr - 2, 4) << " 0.0" << endl;
  SS_smry << "TotCatch_Initial " << Smry_Table(styr - 1, 4) << " 0.0" << endl;
  for (y = styr; y <= YrMax; y++)
  {
    SS_smry << "TotCatch_" << y << " " << Smry_Table(y, 4) << " 0.0" << endl;
  }

  //    report2 <<runnumber<<" Timeseries TotBio "<<column(Smry_Table,1)<<endl;
  //  report2 <<runnumber<<" Timeseries SmryBio-"<<Smry_Age<<" "<<column(Smry_Table,2)<<endl;
  //  report2 <<runnumber<<" Timeseries TotCatch "<<column(Smry_Table,4)<<endl;
  //  report2 <<runnumber<<" Timeseries RetCatch "<<column(Smry_Table,5)<<endl;

  SS_smry.close();
  echoinput << "Finished SS_summary.sso" << endl;
  return;
  }

//********************************************************************
 /*  SS_Label_FUNCTION 37 write_rebuilder_output */
FUNCTION void write_rebuilder_output()
  {
  if (rundetail > 0 && mceval_counter == 0)
    cout << " produce output for rebuilding package" << endl;
  rebuilder.open(sso_pathname + "rebuild.sso", ios::app);
  rebuild_dat.open(sso_pathname + "rebuild.dat");

  if (mceval_counter == 0) // writing to rebuild.dat
  {
    rebuild_dat << "#Title, #runnumber: " << runnumber << " " << datfilename << " " << ctlfilename << " " << obj_fun << " " << SSB_yr(styr - 2) << " " << SSB_yr(endyr + 1) << " StartTime: " << ctime(&start);
    rebuild_dat << "SSv3_default_rebuild.dat" << endl;
    rebuild_dat << "# Number of sexes" << endl
                << gender << endl;
    rebuild_dat << "# Age range to consider (minimum age; maximum age)" << endl
                << 0 << " " << nages << endl;
    rebuild_dat << "# Number of fleets" << endl
                << Nfleet1 << endl;
    rebuild_dat << "# First year of projection (Yinit)" << endl
                << Rebuild_Yinit << endl;
    rebuild_dat << "# First Year of rebuilding period (Ydecl)" << endl
                << Rebuild_Ydecl << endl;
    rebuild_dat << "# Number of simulations" << endl
                << 1000 << endl;
    rebuild_dat << "# Maximum number of years" << endl
                << 500 << endl;
    rebuild_dat << "# Conduct projections with multiple starting values (0=No;else yes)" << endl
                << 0 << endl;
    rebuild_dat << "# Number of parameter vectors" << endl
                << 1000 << endl;
    rebuild_dat << "# Is the maximum age a plus-group (1=Yes;2=No)" << endl
                << 1 << endl;
    rebuild_dat << "# Generate future recruitments using historical recruitments (1)  historical recruits/spawner (2)  or a stock-recruitment (3)" << endl
                << 3 << endl;
    rebuild_dat << "# Constant fishing mortality (1) or constant Catch (2) projections" << endl
                << 1 << endl;
    rebuild_dat << "# Fishing mortality based on SPR (1) or actual rate (2)" << endl
                << 1 << endl;
    rebuild_dat << "# Pre-specify the year of recovery (or -1) to ignore" << endl
                << -1 << endl;
    rebuild_dat << "# Fecundity-at-age" << endl;
  }

  // stuff written to both rebuild.dat and rebuild.SSO
  //a. "blank line" with run info
  if (mceval_phase())
    rebuilder << "# mceval phase, cnt=" << mceval_counter << ", StartTime: " << ctime(&start);
  else
    rebuilder << "# in maximization mode, StartTime: " << ctime(&start);

  if (mceval_counter == 0)
    rebuild_dat << "#" << age_vector << " #runnumber: " << runnumber << " " << datfilename << " " << ctlfilename << " " << obj_fun << " " << SSB_yr(styr - 2) << " " << SSB_yr(endyr + 1) << endl;

  //b.  fecundity-at-age
  t = styr + (Rebuild_Yinit - styr) * nseas;
  dvar_vector tempvec2(0, nages);
  dvar_vector tempvec3(0, nages);
  tempvec_a.initialize();
  tempvec2.initialize();
  for (p = 1; p <= pop; p++)
    for (g = 1; g <= gmorph; g++)
      if (sx(g) == 1)
      {
        //  NEED to adjust for spawning timing within season
        tempvec_a += elem_prod(fec(g), natage(t + spawn_seas - 1, p, g));
        tempvec2 += natage(t + spawn_seas - 1, p, g);
      }
  tempvec_a = elem_div(tempvec_a, tempvec2);
  rebuilder << tempvec_a << " #female fecundity; weighted by N in year Y_init across morphs and areas" << endl;
  if (mceval_counter == 0)
  {
    rebuild_dat << tempvec_a << " #female fecundity; weighted by N in year Y_init across morphs and areas" << endl;
    rebuild_dat << "# Age specific selectivity and weight adjusted for discard and discard mortality" << endl;
  }

  //c.  Weight-at-age and selectivity-at-age (ordered by sex and fleet).
  // use the deadfish vectors that account for discard and for mortality of discards
  // average across morphs and areas using N_at_Age in year Yinit and across seasons using Fcast_RelF
  for (gg = 1; gg <= gender; gg++)
    for (f = 1; f <= Nfleet1; f++)
    {
      tempvec_a.initialize();
      tempvec2.initialize();
      tempvec3.initialize();
      j = 0;
      for (s = 1; s <= nseas; s++)
        for (p = 1; p <= pop; p++)
          if (fleet_area(f) == p && Fcast_RelF_Use(s, f) > 0.0) // active fishery in this area in endyr
          {
            j = 1;
            for (g = 1; g <= gmorph; g++)
              if (sx(g) == gg)
              {
                tempvec_a += elem_prod(Wt_Age_t(t, f, g), natage(t + s - 1, p, g) * Fcast_RelF_Use(s, f)); // body wt
                tempvec2 += elem_prod(sel_num(s, f, g), natage(t + s - 1, p, g) * Fcast_RelF_Use(s, f)); //no wt
                tempvec3 += natage(t + s - 1, p, g) * Fcast_RelF_Use(s, f);
              }
          }
      if (j == 1)
      {
        tempvec_a = elem_div(tempvec_a, tempvec3);
        tempvec2 = elem_div(tempvec2, tempvec3);
        rebuilder << tempvec_a << " #bodywt for gender,fleet: " << gg << " / " << f << " " << fleetname(f) << endl;
        rebuilder << tempvec2 << " #selex for gender,fleet: " << gg << " / " << f << " " << fleetname(f) << endl;
        if (mceval_counter == 0)
        {
          rebuild_dat << " #wt and selex for gender,fleet: " << gg << " " << f << " " << fleetname(f) << endl;
          rebuild_dat << tempvec_a << endl
                      << tempvec2 << endl;
        }
      }
    }

  if (mceval_counter == 0)
    {
      rebuild_dat << "# Sex ratio correction" << endl;
      if (gender_rd < 0) 
      {rebuild_dat << fracfemale << endl;}  // where fracfemale is set to the sexratio parameter value
      else
      {rebuild_dat << "1" << endl;}  // value to indicate not used
   }  

  //d.  Natural mortality and numbers-at-age for year Yinit  (females then males).
  if (mceval_counter == 0)
    rebuild_dat << "# M and current age-structure in year Yinit: " << Rebuild_Yinit << endl;

  for (gg = 1; gg <= gender; gg++)
  {
    tempvec_a.initialize();
    tempvec2.initialize();
    tempvec3.initialize();
    for (p = 1; p <= pop; p++)
    {
      for (g = 1; g <= gmorph; g++)
        if (sx(g) == gg && use_morph(g) > 0)
        {
          tempvec_a += elem_prod(natM(t, p, GP3(g)), natage(t, p, g));
          tempvec2 += natage(t, p, g); //  note, uses season 1 only
        }
    }
    tempvec_a = elem_div(tempvec_a, tempvec2);
    rebuilder << tempvec_a << " #mean M for year Yinit: " << Rebuild_Yinit << " sex: " << gg << endl;
    rebuilder << tempvec2 << " #numbers for year Yinit: " << Rebuild_Yinit << " sex: " << gg << endl;
    if (mceval_counter == 0)
      rebuild_dat << " # gender = " << gg << endl
                  << tempvec_a << endl
                  << tempvec2 << endl;
  }

  //e.  Numbers-at-age for year Ydecl  (females then males).
  t = styr + (Rebuild_Ydecl - styr) * nseas;
  if (mceval_counter == 0)
    rebuild_dat << "# Age-structure at Ydeclare= " << Rebuild_Ydecl << endl;
  for (gg = 1; gg <= gender; gg++)
  {
    tempvec_a.initialize();
    tempvec2.initialize();
    tempvec3.initialize();
    for (p = 1; p <= pop; p++)
    {
      for (g = 1; g <= gmorph; g++)
        if (sx(g) == gg && use_morph(g) > 0)
        {
          tempvec2 += natage(t, p, g);
        }
    }
    rebuilder << tempvec2 << " #numbers for year Ydeclare: " << Rebuild_Ydecl << " sex: " << gg << endl;
    if (mceval_counter == 0)
      rebuild_dat << tempvec2 << endl;
  }

  k = endyr;
  if (Rebuild_Yinit > k)
    k = Rebuild_Yinit;

  //f. "blank line" used for header for following lines
  rebuilder << "#R0 " << years << " #years" << endl;

  //g. recruitment
  rebuilder << exp_rec(styr - 2, 4) << " ";
  for (y = styr; y <= k; y++)
  {
    rebuilder << exp_rec(k, 4) << " ";
  }
  rebuilder << " #Recruits" << endl;

  //h. spawnbio
  rebuilder << SSB_yr(styr - 2) << " " << SSB_yr(styr, k) << " #SpawnBio" << endl;

  //i. steepness; SigmaR; rho
  rebuilder << SRparm(2) << " " << sigmaR << " " << SRparm(N_SRparm2) << " # spawn-recr steepness, sigmaR, autocorr" << endl;

  if (mceval_counter == 0)
  {
    rebuild_dat << "# Year for Tmin Age-structure (set to Ydecl by SS)" << endl
                << Rebuild_Ydecl << endl;

    rebuild_dat << "#  recruitment and biomass" << endl
                << "# Number of historical assessment years" << endl
                << k - styr + 2 << endl;
    rebuild_dat << "# Historical data" << endl
                << "# year recruitment spawner in B0 in R project in R/S project" << endl;
    rebuild_dat << styr - 1 << " " << years;
    if (Rebuild_Yinit > endyr)
      rebuild_dat << " " << Rebuild_Yinit;
    rebuild_dat << " #years (with first value representing R0)" << endl;
    rebuild_dat << exp_rec(styr - 2, 4) << " ";
    for (y = styr; y <= k; y++)
    {
      rebuild_dat << exp_rec(y, 4) << " ";
    }
    rebuild_dat << " #recruits; first value is R0 (virgin)" << endl;
    rebuild_dat << SSB_yr(styr - 2) << " " << SSB_yr(styr, k) << " #SSBio; first value is SSB_virgin (virgin)" << endl;
    rebuild_dat << 1 << " ";
    for (y = styr; y <= k; y++)
      rebuild_dat << 0 << " ";
    rebuild_dat << " # in Bzero" << endl;
    rebuild_dat << 0 << " ";
    for (y = styr; y <= k - 3; y++)
      rebuild_dat << 1 << " ";
    rebuild_dat << " 0 0 0 # in R project" << endl;
    rebuild_dat << 0 << " ";
    for (y = styr; y <= k - 3; y++)
      rebuild_dat << 1 << " ";
    rebuild_dat << " 0 0 0 # in R/S project" << endl;
    rebuild_dat << "# Number of years with pre-specified catches" << endl
                << 0 << endl;
    rebuild_dat << "# catches for years with pre-specified catches go next" << endl;
    //      rebuild_dat<<"# Number of future recruitments to override"<<endl<<0<<endl;
    //      rebuild_dat<<"# Process for overiding (-1 for average otherwise index in data list)"<<endl;

    rebuild_dat << "# Number of future recruitments to override" << endl;
    rebuild_dat << Rebuild_Yinit - Rebuild_Ydecl << endl;
    rebuild_dat << "# Process for overiding (-1 for average otherwise index in data list)" << endl;
    if (Rebuild_Yinit >= Rebuild_Ydecl + 1)
    {
      for (y = Rebuild_Ydecl + 1; y <= Rebuild_Yinit; y++)
        rebuild_dat << y << " " << 1 << " " << y << endl;
    }

    rebuild_dat << "# Which probability to product detailed results for (1=0.5; 2=0.6; etc.)" << endl
                << 3 << endl;
    rebuild_dat << "# Steepness sigma-R Auto-correlation" << endl
                << SRparm(2) << " " << sigmaR << " " << 0 << endl;
    rebuild_dat << "# Target SPR rate (FMSY Proxy); manually change to SPR_MSY if not using SPR_target" << endl
                << SPR_target << endl;
    rebuild_dat << "# Discount rate (for cumulative catch)" << endl
                << 0.1 << endl;
    rebuild_dat << "# Truncate the series when 0.4B0 is reached (1=Yes)" << endl
                << 0 << endl;
    rebuild_dat << "# Set F to FMSY once 0.4B0 is reached (1=Yes)" << endl
                << 0 << endl;
    rebuild_dat << "# Maximum possible F for projection (-1 to set to FMSY)" << endl
                << -1 << endl;
    rebuild_dat << "# Defintion of recovery (1=now only;2=now or before)" << endl
                << 2 << endl;
    rebuild_dat << "# Projection type" << endl
                << 4 << endl;
    rebuild_dat << "# Definition of the 40-10 rule" << endl
                << 10 << " " << 40 << endl;
    rebuild_dat << "# Sigma Assessment Error (Base, Year1, Slope, MaxSigma)" << endl
                << "1.0 " << endyr + 1 << " 0.075 2.0" << endl;
    rebuild_dat << "# Pstar" << endl
                << 0.45 << endl;
    rebuild_dat << "# Constrain catches by the ABC (1=yes, 2=no)" << endl
                << 2 << endl;
    rebuild_dat << "# Implementation Error (0=no; 1=lognormal; 2=uniform)" << endl
                << 0 << endl;
    rebuild_dat << "#Parameters of Implementaion Error" << endl
                << "1 0.3" << endl;
    rebuild_dat << "# Calculate coefficients of variation (1=Yes)" << endl
                << 0 << endl;
    rebuild_dat << "# Number of replicates to use" << endl
                << 10 << endl;
    rebuild_dat << "# Random number seed" << endl
                << -99004 << endl;
    rebuild_dat << "# File with multiple parameter vectors " << endl
                << "rebuild.SSO" << endl;
    rebuild_dat << "# User-specific projection (1=Yes); Output replaced (1->9)" << endl
                << "0  5" << endl;
    rebuild_dat << "# Catches and Fs (Year; 1/2/3 (F or C or SPR); value); Final row is -1" << endl;
    rebuild_dat << k << " 1 1" << endl
                << "-1 -1 -1" << endl;
    rebuild_dat << "# Fixed catch project (1=Yes); Output replaced (1->9); Approach (-1=Read in else 1-9)" << endl;
    rebuild_dat << "0 2 -1" << endl;
    rebuild_dat << "# (48a) Special catch options (1-Yes) [CUT_OFF, Emsy, distribution, MAXCAT, Add, replace_code]" << endl
                << "0 0.18 1.00 1.00 0 6" << endl;
    rebuild_dat << "# (48b) B1Target" << endl
                << 150000 << endl;
    tempvec_a(1, Nfleet) = colsum(Fcast_RelF_Use);
    rebuild_dat << "# Split of Fs" << endl;
    rebuild_dat << Rebuild_Yinit << " ";
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        rebuild_dat << " " << tempvec_a(f) << endl;
      }
    rebuild_dat << "-1 ";
    for (f = 1; f <= Nfleet; f++)
      rebuild_dat << " 1";
    rebuild_dat << endl;
    rebuild_dat << "# Yrs to define T_target for projection type 4 (a.k.a. 5 pre-specified inputs)" << endl;
    rebuild_dat << endyr + 6 << " " << endyr + 7 << " " << endyr + 8 << " " << endyr + 9 << " " << endyr + 10 << " " << endl;
    rebuild_dat << "# Year for probability of recovery" << endl;
    rebuild_dat << endyr + 10 << " " << endyr + 11 << " " << endyr + 12 << " " << endyr + 13 << " " << endyr + 14 << " " << endyr + 15 << " " << endyr + 16 << " " << endyr + 17 << endl;
    rebuild_dat << "# Time varying weight-at-age (1=Yes;0=No)" << endl
                << 0 << endl;
    rebuild_dat << "# File with time series of weight-at-age data" << endl
                << "none" << endl;
    rebuild_dat << "# Use bisection (0) or linear interpolation (1)" << endl
                << 1 << endl;
    rebuild_dat << "# Target Depletion" << endl
                << 0.4 << endl;
    rebuild_dat << "# CV of implementation error" << endl
                << 0 << endl;
  }
  } //  end output of rebuilding quantities

FUNCTION void write_SIStable() //Note: deprecated, but add a message for now.
  {
  SIS_table.open(sso_pathname + "SIS_table.sso");
  SIS_table << "Note: SIS_table.sso is deprecated, please use the r4ss function get_SIS_info() instead" << endl;
  }
//********************************************************************
 /*  SS_Label_FUNCTION 41 write_Bzero_output */
FUNCTION void write_Bzero_output()
  {
  //  output annual time series for beginning of year and summing across areas for each GP and gender
  if (SS2out.is_open())
    SS2out.close();
  SS2out.open(report_sso_filename, ios::app);
  for (fishery_on_off = 1; fishery_on_off >= 0; fishery_on_off--)
  {

    /*
   in first pass, fishery is on (1) so just report current values
   in second pass, rerun the time series with no fishery, then do the same reporting
   */
    SS2out << endl
           << pick_report_name(59) << endl;
    SS2out << "Spawning_Biomass_Report";
    if (fishery_on_off == 0)
    {
      SS2out << "_1 No_fishery_for_Z=M_and_dynamic_Bzero";
    }
    else
    {
      SS2out << "_2 With_fishery";
    }
    SS2out << endl
           << "Yr Area: ";
    for (p = 1; p <= pop; p++)
      for (gp = 1; gp <= N_GP; gp++)
      {
        SS2out << p << " ";
      }
    SS2out << endl
           << "xxxx GP: ";
    for (p = 1; p <= pop; p++)
      for (gp = 1; gp <= N_GP; gp++)
      {
        SS2out << gp << " ";
      }
    SS2out << endl;

    if (fishery_on_off == 0)
    {
      setup_recdevs();
      get_initial_conditions();
      get_time_series(); //  in write_big_report

      if (Do_Forecast > 0)
      {
        show_MSY = 0;
        report5 << "#" << endl
                << " FORECAST: in Bzero report with fishery onoff= " << fishery_on_off << endl;
        Get_Forecast();
      }
    }

    for (y = styr - 2; y <= YrMax; y++)
    {
      SS2out << y;
      if (y == styr - 2)
      {
        SS2out << " VIRG ";
      }
      else if (y == styr - 1)
      {
        SS2out << " INIT ";
      }
      else if (y <= endyr)
      {
        SS2out << " TIME ";
      }
      else
      {
        SS2out << " FORE ";
      }
      for (p = 1; p <= pop; p++)
        for (gp = 1; gp <= N_GP; gp++)
        {
          SS2out << " " << SSB_pop_gp(y, p, gp);
        }
      SS2out << endl;
    }

    SS2out << endl
           << "NUMBERS_AT_AGE_Annual";
    if (fishery_on_off == 0)
    {
      SS2out << "_1 No_fishery_for_Z=M_and_dynamic_Bzero";
    }
    else
    {
      SS2out << "_2 With_fishery";
    }
    SS2out << endl;
    SS2out << "Bio_Pattern Sex Yr " << age_vector << endl;
    dvector tempvec2(1, nages); // holds summed survivors
    tempvec2.initialize();
    for (gg = 1; gg <= gender; gg++)
      for (gp = 1; gp <= N_GP; gp++)
        for (y = styr; y <= YrMax; y++)
        {
          tempvec_a.initialize();
          t = styr + (y - styr) * nseas; // first season only
          for (p = 1; p <= pop; p++)
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0 && GP4(g) == gp && sx(g) == gg)
              {
                tempvec_a += value(natage(t, p, g));
                if (nseas > 1)
                {
                  //  add in age 0 fish recruiting in later seasons
                  for (s = 2; s <= nseas; s++)
                    if (Bseas(g) == s)
                      tempvec_a(0) += value(natage(t + s - 1, p, g, 0));
                }
              }
          SS2out << gp << " " << gg << " " << y << " " << tempvec_a << endl;
        }
    SS2out << endl
           << "Z_AT_AGE_Annual";
    if (fishery_on_off == 0)
    {
      SS2out << "_1 No_fishery_for_Z=M_and_dynamic_Bzero";
    }
    else
    {
      SS2out << "_2 With_fishery";
    }
    if (Hermaphro_Option != 0)
      SS2out << ";_hermaphrodites_combined_sex_output";
    if (N_pred > 0 && fishery_on_off == 0)
      SS2out << ";_reported_M_includes_PredM2";
    SS2out << endl;
    SS2out << "Bio_Pattern Sex Yr " << age_vector << endl;
    for (gg = 1; gg <= gender; gg++)
      for (gp = 1; gp <= N_GP; gp++)
      {
        tempvec2.initialize();
        for (y = styr; y <= YrMax; y++)
        {
          tempvec_a.initialize();
          t = styr + (y - styr) * nseas; // first season only
          for (p = 1; p <= pop; p++)
            for (g = 1; g <= gmorph; g++)
              if (use_morph(g) > 0 && GP4(g) == gp && sx(g) == gg)
              {
                tempvec_a += value(natage(t, p, g));
                if (nseas > 1)
                {
                  for (s = 2; s <= nseas; s++)
                    if (Bseas(g) == s)
                    {
                      tempvec_a(0) += value(natage(t + s - 1, p, g, 0));
                    }
                }
              }
          if (y > styr)
          {
            SS2out << gp << " " << gg << " " << y - 1 << " " << log(elem_div(tempvec2(1, nages), tempvec_a(1, nages))) << " _ " << endl;
          }
          for (a = 0; a <= nages - 1; a++)
            tempvec2(a + 1) = value(tempvec_a(a));
          tempvec2(nages) += value(tempvec_a(nages));
        }
      }

    SS2out << endl
           << "Report_Z_by_area_morph_platoon";
    if (fishery_on_off == 0)
    {
      SS2out << "_1 No_fishery_for_Z=M_and_dynamic_Bzero";
    }
    else
    {
      SS2out << "_2 With_fishery";
    }
    SS2out << endl;
    SS2out << "Area Bio_Pattern Sex BirthSeas Settlement Platoon Morph Yr Seas Time Beg/Mid Era" << age_vector << endl;
    for (p = 1; p <= pop; p++)
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (y = styr - 2; y <= YrMax; y++)
            for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              temp = double(y) + azero_seas(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " _ ";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Z_rate(t, p, g) << endl;
            }
        }
  }
  SS2out << " Note:  Z calculated as -ln(Nt+1 / Nt)" << endl;
  SS2out << " Note:  Z calculation for maxage not possible, for maxage-1 includes numbers at maxage, so is approximate" << endl;
  if (nseas > 1)
    SS2out << " Z for age zero fish is not correct here if recruitment occurs in season after season 1" << endl;

  fishery_on_off = 1;
  /*
    SS2out<<endl<<"Report_Z_by_area_morph_platoon"<<endl;

    for (fishery_on_off=1;fishery_on_off>=0;fishery_on_off--)
    {
    if(fishery_on_off==0) {SS2out<<"_1 No_fishery_for_Z=M";} else {SS2out<<"_2 With_fishery";}
      save_gparm=0;
        setup_recdevs();
        get_initial_conditions();
        get_time_series();  //  in write_big_report
        if(Do_Forecast>0)
        {
          show_MSY=0;
          report5<<"#"<<endl<<" FORECAST: in M & Z report with fishery onoff= "<<fishery_on_off<<endl;
          Get_Forecast();
        }
    SS2out <<endl<<"Area Bio_Pattern Sex BirthSeas Settlement Platoon Morph Yr Seas Time Beg/Mid Era"<<age_vector <<endl;
    for (p=1;p<=pop;p++)
    for (g=1;g<=gmorph;g++)
    if(use_morph(g)>0)
      {
      for (y=styr-2;y<=YrMax;y++)
      for (s=1;s<=nseas;s++)
      {
       t = styr+(y-styr)*nseas+s-1;
       temp=double(y)+azero_seas(s);
       SS2out <<p<<" "<<GP4(g)<<" "<<sx(g)<<" "<<Bseas(g)<<" "<<settle_g(g)<<" "<<GP2(g)<<" "<<g<<" "<<y<<" "<<s<<" "<<temp<<" _ ";
       if(y==styr-2)
         {SS2out<<" VIRG ";}
       if(y==styr-1)
         {SS2out<<" INIT ";}
       else if (y<=endyr)
         {SS2out<<" TIME ";}
       else
         {SS2out<<" FORE ";}
       SS2out<<Z_rate(t,p,g)<<endl;
      }
      }
    }
  */
  return;
  } //  end write Z report

//********************************************************************
 /*  SS_Label_FUNCTION 28 Report_Parm */
FUNCTION void Report_Parm(const int NParm, const int AC, const int Activ, const prevariable& Pval, const double& Pmin, const double& Pmax, const double& RD, const double& Jitter, const double& PR, const double& CV, const int PR_T, const int PH, const prevariable& Like)
  {
  dvar_vector parm_val(1, 14);
  dvar_vector prior_val(1, 14);
  int i;
  dvariable parmvar, parmgrad;
  parmvar = 0.0;
  parmgrad = 0.0;
  SS2out << NParm << " " << ParmLabel(NParm) << " " << Pval;
  if (Activ > 0)
  {
    parmvar = CoVar(AC, 1);
    parmgrad = parm_gradients(AC);

    SS2out << " " << AC << " " << PH << " " << Pmin << " " << Pmax << " " << RD << " " << Jitter;
    if (Pval == RD)
    {
      SS2out << " NO_MOVE ";
    }
    else
    {
      temp = (Pval - Pmin) / (Pmax - Pmin);
      if (temp == 0.0 || temp == 1.0)
      {
        SS2out << " BOUND ";
        Nparm_on_bound++;
      }
      else if (temp < 0.01)
      {
        SS2out << " LO ";
        Nparm_on_bound++;
      }
      else if (temp >= 0.99)
      {
        SS2out << " HI ";
        Nparm_on_bound++;
      }
      else
      {
        SS2out << " OK ";
      }
    }
    SS2out << " " << parmvar;

    SS2out << " " << parmgrad;
  }
  else
  {
    SS2out << " _ " << PH << " " << Pmin << " " << Pmax << " " << RD << " " << Jitter << " NA _ _ ";
  }
  if (PR_T > 0)
  {
    switch (PR_T)
    {
      case 6:
      {
        SS2out << " Normal ";
        break;
      }
      case 1:
      {
        SS2out << " Sym_Beta ";
        break;
      }
      case 2:
      {
        SS2out << " Full_Beta ";
        break;
      }
      case 3:
      {
        SS2out << " Log_Norm ";
        break;
      }
      case 4:
      {
        SS2out << " Log_Norm_w/biasadj ";
        break;
      }
      case 5:
      {
        SS2out << " Gamma ";
        break;
      }
    }
    SS2out << " " << PR << " " << CV << " " << Like << " ";
    i = 1;
    parm_val(i) = Pval;
    prior_val(i) = Get_Prior(PR_T, Pmin, Pmax, PR, CV, Pval);
    i = 2;
    temp = Pval - 1.96 * parmvar;
    if (temp < Pmin)
      temp = Pmin;
    parm_val(i) = temp;
    prior_val(i) = Get_Prior(PR_T, Pmin, Pmax, PR, CV, temp);

    i = 3;
    temp = Pval + 1.96 * parmvar;
    if (temp > Pmax)
      temp = Pmax;
    parm_val(i) = temp;
    prior_val(i) = Get_Prior(PR_T, Pmin, Pmax, PR, CV, temp);

    i = 4;
    temp = Pmin + 0.01 * (Pmax - Pmin);
    parm_val(i) = temp;
    prior_val(i) = Get_Prior(PR_T, Pmin, Pmax, PR, CV, temp);
    i = 14;
    temp = Pmax - 0.01 * (Pmax - Pmin);
    parm_val(i) = temp;
    prior_val(i) = Get_Prior(PR_T, Pmin, Pmax, PR, CV, temp);

    for (int i = 5; i <= 13; i++)
    {
      temp = Pmin + float(i - 4) / 10.0 * (Pmax - Pmin);
      parm_val(i) = temp;
      prior_val(i) = Get_Prior(PR_T, Pmin, Pmax, PR, CV, temp);
    }
    SS2out << parm_val << " " << prior_val;
  }
  else
  {
    SS2out << " No_prior ";
  }
  SS2out << endl;
  }

// SS_Label_file  #18. **SS_write_ssnew.tpl**
// SS_Label_file  # * <u>write_nudata()</u>  //  produces *starter.ss_new*, *forecast.ss_new*, *data_echo.ss_new*, *data_expval.ss*, bootstraps
// SS_Label_file  # * <u>write_nucontrol()</u>  //  produces *control.ss_new*
// SS_Label_file  #

//********************************************************************
 /*  SS_Label_FUNCTION 38 write_nudata */
FUNCTION void write_nudata()
  {
  //  code for multinomial distribution developed by Ian Stewart, Oct 2005

  dvector temp_mult(1, 50000);
  dvector temp_probs(1, nlen_bin2);
  int compindex = 0;
  dvector temp_probs2(1, n_abins2);
  int Nudat = 0;
  int Nubootdat = 0;
  int Nsamp_DM = 0;
  adstring newdatfilename;
  adstring datinfostring;
  //  create bootstrap data files; except first file just replicates the input and second is the estimate without error
  if (irand_seed < 0)
    irand_seed = long(time(&start));

  random_number_generator radm(irand_seed);
  for (i = 1; i <= 1234; i++)
  {
    temp = randn(radm);
  }

  for (Nudat = 1; Nudat <= N_nudata; Nudat++)
  {
    if (Nudat == 1)
    {
      echoinput << "Begin writing data_echo.ss_new file" << endl;
      newdatfilename = "data_echo.ss_new";
	    datinfostring = "echo_input_data";
    }
    else if (Nudat == 2)
    {
      echoinput << "Begin writing data_expval.ss file" << endl;
      newdatfilename = "data_expval.ss";
	    datinfostring = "expected_values";
    }
    else // data_boot files
    {
      echoinput << "Begin writing bootstrap data file(s)" << endl;
      Nubootdat = Nudat - 2;
      anystring2 = "     ";
      sprintf(anystring2, "%d", Nubootdat);
      if (Nubootdat < 10)
      {
        newdatfilename = "data_boot_00" + anystring2 + ".ss";
      }
      else if (Nubootdat < 100)
      {
        newdatfilename = "data_boot_0" + anystring2 + ".ss";
      }
      else // Nubootdat > 99
      {
        newdatfilename = "data_boot_" + anystring2 + ".ss";
      }
	    datinfostring = "bootstrap";
    }
    anystring = ssnew_pathname + newdatfilename;
    report1.open(anystring);
    report1 << version_info(1) << version_info(2) << version_info(3) << endl
            << version_info2 << endl
            << "#_Start_time: " << ctime(&start);
    report1 << "#_" << datinfostring << endl;
    report1 << Data_Comments << endl;
	if (Nudat > 2)
	  report1 << "#_bootstrap file: " << Nubootdat << "  irand_seed: " << irand_seed << " first rand#: " << randn(radm) << endl;

    report1 << version_info(1) << version_info(2) << version_info(3) << endl;
    report1 << styr << " #_StartYr" << endl;
    report1 << endyr << " #_EndYr" << endl;
    report1 << nseas << " #_Nseas" << endl;
    report1 << 12. * seasdur << " #_months/season" << endl;
    report1 << N_subseas << " #_Nsubseasons (even number, minimum is 2)" << endl;
    report1 << spawn_month << " #_spawn_month" << endl;
    report1 << gender_rd << " #_Nsexes: 1, 2, -1  (use -1 for 1 sex setup with SSB multiplied by female_frac parameter)" << endl;
    report1 << nages << " #_Nages=accumulator age, first age is always age 0" << endl;
    report1 << pop << " #_Nareas" << endl;
    report1 << Nfleet << " #_Nfleets (including surveys)" << endl;
    report1 << "#_fleet_type: 1=catch fleet; 2=bycatch only fleet; 3=survey; 4=predator(M2) " << endl;
    report1 << "#_sample_timing: -1 for fishing fleet to use season-long catch-at-age for observations, or 1 to use observation month;  (always 1 for surveys)" << endl;
    report1 << "#_fleet_area:  area the fleet/survey operates in " << endl;
    report1 << "#_units of catch:  1=bio; 2=num (ignored for surveys; their units read later)" << endl;
    report1 << "#_catch_mult: 0=no; 1=yes" << endl;
    report1 << "#_rows are fleets" << endl
            << "#_fleet_type fishery_timing area catch_units need_catch_mult fleetname" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      report1 << fleet_setup(f) << " " << fleetname(f) << "  # " << f << endl;
    }
    report1 << "#Bycatch_fleet_input_goes_next" << endl;
    report1 << "#a:  fleet index" << endl;
    report1 << "#b:  1=include dead bycatch in total dead catch for F0.1 and MSY optimizations and forecast ABC; 2=omit from total catch for these purposes (but still include the mortality)" << endl;
    report1 << "#c:  1=Fmult scales with other fleets; 2=bycatch F constant at input value; 3=bycatch F from range of years" << endl;
    report1 << "#d:  F or first year of range" << endl;
    report1 << "#e:  last year of range" << endl;
    report1 << "#f:  not used" << endl;
    report1 << "# a   b   c   d   e   f " << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (fleet_type(f) == 2)
        report1 << bycatch_setup(f) << "  # " << fleetname(f) << endl;
    }

    if (Nudat == 1) // report back the input data
    {

      report1 << "#_Catch data: year, seas, fleet, catch, catch_se" << endl;
      report1 << "#_catch_se:  standard error of log(catch)" << endl;
      report1 << "#_NOTE:  catch data is ignored for survey fleets" << endl;
      k = 0;
      for (f = 1; f <= Nfleet; f++)
      {
        if (fleet_type(f) <= 2)
        {
          for (y = styr - 1; y <= endyr; y++)
          {
            for (s = 1; s <= nseas; s++)
            {
              k++;
              t = styr + (y - styr) * nseas + s - 1;
              if (y == styr - 1)
              {
                g = -999;
              }
              else
              {
                g = y;
              }
              report1 << g << " " << s << " " << f << " " << catch_ret_obs(f, t) << " " << catch_se(t, f) << endl;
            }
          }
        }
      }
      report1 << "-9999 0 0 0 0" << endl
              << "#" << endl;

      report1 << "#_CPUE_and_surveyabundance_and_index_observations" << endl;
      report1 << "#_units: 0=numbers; 1=biomass; 2=F; 30=spawnbio; 31=exp(recdev); 36=recdev; 32=spawnbio*recdev; 33=recruitment; 34=depletion(&see Qsetup); 35=parm_dev(&see Qsetup)" << endl;
      report1 << "#_errtype:  -1=normal; 0=lognormal; 1=lognormal with bias correction; >1=df for T-dist" << endl;
      report1 << "#_SD_report: 0=not; 1=include survey expected value with se" << endl;
      report1 << "#_note that link functions are specified in Q_setup section of control file" << endl;
      report1 << "#_dataunits = 36 and 35 should use Q_type 5 to provide offset parameter" <<endl;
      report1 << "#_fleet units errtype SD_report" << endl;
      for (f = 1; f <= Nfleet; f++)
        report1 << f << " " << Svy_units(f) << " " << Svy_errtype(f) << " " << Svy_sdreport(f) << " # " << fleetname(f) << endl;
      report1 << "#_year month fleet obs stderr" << endl;

      if (Svy_N > 0)
        for (f = 1; f <= Nfleet; f++)
          for (i = 1; i <= Svy_N_fleet(f); i++)
          {
            t = Svy_time_t(f, i);
            ALK_time = Svy_ALK_time(f, i);
            report1 << Show_Time(t, 1) << " " << Svy_super(f, i) * data_time(ALK_time, f, 1) << " " << f * Svy_use(f, i) << " ";
            report1 << Svy_obs(f, i) << " " << Svy_se_rd(f, i) << " #_ " << fleetname(f) << endl;
          }
      report1 << "-9999 1 1 1 1 # terminator for survey observations " << endl;

      report1 << "#" << endl
              << Ndisc_fleets << " #_N_fleets_with_discard" << endl;
      report1 << "#_discard_units (1=same_as_catchunits(bio/num); 2=fraction; 3=numbers)" << endl;
      report1 << "#_discard_errtype:  >0 for DF of T-dist(read CV below); 0 for normal with CV; -1 for normal with se; -2 for lognormal; -3 for trunc normal with CV" << endl;
      report1 << "# note: only enter units and errtype for fleets with discard " << endl;
      report1 << "# note: discard data is the total for an entire season, so input of month here must be to a month in that season" << endl;
      report1 << "#_fleet units errtype" << endl;
      if (Ndisc_fleets > 0)
      {
        for (f = 1; f <= Nfleet; f++)
          if (disc_units(f) > 0)
            report1 << f << " " << disc_units(f) << " " << disc_errtype(f) << " # " << fleetname(f) << endl;
        report1 << "#_year month fleet obs stderr" << endl;
        for (f = 1; f <= Nfleet; f++)
          for (i = 1; i <= disc_N_fleet(f); i++)
          {
            ALK_time = disc_time_ALK(f, i);
            report1 << Show_Time(disc_time_t(f, i), 1) << " " << yr_disc_super(f, i) * data_time(ALK_time, f, 1) << " " << f * yr_disc_use(f, i) << " ";
            report1 << obs_disc(f, i) << " " << cv_disc(f, i) << " #_ " << fleetname(f) << endl;
          }
      }
      else
      {
        report1 << "# ";
      }
      report1 << "-9999 0 0 0.0 0.0 # terminator for discard data " << endl;

      report1 << "#" << endl
              << do_meanbodywt << " #_use meanbodysize_data (0/1)" << endl;
      if (nobs_mnwt_rd == 0)
        report1 << "#_COND_";
      report1 << DF_bodywt << " #_DF_for_meanbodysize_T-distribution_like" << endl;
      report1 << "# note:  type=1 for mean length; type=2 for mean body weight " << endl;
      report1 << "#_year month fleet part type obs stderr" << endl;
      if (nobs_mnwt > 0)
      {
        for (i = 1; i <= nobs_mnwt; i++)
        {
          f = abs(mnwtdata(3, i));
          report1 << Show_Time(mnwtdata(1, i), 1) << " " << mnwtdata(2, i) << " " << mnwtdata(3, i) << " " << mnwtdata(4, i) << " " << mnwtdata(5, i) << " " << mnwtdata(6, i) << " " << mnwtdata(7, i) - var_adjust(3, f) << " #_ " << fleetname(f) << endl;
        }
      }
      if (do_meanbodywt == 0)
        report1 << "# ";
      report1 << " -9999 0 0 0 0 0 0 # terminator for mean body size data " << endl;

      report1 << "#" << endl
              << "# set up population length bin structure (note - irrelevant if not using size data and using empirical wtatage" << endl;
      report1 << LenBin_option << " # length bin method: 1=use databins; 2=generate from binwidth,min,max below; 3=read vector" << endl;
      if (LenBin_option == 1)
      {
        report1 << "# no additional input for option 1" << endl;
        report1 << "# read binwidth, minsize, lastbin size for option 2" << endl;
        report1 << "# read N poplen bins, then vector of bin lower boundaries, for option 3" << endl;
      }
      else if (LenBin_option == 2)
      {
        report1 << binwidth2 << " # binwidth for population size comp " << endl;
        report1 << minLread << " # minimum size in the population (lower edge of first bin and size at age 0.00) " << endl;
        report1 << maxLread << " # maximum size in the population (lower edge of last bin) " << endl;
      }
      else
      {
        report1 << nlength << " # number of population size bins " << endl;
        report1 << len_bins << endl;
      }

      report1 << use_length_data << " # use length composition data (0/1/2) where 2 invokes new comp_control format" << endl;
      if (use_length_data > 0)
      {
        report1 << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
        report1 << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
        report1 << "#_combM+F: males and females treated as combined sex below this bin number " << endl;
        report1 << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
        report1 << "#_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
        report1 << "#_ParmSelect:  consecutive index for dirichlet or MV_Tweedie" << endl;
        report1 << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;
        report1 << "#" << endl;
        if(use_length_data == 1)
        {
          report1 << "#_Using old format for composition controls" << endl;
        report1 << "#_mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
        for (f = 1; f <= Nfleet; f++)
        {
          report1 << min_tail_L(0, f) << " " << min_comp_L(0, f) << " " << CombGender_L(0, f) << " " << AccumBin_L(0, f) << " " << Comp_Err_L(0, f) << " " << Comp_Err_L2(0, f) << " " << min_sample_size_L(0, f) << " #_fleet:" << f << "_" << fleetname(f) << endl;
        }
        }
        else if (use_length_data == 2)
        {
          report1 << "#_Using new list format for composition controls" << endl;
          report1 << "#_use negative fleet value to fill for all higher numbered fleets (recommended!)" << endl;
          report1 << "#_must enter in fleet, partition order; but only need to enter for used combos" << endl;
          report1 << "#_fleet = -9999 to terminate list" << endl;
          report1 << "#_fleet partition mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
          for (int i = 0; i <= comp_control_L_count; i++)
            report1 << comp_control_L[i] << endl;
        }

        report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
        report1 << "# partition codes:  (0=combined; 1=discard; 2=retained" << endl;
        report1 << nlen_bin << " #_N_LengthBins; then enter lower edge of each length bin" << endl
                << len_bins_dat << endl;
        //  report1<<nobsl_rd<<" #_N_Length_obs"<<endl;
        report1 << "#_year month fleet sex part Nsamp datavector(female-male)" << endl;
        if (nobsl_rd > 0)
        {
          for (i = 0; i <= nobsl_rd - 1; i++)
          {
            report1 << lendata[i] << endl;
          }
        }
        report1 << -9999. << " ";
        for (j = 2; j <= 6 + nlen_bin2; j++)
          report1 << "0 ";
        report1 << endl;
      }
      else
      {
        report1 << "# see manual for format of length composition data " << endl;
      }

      report1 << "#" << endl
              << n_abins << " #_N_age_bins" << endl;
      if (n_abins > 0)
      {
        report1 << age_bins1 << endl;
      }
      else
      {
        report1 << "# ";
      }
      report1 << N_ageerr << " #_N_ageerror_definitions" << endl;
      if (N_ageerr > 0)
        report1 << age_err_rd << endl;

      report1 << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
      report1 << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
      report1 << "#_combM+F: males and females treated as combined sex below this bin number " << endl;
      report1 << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
      report1 << "#_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
      report1 << "#_ParmSelect:  consecutive index for dirichlet or MV_Tweedie" << endl;
      report1 << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;
      report1 << "#" << endl;
      report1 << "#_mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
      for (f = 1; f <= Nfleet; f++)
      {
        if (n_abins <= 0)
          report1 << "# ";
        report1 << min_tail_A(f) << " " << min_comp_A(f) << " " << CombGender_A(f) << " " << AccumBin_A(f) << " " << Comp_Err_A(f) << " " << Comp_Err_A2(f) << " " << min_sample_size_A(f) << " #_fleet:" << f << "_" << fleetname(f) << endl;
      }

      if (n_abins <= 0)
        report1 << "# ";
      report1 << Lbin_method << " #_Lbin_method_for_Age_Data: 1=poplenbins; 2=datalenbins; 3=lengths" << endl;
      report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
      report1 << "# partition codes:  (0=combined; 1=discard; 2=retained" << endl;
      report1 << "#_year month fleet sex part ageerr Lbin_lo Lbin_hi Nsamp datavector(female-male)" << endl;
      if (nobsa_rd > 0)
      {
        for (i = 0; i <= nobsa_rd - 1; i++)
        {
          report1 << Age_Data[i] << endl;
        }
      }
      f = exp_a_temp.size() + 8;
      if (n_abins <= 0)
        report1 << "# ";
      report1 << "-9999 ";
      for (i = 1; i <= f; i++)
        report1 << " 0";
      report1 << endl;

      report1 << "#" << endl
              << use_meansizedata << " #_Use_MeanSize-at-Age_obs (0/1)" << endl;
      if (use_meansizedata > 0)
      {
        report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
        report1 << "# partition codes:  0=combined; 1=discard; 2=retained" << endl;
        report1 << "# ageerr codes:  positive means mean length-at-age; negative means mean bodywt_at_age" << endl;
        report1 << "#_year month fleet sex part ageerr ignore datavector(female-male)" << endl;
        report1 << "#                                          samplesize(female-male)" << endl;
        if (nobs_ms_rd > 0)
        {
          if (finish_starter == 999)
          {
            for (i = 1; i <= nobs_ms_rd; i++)
            {
              report1 << sizeAge_Data[i] << endl;
            }
          }
          else
          {
            for (i = 0; i <= nobs_ms_rd - 1; i++)
            {
              report1 << sizeAge_Data[i] << endl;
            }
          }
          report1 << "-9999 ";
          for (j = 1; j <= 6 + 2 * n_abins2; j++)
            report1 << " 0";
          report1 << endl;
        }
      }

      report1 << "#" << endl
              << N_envvar << " #_N_environ_variables" << endl;
      report1 << "# -2 in year will subtract mean for that env_var; -1 will subtract mean and divide by stddev (e.g. Z-score)" << endl;
      report1 << "#_year variable value" << endl;
      if (N_envvar > 0)
      {
        for (i = 0; i <= N_envdata - 1; i++)
          report1 << env_temp[i] << endl;
        report1 << "-9999 0 0" << endl;
      }

      report1 << "#" << endl << "# Sizefreq data. Defined by method because a fleet can use multiple methods" << endl;
      report1 << SzFreq_Nmeth_rd << " # N sizefreq methods to read (or -1 for expanded options)" << endl;
      if (SzFreq_Nmeth_rd < 0) {
        report1 << SzFreq_Nmeth << " # N sizefreq methods to read" << endl;
      }
      if (SzFreq_Nmeth != 0)
      {
        report1 << "# each row below has entry for each sizefreq method " << endl;
        report1 << "#_ ";
        for (int j = 1; j <= SzFreq_Nmeth; j++ )
          { report1 << j << " ";}
        report1 << " # Method" << endl;
        report1 << SzFreq_Nbins << " #_Sizefreq N bins" << endl;
        report1 << SzFreq_units << " #_Sizefreq units(1=bio/2=num)" << endl;
        report1 << SzFreq_scale << " #_Sizefreq scale(1=kg/2=lbs/3=cm/4=inches)" << endl;
        report1 << SzFreq_mincomp << " #_Sizefreq:  small constant to add to comps" << endl;
        report1 << SzFreq_nobs << " #_Sizefreq number of obs per method" << endl;
        if (SzFreq_Nmeth_rd < 0) {
          report1 << Comp_Err_Sz <<  " #_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
          report1 << Comp_Err_Sz2 << " #_ParmSelect: consecutive index for dirichlet or MV_Tweedie comp_error" << endl;
        }
        report1 << "#_Sizefreq bins. one row for each method" << endl
                << "#Note: negative value for first bin makes it accumulate all smaller fish vs. truncate small fish" << endl;
        for (i = 1; i <= SzFreq_Nmeth; i++)
        { report1 << SzFreq_Omit_Small(i) * SzFreq_bins1(i, 1) << SzFreq_bins1(i)(2, SzFreq_Nbins(i)) << endl; }
        report1 << "#_method year month fleet sex part Nsamp <data> " << endl << SzFreq_obs1 << endl;
      }

      // begin tagging data section #1 (observed data)
      report1 << "# " << endl
              << Do_TG_rd << " # do tags (0/1/2); where 2 allows entry of TG_min_recap" << endl;
      if (Do_TG_rd > 0)
      {
        // info on dimensions of tagging data
        report1 << N_TG << " # N tag groups" << endl;
        report1 << N_TG_recap << " # N recap events" << endl;
        report1 << TG_mixperiod << " # TG_mixperiod ## (latency) is the first period in which logL is calculated for this tag group (0 = release period)" << endl;
        report1 << TG_maxperiods << " # max periods ##  to track recaptures (units=seasons), after which tags are still read into this accumulator period" << endl;
        if (Do_TG_rd == 2)
        {
          report1 << TG_min_recap << " # TG_min_recap ## tag group's N recaps >=mixperiod must be >= min_recap to include tag group in logL)" << endl;
        }
        else
        {
          report1 << "# COND:  TG_min_recap ##  use Do_TG=2 to invoke reading TG_min_recap after TG_maxperiods" << endl;
        }

        // tag releases
        report1 << "# Release data for each tag group.  Tags are considered to be released at the beginning of a season (period)" << endl;
        report1 << "#<TG> area year seas <tfill> sex age Nrelease  (note that the TG and tfill values are placeholders and are replaced by program generated values)" << endl;
        report1 << TG_release << endl;

        // tag recaptures
        report1 << "#_TG year seas fleet Nrecap" << endl;
        for (j = 1; j <= N_TG_recap; j++)
        {
          // fill in first 4 columns:
          for (k = 1; k <= 5; k++)
            report1 << TG_recap_data(j, k) << " ";
          report1 << endl;
        }
      }
      // end tagging data section #1 (observed data)

      report1 << "#" << endl
              << Do_Morphcomp << " #    morphcomp data(0/1) " << endl;
      if (Do_Morphcomp > 0)
      {
        report1 << Morphcomp_nobs_rd << "  #  Nobs" << endl;
        report1 << Morphcomp_nmorph << " # Nmorphs" << endl;
        report1 << Morphcomp_mincomp << " # add_to_comp" << endl;
        report1 << "#_year, month, fleet, null, Nsamp, datavector_by_Nmorphs" << endl;
        for (i = 1; i <= Morphcomp_nobs_rd; i++)
        {
          report1 << Morphcomp_obs_rd << endl;
        }
      }
      else
      {
        report1 << "#  Nobs, Nmorphs, mincomp" << endl;
        report1 << "#_year, seas, type, partition, Nsamp, datavector_by_Nmorphs" << endl;
      }

      report1 << "#" << endl
              << Do_SelexData << "  #  Do dataread for selectivity priors(0/1)" << endl;
      report1 << "#_year, seas, fleet, age/size, bin, selex_prior, prior_sd" << endl;
      report1 << "# feature not yet implemented" << endl;

      report1 << "#" << endl
              << "999" << endl
              << endl;
    }

    else if (Nudat == 2) // report expected value with no added error
    {

      report1 << "#_Catch data: year, seas, fleet, catch, catch_se" << endl;
      report1 << "#_catch_se:  standard error of log(catch)" << endl;
      report1 << "#_NOTE:  catch data is ignored for survey fleets" << endl;
      k = 0;
      for (f = 1; f <= Nfleet; f++)
      {
        if (fleet_type(f) <= 2)
        {
          for (y = styr - 1; y <= endyr; y++)
          {
            for (s = 1; s <= nseas; s++)
            {
              k++;
              t = styr + (y - styr) * nseas + s - 1;
              if (y == styr - 1)
              { report1 << -999 << " "; }
              else
              { report1 << y << " "; }
              report1 << s << " " << f << " ";
                if (fleet_type(f) == 2 && catch_ret_obs(f, t) > 0.0)
                {
                  report1 << 0.1 << " " << catch_se(t, f) << endl; //  for bycatch only fleet
                }
                else if (catchunits(f) == 1)
                {
                  report1 << catch_fleet(t, f, 3) << " " << catch_se(t, f) << endl;
                }
                else
                {
                  report1 << catch_fleet(t, f, 6) << " " << catch_se(t, f) << endl;
                }
            }
          }
        }
      }
      report1 << "-9999 0 0 0 0" << endl
              << "#" << endl;

      report1 << "#_CPUE_and_surveyabundance_and_index_observations" << endl;
      report1 << "#_units: 0=numbers; 1=biomass; 2=F; 30=spawnbio; 31=exp(recdev); 36=recdev; 32=spawnbio*recdev; 33=recruitment; 34=depletion(&see Qsetup); 35=parm_dev(&see Qsetup)" << endl;
      report1 << "#_errtype:  -1=normal; 0=lognormal; 1=lognormal with bias correction; >1=df for T-dist" << endl;
      report1 << "#_SD_report: 0=not; 1=include survey expected value with se" << endl;
      report1 << "#_note that link functions are specified in Q_setup section of control file" << endl;
      report1 << "#_dataunits = 36 and 35 should use Q_type 5 to provide offset parameter" <<endl;
      report1 << "#_fleet units errtype SD_report" << endl;
      for (f = 1; f <= Nfleet; f++)
        report1 << f << " " << Svy_units(f) << " " << Svy_errtype(f) << " " << Svy_sdreport(f) << " # " << fleetname(f) << endl;
      report1 << "#_year month index obs err" << endl;
      if (Svy_N > 0)
        for (f = 1; f <= Nfleet; f++)
          for (i = 1; i <= Svy_N_fleet(f); i++)
          {
            t = Svy_time_t(f, i);
            ALK_time = Svy_ALK_time(f, i);
            report1 << Show_Time(t, 1) << " " << Svy_super(f, i) * data_time(ALK_time, f, 1) << " " << f * Svy_use(f, i) << " ";
            if (Svy_errtype(f) == -1) // normal
            {
              report1 << Svy_est(f, i);
            }
            else if (Svy_errtype(f) == -2) // gamma 
            {
              //  need gamma here
            }
            else
            {
              report1 << mfexp(Svy_est(f, i));  //  lognormal or T-dist or lognormal w/bias
            } 
            report1 << " " << Svy_se_rd(f, i) << " #_orig_obs: " << Svy_obs(f, i) << " " << fleetname(f) << endl;
          }
      report1 << "-9999 1 1 1 1 # terminator for survey observations " << endl;

      report1 << "#" << endl
              << Ndisc_fleets << " #_N_fleets_with_discard" << endl;
      report1 << "#_discard_units (1=same_as_catchunits(bio/num); 2=fraction; 3=numbers)" << endl;
      report1 << "#_discard_errtype:  >0 for DF of T-dist(read CV below); 0 for normal with CV; -1 for normal with se; -2 for lognormal; -3 for trunc normal with CV" << endl;
      report1 << "# note: only enter units and errtype for fleets with discard " << endl;
      report1 << "# note: discard data is the total for an entire season, so input of month here must be to a month in that season" << endl;
      report1 << "#_fleet units errtype" << endl;
      if (Ndisc_fleets > 0)
      {
        for (f = 1; f <= Nfleet; f++)
          if (disc_units(f) > 0)
            report1 << f << " " << disc_units(f) << " " << disc_errtype(f) << " # " << fleetname(f) << endl;
        report1 << "#_year month fleet obs stderr" << endl;
        for (f = 1; f <= Nfleet; f++)
          if (disc_N_fleet(f) > 0)
            for (i = 1; i <= disc_N_fleet(f); i++)
            {
              ALK_time = disc_time_ALK(f, i);
              report1 << Show_Time(disc_time_t(f, i), 1) << " " << yr_disc_super(f, i) * data_time(ALK_time, f, 1) << " " << f * yr_disc_use(f, i) << " ";
              {
                report1 << exp_disc(f, i);
              }
              report1 << " " << cv_disc(f, i) << " #_orig_obs: " << obs_disc(f, i) << " #_ " << fleetname(f) << endl;
            }
      }
      else
      {
        report1 << "# ";
      }
      report1 << "-9999 0 0 0.0 0.0 # terminator for discard data " << endl;

      report1 << "#" << endl
              << do_meanbodywt << " #_use meanbodysize_data (0/1)" << endl;

      if (nobs_mnwt_rd == 0)
        report1 << "#_COND_";
      report1 << DF_bodywt << " #_DF_for_meanbodysize_T-distribution_like" << endl;
      report1 << "# note:  type=1 for mean length; type=2 for mean body weight " << endl;
      report1 << "#_year month fleet part type obs stderr" << endl;
      if (nobs_mnwt > 0)
      {
        for (i = 1; i <= nobs_mnwt; i++)
        {
          f = abs(mnwtdata(3, i));
          report1 << Show_Time(mnwtdata(1, i), 1) << " " << mnwtdata(2, i) << " " << mnwtdata(3, i) << " " << mnwtdata(4, i) << " " << mnwtdata(5, i) << " " << exp_mnwt(i) << " " << mnwtdata(7, i) - var_adjust(3, f) << " #_orig_obs: " << mnwtdata(6, i) << "  #_ " << fleetname(f) << endl;
        }
      }
      if (do_meanbodywt == 0)
        report1 << "# ";
      report1 << " -9999 0 0 0 0 0 0 # terminator for mean body size data " << endl;

      report1 << "#" << endl
              << "# set up population length bin structure (note - irrelevant if not using size data and using empirical wtatage" << endl;
      report1 << LenBin_option << " # length bin method: 1=use databins; 2=generate from binwidth,min,max below; 3=read vector" << endl;
      if (LenBin_option == 1)
      {
        report1 << "# no additional input for option 1" << endl;
        report1 << "# read binwidth, minsize, lastbin size for option 2" << endl;
        report1 << "# read N poplen bins, then vector of bin lower boundaries, for option 3" << endl;
      }
      else if (LenBin_option == 2)
      {
        report1 << binwidth2 << " # binwidth for population size comp " << endl;
        report1 << minLread << " # minimum size in the population (lower edge of first bin and size at age 0.00) " << endl;
        report1 << maxLread << " # maximum size in the population (lower edge of last bin) " << endl;
      }
      else
      {
        report1 << nlength << " # number of population size bins " << endl;
        report1 << len_bins << endl;
      }

      report1 << use_length_data << " # use length composition data (0/1/2) where 2 invokes new comp_comtrol format" << endl;
      if (use_length_data > 0)
      {
        report1 << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
        report1 << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
        report1 << "#_combM+F: males and females treated as combined sex below this bin number " << endl;
        report1 << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
        report1 << "#_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
        report1 << "#_ParmSelect:  consecutive index for dirichlet or MV_Tweedie" << endl;
        report1 << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;
        report1 << "#" << endl;
        if(use_length_data == 1)
        {
          report1 << "#_Using old format for composition controls" << endl;
        report1 << "#_mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
        for (f = 1; f <= Nfleet; f++)
        {
          report1 << min_tail_L(0, f) << " " << min_comp_L(0, f) << " " << CombGender_L(0, f) << " " << AccumBin_L(0, f) << " " << Comp_Err_L(0, f) << " " << Comp_Err_L2(0, f) << " " << min_sample_size_L(0, f) << " #_fleet:" << f << "_" << fleetname(f) << endl;
        }
        }
        else if (use_length_data == 2)
        {
          report1 << "#_Using new list format for composition controls" << endl;
          report1 << "#_use negative fleet value to fill for all higher numbered fleets (recommended!)" << endl;
          report1 << "#_must enter in fleet, partition order; but only need to enter for used combos" << endl;
          report1 << "#_fleet = -9999 to terminate list" << endl;
          report1 << "#_fleet partition mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
          for (int i = 0; i <= comp_control_L_count; i++)
            report1 << comp_control_L[i] << endl;
        }

        report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
        report1 << "# partition codes:  (0=combined; 1=discard; 2=retained" << endl;
        report1 << nlen_bin << " #_N_LengthBins" << endl
                << len_bins_dat << endl;
        //  report1<<sum(Nobs_l)<<" #_N_Length_obs"<<endl;
        report1 << "#_year month fleet sex part Nsamp datavector(female-male)" << endl;
        for (f = 1; f <= Nfleet; f++)
        {
          if (Nobs_l(f) > 0)
          {
            for (i = 1; i <= Nobs_l(f); i++)
            {
              k = 1000;
              if (nsamp_l(f, i) < k)
                k = nsamp_l(f, i);
              exp_l_temp_dat = nsamp_l(f, i) * value(exp_l(f, i) / sum(exp_l(f, i)));
              report1 << header_l_rd(f, i)(1, 3) << " " << gen_l(f, i) << " " << header_l_rd(f, i)(5) << " " << nsamp_l(f, i) << " " << exp_l_temp_dat << endl;
            }
          }
        }
        report1 << -9999. << " ";
        for (j = 2; j <= 6 + nlen_bin2; j++)
          report1 << "0 ";
        report1 << endl;
      }
      else
      {
        report1 << "# see manual for format of length composition data " << endl;
      }

      report1 << "#" << endl
              << n_abins << " #_N_age_bins" << endl;
      if (n_abins > 0)
      {
        report1 << age_bins1 << endl;
      }
      else
      {
        report1 << "# ";
      }
      report1 << N_ageerr << " #_N_ageerror_definitions" << endl;
      if (N_ageerr > 0)
        report1 << age_err_rd << endl;

      report1 << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
      report1 << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
      report1 << "#_combM+F: males and females treated as combined sex below this bin number " << endl;
      report1 << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
      report1 << "#_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
      report1 << "#_ParmSelect:  parm number for dirichlet or MV_Tweedie" << endl;
      report1 << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;
      report1 << "#" << endl;
      report1 << "#_mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
      for (f = 1; f <= Nfleet; f++)
      {
        if (n_abins <= 0)
          report1 << "# ";
        report1 << min_tail_A(f) << " " << min_comp_A(f) << " " << CombGender_A(f) << " " << AccumBin_A(f) << " " << Comp_Err_A(f) << " " << Comp_Err_A2(f) << " " << min_sample_size_A(f) << " #_fleet:" << f << "_" << fleetname(f) << endl;
      }

      if (n_abins <= 0)
        report1 << "# ";
      report1 << Lbin_method << " #_Lbin_method_for_Age_Data: 1=poplenbins; 2=datalenbins; 3=lengths" << endl;
      report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
      report1 << "# partition codes:  (0=combined; 1=discard; 2=retained" << endl;
      report1 << "#_year month fleet sex part ageerr Lbin_lo Lbin_hi Nsamp datavector(female-male)" << endl;
      if (Nobs_a_tot > 0)
        for (f = 1; f <= Nfleet; f++)
        {
          if (Nobs_a(f) >= 1)
          {
            for (i = 1; i <= Nobs_a(f); i++)
            {
              k = 1000;
              if (nsamp_a(f, i) < k)
                k = nsamp_a(f, i); // note that nsamp is adjusted by var_adjust, so var_adjust
              // should be reset to 1.0 in control files that read the nudata.dat files
              exp_a_temp = nsamp_a(f, i) * value(exp_a(f, i) / sum(exp_a(f, i)));
              report1 << header_a(f, i)(1) << " " << header_a_rd(f, i)(2, 3) << " " << header_a(f, i)(4, 8) << " " << nsamp_a(f, i) << " " << exp_a_temp << endl;
            }
          }
        }
      f = exp_a_temp.size() + 8;
      if (n_abins <= 0)
        report1 << "# ";
      report1 << "-9999 ";
      for (i = 1; i <= f; i++)
        report1 << " 0";
      report1 << endl;

      report1 << "#" << endl
              << use_meansizedata << " #_Use_MeanSize-at-Age_obs (0/1)" << endl;
      if (use_meansizedata > 0)
      {
        report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
        report1 << "# partition codes:  0=combined; 1=discard; 2=retained" << endl;
        report1 << "# ageerr codes:  positive means mean length-at-age; negative means mean bodywt_at_age" << endl;
        report1 << "#_year month fleet sex part ageerr ignore datavector(female-male)" << endl;
        report1 << "#                                          samplesize(female-male)" << endl;
        for (f = 1; f <= Nfleet; f++)
        {
          if (Nobs_ms(f) > 0)
          {
            for (i = 1; i <= Nobs_ms(f); i++)
            {
              report1 << header_ms(f, i)(1) << " " << header_ms_rd(f, i)(2, 3) << " " << header_ms(f, i)(4, 7);
              for (a = 1; a <= n_abins2; a++)
              {
                report1 << " ";
                temp = exp_ms(f, i, a);
                if (temp <= 0.)
                {
                  temp = 0.0001;
                }
                report1 << temp;
              }
              report1 << endl
                      << obs_ms_n_read(f, i) << endl;
            }
          }
        }
        report1 << "-9999 ";
        for (j = 1; j <= 6 + n_abins2; j++)
          report1 << " 0";
        report1 << endl;
        for (j = 1; j <= n_abins2; j++)
          report1 << " 0";
        report1 << endl;
      }

      report1 << "#" << endl
              << N_envvar << " #_N_environ_variables" << endl;
      report1 << "# -2 in year will subtract mean for that env_var; -1 will subtract mean and divide by stddev (e.g. Z-score)" << endl;
      report1 << "#_year variable value" << endl;
      if (N_envvar > 0)
      {
        for (i = 0; i <= N_envdata - 1; i++)
          report1 << env_temp[i] << endl;
        report1 << "-9999 0 0" << endl;
      }

      report1 << "#" << endl << "# Sizefreq data. Defined by method because a fleet can use multiple methods" << endl;
      report1 << SzFreq_Nmeth_rd << " # N sizefreq methods to read (or -1 for expanded options)" << endl;
      if (SzFreq_Nmeth_rd < 0) {
        report1 << SzFreq_Nmeth << " # N sizefreq methods to read" << endl;
      }
     if (SzFreq_Nmeth != 0)
      {
        report1 << "# each row below has entry for each sizefreq method " << endl;
        report1 << "#_ ";
        for (int j = 1; j <= SzFreq_Nmeth; j++ )
          { report1 << j << " ";}
        report1 << " # Method" << endl;
        report1 << SzFreq_Nbins << " #_Sizefreq N bins" << endl;
        report1 << SzFreq_units << " #_Sizefreq units(1=bio/2=num)" << endl;
        report1 << SzFreq_scale << " #_Sizefreq scale(1=kg/2=lbs/3=cm/4=inches)" << endl;
        report1 << SzFreq_mincomp << " #_Sizefreq:  small constant to add to comps" << endl;
        report1 << SzFreq_nobs << " #_Sizefreq number of obs per method" << endl;
        if (SzFreq_Nmeth_rd < 0) {
          report1 << Comp_Err_Sz <<  " #_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
          report1 << Comp_Err_Sz2 << " #_ParmSelect: consecutive index for dirichlet or MV_Tweedie comp_error" << endl;
        }
        report1 << "#_Sizefreq bins. one row for each method" << endl
                << "#Note: negative value for first bin makes it accumulate all smaller fish vs. truncate small fish" << endl;
        for (i = 1; i <= SzFreq_Nmeth; i++)
        { report1 << SzFreq_Omit_Small(i) * SzFreq_bins1(i, 1) << SzFreq_bins1(i)(2, SzFreq_Nbins(i)) << endl; }
        report1 << "#_method year month fleet sex part Nsamp <data> " << endl;
        for (iobs = 1; iobs <= SzFreq_totobs; iobs++) {
          report1 << SzFreq_obs1(iobs)(1, 7) << " " << SzFreq_exp(iobs) << endl;
        }
      }

      // begin tagging data section #2 (expected values)
      report1 << "#" << endl
              << Do_TG << " # do tags (0/1)" << endl;
      if (Do_TG > 0)
      {
        // info on dimensions of tagging data
        report1 << N_TG << " # N tag groups" << endl;
        report1 << N_TG_recap << " # N recap events" << endl;
        report1 << TG_mixperiod << " # mixing latency period: N periods to delay before comparing observed to expected recoveries (0 = release period)" << endl;
        report1 << TG_maxperiods << " # max periods (seasons) to track recoveries, after which tags enter accumulator" << endl;

        // tag releases
        report1 << "# Release data for each tag group.  Tags are considered to be released at the beginning of a season (period)" << endl;
        report1 << "#<TG> area year seas <tfill> sex age Nrelease  (note that the TG and tfill values are placeholders and are replaced by program generated values)" << endl;
        report1 << TG_release << endl;

        // tag recaptures
        report1 << "#_Note: Expected values for tag recaptures are reported only for the same combinations of" << endl;
        report1 << "#       group, year, area, and fleet that had observed recaptures. " << endl;
        report1 << "#_TG year seas fleet Nrecap" << endl;
        for (j = 1; j <= N_TG_recap; j++)
        {
          // fill in first 4 columns:
          for (k = 1; k <= 4; k++)
            report1 << TG_recap_data(j, k) << " ";
          // fill in 5th column with bootstrap values
          TG = TG_recap_data(j, 1);
          overdisp = TG_parm(2 * N_TG + TG);
          t = styr + int((TG_recap_data(j, 2) - styr) * nseas + TG_recap_data(j, 3) - 1) - TG_release(TG, 5); // find elapsed time in terms of number of seasons
          if (t > TG_maxperiods)
            t = TG_maxperiods;
          report1 << value(TG_recap_exp(TG, t, 0)) << " #_overdisp: " << value(overdisp) << endl;
        }
      }
      // end tagging data section #2 (expected values)

      report1 << "#" << endl
              << Do_Morphcomp << " #    morphcomp data(0/1) " << endl;
      if (Do_Morphcomp > 0)
      {
        report1 << "# note that raw data, not bootstrap are reported here " << endl;
        report1 << Morphcomp_nobs << "  #  Nobs" << endl;
        report1 << Morphcomp_nmorph << " # Nmorphs" << endl;
        report1 << Morphcomp_mincomp << " # add_to_comp" << endl;
        report1 << "#_year, month, fleet, null, Nsamp, datavector_by_Nmorphs" << endl;
        for (i = 1; i <= Morphcomp_nobs; i++)
        {
          report1 << Morphcomp_obs(i)(1, 5) << " " << Morphcomp_exp(i) << endl;
        }
      }
      else
      {
        report1 << "#  Nobs, Nmorphs, mincomp" << endl;
        report1 << "#_year, seas, type, partition, Nsamp, datavector_by_Nmorphs" << endl;
      }

      report1 << "#" << endl
              << Do_SelexData << "  #  Do dataread for selectivity priors(0/1)" << endl;
      report1 << "#_year, seas, fleet, age/size, bin, selex_prior, prior_sd" << endl;
      report1 << "# feature not yet implemented" << endl;

      report1 << "#" << endl
              << "999" << endl
              << endl;
    }

    else //  create bootstrap data
    {

      report1 << "#_Catch data: year, seas, fleet, catch, catch_se" << endl;
      report1 << "#_catch_se:  standard error of log(catch)" << endl;
      report1 << "#_NOTE:  catch data is ignored for survey fleets" << endl;
      k = 0;
      for (f = 1; f <= Nfleet; f++)
      {
        if (fleet_type(f) <= 2)
        {
          for (y = styr - 1; y <= endyr; y++)
          {
            for (s = 1; s <= nseas; s++)
            {
              k++;
              t = styr + (y - styr) * nseas + s - 1;
              if (y == styr - 1)
              { report1 << -999 << " "; }
              else
              { report1 << y << " "; }
              report1 << s << " " << f << " ";
              if (fleet_type(f) == 2 && catch_ret_obs(f, t) > 0.0)
              {
                report1 << 0.1 << " " << catch_se(t, f) << endl; //  for bycatch only fleet
              }
              else if (catchunits(f) == 1)
              {
                report1 << catch_fleet(t, f, 3) * mfexp(randn(radm) * catch_se(t, f) - 0.5 * catch_se(t, f) * catch_se(t, f))
                        << " " << catch_se(t, f) << endl;
              }
              else
              {
                report1 << catch_fleet(t, f, 6) * mfexp(randn(radm) * catch_se(t, f) - 0.5 * catch_se(t, f) * catch_se(t, f))
                        << " " << catch_se(t, f) << endl;
              }
            }
          }
        }
      }
      report1 << "-9999 0 0 0 0" << endl
              << "#" << endl;

      report1 << "#_CPUE_and_surveyabundance_and_index_observations" << endl;
      report1 << "#_units: 0=numbers; 1=biomass; 2=F; 30=spawnbio; 31=exp(recdev); 36=recdev; 32=spawnbio*recdev; 33=recruitment; 34=depletion(&see Qsetup); 35=parm_dev(&see Qsetup)" << endl;
      report1 << "#_errtype:  -1=normal; 0=lognormal; 1=lognormal with bias correction; >1=df for T-dist" << endl;
      report1 << "#_SD_report: 0=not; 1=include survey expected value with se" << endl;
      report1 << "#_note that link functions are specified in Q_setup section of control file" << endl;
      report1 << "#_dataunits = 36 and 35 should use Q_type 5 to provide offset parameter" <<endl;
      report1 << "#_fleet units errtype SD_report" << endl;
      for (f = 1; f <= Nfleet; f++)
        report1 << f << " " << Svy_units(f) << " " << Svy_errtype(f) << " " << Svy_sdreport(f) << " # " << fleetname(f) << endl;
      report1 << "#_year month index obs err" << endl;
      if (Svy_N > 0)
        for (f = 1; f <= Nfleet; f++)
          for (i = 1; i <= Svy_N_fleet(f); i++)
          {
            t = Svy_time_t(f, i);
            ALK_time = Svy_ALK_time(f, i);
            double newobs = 0.0;
            report1 << Show_Time(t, 1) << " " << Svy_super(f, i) * data_time(ALK_time, f, 1) << " " << f * Svy_use(f, i) << " ";
            if (Svy_errtype(f) == -1) // normal error
            {
              newobs = value(Svy_est(f, i) + randn(radm) * Svy_se_use(f, i)); //  uses Svy_se_use, not Svy_se_rd to include both effect of input var_adjust and extra_sd
            }
            if (Svy_errtype(f) == 0) // lognormal
            {
              newobs = value(mfexp(Svy_est(f, i) + randn(radm) * Svy_se_use(f, i))); //  uses Svy_se_use, not Svy_se_rd to include both effect of input var_adjust and extra_sd
            }
            else if (Svy_errtype(f) > 1000) // T-dist
            {
              dvariable df = Svy_errtype(f) - 1000.;
              temp = sqrt((df + 1.) / df);
              newobs = value(mfexp(Svy_est(f, i) + randn(radm) * Svy_se_use(f, i) * temp)); //  adjusts the sd by the df sample size
            }
            if (Svy_minval(f) >= 0.0 && Svy_errtype(f) != 0)  // this logic may need adjustment
              newobs = max(newobs, 0.5 * Svy_minval(f));
            report1 << newobs << " " << Svy_se_rd(f, i) << " #_orig_obs: " << Svy_obs(f, i) << " " << fleetname(f) << endl;
          }
      report1 << "-9999 1 1 1 1 # terminator for survey observations " << endl;

      report1 << "#" << endl
              << Ndisc_fleets << " #_N_fleets_with_discard" << endl;
      report1 << "#_discard_units (1=same_as_catchunits(bio/num); 2=fraction; 3=numbers)" << endl;
      report1 << "#_discard_errtype:  >0 for DF of T-dist(read CV below); 0 for normal with CV; -1 for normal with se; -2 for lognormal; -3 for trunc normal with CV" << endl;
      report1 << "# note: only enter units and errtype for fleets with discard " << endl;
      report1 << "# note: discard data is the total for an entire season, so input of month here must be to a month in that season" << endl;
      report1 << "#_Fleet units errtype" << endl;
      if (Ndisc_fleets > 0)
      {
        for (f = 1; f <= Nfleet; f++)
          if (disc_units(f) > 0)
            report1 << f << " " << disc_units(f) << " " << disc_errtype(f) << " # " << fleetname(f) << endl;
        report1 << "#_year month fleet obs stderr" << endl;
        for (f = 1; f <= Nfleet; f++)
          for (i = 1; i <= disc_N_fleet(f); i++)
          {
            ALK_time = disc_time_ALK(f, i);
            report1 << Show_Time(disc_time_t(f, i), 1) << " " << yr_disc_super(f, i) * data_time(ALK_time, f, 1) << " " << f * yr_disc_use(f, i) << " ";
            if (disc_errtype(f) >= 1)
            {
              temp = exp_disc(f, i) + randn(radm) * sd_disc(f, i) * sqrt((disc_errtype(f) + 1.) / disc_errtype(f)) * exp_disc(f, i);
              if (temp < 0.001)
                temp = 0.001;
            }
            else if (disc_errtype(f) == 0)
            {
              temp = exp_disc(f, i) + randn(radm) * sd_disc(f, i);
              if (temp < 0.001)
                temp = 0.001;
            }
            else if (disc_errtype(f) == -1)
            {
              temp = exp_disc(f, i) + randn(radm) * sd_disc(f, i);
              if (temp < 0.001)
                temp = 0.001;
            }
            else if (disc_errtype(f) == -2)
            {
              temp = exp_disc(f, i) * mfexp(randn(radm) * sd_disc(f, i));
            }
            else if (disc_errtype(f) == -3)
            {
              temp = exp_disc(f, i) + randn(radm) * (sd_disc(f, i) / sqrt(cumd_norm((1 - exp_disc(f, i)) / sd_disc(f, i)) - cumd_norm((0 - exp_disc(f, i)) / sd_disc(f, i))));
              if (temp < 0.001)
                temp = 0.001;
            }
            if (disc_minval(f) >= 0.0)
              temp = max(value(temp), 0.5 * disc_minval(f));

            report1 << " " << temp << " " << cv_disc(f, i) << " #_orig_obs: " << obs_disc(f, i) << " #_ " << fleetname(f) << endl;
          }
      }
      else
      {
        report1 << "# ";
      }
      report1 << "-9999 0 0 0.0 0.0 # terminator for discard data " << endl;

      report1 << "#" << endl
              << do_meanbodywt << " #_use meanbodysize_data (0/1)" << endl;
      if (do_meanbodywt == 0)
        report1 << "#_COND_";
      report1 << DF_bodywt << " #_DF_for_meanbodysize_T-distribution_like" << endl;
      report1 << "# note:  type=1 for mean length; type=2 for mean body weight " << endl;
      report1 << "#_year month fleet part type obs stderr" << endl;

      // NOTE, the se stored in mnwtdata(7,i) was adjusted in prelim calc to include the input var_adjustment
      //  so var_adjust is subtracted here when the observation is written
      if (nobs_mnwt > 0)
      {
        for (i = 1; i <= nobs_mnwt; i++)
        {
          temp = exp_mnwt(i) + randn(radm) * mnwtdata(7, i) * sqrt((DF_bodywt + 1.) / DF_bodywt) * exp_mnwt(i);
          if (temp <= 0.0)
          {
            temp = 0.0001;
          }
          f = abs(mnwtdata(3, i));
          report1 << Show_Time(mnwtdata(1, i), 1) << " " << mnwtdata(2, i) << " " << mnwtdata(3, i) << " " << mnwtdata(4, i) << " " << mnwtdata(5, i) << " " << temp << " " << mnwtdata(7, i) - var_adjust(3, f) << " #_orig_obs: " << mnwtdata(6, i) << "  #_ " << fleetname(f) << endl;
        }
      }
      if (do_meanbodywt == 0)
        report1 << "# ";
      report1 << " -9999 0 0 0 0 0 0 # terminator for mean body size data " << endl;

      report1 << "#" << endl
              << "# set up population length bin structure (note - irrelevant if not using size data and using empirical wtatage" << endl;
      report1 << LenBin_option << " # length bin method: 1=use databins; 2=generate from binwidth,min,max below; 3=read vector" << endl;
      if (LenBin_option == 1)
      {
        report1 << "# no additional input for option 1" << endl;
        report1 << "# read binwidth, minsize, lastbin size for option 2" << endl;
        report1 << "# read N poplen bins, then vector of bin lower boundaries, for option 3" << endl;
      }
      else if (LenBin_option == 2)
      {
        report1 << binwidth2 << " # binwidth for population size comp " << endl;
        report1 << minLread << " # minimum size in the population (lower edge of first bin and size at age 0.00) " << endl;
        report1 << maxLread << " # maximum size in the population (lower edge of last bin) " << endl;
      }
      else
      {
        report1 << nlength << " # number of population size bins " << endl;
        report1 << len_bins << endl;
      }

      report1 << use_length_data << " # use length composition data (0/1/2) where 2 invokes new comp_comtrol format" << endl;
      if (use_length_data > 0)
      {
        report1 << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
        report1 << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
        report1 << "#_combM+F: males and females treated as combined sex below this bin number " << endl;
        report1 << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
        report1 << "#_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
        report1 << "#_ParmSelect:  consecutive index for dirichlet or MV_Tweedie" << endl;
        report1 << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;
        report1 << "#" << endl;
        if(use_length_data == 1)
        {
          report1 << "#_Using old format for composition controls" << endl;
        report1 << "#_mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
        for (f = 1; f <= Nfleet; f++)
        {
          report1 << min_tail_L(0, f) << " " << min_comp_L(0, f) << " " << CombGender_L(0, f) << " " << AccumBin_L(0, f) << " " << Comp_Err_L(0, f) << " " << Comp_Err_L2(0, f) << " " << min_sample_size_L(0, f) << " #_fleet:" << f << "_" << fleetname(f) << endl;
        }
        }
        else if (use_length_data == 2)
        {
          report1 << "#_Using new list format for composition controls" << endl;
          report1 << "#_use negative fleet value to fill for all higher numbered fleets (recommended!)" << endl;
          report1 << "#_must enter in fleet, partition order; but only need to enter for used combos" << endl;
          report1 << "#_fleet = -9999 to terminate list" << endl;
          report1 << "#_fleet partition mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
          for (int i = 0; i <= comp_control_L_count; i++)
            report1 << comp_control_L[i] << endl;
        }

        report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
        report1 << "# partition codes:  (0=combined; 1=discard; 2=retained" << endl;
        report1 << nlen_bin << " #_N_LengthBins" << endl
                << len_bins_dat << endl;
        report1 << "#_year month fleet sex part Nsamp datavector(female-male)" << endl;
        for (f = 1; f <= Nfleet; f++)
        {
          if (Nobs_l(f) > 0)
          {
            for (i = 1; i <= Nobs_l(f); i++)
            {
              int parti = mkt_l(f, i);
              switch (Comp_Err_L(parti, f))
              {
                case 0:
                {
                  Nsamp_DM = nsamp_l(f, i);
                  break;
                }
                case 1: //  Dirichlet #1
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_L2(parti, f), 1))); //  Thorson's theta from eq 10
                  // effN_DM = 1/(1+theta) + n*theta/(1+theta)
                  Nsamp_DM = value(1. / (1. + dirichlet_Parm) + nsamp_l(f, i) * dirichlet_Parm / (1. + dirichlet_Parm));
                  break;
                }
                case 2:  //  Dirichlet #2
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_L2(parti,f), 1))); //  Thorson's beta from eq 12
                  // effN_DM = (n+n*beta)/(n+beta)
                  Nsamp_DM = value((nsamp_l(f, i) + dirichlet_Parm * nsamp_l(f, i)) / (dirichlet_Parm + nsamp_l(f, i)));
                  break;
                }
                case 3: //  MV_Tweedie
                {
                  //  need MV_tweedie
                  break;
                }
              }
              Nsamp_DM = min(Nsamp_DM, 50000);
              Nsamp_DM = max(Nsamp_DM, 1);
              exp_l_temp_dat.initialize();
              temp_probs = value(exp_l(f, i));
              temp_mult.fill_multinomial(radm, temp_probs); // create multinomial draws with prob = expected values
              for (compindex = 1; compindex <= Nsamp_DM; compindex++) // cumulate the multinomial draws by index in the new data
              {
                exp_l_temp_dat(temp_mult(compindex)) += 1.0;
              }

              report1 << header_l_rd(f, i)(1, 5) << " " << Nsamp_DM << " " << exp_l_temp_dat << endl;
//              report1 << header_l_rd(f, i)(1, 3) << " " << gen_l(f, i) << " " << header_l_rd(f, i)(5) << " " << Nsamp_DM << " " << exp_l_temp_dat << endl;
            }
          }
        }
        report1 << -9999. << " ";
        for (j = 2; j <= 6 + nlen_bin2; j++)
          report1 << "0 ";
        report1 << endl;
      }
      else
      {
        report1 << "# see manual for format of length composition data " << endl;
      }

      report1 << "#" << endl
              << n_abins << " #_N_age_bins" << endl;
      if (n_abins > 0)
      {
        report1 << age_bins1 << endl;
      }
      else
      {
        report1 << "# ";
      }
      report1 << N_ageerr << " #_N_ageerror_definitions" << endl;
      if (N_ageerr > 0)
        report1 << age_err_rd << endl;

      report1 << "#_mintailcomp: upper and lower distribution for females and males separately are accumulated until exceeding this level." << endl;
      report1 << "#_addtocomp:  after accumulation of tails; this value added to all bins" << endl;
      report1 << "#_combM+F: males and females treated as combined sex below this bin number " << endl;
      report1 << "#_compressbins: accumulate upper tail by this number of bins; acts simultaneous with mintailcomp; set=0 for no forced accumulation" << endl;
      report1 << "#_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
        report1 << "#_ParmSelect:  consecutive index for dirichlet or MV_Tweedie" << endl;
      report1 << "#_minsamplesize: minimum sample size; set to 1 to match 3.24, minimum value is 0.001" << endl;
      report1 << "#" << endl;
      report1 << "#_mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize" << endl;
      for (f = 1; f <= Nfleet; f++)
      {
        if (n_abins <= 0)
          report1 << "# ";
        report1 << min_tail_A(f) << " " << min_comp_A(f) << " " << CombGender_A(f) << " " << AccumBin_A(f) << " " << Comp_Err_A(f) << " " << Comp_Err_A2(f) << " " << min_sample_size_A(f) << " #_fleet:" << f << "_" << fleetname(f) << endl;
      }

      if (n_abins <= 0)
        report1 << "# ";
      report1 << Lbin_method << " #_Lbin_method_for_Age_Data: 1=poplenbins; 2=datalenbins; 3=lengths" << endl;
      report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
      report1 << "# partition codes:  (0=combined; 1=discard; 2=retained" << endl;

      report1 << "#_year month fleet sex part ageerr Lbin_lo Lbin_hi Nsamp datavector(female-male)" << endl;
      if (Nobs_a_tot > 0)
        for (f = 1; f <= Nfleet; f++)
        {
          if (Nobs_a(f) > 0)
          {
            for (i = 1; i <= Nobs_a(f); i++)
            {
              switch (Comp_Err_A(f))
              {
                case 0:
                {
                  Nsamp_DM = nsamp_a(f, i);
                  break;
                }
                case 1: //  Dirichlet #1
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_A2(f),1))); //  Thorson's theta from eq 10
                  // effN_DM = 1/(1+theta) + n*theta/(1+theta)
                  Nsamp_DM = value(1. / (1. + dirichlet_Parm) + nsamp_a(f, i) * dirichlet_Parm / (1. + dirichlet_Parm));
                  break;
                }
                case 2:  //  Dirichlet #2
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_A2(f),1))); //  Thorson's beta from eq 12
                  // effN_DM = (n+n*beta)/(n+beta)      computed in Fit_LenComp
                  Nsamp_DM = value((nsamp_a(f, i) + dirichlet_Parm * nsamp_a(f, i)) / (dirichlet_Parm + nsamp_a(f, i)));
                  break;
                }
                case 3: //  MV_Tweedie
                {
                  //  need MV_tweedie
                  break;
                }
              }
              Nsamp_DM = min(Nsamp_DM, 50000);
              Nsamp_DM = max(Nsamp_DM, 1);
              exp_a_temp.initialize();
              temp_probs2 = value(exp_a(f, i));
              temp_mult.fill_multinomial(radm, temp_probs2); // create multinomial draws with prob = expected values
              for (compindex = 1; compindex <= Nsamp_DM; compindex++) // cumulate the multinomial draws by index in the new data
              {
                exp_a_temp(temp_mult(compindex)) += 1.0;
              }

              report1 << header_a(f, i)(1) << " " << header_a_rd(f, i)(2, 3) << " " << header_a(f, i)(4, 8) << " " << Nsamp_DM << " " << exp_a_temp << endl;
            }
          }
        }
      f = exp_a_temp.size() + 8;
      if (n_abins <= 0)
        report1 << "# ";
      report1 << "-9999 ";
      for (i = 1; i <= f; i++)
        report1 << " 0";
      report1 << endl;

      report1 << "#" << endl
              << use_meansizedata << " #_Use_MeanSize-at-Age_obs (0/1)" << endl;
      if (use_meansizedata > 0)
      {
        report1 << "# sex codes:  0=combined; 1=use female only; 2=use male only; 3=use both as joint sex*length distribution" << endl;
        report1 << "# partition codes:  0=combined; 1=discard; 2=retained" << endl;
        report1 << "# ageerr codes:  positive means mean length-at-age; negative means mean bodywt_at_age" << endl;
        report1 << "#_year month fleet sex part ageerr ignore datavector(female-male)" << endl;
        report1 << "#                                          samplesize(female-male)" << endl;
        for (f = 1; f <= Nfleet; f++)
        {
          if (Nobs_ms(f) > 0)
          {
            for (i = 1; i <= Nobs_ms(f); i++)
            {
              report1 << header_ms(f, i)(1) << " " << header_ms_rd(f, i)(2, 3) << " " << header_ms(f, i)(4, 7);
              for (a = 1; a <= n_abins2; a++)
              {
                report1 << " ";
                temp = exp_ms(f, i, a) + randn(radm) * exp_ms_sq(f, i, a) / obs_ms_n(f, i, a);
                if (temp <= 0.)
                {
                  temp = 0.0001;
                }
                report1 << temp;
              }
              report1 << endl
                      << obs_ms_n_read(f, i) << endl;
            }
          }
        }
        report1 << "-9999 ";
        for (j = 1; j <= 6 + n_abins2; j++)
          report1 << " 0";
        report1 << endl;
        for (j = 1; j <= n_abins2; j++)
          report1 << " 0";
        report1 << endl;
      }

      report1 << "#" << endl
              << N_envvar << " #_N_environ_variables" << endl;
      report1 << "# -2 in year will subtract mean for that env_var; -1 will subtract mean and divide by stddev (e.g. Z-score)" << endl;
      report1 << "#_year variable value" << endl;
      if (N_envvar > 0)
      {
        for (i = 0; i <= N_envdata - 1; i++)
          report1 << env_temp[i] << endl;
        report1 << "-9999 0 0" << endl;
      }

      report1 << "#" << endl << "# Sizefreq data. Defined by method because a fleet can use multiple methods" << endl;
      report1 << SzFreq_Nmeth_rd << " # N sizefreq methods to read (or -1 for expanded options)" << endl;
      if (SzFreq_Nmeth_rd < 0) {
        report1 << SzFreq_Nmeth << " # N sizefreq methods to read" << endl;
      }
      if (SzFreq_Nmeth != 0)
      {
        report1 << "# each row below has entry for each sizefreq method " << endl;
        report1 << "#_ ";
        for (int j = 1; j <= SzFreq_Nmeth; j++ )
          { report1 << j << " ";}
        report1 << " # Method" << endl;
        report1 << SzFreq_Nbins << " #_Sizefreq N bins" << endl;
        report1 << SzFreq_units << " #_Sizefreq units(1=bio/2=num)" << endl;
        report1 << SzFreq_scale << " #_Sizefreq scale(1=kg/2=lbs/3=cm/4=inches)" << endl;
        report1 << SzFreq_mincomp << " #_Sizefreq:  small constant to add to comps" << endl;
        report1 << SzFreq_nobs << " #_Sizefreq number of obs per method" << endl;
        if (SzFreq_Nmeth_rd < 0) {
          report1 << Comp_Err_Sz <<  " #_Comp_Error:  0=multinomial, 1=dirichlet using Theta*n, 2=dirichlet using beta, 3=MV_Tweedie" << endl;
          report1 << Comp_Err_Sz2 << " #_ParmSelect: consecutive index for dirichlet or MV_Tweedie comp_error" << endl;
        }
        report1 << "#_Sizefreq bins. one row for each method" << endl
                << "#Note: negative value for first bin makes it accumulate all smaller fish vs. truncate small fish" << endl;
        for (i = 1; i <= SzFreq_Nmeth; i++)
        { report1 << SzFreq_Omit_Small(i) * SzFreq_bins1(i, 1) << SzFreq_bins1(i)(2, SzFreq_Nbins(i)) << endl; }
        report1 << "#_method year month fleet sex part Nsamp <data> " << endl;
        j = 2 * max(SzFreq_Nbins);
        dvector temp_probs3(1, j);
        dvector SzFreq_newdat(1, j);
        for (iobs = 1; iobs <= SzFreq_totobs; iobs++)
        {
          f = SzFreq_obs1(iobs, 1);  //  sizefreq method
          double Nsamp_dat = 50000;
          if (SzFreq_obs1(iobs, 7) < Nsamp_dat)
          Nsamp_dat = SzFreq_obs1(iobs, 7);
          SzFreq_newdat.initialize();

              switch (Comp_Err_Sz(f))
              {
                case 0:
                {
                  Nsamp_DM = Nsamp_dat;
                  break;
                }
                case 1: //  Dirichlet #1
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(f),1))); //  Thorson's theta from eq 10
                  // effN_DM = 1/(1+theta) + n*theta/(1+theta)
                  Nsamp_DM = value(1. / (1. + dirichlet_Parm) + Nsamp_dat * dirichlet_Parm / (1. + dirichlet_Parm));
                  break;
                }
                case 2:  //  Dirichlet #2
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(f),1)));  //  Thorson's beta from eq 12
                  // effN_DM = (n+n*beta)/(n+beta)      computed in Fit_LenComp
                  Nsamp_DM = value((nsamp_l(f, i) + dirichlet_Parm * nsamp_l(f, i)) / (dirichlet_Parm + Nsamp_dat));
                  break;
                }
                case 3: //  MV_Tweedie
                {
                  //  need MV_tweedie
                  break;
                }
              }

          temp_probs3(1, SzFreq_Setup2(iobs)) = value(SzFreq_exp(iobs));
          temp_mult.fill_multinomial(radm, temp_probs3(1, SzFreq_Setup2(iobs))); // create multinomial draws with prob = expected values
          for (compindex = 1; compindex <= j; compindex++) // cumulate the multinomial draws by index in the new data
          {
            SzFreq_newdat(temp_mult(compindex)) += 1.0;
          }

          report1 << SzFreq_obs1(iobs)(1, 7) << " " << SzFreq_newdat(1, SzFreq_Setup2(iobs)) << endl;
        }        
      }

      // begin tagging data section #3 (bootstrap data)
      report1 << "#" << endl
              << Do_TG << " # do tags (0/1)" << endl;
      if (Do_TG > 0)
      {
        dvector temp_negbin(1, 50000);

        // changes authored by Gavin Fay in June 2016 in SS3 3.24Y
        TG_recap_gen.initialize();
        int N_TG_recap_gen = 0;
        for (TG = 1; TG <= N_TG; TG++)
        {
          overdisp = TG_parm(2 * N_TG + TG);

          dvector TG_fleet_probs(1, Nfleet);
          dvector temp_tags(1, Nfleet);
          //  problem:  TG_recap_exp only dimensioned to TG_endtime
          for (t = 0; t <= min(TG_maxperiods, TG_endtime(TG)); t++)
          {
            if (value(TG_recap_exp(TG, t, 0)) > 0)
            {
              temp_negbin.initialize();
              temp_negbin.fill_randnegbinomial(value(TG_recap_exp(TG, t, 0)), value(overdisp), radm);
              //cout << TG << " " << t << " " << temp_negbin <<  " " << TG_recap_exp(TG,t,0) << " " << value(overdisp) << endl;
              if (temp_negbin(1) > 0)
              {
                TG_fleet_probs = value(TG_recap_exp(TG, t)(1, Nfleet)) / temp_negbin(1);
                temp_tags = 0.0;
                temp_mult.fill_multinomial(radm, TG_fleet_probs);
                for (compindex = 1; compindex <= temp_negbin(1); compindex++) // cumulate the multinomial draws by index in the new data
                {
                  temp_tags(temp_mult(compindex)) += 1.0;
                }
                for (f = 1; f <= Nfleet; f++)
                {
                  if (temp_tags(f) > 0)
                  {
                    N_TG_recap_gen += 1;
                    TG_recap_gen(N_TG_recap_gen, 1) = TG;
                    TG_recap_gen(N_TG_recap_gen, 2) = TG_release(TG, 3) + int((t + TG_release(TG, 4) - 1) / nseas);
                    int k = TG_release(TG, 4);
                    TG_recap_gen(N_TG_recap_gen, 3) = ((t + k - 1) % nseas) + 1;
                    TG_recap_gen(N_TG_recap_gen, 4) = f;
                    TG_recap_gen(N_TG_recap_gen, 5) = temp_tags(f);
                  }
                }
              }
            }
          }
        }

        // info on dimensions of tagging data
        report1 << N_TG << " # N tag groups" << endl;
        // //report1<<N_TG_recap<<" # N recap events"<<endl;
        report1 << N_TG_recap_gen << " # N recap events" << endl;
        report1 << TG_mixperiod << " # mixing latency period: N periods to delay before comparing observed to expected recoveries (0 = release period)" << endl;
        report1 << TG_maxperiods << " # max periods (seasons) to track recoveries, after which tags enter accumulator" << endl;

        // tag releases
        report1 << "# Release data for each tag group.  Tags are considered to be released at the beginning of a season (period)" << endl;
        report1 << "#<TG> area year seas <tfill> sex age Nrelease  (note that the TG and tfill values are placeholders and are replaced by program generated values)" << endl;
        report1 << TG_release << endl;

        // tag recaptures
        report1 << "#_Note: Bootstrap values for tag recaptures are produced only for the same combinations of" << endl;
        report1 << "#       group, year, area, and fleet that had observed recaptures. " << endl;
        report1 << "#_TG year seas fleet Nrecap" << endl;
        for (j = 1; j <= N_TG_recap_gen; j++)
        {
          report1 << TG_recap_gen(j) << endl;
        }
      }
      // end tagging data section #3 (bootstrap data)

      report1 << "#" << endl
              << Do_Morphcomp << " #    morphcomp data(0/1) " << endl;
      if (Do_Morphcomp > 0)
      {
        report1 << "# note that raw data, not bootstrap are reported here " << endl;
        report1 << Morphcomp_nobs << "  #  Nobs" << endl;
        report1 << Morphcomp_nmorph << " # Nmorphs" << endl;
        report1 << Morphcomp_mincomp << " # add_to_comp" << endl;
        report1 << "#_year, month, fleet, null, Nsamp, datavector_by_Nmorphs (no error added!!!)" << endl;
        for (i = 1; i <= Morphcomp_nobs; i++)
        {
          report1 << Morphcomp_obs(i)(1, 5) << " " << Morphcomp_exp(i) << endl;
        }
      }
      else
      {
        report1 << "#  Nobs, Nmorphs, mincomp" << endl;
        report1 << "#_year, seas, type, partition, Nsamp, datavector_by_Nmorphs" << endl;
      }

      report1 << "#" << endl
              << Do_SelexData << "  #  Do dataread for selectivity priors(0/1)" << endl;
      report1 << "#_year, seas, fleet, age/size, bin, selex_prior, prior_sd" << endl;
      report1 << "# feature not yet implemented" << endl;

      report1 << "#" << endl
              << "999" << endl
              << endl;
    }
    report1.close();
  }

  //  report1 << "ENDDATA" << endl;
  return;
  } //  end of write data

//********************************************************************
 /*  SS_Label_FUNCTION 39 write_nucontrol  write new control file and starter file */
FUNCTION void write_nucontrol()
  {
  echoinput << "Write starter.ss_new file " << endl;
  anystring = ssnew_pathname + "starter.ss_new";
  ofstream NuStart(anystring);
  NuStart << version_info(1) << version_info(2) << version_info(3) << endl
          << version_info2 << endl;
  if (N_SC > 0)
    NuStart << Starter_Comments << endl;
  NuStart << datfilename << " #_datfile" << endl
          << ctlfilename << " #_ctlfile" << endl;
  NuStart << readparfile << " #_init_values_src:  0 (use init values in control file); 1 (use ss3.par)" << endl;
  NuStart << rundetail << " #_screen_display:  0 (minimal); 1 (one line per iter); 2 (each logL)" << endl;
  NuStart << reportdetail << " #_report_table_selection:  0 (minimal; no wtatage.ss_new); 1 (all tables); 2 (brief), 3 (custom, read list) " << endl;
  if (reportdetail == 3)
  {
    NuStart << "# custom report options: -100 to start with minimal; -101 to start with all; -number to remove, +number to add, -999 to end" << endl;
    for (unsigned j = 0; j <= reportdetail_list.size() - 1; j++)
    {
      NuStart << reportdetail_list[j](1) << endl;
    }
  }
  else
  {
    NuStart << "# COND: custom report options: -100 to start with minimal; -101 to start with all; -number to remove, +number to add, -999 to end" << endl;
  }

  NuStart << docheckup << " #_checkup:  write more 1st iteration age-specific details to echoinput.sso file (0,1) " << endl;
  NuStart << Do_ParmTrace << " #_parmtrace:  write parm values to ParmTrace.sso:  0 (no); 1 (good_iter,active_parms); 2 (good,all); 3 (every,all); 4 (every,active)" << endl;
  NuStart << Do_CumReport << " #_cumreport:  write to cumreport.sso: 0 (no); 1 (like&timeseries); 2 (add survey fits)" << endl;
  NuStart << Do_all_priors << " #_prior_like:  include prior_like for non-estimated parameters (0,1) " << endl;
  NuStart << SoftBound << " #_soft_bounds:  Use Soft Boundaries to aid convergence (0,1) (recommended)" << endl;
  NuStart << "#" << endl
          << N_nudata_read << " #_N_bootstraps:  Number of datafiles to produce:  0 turns off all *.ss_new; 1st is data_echo.ss_new, 2nd is data_expval.ss, 3rd and higher are data_boot_**N.ss," << endl;
  NuStart << Turn_off_phase_rd << " #_last_estimation_phase:  turn off estimation for parameters entering after this phase" << endl;
  NuStart << "#" << endl
          << burn_intvl << " #_MCMCburn" << endl;
  NuStart << thin_intvl << " #_MCMCthin" << endl;
  NuStart << jitter << " # jitter_fraction:  jitter within parameter bounds" << endl;

  NuStart << STD_Yr_min_rd << " #_minyr_sdreport:  min year for sdreport outputs (-1 for styr); #_" << STD_Yr_min << endl;
  NuStart << STD_Yr_max_rd << " #_maxyr_sdreport:  max year for sdreport outputs (-1 for endyr+1; -2 for endyr+Nforecastyrs); #_" << STD_Yr_max << endl;
  NuStart << N_STD_Yr_RD << " #_N_STD_yrs:  N individual STD years " << endl;
  NuStart << "#COND: vector of year values if N>0" << endl
          << STD_Yr_RD << endl;

  NuStart << final_conv << " #_converge_criterion: (e.g. 1.0e-04) " << endl;
  NuStart << retro_yr - endyr << " #_retro_yr:  retrospective year relative to end year (e.g. -4)" << endl;
  NuStart << Smry_Age << " #_min_age_summary_bio" << endl;
  NuStart << depletion_basis_rd << " #_depl_basis:  Depletion denom is: 0=skip; 1=X*SSB_virgin; 2=X*SSB_msy; 3=X*SSB_styr; 4=X*SSB_endyr; 5=X*dyn_Bzero; 6=X*SSB_unf_bmark; values>=11 invoke N multiyr with 10s & 100s digit; append .1 to invoke log(ratio); e.g. 122.1 produces log(12 yr trailing average of B/Bmsy)" << endl;
  NuStart << "# If value = 1, then Btarget in benchmark will be a fraction of SSB_virgin, else will be a fraction of SSB_benchmark" << endl;
  NuStart << depletion_level << " #_depl_denom_frac:  fraction (X) for Depletion denominator (e.g. 0.4)" << endl;
  NuStart << SPR_reporting << " #_SPR_basis:  0 (skip); 1 (1-SPR)/(1-SPR_tgt); 2 (1-SPR)/(1-SPR_MSY); 3 (1-SPR)/(1-SPR_Btarget); 4 (1-SPR); 5 (SPR)" << endl;
  NuStart << F_reporting << " # F_std_units:  0 (skip); 1 (exploitation(Bio)); 2 (exploitation(Num)); 3 (sum(Apical_F's)); 4 (mean F for range of ages (numbers weighted)); 5 (unweighted mean F for range of ages)" << endl;
  if (F_reporting == 4 || F_reporting == 5)
  {
    NuStart << F_reporting_ages << " # min and max age over which mean F will be calculated, with F=Z-M" << endl;
  }
  else
  {
    NuStart << "#COND 10 15 #_min and max age over which mean F will be calculated with F_reporting=4 or 5" << endl;
  }
  NuStart << F_std_basis_rd << " # F_std_basis: 0=no scaling; 1 (F/Fspr); 2 (F/Fmsy); 3 (F/Fbtgt); where F means annual F_std, Fmsy means F_std@msy; values >=11 invoke N multiyr using 10s and 100s digit; append .1 to invoke log(ratio)" << endl;
  NuStart << double(mcmc_output_detail) + MCMC_bump << " #_MCMC_output_detail: integer part (0=default; 1=adds obj func components; 2= +write_report_for_each_mceval); and decimal part (added to SR_LN(R0) on first call to mcmc)" << endl;
  NuStart << ALK_tolerance << " #_deprecated:  ALK tolerance ***disabled in code" << endl;
  NuStart << irand_seed_rd << " #_seed:  random number seed for bootstrap data (-1 to use long(time) as seed): # " << irand_seed << endl;
  NuStart << timevary_bio_4SRR << " #_Compatibility:  flag for legacy (0) vs improved (1) impact of timevary biology on benchmark SRR calcs >=3.30.24" << endl;
  NuStart << "3.30 #_final:  check value for end of file and for version control" << endl;
  NuStart.close();

  echoinput << "Write forecast.ss_new file " << endl;
  anystring = ssnew_pathname + "forecast.ss_new";
  ofstream NuFore(anystring);
  NuFore << version_info(1) << version_info(2) << version_info(3) << endl;
  if (N_FC > 0)
    NuFore << Forecast_Comments << endl;
  NuFore << "# for all year entries except rebuilder; enter either: actual year, -999 for styr, 0 for endyr, neg number for rel. endyr" << endl;
  NuFore << Do_Benchmark << " # Benchmarks: 0=skip; 1=calc F_spr,F_Btgt,F_msy; 2=calc F_spr,F0.1,F_msy; 3=add F_Blimit; " << endl;
  NuFore << Do_MSY << " # Do_MSY: 1= set to F(SPR); 2=calc F(MSY); 3=set to F(Btgt) or F0.1; 4=set to F(endyr); 5=calc F(MEY) with MSY_unit options" << endl;
  NuFore << "# if Do_MSY=5, enter MSY_Units; then list fleet_ID, cost/F, price/mt, include_in_Fmey_scaling; # -fleet_ID to fill; -9999 to terminate" << endl;
  if (Do_MSY == 5)
  {
    NuFore << MSY_units << " # MSY_units: 1=dead biomass, 2=dead biomass w/o excluded bycatch fleet, 3=retained biomass; 4=profits using price and costs" << endl;
    NuFore << "# Note: if a fleet's catch is excluded from the Fmey search, its catch or profits are still included in the MSY value using historical F levels from Bmark_years" << endl;
    NuFore << "# Fleet Cost_per_F Price_per_F include_in_Fmey_search" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (YPR_mask(f) > 0.0)
        NuFore << f << " " << CostPerF(f) << " " << PricePerF(f) << " " << AdjustBenchF(f) << endl;
    }
    NuFore << "-9999 1 1 1 # terminate list of fleet costs and prices" << endl;
  }

  NuFore << SPR_target << " # SPR target (e.g. 0.40)" << endl;
  NuFore << BTGT_frac << " # Biomass target (e.g. 0.40) as fraction of SSB_virgin if depletion basis = 1 or time_vary compatibility = 0, else as fraction of SSB_unfished in benchmark" << endl;
  if (Do_Benchmark != 3) NuFore << "#";
  NuFore << Blim_frac << " # COND: Do_Benchmark==3;  Blimit as fraction of Bmsy (neg value to use as frac of SSB_virgin or SSB_unfished) (e.g. 0.50)";
  NuFore << "#" << endl << "# Bmark_years: beg_bio, end_bio, beg_selex, end_selex, beg_relF, end_relF, beg_recr_dist, end_recr_dist, beg_SRparm, end_SRparm (enter actual year, or values of 0 or -integer to be rel. endyr)" << endl
         << Bmark_Yr_rd << endl
         << "# " << Bmark_Yr << endl;
  NuFore << "# value <0 convert to endyr-value; except -999 converts to start_yr; must be >=start_yr and <=endyr" << endl;
  NuFore << Bmark_RelF_Basis << " # Bmark_relF_Basis: 1 = use year range; 2 = set relF same as forecast below" << endl;
  NuFore << "#" << endl
         << Do_Forecast_rd << " # Forecast: -1=none; 0=simple_1yr; 1=F(SPR); 2=F(MSY) 3=F(Btgt) or F0.1; 4=Ave F (uses first-last relF yrs); 5=input annual F scalar" << endl;
  NuFore << "# where none and simple require no input after this line; simple sets forecast F same as end year F" << endl;
  NuFore << N_Fcast_Yrs << " # N forecast years " << endl;
  NuFore << Fcast_Flevel << " # Fmult (only used for Do_Forecast==5) such that apical_F(f)=Fmult*relF(f)" << endl;
  anystring = "";
  if(Fcast_yr_rd(1) != -12345)
  {   //  write in old format
    NuFore << "#_Fcast_years for averaging:  beg_selex, end_selex, beg_relF, end_relF, beg_mean recruits, end_recruits  (enter actual year, or values of 0 or -integer to be rel. endyr)" << endl
         << Fcast_yr_rd << endl
         << "# " << Fcast_yr << endl;
    NuFore << Fcast_timevary_Selex_rd << " # Forecast selectivity (0=fcast selex is mean from year range; 1=fcast selectivity from time-vary parms). NOTE: logic reverses in new format" << endl;
    //  
    NuFore << "# A revised protocol for the Fcast_yr specification is available and recommended. Template is below." << endl;
          warnstream << "A revised protocol for the Fcast_yr specification is available and recommended.";
          write_message (NOTE, 1);
    anystring = "#";
  }
//  else
  {  //  new list based format for Fcast years
  NuFore << anystring << endl << anystring << " -12345  # code to invoke new format for expanded fcast year controls" << endl
         << "# biology and selectivity vectors are updated annually in the forecast according to timevary parameters, so check end year of blocks and dev vectors" << endl
         << "# input in this section directs creation of means over historical years to override any time_vary changes" << endl
				 << "# Factors implemented so far: 1=M, 4=recr_dist, 5=migration, 10=selectivity, 11=rel_F, 12=recruitment" << endl
         << "# rel_F and Recruitment also have additional controls later in forecast.ss" << endl
         << "# input as list: Factor, method (0, 1), st_yr, end_yr" << endl
         << "# Terminate with -9999 for Factor" << endl
         << "# st_yr and end_yr input can be actual year; <=0 sets rel. to timeseries endyr; Except -999 for st_yr sets to first year if time series" << endl
//				 << "#_Factor: 1=M, 2=growth, 3=wtlen, 4=recr_dist&femfrac, 5=migration, 6=ageerror, 7=catchmult, 8=hermaphroditism" << endl
         << "# Method = 0 (or omitted) continue using time_vary parms; 1  use mean of derived factor over specified year range"<<endl;
    NuFore << "# Factor method st_yr end_yr " << endl;
    for (int i = 1; i <= 12; i++)
    if (Fcast_MGparm_ave_rd(i, 1) > 0)
	  {
      NuFore << anystring << Fcast_MGparm_ave_rd(i) << " # " << MGtype_Lbl(i) << "; use: "  << Fcast_MGparm_ave(i) << endl;
    }

    NuFore << anystring << "-9999 0 0 0" << endl << "#" <<endl;
  }

  NuFore << HarvestPolicy << " # Control rule method (0: none; 1: ramp does catch=f(SSB), buffer on F; 2: ramp does F=f(SSB), buffer on F; 3: ramp does catch=f(SSB), buffer on catch; 4: ramp does F=f(SSB), buffer on catch) " << endl;
  NuFore << "# values for top, bottom and buffer required, but not used when Policy=0" << endl;
  NuFore << H4010_top_rd << " # Control rule inflection for constant F (as frac of HCR_anchor, see below); must be > control rule cutoff" << endl;
  NuFore << H4010_bot << " # Control rule cutoff for no F (as frac of HCR_anchor, e.g. 0.10) " << endl;
  NuFore << H4010_scale_rd << " # Buffer:  enter Control rule target as fraction of Flimit (e.g. 0.75), negative value invokes list of [year, scalar]. -year fills from year to YrMax " << endl;
  NuFore << "# Also see HCR_anchor below to use virgin vs benchmark SSB or Bmsy as basis for inflection and cutoff" << endl;
  if (H4010_scale_rd < 0)
  {
    j = H4010_scale_vec_rd.size() - 1;
    for (int s = 0; s <= j; s++)
    {
      NuFore << H4010_scale_vec_rd[s] << endl;
    }
  }

  NuFore << "#" << endl << Fcast_Loop_Control(1) << " #_N forecast loops (1=OFL only; 2=ABC; 3=get F from forecast ABC catch with allocations applied)" << endl;
  NuFore << Fcast_Loop_Control(2) << " # First forecast loop with stochastic recruitment" << endl;
  NuFore << Fcast_Loop_Control(3) << " # Forecast base recruitment:  0= spawn_recr; 1=mult*spawn_recr_fxn; 2=mult*VirginRecr; 3=deprecated; 4=mult*mean_over_yr_range" << endl;
  NuFore << "# for option 4, set phase for fore_recr_devs to -1 in control to get constant mean in MCMC, else devs will be applied" << endl;
  if (Fcast_Loop_Control(3) == 0)
  {
    NuFore << 1.0 << " # Value multiplier is ignored" << endl;
  }
  else
  {
    NuFore << Fcast_Loop_Control(4) << " # multiplier on base recruitment " << endl;
  }
  NuFore << Fcast_Loop_Control(5) << " # HCR_anchor: 0 or 2 uses unfished benchmark SSB (old hardwired approach); 1 = virgin SSB; 3 = BMSY" << endl << "#" << endl;

  NuFore << Fcast_Cap_FirstYear << "  # FirstYear for caps and allocations (should be after years with fixed inputs) " << endl;

  NuFore << Impl_Error_Std << " # stddev of log(realized catch/target catch) in forecast (set value>0.0 to cause active impl_error)" << endl;

  NuFore << Do_Rebuilder << " # Do West Coast gfish rebuilder output: 0=no; 1=yes " << endl;
  NuFore << Rebuild_Ydecl << " # Rebuilder:  first year catch could have been set to zero (Ydecl)(-1 to set to 1999)" << endl;
  NuFore << Rebuild_Yinit << " # Rebuilder:  year for current age structure (Yinit) (-1 to set to endyear+1)" << endl;

  NuFore << Fcast_RelF_Basis << " # fleet relative F:  1=use mean over year range; 2=read seas, fleet, alloc list below" << endl;
  NuFore << "# Note that fleet allocation values is used directly as F if Do_Forecast=4 " << endl;

  NuFore << Fcast_Catch_Basis << " # basis for fcast catch tuning and for fcast catch caps and allocation  (2=deadbio; 3=retainbio; 5=deadnum; 6=retainnum); NOTE: same units for all fleets" << endl;

  NuFore << "# Conditional input if relative F choice = 2" << endl;
  NuFore << "# enter list of:  season, fleet, relF; if used, terminate with season=-9999" << endl;
  {
    for (s = 1; s <= nseas; s++)
      for (f = 1; f <= Nfleet; f++)
      {
        if (Fcast_RelF_Use(s, f) > 0.0)
        {
          if (Fcast_RelF_Basis == 1)
            NuFore << "# ";
          NuFore << s << " " << f << " " << Fcast_RelF_Use(s, f) << endl;
        }
      }
    if (Fcast_RelF_Basis == 1)
      NuFore << "# ";
    NuFore << "-9999 0 0  # terminator for list of relF" << endl;
  }

  NuFore << "# enter list of: fleet number, max annual catch for fleets with a max; terminate with fleet=-9999" << endl;
  for (f = 1; f <= Nfleet; f++)
  {
    if (Fcast_MaxFleetCatch(f) > -1 && fleet_type(f) == 1)
      NuFore << f << " " << Fcast_MaxFleetCatch(f) << endl;
  }
  NuFore << "-9999 -1" << endl;

  NuFore << "# enter list of area ID and max annual catch; terminate with area=-9999" << endl;
  for (p = 1; p <= pop; p++)
  {
    if (Fcast_MaxAreaCatch(p) > -1)
      NuFore << p << " " << Fcast_MaxAreaCatch(p) << endl;
  }
  NuFore << "-9999 -1" << endl;

  NuFore << "# enter list of fleet number and allocation group assignment, if any; terminate with fleet=-9999" << endl;
  for (f = 1; f <= Nfleet; f++)
  {
    if (Allocation_Fleet_Assignments(f) > 0)
      NuFore << f << " " << Allocation_Fleet_Assignments(f) << endl;
  }
  NuFore << "-9999 -1" << endl;

  NuFore << "#_if N allocation groups >0, list year, allocation fraction for each group " << endl;
  NuFore << "# list sequentially because read values fill to end of N forecast" << endl;
  NuFore << "# terminate with -9999 in year field " << endl;

  if (Fcast_Catch_Allocation_Groups > 0)
  {
    if (finish_starter == 999)
    {
      NuFore << endyr + 1 << " " << Fcast_Catch_Allocation(1) << endl;
    }
    else
    {
      j = Fcast_Catch_Allocation_list.size() - 1;
      for (k = 0; k <= j - 1; k++)
        NuFore << Fcast_Catch_Allocation_list[k] << endl;
    }
    NuFore << " -9999 ";
    for (j = 1; j <= Fcast_Catch_Allocation_Groups; j++)
    {
      NuFore << " 1 ";
    }
    NuFore << endl;
  }
  else
  {
    NuFore << "# no allocation groups" << endl;
  }

  NuFore << "#" << endl;
  NuFore << Fcast_InputCatch_Basis << " # basis for input Fcast catch: -1=read basis with each obs; 2=dead catch; 3=retained catch; 99=input apical_F; NOTE: bio vs num based on fleet's catchunits" << endl;

  NuFore << "#enter list of Fcast catches or Fa; terminate with line having year=-9999" << endl;
  NuFore << "#_year seas fleet catch(or_F)";
  if (Fcast_InputCatch_Basis == -1)
    NuFore << " Basis ";
  NuFore << endl;
  for (j = 1; j <= N_Fcast_Input_Catches; j++)
  {
    NuFore << Fcast_InputCatch_rd(j) << endl;
  }
  NuFore << "-9999 1 1 0 ";
  if (Fcast_InputCatch_Basis == -1)
    NuFore << " 2 ";
  NuFore << endl;
  NuFore << "#" << endl
         << 999 << " # verify end of input " << endl;
  NuFore.close();

  //**********************************************************
  echoinput << "Write control.ss_new file " << endl;

  ofstream report4("control.ss_new");
  report4 << version_info(1) << version_info(2) << version_info(3) << endl;
  report4 << version_info2 << endl;
  if (N_CC > 0)
    report4 << Control_Comments << endl;
  report4 << "#_data_and_control_files: " << datfilename << " // " << ctlfilename << endl;
  report4 << WTage_rd << "  # 0 means do not read wtatage.ss; 1 means read and use wtatage.ss and also read and use growth parameters" << endl;
  report4 << N_GP << "  #_N_Growth_Patterns (Growth Patterns, Morphs, Bio Patterns, GP are terms used interchangeably in SS3)" << endl;
  report4 << N_platoon << " #_N_platoons_Within_GrowthPattern " << endl;
  if (N_platoon == 1)
    report4 << "#_Cond ";
  else
    sd_ratio_rd = (sd_ratio_rd < 0)? -platoon_sd_ratio: platoon_sd_ratio;
  report4 << sd_ratio_rd << " #_Platoon_within/between_stdev_ratio (no read if N_platoons=1)" << endl;
  report4 << "#_Cond sd_ratio_rd < 0: platoon_sd_ratio parameter required after movement params." << endl;
  if (N_platoon == 1)
    report4 << "#_Cond ";
  report4 << platoon_distr(1, N_platoon) << " #vector_platoon_dist_(-1_in_first_val_gives_normal_approx)" << endl;
  report4 << "#" << endl;
  if (finish_starter == 999)
  {
    report4 << 2 << " # recr_dist_method for parameters:  2=main effects for GP, Settle timing, Area; 3=each Settle entity; 4=none, only when N_GP*Nsettle*pop==1" << endl;
  }
  else
  {
    report4 << recr_dist_method << " # recr_dist_method for parameters:  2=main effects for GP, Area, Settle timing; 3=each Settle entity; 4=none (only when N_GP*Nsettle*pop==1)" << endl;
  }
  report4 << recr_dist_area << " # not yet implemented; Future usage: Spawner-Recruitment: 1=global; 2=by area" << endl;
  report4 << N_settle_assignments << " #  number of recruitment settlement assignments " << endl;
  report4 << 0 << " # unused option" << endl;
  report4 << "#GPattern month  area  age (for each settlement assignment)" << endl
          << settlement_pattern_rd << endl
          << "#" << endl;
  if (pop == 1)
  {
    report4 << "#_Cond 0 # N_movement_definitions goes here if Nareas > 1" << endl
            << "#_Cond 1.0 # first age that moves (real age at begin of season, not integer) also cond on do_migration>0" << endl
            << "#_Cond 1 1 1 2 4 10 # example move definition for seas=1, morph=1, source=1 dest=2, age1=4, age2=10" << endl;
  }
  else
  {
    report4 << do_migration << " #_N_movement_definitions" << endl;
    if (do_migration > 0)
    {
      report4 << migr_firstage << " # first age that moves (real age at begin of season, not integer)" << endl
              << "# seas,GP,source_area,dest_area,minage,maxage" << endl
              << move_def << endl;
    }
    else
    {
      report4 << "#_Cond 1.0 # first age that moves (real age at begin of season, not integer) if do_migration>0" << endl
              << "#_Cond 1 1 1 2 4 10 # example move definition for seas=1, GP=1, source=1 dest=2, age1=4, age2=10" << endl;
    }
  }
  report4 << "#" << endl;
  report4 << N_Block_Designs << " #_Nblock_Patterns" << endl;
  if (N_Block_Designs > 0)
  {
    report4 << Nblk << " #_blocks_per_pattern " << endl
            << "# begin and end years of blocks" << endl
            << Block_Design << endl;
  }
  else
  {
    report4 << "#_Cond " << 0 << " #_blocks_per_pattern " << endl
            << "# begin and end years of blocks" << endl;
  }
  report4 << "#" << endl;
  report4 << "# controls for all timevary parameters " << endl;
  report4 << parm_adjust_method << " #_time-vary parm bound check (1=warn relative to base parm bounds; 3=no bound check); Also see env (3) and dev (5) options to constrain with base bounds" << endl
          << "#" << endl;
  report4 << "# AUTOGEN" << endl;
  report4 << autogen_timevary << " # autogen: 1st element for biology, 2nd for SR, 3rd for Q, 4th reserved, 5th for selex" << endl;
  report4 << "# where: 0 = autogen time-varying parms of this category; 1 = read each time-varying parm line; 2 = read then autogen if parm min==-12345" << endl;

  report4 << "#" << endl
          << "#_Available timevary codes" << endl;
  report4 << "#_Block types: 0: P_block=P_base*exp(TVP); 1: P_block=P_base+TVP; 2: P_block=TVP; 3: P_block=P_block(-1) + TVP" << endl;
  report4 << "#_Block_trends: -1: trend bounded by base parm min-max and parms in transformed units (beware); -2: endtrend and infl_year direct values; -3: end and infl as fraction of base range" << endl;

  report4 << "#_EnvLinks:  1: P(y)=P_base*exp(TVP*env(y));  2: P(y)=P_base+TVP*env(y);  3: P(y)=f(TVP,env_Zscore) w/ logit to stay in min-max;  4: P(y)=2.0/(1.0+exp(-TVP1*env(y) - TVP2))" << endl;
  report4 << "#_DevLinks:  1: P(y)*=exp(dev(y)*dev_se;  2: P(y)+=dev(y)*dev_se;  3: random walk;  4: zero-reverting random walk with rho;  5: like 4 with logit transform to stay in base min-max" << endl
          << "#_DevLinks(more):  21-25 keep last dev for rest of years" << endl
          << "#" << endl;
  report4 << "#_Prior_codes:  0=none; 6=normal; 1=symmetric beta; 2=CASAL's beta; 3=lognormal; 4=lognormal with biascorr; 5=gamma" << endl;
  report4 << "#" << endl
          << "# setup for M, growth, wt-len, maturity, fecundity, (hermaphro), recr_distr, cohort_grow, (movement), (age error), (catch_mult), sex ratio " << endl;
  report4 << "#_NATMORT" << endl
          << natM_type << " #_natM_type:_0=1Parm; 1=N_breakpoints;_2=Lorenzen;_3=agespecific;_4=agespec_withseasinterpolate;_5=BETA:_Maunder_link_to_maturity;_6=Lorenzen_range" << endl;
  if (natM_type == 0)
  {
    report4 << "  #_no additional input for selected M option; read 1P per morph" << endl;
  }
  else if (natM_type == 1)
  {
    report4 << N_natMparms << " #_N_breakpoints" << endl
            << NatM_break << " # age(real) at M breakpoints" << endl;
  }
  else if (natM_type == 2)
  {
    report4 << natM_amin << " #_reference age for Lorenzen M; read 1P per morph" << endl;
  }
  else if (natM_type == 6)
  {
    report4 << natM_amin << " #_minimum age for Lorenzen" << endl
            << natM_amax << " #_maximum age for Lorenzen; read 1P per morph" << endl;
  }
  else if (natM_type >= 3 && natM_type < 5)
  {
    report4 << " #_Age_natmort_by sex x growthpattern (nest GP in sex)" << endl
            << Age_NatMort << endl;
  }
  else
  {
    report4 << natM_5_opt << "  #_Maunder_M suboptions: 1 (4 parm per sex*GP, using age_maturity), 2 (4 parm, same), 3 (6 parm)" << endl;
    report4 << "#_Note:_parm2(young_fish_power)_has_neg_value_(plaus._range:~-3_to_0.0);linear_@_-1.0; const_@_0.0" << endl;
  }
  report4 << "#" << endl;
  report4 << Grow_type << " # GrowthModel: 1=vonBert with L1&L2; 2=Richards with L1&L2; 3=age_specific_K_incr; 4=age_specific_K_decr; 5=age_specific_K_each; 6=NA; 7=NA; 8=growth cessation" << endl;
  if (Grow_type <= 5 || Grow_type == 8)
  {
    report4 << AFIX << " #_Age(post-settlement) for L1 (aka Amin); first growth parameter is size at this age; linear growth below this" << endl
            << AFIX2 << " #_Age(post-settlement) for L2 (aka Amax); 999 to treat as Linf" << endl
            << Linf_decay << " #_exponential decay for growth above maxage (value should approx initial Z; -999 replicates 3.24; -998 to not allow growth above maxage)" << endl;
    report4 << "0  #_placeholder for future growth feature" << endl;
    if (Grow_type >= 3 && Grow_type <= 5)
    {
      report4 << Age_K_count << " # number of K multipliers to read" << endl
              << Age_K_points << " # ages for K multiplier" << endl;
    }
  }
  else
  {
    report4 << " #_growth type not implemented" << endl;
  }
  report4 << "#" << endl;
  report4 << SD_add_to_LAA << " #_SD_add_to_LAA (set to 0.1 for SS2 V1.x compatibility)" << endl; // constant added to SD length-at-age (set to 0.1 for compatibility with SS2 V1.x
  report4 << CV_depvar << " #_CV_Growth_Pattern:  0 CV=f(LAA); 1 CV=F(A); 2 SD=F(LAA); 3 SD=F(A); 4 logSD=F(A)" << endl;
  report4 << "#" << endl;
  report4 << Maturity_Option << " #_maturity_option:  1=length logistic; 2=age logistic; 3=read age-maturity matrix by growth_pattern; 4=read age-fecundity; 5=disabled; 6=read length-maturity" << endl;
  if (Maturity_Option == 3)
  {
    report4 << "#_Age_Maturity by growth pattern" << endl
            << Age_Maturity << endl;
  }
  else if (Maturity_Option == 4)
  {
    report4 << "#_Age_Fecundity by growth pattern" << endl
            << Age_Maturity << endl;
  }
  else if (Maturity_Option == 5)
  {
    report4 << "#_Age_Fecundity by growth pattern from wt-at-age.ss now invoked by read bodywt flag" << endl;
  }
  else if (Maturity_Option == 6)
  {
    report4 << "#_Length_Maturity by growth pattern" << endl
            << Length_Maturity << endl;
  }
  report4 << First_Mature_Age << " #_First_Mature_Age" << endl;
  if (Maturity_Option == 4 || Maturity_Option == 5) {
    report4 << "# NOTE: maturity options 4 and 5 cause fecundity_at_length to be ignored, but parameters still needed " << endl;
  }
  report4 << Fecund_Option << " #_fecundity_at_length option:(1)eggs=Wt*(a+b*Wt);(2)eggs=a*L^b;(3)eggs=a*Wt^b; (4)eggs=a+b*L; (5)eggs=a+b*W" << endl;
  report4 << Hermaphro_Option << " #_hermaphroditism option:  0=none; 1=female-to-male age-specific fxn; -1=male-to-female age-specific fxn" << endl;
  if (Hermaphro_Option != 0)
  {
    report4 << Hermaphro_seas_rd << " # Hermaphro_season.first_age (seas=-1 means all seasons; first_age must be 0 to 9)" << endl
            << Hermaphro_maleSSB << " # fraction_of_maleSSB_added_to_total_SSB " << endl;
  }

  report4 << MGparm_def << " #_parameter_offset_approach for M, G, CV_G:  1- direct, no offset**; 2- male=fem_parm*exp(male_parm); 3: male=female*exp(parm) then old=young*exp(parm)" << endl;
  report4 << "#_** in option 1, any male parameter with value = 0.0 and phase <0 is set equal to female parameter" << endl;
  report4 << "#" << endl;
  report4 << "#_growth_parms";
  if (N_GP > 1)
    report4 << ";  if N_GP>1, then nest GP within sex in parameters below";
  report4 << endl;
  report4 << "#_ LO HI INIT PRIOR PR_SD PR_type PHASE env_var&link dev_link dev_minyr dev_maxyr dev_PH Block Block_Fxn" << endl;
  NP = 0;
  for (gg = 1; gg <= gender; gg++)
  {
    for (gp = 1; gp <= N_GP; gp++)
    {
      report4 << "# Sex: " << gg << "  BioPattern: " << gp << "  NatMort" << endl;
      for (k = 1; k <= N_natMparms; k++)
      {
        NP++;
        MGparm_1(NP, 3) = value(MGparm(NP));
        report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
      }
      report4 << "# Sex: " << gg << "  BioPattern: " << gp << "  Growth" << endl;
      for (k = 1; k <= N_growparms; k++)
      {
        NP++;
        MGparm_1(NP, 3) = value(MGparm(NP));
        report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
      }
      report4 << "# Sex: " << gg << "  BioPattern: " << gp << "  WtLen" << endl;
      for (k = 1; k <= 2; k++)
      {
        NP++;
        MGparm_1(NP, 3) = value(MGparm(NP));
        report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
      }
      if (gg == 1)
      {
        report4 << "# Sex: " << gg << "  BioPattern: " << gp << "  Maturity&Fecundity" << endl;
        for (k = 1; k <= 4; k++)
        {
          NP++;
          MGparm_1(NP, 3) = value(MGparm(NP));
          report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
        }
      }
    }
  }
  report4 << "# Hermaphroditism" << endl;
  if (Hermaphro_Option != 0)
  {
    for (k = 1; k <= 3; k++)
    {
      NP++;
      MGparm_1(NP, 3) = value(MGparm(NP));
      report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
    }
  }

  report4 << "#  Recruitment Distribution " << endl;
  j = NP + 1;
  if (MGP_CGD > j)
  {
    for (k = j; k <= MGP_CGD - 1; k++)
    {
      NP++;
      MGparm_1(NP, 3) = value(MGparm(NP));
      report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
    }
  }

  report4 << "#  Cohort growth dev base" << endl;
  NP++;
  MGparm_1(NP, 3) = value(MGparm(NP));
  report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;

  report4 << "#  Movement" << endl;
  if (do_migration > 0)
  {
    for (k = 1; k <= 2 * do_migration; k++)
    {
      NP++;
      MGparm_1(NP, 3) = value(MGparm(NP));
      report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
    }
  }

  report4 << "#  Platoon StDev Ratio " << endl;
  if (N_platoon > 1 && sd_ratio_rd < 0)
  {
    NP++;
    MGparm_1(NP, 3) = value(MGparm(NP));
    report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
  }
  
  report4 << "#  Age Error from parameters" << endl;
  if (Use_AgeKeyZero > 0)
  {
    for (k = 1; k <= 7; k++)
    {
      NP++;
      MGparm_1(NP, 3) = value(MGparm(NP));
      report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
    }
  }

  report4 << "#  catch multiplier" << endl;
  if (catch_mult_pointer > 0)
  {
    for (k = 1; k <= Nfleet; k++)
      if (need_catch_mult(k) == 1)
      {
        NP++;
        MGparm_1(NP, 3) = value(MGparm(NP));
        report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
      }
  }

  //  for (f=1;f<=N_MGparm;f++)
  //  {
  //    NP++;
  //    MGparm_1(f,3)=value(MGparm(f));
  //    report4<<MGparm_1(f)<<" # "<<ParmLabel(NP)<<endl;
  //  }
  report4 << "#  fraction female, by GP" << endl;

  if (frac_female_pointer == -1) //  3.24 format
  {
    // placeholders to change fracfemale (3.24) to MGparm (3.30)
    for (gp = 1; gp <= N_GP; gp++)
    {
      report4 << " 0.000001 0.999999 " << femfrac(gp) << " 0.5  0.5 0 -99 0 0 0 0 0 0 0 "
              << "# FracFemale_GP_" << gp << endl;
    }
  }
  else
  {
    for (gp = 1; gp <= N_GP; gp++)
    {
      NP++;
      MGparm_1(NP, 3) = value(MGparm(NP));
      report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
    }
  }

  report4 << "#  M2 parameter for each predator fleet" << endl;
  for (int gp = 1; gp <= N_predparms; gp++)
  {
    NP++;
    MGparm_1(NP, 3) = value(MGparm(NP));
    report4 << MGparm_1(NP) << " # " << ParmLabel(NP) << endl;
  }

  report4 << "#" << endl;
  j = N_MGparm;
  if (timevary_parm_cnt_MG > 0)
  {
    report4 << "# timevary MG parameters " << endl
            << "#_ LO HI INIT PRIOR PR_SD PR_type  PHASE" << endl;
    for (f = 1; f <= timevary_parm_cnt_MG; f++)
    {
      NP++;
      timevary_parm_rd[f](3) = value(timevary_parm(f));
      report4 << timevary_parm_rd[f] << " # " << ParmLabel(NP) << endl;
    }
    report4 << "# info on dev vectors created for MGparms are reported with other devs after tag parameter section " << endl;
  }
  else
  {
    report4 << "#_no timevary MG parameters" << endl;
  }

  report4 << "#" << endl;
  report4 << "#_seasonal_effects_on_biology_parms" << endl
          << MGparm_seas_effects << " #_femwtlen1,femwtlen2,mat1,mat2,fec1,fec2,Malewtlen1,malewtlen2,L1,K" << endl;
  report4 << "#_ LO HI INIT PRIOR PR_SD PR_type PHASE" << endl;
  if (MGparm_doseas > 0)
  {
    for (f = 1; f <= N_MGparm_seas; f++)
    {
      NP++;
      j++;
      MGparm_seas_1(f, 3) = value(MGparm(j));
      report4 << MGparm_seas_1(f) << " # " << ParmLabel(NP) << endl;
    }
  }
  else
  {
    report4 << "#_Cond -2 2 0 0 -1 99 -2 #_placeholder when no seasonal MG parameters" << endl;
  }

  report4 << "#" << endl;
  report4 << SR_fxn << " #_Spawner-Recruitment; Options: 1=NA; 2=Ricker; 3=std_B-H; 4=SCAA; 5=Hockey; 6=B-H_flattop; 7=survival_3Parm; 8=Shepherd_3Parm; 9=RickerPower_3parm; 10=B-H_ab" << endl;
  report4 << init_equ_steepness << "  # 0/1 to use steepness in initial equ recruitment calculation" << endl;
  report4 << " 0 #  not_used" << endl;
  report4 << "#_          LO            HI          INIT         PRIOR         PR_SD       PR_type      PHASE    env-var    use_dev   dev_mnyr   dev_mxyr     dev_PH      Block    Blk_Fxn #  parm_name" << endl;
  report4.unsetf(std::ios_base::fixed);
  report4.unsetf(std::ios_base::floatfield);
  for (f = 1; f <= N_SRparm2; f++)
  {
    NP++;
    SRparm_1(f, 3) = value(SRparm(f));
    for (j = 1; j <= 6; j++)
      report4 << setw(14) << SRparm_1(f, j);
    for (j = 7; j <= 14; j++)
      report4 << setw(11) << SRparm_1(f, j);
    report4 << " # " << ParmLabel(NP) << endl;
  }
  report4.unsetf(std::ios_base::fixed);
  report4.unsetf(std::ios_base::floatfield);
  if (N_SRparm3 > N_SRparm2)
  {
    report4 << "# timevary SR parameters" << endl;
    for (f = timevary_SRparm_first; f <= timevary_parm_SR_last; f++)
    {
      NP++;
      timevary_parm_rd[f](3) = value(timevary_parm(f));
      report4 << timevary_parm_rd[f] << " # " << ParmLabel(NP) << endl;
    }
    report4.precision(6);
    report4.unsetf(std::ios_base::fixed);
    report4.unsetf(std::ios_base::floatfield);
  }
  else
  {
    report4 << "#_no timevary SR parameters" << endl;
  }

  report4 << do_recdev << " #do_recdev:  0=none; 1=devvector (R=F(SSB)+dev); 2=deviations (R=F(SSB)+dev); 3=deviations (R=R0*dev; dev2=R-f(SSB)); 4=like 3 with sum(dev2) adding penalty" << endl;
  report4 << recdev_start << " # first year of main recr_devs; early devs can precede this era" << endl;
  report4 << recdev_end << " # last year of main recr_devs; forecast devs start in following year" << endl;
  report4 << recdev_PH_rd << " #_recdev phase " << endl;
  report4 << recdev_adv << " # (0/1) to read 13 advanced options" << endl;
  if (recdev_adv == 0)
  {
    onenum = "#_Cond ";
  }
  else
  {
    onenum = " ";
  }
  report4 << onenum << recdev_early_start_rd << " #_recdev_early_start (0=none; neg value makes relative to recdev_start)" << endl;
  report4 << onenum << recdev_early_PH_rd << " #_recdev_early_phase" << endl;
  report4 << onenum << Fcast_recr_PH_rd << " #_forecast_recruitment phase (incl. late recr) (0 value resets to maxphase+1)" << endl;
  report4 << onenum << Fcast_recr_lambda << " #_lambda for Fcast_recr_like occurring before endyr+1" << endl;
  report4 << onenum << recdev_adj(1) << " #_last_yr_nobias_adj_in_MPD; begin of ramp" << endl;
  report4 << onenum << recdev_adj(2) << " #_first_yr_fullbias_adj_in_MPD; begin of plateau" << endl;
  report4 << onenum << recdev_adj(3) << " #_last_yr_fullbias_adj_in_MPD" << endl;
  report4 << onenum << recdev_adj(4) << " #_end_yr_for_ramp_in_MPD (can be in forecast to shape ramp, but SS3 sets bias_adj to 0.0 for fcast yrs)" << endl;
  report4 << onenum << recdev_adj(5) << " #_max_bias_adj_in_MPD (typical ~0.8; -3 sets all years to 0.0; -2 sets all non-forecast yrs w/ estimated recdevs to 1.0; -1 sets biasadj=1.0 for all yrs w/ recdevs)" << endl;
  report4 << onenum << recdev_cycle << " #_period of cycles in recruitment (N parms read below)" << endl;
  report4 << onenum << recdev_LO << " #min rec_dev" << endl;
  report4 << onenum << recdev_HI << " #max rec_dev" << endl;
  report4 << onenum << recdev_read << " #_read_recdevs" << endl;
  report4 << "#_end of advanced SR options" << endl;
  report4 << "#" << endl;
  if (recdev_cycle > 0)
  {
    for (y = 1; y <= recdev_cycle; y++)
    {
      NP++;
      recdev_cycle_parm_RD(y, 3) = value(recdev_cycle_parm(y));
      report4 << recdev_cycle_parm_RD(y) << " # " << ParmLabel(NP) << endl;
    }
  }
  else
  {
    report4 << "#_placeholder for full parameter lines for recruitment cycles" << endl;
  }
  if (recdev_read > 0)
  {
    report4 << "# Specified recr devs to read" << endl;
    report4 << "#_year Input_value # Final_value" << endl;
    for (j = 1; j <= recdev_read; j++)
    {
      y = recdev_input(j, 1);
      report4 << recdev_input(j) << " # ";
      if (y >= recdev_first)
      {
        report4 << recdev(y) << endl;
      }
      else
      {
        report4 << " not used " << endl;
      }
    }
  }
  else
  {
    report4 << "# read specified recr devs" << endl;
    report4 << "#_year Input_value" << endl;
  }
  report4 << "#" << endl;
  report4 << "# all recruitment deviations" << endl
          << "# ";
  if (recdev_do_early > 0)
  {
    for (y = recdev_early_start; y <= recdev_early_end; y++)
    {
      report4 << " " << y << "E";
    }
  }
  if (do_recdev > 0)
  {
    for (y = recdev_start; y <= recdev_end; y++)
    {
      report4 << " " << y << "R";
    }
  }
  if (Do_Forecast > 0)
  {
    for (y = recdev_end + 1; y <= YrMax; y++)
    {
      report4 << " " << y << "F";
    }
  }
  report4 << endl
          << "# ";
  if (recdev_do_early > 0)
  {
    for (y = recdev_early_start; y <= recdev_early_end; y++)
    {
      NP++;
      report4 << " " << recdev(y);
    }
  }

  if (do_recdev > 0)
  {
    for (y = recdev_start; y <= recdev_end; y++)
    {
      NP++;
      report4 << " " << recdev(y);
    }
  }

  if (Do_Forecast > 0 && do_recdev > 0)
  {
    for (y = recdev_end + 1; y <= YrMax; y++)
    {
      NP++;
      report4 << " " << recdev(y);
    }
    report4 << endl;
    if (Do_Impl_Error > 0)
    {
      report4 << "# implementation error by year in forecast: ";
      for (y = endyr + 1; y <= YrMax; y++)
      {
        NP++;
        report4 << " " << Fcast_impl_error(y);
      }
      report4 << endl;
    }
  }
  report4 << "#" << endl;
  report4 << "#Fishing Mortality info " << endl;
  report4 << F_ballpark << " # F ballpark value in units of annual_F" << endl;
  report4 << F_ballpark_yr << " # F ballpark year (neg value to disable)" << endl;

  report4 << F_Method << " # F_Method:  1=Pope midseason rate; 2=F as parameter; 3=F as hybrid; 4=fleet-specific parm/hybrid (#4 is superset of #2 and #3 and is recommended)" << endl;
  report4 << max_harvest_rate << " # max F (methods 2-4) or harvest fraction (method 1)" << endl;
  if (F_Method == 1)
  {
    report4 << "# F_Method 1:  no additional input needed" << endl;
  }
  else if (F_Method == 2)
  {
    report4 << F_parm_intval(1) << " # overall start F value (all fleets; used if start phase = 1 and not reading parfile)" << endl;
    report4 << F_Method_PH(1) << " # start phase for parms (does hybrid in early phases)" << endl;
    report4 << F_detail << " # N detailed inputs to read" << endl;
    report4 << "# detailed setup for F_Method=2; -Yr to fill remaining years; -999 for phase or se ignores keeps default for those fields " << endl;
    report4 << "#_fleet year seas F_value se phase" << endl;
    if (F_detail > 0)
      report4 << F_setup2 << endl;
  }
  else if (F_Method == 3)
  {
    report4 << F_Tune << "  # N iterations for tuning in hybrid mode; recommend 3 (faster) to 5 (more precise if many fleets)" << endl;
  }
  else if (F_Method == 4)
  {
    report4 << "# Read list of fleets that do F as parameter; unlisted fleets stay hybrid, bycatch fleets must be included with start_PH=1, high F fleets should switch early" << endl;
    report4 << "# (A) fleet;" << endl <<"# (B) F_starting_value (ignored if start_PH=1 or reading from ss3.par);" <<
    endl << "# (C) start_PH for fleet's Fparms (99 to stay in hybrid, <0 to stay at starting value)" << endl << 
    "# Terminate list with -9999 for fleet" << endl <<
    "# or terminate with -9998 to invoke reading fleet-time specific F values after first reading N hybrid tune loops)" << endl;
    report4 << "# (A) (B) (C)" << endl;
    for (unsigned j = 1; j <= F_Method_4_input.size() - 2; j++)
    {
      report4 << F_Method_4_input[j] << " # " << fleetname(F_Method_4_input[j](1)) << endl;
    }
    if (F_detail <=0 )
    {report4 << -9999 << " 1 1 # end of list" << endl <<
       "#F_detail template: fleet year seas F_value catch_se phase" << endl; }
    else
    {report4 << -9998 << " 1 1 # end of list, triggers reading F_detail" << endl; }
    report4 << F_Tune << " #_number of loops for hybrid tuning; 4 precise; 3 faster; 2 enough if switching to parms is enabled" << endl;
    if (F_detail > 0)
    {
      report4 << "# F_detail:  List of fleet-time specific F related values to read; enter -Yr to fill remaining years&seasons; -999 for phase or catch_se keeps base value for the run" << endl;
      report4 << "#fleet year seas F_value catch_se phase" << endl;
      report4 << F_setup2 << endl;
      report4 << "-9999 1 1 1 1 1  # end of F_detail" << endl;
    }
  }

  report4 << "#" << endl;
  report4 << "#_initial_F_parms; for each fleet x season that has init_catch; nest season in fleet; count = " << N_init_F2 << endl;
  report4 << "#_for unconstrained init_F, use an arbitrary initial catch and set lambda=0 for its logL" << endl;
  report4 << "#_ LO HI INIT PRIOR PR_SD  PR_type  PHASE" << endl;
  if (finish_starter == 999)
  {
    for (f = 1; f <= Nfleet1; f++)
    {
      NP++;
  init_F_parm_1(f, 3) = value(init_F(f));
      if (obs_equ_catch(1, f) != 0.)
        report4 << init_F_parm_1(f) << " # " << ParmLabel(NP) << endl;
    }
  }
  else if (N_init_F2 > 0)
  {
    for (f = 1; f <= N_init_F2; f++)
    {
      NP++;
  init_F_parm_1(f, 3) = value(init_F(f));
      report4 << init_F_parm_1(f) << " # " << ParmLabel(NP) << endl;
    }
  }

  report4 << "#" << endl
          << "# F rates by fleet x season" << endl;
  report4 << "#_year: ";
  for (y = styr; y <= YrMax; y++)
    for (s = 1; s <= nseas; s++)
    {
      report4 << " " << y;
    }
  report4 << endl
          << "# seas: ";
  for (y = styr; y <= YrMax; y++)
    for (s = 1; s <= nseas; s++)
    {
      report4 << " " << s;
    }
  report4 << endl;
  j = styr + (YrMax - styr) * nseas + nseas - 1;
  for (f = 1; f <= Nfleet; f++)
    if (fleet_type(f) <= 2)
    {
      report4 << "# " << fleetname(f) << Hrate(f)(styr, j) << endl;
    }
  NP += N_Fparm;
  report4 << "#" << endl;
  report4 << "#_Q_setup for fleets with cpue or survey or deviation data" << endl;
  report4 << "#_1:  fleet number" << endl;
  report4 << "#_2:  link type: 1=simple q; 2=mirror; 3=power (+1 parm); 4=mirror with scale (+1p); 5=offset (+1p); 6=offset & power (+2p)" << endl;
  report4 << "#_     where power is applied as y = q * x ^ (1 + power); so a power value of 0 has null effect" << endl;
  report4 << "#_     and with the offset included it is y = q * (x + offset) ^ (1 + power)" << endl;
  report4 << "#_3:  extra input for link, i.e. mirror fleet# or dev index number" << endl;
  report4 << "#_4:  0/1 to select extra sd parameter" << endl;
  report4 << "#_5:  0/1 for biasadj or not" << endl;
  report4 << "#_6:  0/1 to float" << endl;
  if (depletion_fleet > 0) //  special code for depletion, so prepare to adjust phases and lambdas
  {
    f = depletion_fleet;
    report4 << "#_survey: " << f << " " << fleetname(f) << " is a depletion fleet" << endl;
    if (depletion_type == 0)
      report4 << "#_Q_setup(f,2)=0; add 1 to phases of all parms; only R0 active in new phase 1" << endl;
    if (depletion_type == 1)
      report4 << "#_Q_setup(f,2)=1  only R0 active in phase 1; then exit;  useful for data-limited draws of other fixed parameter" << endl;
    if (depletion_type == 2)
      report4 << "#_Q_setup(f,2)=2  no phase adjustments, can be used when profiling on fixed R0" << endl;
  }

  report4 << "#_   fleet      link link_info  extra_se   biasadj     float  #  fleetname" << endl;
  for (f = 1; f <= Nfleet; f++)
  {
    if (Svy_N_fleet(f) > 0)
    {
      report4 << " " << setw(9) << f;
      for (j = 1; j <= 5; j++)
        report4 << setw(10) << Q_setup(f, j);
      report4 << "  #  " << fleetname(f) << endl;
    }
  }
  report4 << "-9999 0 0 0 0 0" << endl
          << "#" << endl;

  report4 << "#_Q_parameters" << endl;
  if (Q_Npar > 0)
  {
    report4 << "#_          LO            HI          INIT         PRIOR         PR_SD       PR_type      PHASE    env-var    use_dev   dev_mnyr   dev_mxyr     dev_PH      Block    Blk_Fxn  #  parm_name" << endl;
    report4.unsetf(std::ios_base::fixed);
    report4.unsetf(std::ios_base::floatfield);
    for (f = 1; f <= Q_Npar; f++)
    {
      NP++;
      Q_parm_1(f, 3) = value(Q_parm(f));
      for (j = 1; j <= 6; j++)
        report4 << setw(14) << Q_parm_1(f, j);
      for (j = 7; j <= 14; j++)
        report4 << setw(11) << Q_parm_1(f, j);
      report4 << "  #  " << ParmLabel(NP) << endl;
    }
    report4.unsetf(std::ios_base::fixed);
    report4.unsetf(std::ios_base::floatfield);

    if (timevary_parm_start_Q > 0)
    {
      report4 << "# timevary Q parameters " << endl;
      report4 << "#_          LO            HI          INIT         PRIOR         PR_SD       PR_type     PHASE  #  parm_name" << endl;
      for (f = timevary_parm_start_Q; f <= timevary_parm_cnt_Q; f++)
      {
        NP++;
        timevary_parm_rd[f](3) = value(timevary_parm(f));
        for (j = 1; j <= 6; j++)
          report4 << setw(14) << timevary_parm_rd[f](j);
        report4 << "      " << timevary_parm_rd[f](7) << "  # " << ParmLabel(NP) << endl;
      }
      report4 << "# info on dev vectors created for Q parms are reported with other devs after tag parameter section " << endl;
    }
    else
    {
      report4 << "#_no timevary Q parameters" << endl;
    }
    report4.unsetf(std::ios_base::fixed);
    report4.unsetf(std::ios_base::floatfield);
  }
  report4 << "#" << endl;
  report4 << "#_size_selex_patterns" << endl;

  report4 << "#Pattern:_0;  parm=0; selex=1.0 for all sizes" << endl;
  report4 << "#Pattern:_1;  parm=2; logistic; with 95% width specification" << endl;
  report4 << "#Pattern:_5;  parm=2; mirror another size selex; PARMS pick the min-max bin to mirror" << endl;
  report4 << "#Pattern:_11; parm=2; selex=1.0  for specified min-max population length bin range" << endl;
  report4 << "#Pattern:_15; parm=0; mirror another age or length selex" << endl;
  report4 << "#Pattern:_6;  parm=2+special; non-parm len selex" << endl;
  report4 << "#Pattern:_43; parm=2+special+2;  like 6, with 2 additional param for scaling (mean over bin range)" << endl;
  report4 << "#Pattern:_8;  parm=8; double_logistic with smooth transitions and constant above Linf option" << endl;
  report4 << "#Pattern:_9;  parm=6; simple 4-parm double logistic with starting length; parm 5 is first length; parm 6=1 does desc as offset" << endl;
  report4 << "#Pattern:_21; parm=2*special; non-parm len selex, read as N break points, then N selex parameters" << endl;
  report4 << "#Pattern:_22; parm=4; double_normal as in CASAL" << endl;
  report4 << "#Pattern:_23; parm=6; double_normal where final value is directly equal to sp(6) so can be >1.0" << endl;
  report4 << "#Pattern:_24; parm=6; double_normal with sel(minL) and sel(maxL), using joiners" << endl;
  report4 << "#Pattern:_2;  parm=6; double_normal with sel(minL) and sel(maxL), using joiners, back compatibile version of 24 with 3.30.18 and older" << endl;
  report4 << "#Pattern:_25; parm=3; exponential-logistic in length" << endl;
  report4 << "#Pattern:_27; parm=special+3; cubic spline in length; parm1==1 resets knots; parm1==2 resets all " << endl;
  report4 << "#Pattern:_42; parm=special+3+2; cubic spline; like 27, with 2 additional param for scaling (mean over bin range)" << endl;

  report4 << "#_discard_options:_0=none;_1=define_retention;_2=retention&mortality;_3=all_discarded_dead;_4=define_dome-shaped_retention" << endl;
  report4 << "#_Pattern Discard Male Special" << endl;
  for (f = 1; f <= Nfleet; f++)
    report4 << seltype_rd(f) << " # " << f << " " << fleetname(f) << endl;
  report4 << "#" << endl;

  report4 << "#_age_selex_patterns" << endl;
  report4 << "#Pattern:_0; parm=0; selex=1.0 for ages 0 to maxage" << endl;
  report4 << "#Pattern:_10; parm=0; selex=1.0 for ages 1 to maxage" << endl;
  report4 << "#Pattern:_11; parm=2; selex=1.0  for specified min-max age" << endl;
  report4 << "#Pattern:_12; parm=2; age logistic" << endl;
  report4 << "#Pattern:_13; parm=8; age double logistic. Recommend using pattern 18 instead." << endl;
  report4 << "#Pattern:_14; parm=nages+1; age empirical" << endl;
  report4 << "#Pattern:_15; parm=0; mirror another age or length selex" << endl;
  report4 << "#Pattern:_16; parm=2; Coleraine - Gaussian" << endl;
  report4 << "#Pattern:_17; parm=nages+1; empirical as random walk  N parameters to read can be overridden by setting special to non-zero" << endl;
  report4 << "#Pattern:_41; parm=2+nages+1; // like 17, with 2 additional param for scaling (mean over bin range)" << endl;
  report4 << "#Pattern:_18; parm=8; double logistic - smooth transition" << endl;
  report4 << "#Pattern:_19; parm=6; simple 4-parm double logistic with starting age" << endl;
  report4 << "#Pattern:_20; parm=6; double_normal,using joiners" << endl;
  report4 << "#Pattern:_26; parm=3; exponential-logistic in age" << endl;
  report4 << "#Pattern:_27; parm=3+special; cubic spline in age; parm1==1 resets knots; parm1==2 resets all " << endl;
  report4 << "#Pattern:_42; parm=2+special+3; // cubic spline; with 2 additional param for scaling (mean over bin range)" << endl;
  report4 << "#Age patterns entered with value >100 create Min_selage from first digit and pattern from remainder" << endl;
  report4 << "#_Pattern Discard Male Special" << endl;
  for (f = 1; f <= Nfleet; f++)
    report4 << seltype_rd(f + Nfleet) << " # " << f << " " << fleetname(f) << endl;
  report4 << "#" << endl;

  report4 << "#_          LO            HI          INIT         PRIOR         PR_SD       PR_type      PHASE    env-var    use_dev   dev_mnyr   dev_mxyr     dev_PH      Block    Blk_Fxn  #  parm_name" << endl;

  // set back to default configuration for output
  report4.unsetf(std::ios_base::fixed);
  report4.unsetf(std::ios_base::floatfield);

  {
    k = 0;
    for (f = 1; f <= 2 * Nfleet; f++)
    {
      if (f > Nfleet)
      {
        f1 = f - Nfleet;
        anystring = "AgeSelex";
      }
      else
      {
        f1 = f;
        anystring = "LenSelex";
      }
      report4 << "# " << f1 << "   " << fleetname(f1) << " " << anystring << endl;
      for (j = 1; j <= N_selparmvec(f); j++)
      {
        NP++;
        k++;
        selparm_1(k)(3) = value(selparm(k));
        for (z = 1; z <= 6; z++)
          report4 << setw(14) << selparm_1(k, z);
        for (z = 7; z <= 14; z++)
          report4 << setw(11) << selparm_1(k, z);
        report4 << "  #  " << ParmLabel(NP) << endl;
      }
    }
    if (Comp_Err_ParmCount > 0)
    {
      report4 << "#_Dirichlet and/or MV Tweedie parameters for composition error" << endl;
      report4 << "#_multiple_fleets_can_refer_to_same_parm;_but_list_cannot_have_gaps" << endl;
      k = Comp_Err_Parm_Start;
      for (f = 1; f <= Comp_Err_ParmCount; f++)
      {
        k++;
        NP++;
        selparm_1(k)(3) = value(selparm(k));
        for (z = 1; z <= 6; z++)
          report4 << setw(14) << selparm_1(k, z);
        for (z = 7; z <= 14; z++)
          report4 << setw(11) << selparm_1(k, z);
        report4 << "  #  " << ParmLabel(NP) << endl;
      }
    }
    else
    {
      report4 << "#_No_Dirichlet parameters" << endl;
    }

    if (N_selparm3 > N_selparm)
    {
      report4 << "# timevary selex parameters " << endl;
      report4 << "#_          LO            HI          INIT         PRIOR         PR_SD       PR_type    PHASE  #  parm_name" << endl;
      //    for (f=timevary_parm_start_sel;f<=timevary_parm_cnt_sel;f++)
      for (int f = timevary_parm_start_sel; f <= timevary_parm_start_sel + N_selparm3 - N_selparm - 1; f++)
      {
        NP++;
        timevary_parm_rd[f](3) = value(timevary_parm(f));
        for (j = 1; j <= 6; j++)
          report4 << setw(14) << timevary_parm_rd[f](j);
        report4 << "      " << timevary_parm_rd[f](7) << "  # " << ParmLabel(NP) << endl;
      }
      report4 << "# info on dev vectors created for selex parms are reported with other devs after tag parameter section " << endl;
    }
    else
    {
      report4 << "#_no timevary selex parameters" << endl;
    }

    report4 << "#" << endl
            << TwoD_AR_do << "   #  use 2D_AR1 selectivity? (0/1)" << endl;
    if (TwoD_AR_do > 0)
    {
      k = timevary_parm_start_sel + N_selparm3 - N_selparm - 1; //  starting point in timevary_parm_rd
      report4 << "#_specifications for 2D_AR1 and associated parameters" << endl;
      report4 << "#_specs:  fleet, ymin, ymax, amin, amax, sigma_amax, use_rho, len1/age2, devphase, before_range, after_range" << endl;
      report4 << "#_sigma_amax>amin means create sigma parm for each bin from min to sigma_amax; sigma_amax<0 means just one sigma parm is read and used for all bins" << endl;
      for (j = 1; j <= TwoD_AR_cnt; j++)
      {
        ivector tempvec(1, 13); //  fleet, ymin, ymax, amin, amax, sigma_amax, use_rho, len1/age2, devphase
        tempvec(1, 13) = TwoD_AR_def[j](1, 13);
        tempvec(6) = TwoD_AR_def_rd[j](6); //  restore the read value in case it got changed
        int isigmasel = TwoD_AR_def[j](13);  //  index of first sigmasel parm in selparm
        if (tempvec(8) == 1)
        {
          anystring = "LEN";
        }
        else
        {
          anystring = "AGE";
        }

        report4 << tempvec(1, 11) << "  #  2D_AR specs for fleet: " << fleetname(tempvec(1)) << " " << anystring << endl;
        int sigma_amax = tempvec(6);
        int use_rho = tempvec(7);
        int amin = tempvec(4);
        int kmax = sigma_amax;
        if (kmax < 0)  kmax = amin;
        for (a = amin; a <= kmax; a++)
        {
          dvector dtempvec(1, 7); //  Lo, Hi, init, prior, prior_sd, prior_type, phase;
          k++;
          dtempvec = timevary_parm_rd[k](1, 7);
          dtempvec(3) = value ( selparm(isigmasel + a - amin) );
          report4 << dtempvec << "  # sigma_sel for fleet:_" << tempvec(1) << "; " << anystring << "_" << a <<endl;
        }
        if (use_rho == 1)
        {
          dvector dtempvec(1, 7); //  Lo, Hi, init, prior, prior_sd, prior_type, phase;
          k++;
          dtempvec = timevary_parm_rd[k](1, 7);
          report4 << dtempvec << "  # rho_year for fleet:_" << tempvec(1) << endl;
          k++;
          dtempvec = timevary_parm_rd[k](1, 7);
          report4 << dtempvec << "  # rho_" << anystring << " for fleet:_" << tempvec(1) << endl;
        }
      }
      report4 << "-9999  0 0 0 0 0 0 0 0 0 0 # terminator" << endl;
    }
    else
    {
      report4 << "#_no 2D_AR1 selex offset used" << endl;
      report4 << "#_specs:  fleet, ymin, ymax, amin, amax, sigma_amax, use_rho, len1/age2, devphase, before_range, after_range" << endl;
      report4 << "#_sigma_amax>amin means create sigma parm for each bin from min to sigma_amax; sigma_amax<0 means just one sigma parm is read and used for all bins" << endl;
      report4 << "#_needed parameters follow each fleet's specifications"<<endl;
      report4 << "# -9999  0 0 0 0 0 0 0 0 0 0 # terminator" << endl;
    }

    report4.unsetf(std::ios_base::fixed);
    report4.unsetf(std::ios_base::floatfield);
  }

  j = N_selparm;

  report4 << "#" << endl
          << "# Tag loss and Tag reporting parameters go next" << endl;
  if (Do_TG > 0)
  {
    report4 << 1 << " # TG_custom:  0=no read and autogen if tag data exist; 1=read" << endl;
    report4 << "#_Note -  tag parameters cannot be time-varying" << endl;
    report4 << "#_Note -  phase=-1000 sets parm value to previous parm; phase=-100X sets to parm(X) value" << endl;
    for (f = 1; f <= 3 * N_TG + 2 * Nfleet1; f++)
    {
      NP++;
      report4 << TG_parm2(f)(1, 2) << " " << TG_parm(f) << " " << TG_parm2(f)(4, 14) << " # " << ParmLabel(NP) << endl;
    }
  }
  else
  {
    report4 << "0  # TG_custom:  0=no read and autogen if tag data exist; 1=read" << endl
            << "#_Cond -6 6 1 1 2 0.01 -4 0 0 0 0 0 0 0  #_placeholder if no parameters" << endl;
    ;
  }
  report4 << "#" << endl;
  if (timevary_cnt == 0)
  {
    report4 << "# no timevary parameters" << endl
            << "#" << endl;
  }
  else
  {
    report4 << "# deviation vectors for timevary parameters" << endl
            << "#  base   base first block   block  env  env   dev   dev   dev   dev   dev" << endl
            << "#  type  index  parm trend pattern link  var  vectr link _mnyr  mxyr phase  dev_vector" << endl;

    for (j = 1; j <= timevary_cnt; j++)
    {
      //        report4.precision(6);
      //        report4.unsetf(std::ios_base::fixed);
      //        report4.unsetf(std::ios_base::floatfield);
      report4 << setw(2) << "# ";
      report4 << setw(5) << timevary_def[j](1, 12);
      if (timevary_def[j](8) > 0) //  now show devs
      {
        report4 << setw(6) << parm_dev(timevary_def[j](8));
      }
      report4 << setw(6) << endl;
    }
  }

  report4 << "#" << endl
          << "# Input variance adjustments factors: " << endl;
  report4 << " #_1=add_to_survey_CV" << endl;
  report4 << " #_2=add_to_discard_stddev" << endl;
  report4 << " #_3=add_to_bodywt_CV" << endl;
  report4 << " #_4=mult_by_lencomp_N" << endl;
  report4 << " #_5=mult_by_agecomp_N" << endl;
  report4 << " #_6=mult_by_size-at-age_N" << endl;
  report4 << " #_7=mult_by_generalized_sizecomp" << endl;
  report4 << "#_factor  fleet  value" << endl;
  {
    if (var_adjust_data.size() > 0)
      for (f = 1; f <= Do_Var_adjust; f++)
        report4 << setw(6) << var_adjust_data[f - 1](1, 2) << " " << setw(9) << var_adjust_data[f - 1](3) << endl;
  }
  report4 << " -9999   1    0  # terminator" << endl;

  report4.precision(6);
  report4.unsetf(std::ios_base::fixed);
  report4.unsetf(std::ios_base::floatfield);

  report4 << "#" << endl
          << max_lambda_phase << " #_maxlambdaphase" << endl;
  report4 << sd_offset << " #_sd_offset; must be 1 if any growthCV, sigmaR, or survey extraSD is an estimated parameter" << endl;

  report4 << "# read " << N_lambda_changes << " changes to default Lambdas (default value is 1.0)" << endl;
  report4 << "# Like_comp codes:  1=surv; 2=disc; 3=mnwt; 4=length; 5=age; 6=SizeFreq; 7=sizeage; 8=catch; 9=init_equ_catch; " << endl
          << "# 10=recrdev; 11=parm_prior; 12=parm_dev; 13=CrashPen; 14=Morphcomp; 15=Tag-comp; 16=Tag-negbin; 17=F_ballpark; 18=initEQregime" << endl
          << "#like_comp fleet  phase  value  sizefreq_method" << endl;

  if (N_lambda_changes > 0)
    report4 << Lambda_changes << endl;
  report4 << "-9999  1  1  1  1  #  terminator" << endl;

  report4 << "#" << endl
          << "# lambdas (for info only; columns are phases)" << endl;
  if (Svy_N > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      report4 << "# " << surv_lambda(f) << " #_CPUE/survey:_" << f << endl;
  }
  if (nobs_disc > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      report4 << "# " << disc_lambda(f) << " #_discard:_" << f << endl;
  }
  if (nobs_mnwt > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      report4 << "# " << mnwt_lambda(f) << " #_meanbodywt:" << f << endl;
  }
  if (Nobs_l_tot > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      report4 << "# " << length_lambda(f) << " #_lencomp:_" << f << endl;
  }
  if (Nobs_a_tot > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      report4 << "# " << age_lambda(f) << " #_agecomp:_" << f << endl;
  }
  if (SzFreq_Nmeth > 0)
    for (f = 1; f <= SzFreq_N_Like; f++)
      report4 << "# " << SzFreq_lambda(f) << " #_sizefreq:_" << f << endl;
  if (nobs_ms_tot > 0)
  {
    for (f = 1; f <= Nfleet; f++)
      report4 << "# " << sizeage_lambda(f) << " #_size-age:_" << f << endl;
  }
  for (f = 1; f <= Nfleet; f++)
    report4 << "# " << init_equ_lambda(f) << " #_init_equ_catch" << f << endl;
  report4 << "# " << recrdev_lambda << " #_recruitments" << endl;
  report4 << "# " << parm_prior_lambda << " #_parameter-priors" << endl;
  report4 << "# " << parm_dev_lambda << " #_parameter-dev-vectors" << endl;
  if (Do_TG > 0)
  {
    for (TG = 1; TG <= N_TG; TG++)
      report4 << "# " << TG_lambda1(TG) << " #_TG-comp_group:_" << TG << endl;
    for (TG = 1; TG <= N_TG; TG++)
      report4 << "# " << TG_lambda2(TG) << " #_TG-negbin_group:_" << TG << endl;
  }
  report4 << "# " << CrashPen_lambda << " #_crashPenLambda" << endl;
  if (Do_Morphcomp > 0)
    report4 << "# " << Morphcomp_lambda << " #_Morphcomplambda" << endl;
  report4 << "# " << F_ballpark_lambda << " # F_ballpark_lambda" << endl;

  report4 << Do_More_Std << " # (0/1/2) read specs for more stddev reporting: 0 = skip, 1 = read specs for reporting stdev for selectivity, size, and numbers, 2 = add options for M,Dyn. Bzero, SmryBio" << endl;

  //3868      Do_Selex_Std=More_Std_Input(1);
  //3869      Selex_Std_AL=More_Std_Input(2);
  //3870      Selex_Std_Year=More_Std_Input(3);
  //3872      Selex_Std_Cnt=More_Std_Input(4);
  //3873      Do_Growth_Std=More_Std_Input(5);
  //3875      Growth_Std_Cnt=More_Std_Input(6);
  //3876      Do_NatAge_Std=More_Std_Input(7);
  //3877      NatAge_Std_Year=More_Std_Input(8);
  //3879      NatAge_Std_Cnt=More_Std_Input(9);

  if (Do_More_Std == 0) // empty/dummy values when extra stddev reporting not used
  {
    report4 << " # 0 2 0 0 # Selectivity: (1) fleet, (2) 1=len/2=age/3=both, (3) year, (4) N selex bins" << endl;
    report4 << " # 0 0 # Growth: (1) growth pattern, (2) growth ages" << endl;
    report4 << " # 0 0 0 # Numbers-at-age: (1) area(-1 for all), (2) year, (3) N ages" << endl;
    report4 << " # -1 # list of bin #'s for selex std (-1 in first bin to self-generate)" << endl;
    report4 << " # -1 # list of ages for growth std (-1 in first bin to self-generate)" << endl;
    report4 << " # -1 # list of ages for NatAge std (-1 in first bin to self-generate)" << endl;
  }
  if (Do_More_Std > 0) // these outputs needed for options 1 and 2
  {
    //    report4<<More_Std_Input<<" # selex_fleet, 1=len/2=age/3=both, year, N selex bins, 0 or Growth pattern, N growth ages, 0 or NatAge_area(-1 for sum), NatAge_yr, N Natages"<<endl;
    report4 << More_Std_Input(1, 4) << " # Selectivity: (1) 0 to skip or fleet, (2) 1=len/2=age/3=combined, (3) year, (4) N selex bins; NOTE: combined reports in age bins" << endl;
    report4 << More_Std_Input(5, 6) << " # Growth: (1) 0 to skip or growth pattern, (2) growth ages; NOTE: does each sex" << endl;
    report4 << More_Std_Input(7, 9) << " # Numbers-at-age: (1) 0 or area(-1 for all), (2) year, (3) N ages;  NOTE: sums across morphs" << endl;
  }
  if (Do_More_Std == 2) // additional output when option 2 is selected
  {
    report4 << More_Std_Input(10, 11) << " # Mortality: (1) 0 to skip or growth pattern, (2) N ages for mortality; NOTE: does each sex" << endl;
    report4 << More_Std_Input(12) << " # Dyn Bzero: 0 to skip, 1 to include, or 2 to add recr" << endl;
    report4 << More_Std_Input(13) << " # SmryBio: 0 to skip, 1 to include" << endl;
  }
  if (Do_More_Std > 0) // vectors associated with options 1 and 2
  {
    if (Do_Selex_Std > 0)
    {
      report4 << Selex_Std_Pick << " # vector with selex std bins (-1 in first bin to self-generate)" << endl;
    }
    else
    {
      report4 << " # -1 # list of bin #'s for selex std (-1 in first bin to self-generate)" << endl;
    }
    //    if(Do_Growth_Std>0){
    if (More_Std_Input(5) > 0)
    {
      report4 << Growth_Std_Pick << " # vector with growth std ages picks (-1 in first bin to self-generate)" << endl;
    }
    else
    {
      report4 << " # -1 # list of ages for growth std (-1 in first bin to self-generate)" << endl;
    }
    if (Do_NatAge_Std != 0)
    {
      report4 << NatAge_Std_Pick << " # vector with NatAge std ages (-1 in first bin to self-generate)" << endl;
    }
    else
    {
      report4 << " # -1 # list of ages for NatAge std (-1 in first bin to self-generate)" << endl;
    }
    if (Do_More_Std == 2) // additional output when option 2 is selected
    {
      if (Do_NatM_Std > 0)
      {
        report4 << NatM_Std_Pick << " # vector with NatM std ages picks (-1 in first bin to self-generate)" << endl;
      }
      else
      {
        report4 << " # -1 # list of ages for NatM std (-1 in first bin to self-generate)" << endl;
      }
    }
  }
  report4 << fim << endl
          << endl; // end of file indicator
  return;
  } //  end of write nucontrol

// SS_Label_file  #19. **SS_write_report.tpl**
// SS_Label_file  # * <u>write_bigoutput()</u>  // produces *report.sso* and *compreport.sso*
// SS_Label_file  # * <u>SPR_profile()</u>  //  calls SSBpR_Calc() and Equil_Spawn_Recr_Fxn() over a range of F to get SPR, YPR, and SSB and catch curves
// SS_Label_file  # * <u>global_MSY()</u>  // similar to SPR_profile but first changes all selectivities to knife edge and profiles on age-at-entry
// SS_Label_file  #

//********************************************************************
 /*  SS_Label_FUNCTION 40 write_bigoutput */
FUNCTION void write_bigoutput()
  {
  if (mceval_counter == 0)
  {
    anystring = sso_pathname + "Report.sso";
    report_sso_filename = anystring;
    if (SS2out.is_open())
      SS2out.close();
    SS2out.open(anystring); // this file was created in globals so accessible to the report_parm function
    anystring = sso_pathname + "CompReport.sso";
    if (SS_compout.is_open())
      SS_compout.close();
    SS_compout.open(anystring);
  }
  else
  {
    anystring = "      ";
    sprintf(anystring, "%d", mceval_counter);
    if (SS2out.is_open())
      SS2out.close();
    if (SS_compout.is_open())
      SS_compout.close();
    anystring2 = sso_pathname + "Report_mce_";
    if (mceval_counter < 10)
    {
      anystring2 += "000";
    }
    else if (mceval_counter < 100)
    {
      anystring2 += "00";
    }
    else if (mceval_counter < 1000)
    {
      anystring2 += "0";
    }
    anystring2 += anystring + ".sso";
    SS2out.open(anystring2);
    report_sso_filename = anystring2; //  save so can be reopened in append mode
    anystring2 = sso_pathname + "CompReport_mce_";
    if (mceval_counter < 10)
    {
      anystring2 += "000";
    }
    else if (mceval_counter < 100)
    {
      anystring2 += "00";
    }
    else if (mceval_counter < 1000)
    {
      anystring2 += "0";
    }
    anystring2 += anystring + ".sso";
    SS_compout.open(anystring2);
  }

  SS2out << version_info(1) << version_info(2) << version_info(3) << endl
         << version_info2 << endl;
  time(&finish);
  SS_compout << version_info(1) << version_info(2) << version_info(3) << endl
             << "StartTime: " << ctime(&start);

  SS2out << "StartTime: " << ctime(&start);
  SS2out << "EndTime: " << ctime(&finish);
  elapsed_time = difftime(finish, start);
  hour = long(elapsed_time) / 3600;
  minute = long(elapsed_time) % 3600 / 60;
  second = (long(elapsed_time) % 3600) % 60;
  SS2out << "This run took: " << hour << " hours, " << minute << " minutes, " << second << " seconds." << endl;
  SS2out << "Data_File: " << datfilename << endl;
  SS2out << "Control_File: " << ctlfilename << endl;
  if (readparfile >= 1)
    {SS2out << "Start_parm_values_from_SS.PAR" << endl;}
    else
    {SS2out << "Start_parm_values_from_control_file" << endl;}
  SS2out << endl
         << "Convergence_Level: " << objective_function_value::pobjfun->gmax << " is_final_gradient" << endl;
  temp = get_ln_det_value();
  if (SDmode == 0)
  {
    SS2out << "Hessian: Not requested." << endl;
  }
  else //  (SDmode == 1)
  {
    if (temp > 0)
    {
      SS2out << "Hessian: " << temp << " is ln(determinant)." << endl;
    }
    if (temp <= 0)
    {
      SS2out << "Hessian: " << temp << " is ln(determinant). Hessian is not positive definite, so don't trust variance estimates." << endl;
    }
  }
  SS2out << "Final_phase: " << current_phase() << endl;
  SS2out << "N_iterations: " << niter << endl;
  SS2out << "total_LogL: " << obj_fun << endl;

  if (N_SC > 0)
  {
    SS2out << endl
           << "Starter_Comments" << endl
           << Starter_Comments << endl;
  }
  if (N_DC > 0)
  {
    SS2out << endl
           << "Data_Comments" << endl
           << Data_Comments << endl;
  }
  if (N_CC > 0)
  {
    SS2out << endl
           << "Control_Comments" << endl
           << Control_Comments << endl;
  }
  if (N_FC > 0)
  {
    SS2out << endl
           << "Forecast_Comments" << endl
           << Forecast_Comments << endl;
  }

  if (N_parm_dev == 0)
    pick_report_use(4) = "N";
  if (SzFreq_Nmeth == 0)
    pick_report_use(12) = "N";
  if (do_migration == 0)
    pick_report_use(13) = "N";
  if (Svy_N == 0)
    pick_report_use(21) = "N";
  if (Svy_N == 0)
    pick_report_use(22) = "N";
  if (Svy_N == 0)
    pick_report_use(23) = "N";
  if (nobs_disc == 0)
    pick_report_use(24) = "N";
  if (nobs_disc == 0)
    pick_report_use(25) = "N";
  if (nobs_mnwt == 0)
    pick_report_use(26) = "N";
  if (Nobs_l_tot == 0)
    pick_report_use(27) = "N";
  if (Nobs_a_tot == 0)
    pick_report_use(28) = "N";
  if (SzFreq_Nmeth == 0)
    pick_report_use(29) = "N";
  if (N_envvar == 0)
    pick_report_use(33) = "N";
  if (Do_TG == 0)
    pick_report_use(34) = "N";
  if (Grow_type < 3 || Grow_type > 6)
    pick_report_use(44) = "N";
  if (MGparm_doseas == 0)
    pick_report_use(46) = "N";
  if (N_ageerr == 0)
    pick_report_use(51) = "N";
  if (use_length_data == 0)
    pick_report_use(46) = "N";

  SS2out << endl
         << "#_KeyWords_of_tables_available_in_report_sso" << endl;
  SS2out << "#_NOTE: table_number_is_order_in_which_tables_are_output" << endl;
  SS2out << "#_List_Tables_related_to_basic_input_pre-processing_and_output" << endl;
  k = 1;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // DEFINITIONS"
  k = 6;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // DERIVED_QUANTITIES"
  k = 33;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // ENVIRONMENTAL_DATA"
  k = 3;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Input_Variance_Adjustment"
  k = 2;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // LIKELIHOOD
  k = 7;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // MGparm_By_Year_after_adjustments
  k = 11;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // MORPH_INDEXING (defines_associations_for_sex_growth_pattern_platoons_settlements)
  k = 30;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // OVERALL_COMPS (average_length_and_age_composition_observed_by_each_fleet)
  k = 5;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // PARAMETERS
  k = 4;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // parmdevs_detail

  SS2out << endl
         << "# List_Tables_related_to_timeseries_output" << endl;
  k = 36;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // BIOMASS_AT_AGE
  k = 38;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // BIOMASS_AT_LENGTH
  k = 15;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // CATCH
  k = 41;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // DISCARD_AT_AGE
  k = 14;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // EXPLOITATION (showing_F_rates_by_fleet)
  k = 40;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // CATCH_AT_AGE
  k = 39;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // F_AT_AGE
  k = 49;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // MEAN_SIZE_TIMESERIES (body length)
  k = 35;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // NUMBERS_AT_AGE
  k = 37;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // NUMBERS_AT_LENGTH
  k = 19;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // SPAWN_RECRUIT
  k = 20;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // SPAWN_RECRUIT_CURVE
  k = 17;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // SPR_series (equilibrium_SPR_and_YPR_calculations_for_each_year)
  k = 16;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // TIME_SERIES
  k = 61;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // ANNUAL_TIME_SERIES

  SS2out << endl
         << "# List_Tables_related_to_fit_to_data" << endl;
  k = 52;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // composition database
  k = 24;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // DISCARD specification
  k = 25;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // DISCARD
  k = 21;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // INDEX, CPUE, effort
  k = 22;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // INDEX, obs
  k = 23;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // INDEX, Q
  k = 27;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // FIT_LEN_COMPS
  k = 28;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // FIT_AGE_COMPS
  k = 29;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // FIT_SIZE_COMPS
  k = 26;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // MEAN_BODY_WT
  k = 34;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // TAG_Recapture

  SS2out << endl
         << "# List_Tables_related_to_selectivity_and_discard" << endl;
  k = 32;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // AGE_SELEX
  k = 31;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // LEN_SELEX
  k = 8;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // selparm(Size)_By_Year_after_adjustments
  k = 9;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // selparm(Age)_By_Year_after_adjustments
  k = 53;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // selex database

  SS2out << endl
         << "#_List_Tables_related_to_biology" << endl;
  k = 51;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // AGE_AGE'_KEY"
  k = 50;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // AGE_LENGTH_KEY
  k = 44;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Age-Specific k
  k = 42;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // BIOLOGY
  k = 47;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Biology-at-age
  k = 45;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Growth_parameters
  k = 48;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // mean body wt time series
  k = 13;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // MOVEMENT (fraction_moving_between_areas)
  k = 43;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Natural_Mortality
  k = 10;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // RECRUITMENT_DIST (distribution_of_recruits_among_morphs_areas_settlement_time)
  k = 46;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Seasonal effects
  k = 12;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // SIZEFREQ_TRANSLATION (If_using_generalized_size_comp)

  SS2out << endl
         << "# List_Tables_related_to_equilibrium_reference_points;_also_see_forecast_report.sso" << endl;
  k = 59;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Dynamic_Bzero
  k = 55;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // GLOBAL_MSY (including_knife-edge_selex_and_slot-age_selex)
  k = 18;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // Kobe_Plot
  k = 54;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // SPR/YPR_PROFILE

  SS2out << endl
         << "# List_Additional_Tables" << endl;
  k = 56;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // ss_summary
  k = 57;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // rebuilder
  k = 58;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // SIS_table
  k = 60;
  SS2out << pick_report_use(k) << " " << pick_report_name(k) << endl; // wt-at-age.ss

  SS2out << endl
         << "# vector_with_report_usage" << endl;
  for (k = 1; k <= 60; k++)
  {
    SS2out << " " << pick_report_use(k);
  }
  SS2out << endl
         << endl;

  // REPORT_KEYWORD 1 DEFINITIONS
  if (pick_report_use(1) == "Y")
  {
    SS2out << endl
           << pick_report_name(1) << endl;
    SS2out << "N_seasons: " << nseas << endl;
    SS2out << "N_sub_seasons: " << N_subseas << endl;
    SS2out << "Sum_of_months_on_read_was:_ " << sumseas << " rescaled_to_sum_to: " << sum(seasdur) << endl;
    SS2out << "Season_Durations: " << seasdur << endl;
    SS2out << "Spawn_month: " << spawn_month << endl
           << "Spawn_seas: " << spawn_seas << endl
           << "spawntiming as frac. of year: " << spawn_time_seas << endl;
    SS2out << "N_areas: " << pop << endl;
    SS2out << "Start_year: " << styr << endl;
    SS2out << "End_year: " << endyr << endl;
    SS2out << "Retro_year: " << retro_yr << endl;
    SS2out << "N_forecast_yrs: " << N_Fcast_Yrs << endl;
    SS2out << "N_areas: " << pop << endl;
    SS2out << "N_sexes: " << gender << endl;
    SS2out << "Max_age: " << nages << endl;
    SS2out << "Empirical_wt_at_age(0,1): " << WTage_rd << endl;
    SS2out << "N_bio_patterns: " << N_GP << endl;
    SS2out << "N_platoons: " << N_platoon << endl;
    SS2out << "NatMort: " << natM_type << " # options:_(0)1Parm;_(1)N_breakpoints;_(2)Lorenzen;_(3)agespecific;_(4)agespec_withseasinterpolate" << endl;
    SS2out << "GrowthModel: " << Grow_type << " # options:_(1)vonBert with L1&L2;_(2)Richards with L1&L2;_(3)age_specific_K_incr;_(4)age_specific_K_decr; (5)age_specific_K_each; (6)not implemented" << endl;
    SS2out << "Maturity: " << Maturity_Option << " # options:_(1)length logistic;_(2)age logistic;_(3)read age-maturity;_(4)read age-fecundity;_(5)disabled;_(6)read length-maturity" << endl;
    SS2out << "Fecundity: " << Fecund_Option << " # options:_(1)eggs=Wt*(a+b*Wt);_(2)eggs=a*L^b;_(3)eggs=a*Wt^b;_(4)eggs=a+b*L;_(5)eggs=a+b*W" << endl;
    SS2out << "Start_from_par(0,1): " << readparfile << endl;
    SS2out << "Do_all_priors(0,1): " << Do_all_priors << endl;
    SS2out << "Use_softbound(0,1): " << SoftBound << endl;
    SS2out << "N_nudata: " << N_nudata << endl;
    SS2out << "Max_phase: " << max_phase << endl;
    SS2out << "Current_phase: " << current_phase() << endl;
    SS2out << "Jitter: " << jitter << endl;
    SS2out << "ALK_tolerance: " << ALK_tolerance << endl;

    if (use_length_data > 0)
    {
      SS2out << "#" << endl << "Length_comp_error_controls" << endl << "Fleet partition mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize " << endl;
      for (f = 1; f <= Nfleet; f++)
      if (Nobs_l(f) > 0)
      {
        int parti_lo = 0;
        int parti_hi = 0;
        if (Do_Retain(f) == 1) parti_hi = 2;
        for (int parti = parti_lo; parti <= parti_hi ; parti++)
        {
          SS2out << f << " " << parti << " " << min_tail_L(parti, f) << " " << min_comp_L(parti, f) << " " << CombGender_L(parti, f) << " " << AccumBin_L(parti, f) << " " << Comp_Err_L(parti, f) << " " << Comp_Err_L2(parti, f) << " " << min_sample_size_L(parti, f) << " #_ " << fleetname(f) << endl;
        }
      }
    }

    if (n_abins > 0)
    {
      SS2out << "#" << endl << "Age_comp_error_controls" << endl << "Fleet  mintailcomp addtocomp combM+F CompressBins CompError ParmSelect minsamplesize " << endl;
      for (f = 1; f <= Nfleet; f++)
      if (Nobs_a(f) > 0)
      {
          SS2out << f << " " << min_tail_A(f) << " " << min_comp_A(f) << " " << CombGender_A(f) << " " << AccumBin_A(f) << " " << Comp_Err_A(f) << " " << Comp_Err_A2(f) << " " << min_sample_size_A(f) << " #_ " << fleetname(f) << endl;
      }
    }

    if(SzFreq_Nmeth > 0)
    {
    SS2out << "#" << endl << "Size_comp_error_controls" << endl << "#_Sz_method error_type error_parm_ID " << endl;
    for (f = 1; f <= SzFreq_Nmeth; f++)
    {
        SS2out << f << " " << Comp_Err_Sz(f) << " " << Comp_Err_Sz2(f) << endl;
    }
    }

    SS2out << "#" << endl;
    SS2out << "Fleet fleet_type timing area catch_units catch_mult survey_units survey_error Fleet_name" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      SS2out << f << " " << fleet_setup(f) << " " << Svy_units(f) << " " << Svy_errtype(f) << " " << fleetname(f) << endl;
    }
  } //  end DEFINITIONS

  // REPORT_KEYWORD 2 LIKELIHOOD
  if (pick_report_use(2) == "Y")
  {
    k = current_phase();
    if (k > max_lambda_phase)
      k = max_lambda_phase;
    SS2out << endl
           << pick_report_name(2) << " " << obj_fun << endl; //SS_Label_310
    SS2out << "Component logL*Lambda Lambda" << endl;
    SS2out << "TOTAL " << obj_fun << " NA" << endl;
    if (F_Method > 1)
      SS2out << "Catch " << catch_like * column(catch_lambda, k) << " NA" << endl;
    SS2out << "Equil_catch " << equ_catch_like * column(init_equ_lambda, k) << " NA" << endl;
    if (Svy_N > 0)
      SS2out << "Survey " << surv_like * column(surv_lambda, k) << " NA" << endl;
    if (nobs_disc > 0)
      SS2out << "Discard " << disc_like * column(disc_lambda, k) << " NA" << endl;
    if (nobs_mnwt > 0)
      SS2out << "Mean_body_wt " << mnwt_like * column(mnwt_lambda, k) << " NA" << endl;
    if (Nobs_l_tot > 0)
      SS2out << "Length_comp " << length_like_tot * column(length_lambda, k) << " NA" << endl;
    if (Nobs_a_tot > 0)
      SS2out << "Age_comp " << age_like_tot * column(age_lambda, k) << " NA" << endl;
    if (nobs_ms_tot > 0)
      SS2out << "Size_at_age " << sizeage_like * column(sizeage_lambda, k) << " NA" << endl;
    if (SzFreq_Nmeth > 0)
      SS2out << "SizeFreq " << SzFreq_like * column(SzFreq_lambda, k) << " NA" << endl;
    if (Do_Morphcomp > 0)
      SS2out << "Morphcomp " << Morphcomp_lambda(k) * Morphcomp_like << " " << Morphcomp_lambda(k) << endl;
    if (Do_TG > 0)
      SS2out << "Tag_comp " << TG_like1 * column(TG_lambda1, k) << " NA" << endl;
    if (Do_TG > 0)
      SS2out << "Tag_negbin " << TG_like2 * column(TG_lambda2, k) << " NA" << endl;
    SS2out << "Recruitment " << recr_like * recrdev_lambda(k) << " " << recrdev_lambda(k) << endl;
    SS2out << "InitEQ_Regime " << regime_like * regime_lambda(k) << " " << regime_lambda(k) << endl;
    SS2out << "Forecast_Recruitment " << Fcast_recr_like << " " << Fcast_recr_lambda << endl;
    SS2out << "Parm_priors " << parm_like * parm_prior_lambda(k) << " " << parm_prior_lambda(k) << endl;
    if (SoftBound > 0)
      SS2out << "Parm_softbounds " << SoftBoundPen << " "
             << " NA" << endl;
    SS2out << "Parm_devs " << (sum(parm_dev_like)) * parm_dev_lambda(k) << " " << parm_dev_lambda(k) << endl;
    if (F_ballpark_yr > 0)
      SS2out << "F_Ballpark " << F_ballpark_lambda(k) * F_ballpark_like << " " << F_ballpark_lambda(k) << endl;
    if (F_ballpark_yr > 0)
      SS2out << "F_Ballpark(info_only)_" << F_ballpark_yr << "_estF_tgtF " << annual_F(F_ballpark_yr, 2) << " " << F_ballpark << endl;
    //  if(F_ballpark_yr>0) SS2out <<"F_Ballpark "<<F_ballpark_lambda(k)*F_ballpark_like<<" "<<F_ballpark_lambda(k)<<"  ##:est&obs: "<<annual_F(F_ballpark_yr,2)<<" "<<F_ballpark<<endl;
    SS2out << "Crash_Pen " << CrashPen_lambda(k) * CrashPen << " " << CrashPen_lambda(k) << endl;
    SS2out << "#_info_for_Laplace_calculations" << endl;
    SS2out << "NoBias_corr_Recruitment(info_only) " << noBias_recr_like * recrdev_lambda(k) << " " << recrdev_lambda(k) << endl;
    SS2out << "Laplace_obj_fun(info_only) " << JT_obj_fun << " NA" << endl;
    SS2out << "#" << endl
           << "Fleet:  ALL ";
    for (f = 1; f <= Nfleet; f++)
      SS2out << f << " ";
    SS2out << endl;
    if (F_Method > 1)
      SS2out << "Catch_lambda: _ " << column(catch_lambda, k) << endl
             << "Catch_like: " << catch_like * column(catch_lambda, k) << " " << catch_like << endl;
    SS2out << "Init_equ_lambda: _ " << column(init_equ_lambda, k) << endl
           << "Init_equ_like: " << equ_catch_like * column(init_equ_lambda, k) << " " << equ_catch_like << endl;
    if (Svy_N > 0)
    {
      SS2out << "Surv_lambda: _ " << column(surv_lambda, k) << endl
             << "Surv_like: " << surv_like * column(surv_lambda, k) << " " << surv_like << endl;
      SS2out << "Surv_N_use: _ " << Svy_N_fleet_use << endl;
      SS2out << "Surv_N_skip: _ " << (Svy_N_fleet - Svy_N_fleet_use) << endl;
    }
    if (nobs_disc > 0)
    {
      SS2out << "Disc_lambda: _ " << column(disc_lambda, k) << endl
             << "Disc_like: " << disc_like * column(disc_lambda, k) << " " << disc_like << endl;
      SS2out << "Disc_N_use: _ " << disc_N_fleet_use << endl;
      SS2out << "Disc_N_skip: _ " << (disc_N_fleet - disc_N_fleet_use) << endl;
    }
    if (nobs_mnwt > 0)
    {
      SS2out << "mnwt_lambda: _ " << column(mnwt_lambda, k) << endl;
      SS2out << "mnwt_like: " << mnwt_like * column(mnwt_lambda, k) << " " << mnwt_like << endl;
      SS2out << "mnwt_N_use: _ " << mnwt_N_fleet_use << endl;
      SS2out << "mnwt_N_skip: _ " << (mnwt_N_fleet - mnwt_N_fleet_use) << endl;
    }
    if (Nobs_l_tot > 0)
    {
      SS2out << "Length_lambda: _ " << column(length_lambda, k) << endl;
      SS2out << "Length_like: " << length_like_tot * column(length_lambda, k) << " " << length_like_tot << endl;
      SS2out << "Length_N_use: _ " << Nobs_l_use << endl;
      SS2out << "Length_N_skip: _ " << (Nobs_l - Nobs_l_use) << endl;
    }
    if (Nobs_a_tot > 0)
    {
      SS2out << "Age_lambda: _ " << column(age_lambda, k) << endl;
      SS2out << "Age_like: " << age_like_tot * column(age_lambda, k) << " " << age_like_tot << endl;
      SS2out << "Age_N_use: _ " << Nobs_a_use << endl;
      SS2out << "Age_N_skip: _ " << (Nobs_a - Nobs_a_use) << endl;
    }
    if (nobs_ms_tot > 0)
    {
      SS2out << "Sizeatage_lambda: _ " << column(sizeage_lambda, k) << endl;
      SS2out << "sizeatage_like: " << sizeage_like * column(sizeage_lambda, k) << " " << sizeage_like << endl;
      SS2out << "sizeatage_N_use: _ " << Nobs_ms_use << endl;
      SS2out << "sizeatage_N_skip: _ " << (Nobs_ms - Nobs_ms_use) << endl;
    }

    // Parm_devs_detail
    // (only reported if there are parameter deviations)
    if (pick_report_use(4) == "Y")
    {
      SS2out << endl
             << pick_report_name(4) << endl;
      SS2out << "Index  Phase  MinYr  MaxYr  N   stddev  Rho  Like_devs  Like_se  mean  rmse  var sqrt(var) est_rho  D-W" << endl;
      for (i = 1; i <= N_parm_dev; i++)
      {
        dvector for_AR1(parm_dev_minyr(i), parm_dev_maxyr(i));
        dvector for_var(parm_dev_minyr(i), parm_dev_maxyr(i));
        int y1 = parm_dev_minyr(i);
        int y2 = parm_dev_maxyr(i);
        double count;
        count = float(y2 - y1 + 1.);
        double mean;
        mean = value(sum(parm_dev(i)) / count);
        for (j = y1 + 1; j <= y2; j++)
        {
          for_AR1(j) = value(parm_dev(i, j - 1)) - mean;
        }
        for_var = value(parm_dev(i)) - mean;
        double cross;
        double Durbin;
        double var;
        var = sumsq(for_var);
        cross = 0.;
        Durbin = 0;
        for (j = y1 + 1; j <= y2; j++)
        {
          cross += for_var(j) * for_AR1(j);
          Durbin += square(for_var(j) - for_AR1(j));
        }
        cross /= (count - 1.);
        Durbin /= (var + 1.0e-09);
        var /= count;
        SS2out << i << " " << parm_dev_PH(i) << " " << y1 << " " << y2 << " " << count << " " << parm_dev_stddev(i) << " " << parm_dev_rho(i) << " " << parm_dev_like(i) << " " << sum(parm_dev(i)) / count << " " << sqrt(1.0e-09 + sumsq(parm_dev(i)) / (count)) << " " << var << " " << sqrt(1.0e-09 + var) << " " << cross / (1.0e-09 + var) << " " << Durbin << " " << endl;
      }
    }
    if (SzFreq_Nmeth > 0)
    {
      for (j = 1; j <= SzFreq_Nmeth; j++)
      {
        SS2out << "SizeFreq_lambda:_" << j << "; ";
        if (j == 1)
        {
          SS2out << "_ ";
        }
        else
        {
          SS2out << "_ ";
        }
        for (f = 1; f <= Nfleet; f++)
        {
          if (SzFreq_LikeComponent(f, j) > 0)
          {
            SS2out << SzFreq_lambda(SzFreq_LikeComponent(f, j), k) << " ";
          }
          else
          {
            SS2out << " NA ";
          }
        }
        SS2out << endl;
        SS2out << "SizeFreq_like:_" << j << "; ";
        if (j == 1)
        {
          SS2out << SzFreq_like * column(SzFreq_lambda, k) << " ";
        }
        else
        {
          SS2out << "_ ";
        }
        for (f = 1; f <= Nfleet; f++)
        {
          if (SzFreq_LikeComponent(f, j) > 0)
          {
            SS2out << SzFreq_like(SzFreq_LikeComponent(f, j)) << " ";
          }
          else
          {
            SS2out << " NA ";
          }
        }
        SS2out << endl;
      }
      //    SS2out<<SzFreq_like<<endl<<offset_Sz_tot<<endl;
    }

    if (Do_TG > 0)
    {
      SS2out << "#" << endl
             << "Tag_Group:  ALL ";
      for (f = 1; f <= N_TG; f++)
        SS2out << f << " ";
      SS2out << endl;
      SS2out << "Tag_comp_Lambda _ " << column(TG_lambda1, k) << endl
             << "Tag_comp_Like " << TG_like1 * column(TG_lambda1, k) << " " << TG_like1 << endl;
      SS2out << "Tag_negbin_Lambda _ " << column(TG_lambda2, k) << endl
             << "Tag_negbin_Like " << TG_like2 * column(TG_lambda2, k) << " " << TG_like2 << endl;
    }
    SS2out << endl;

    SS2out << endl
           << pick_report_name(3) << endl;
    SS2out << "Fleet ";
    for (i = 1; i <= Nfleet; i++)
    {
      SS2out << " " << i;
    }
    SS2out << endl;
    SS2out << "Index_extra_CV " << var_adjust(1) << endl;
    SS2out << "Discard_extra_CV " << var_adjust(2) << endl;
    SS2out << "MeanBodyWt_extra_CV " << var_adjust(3) << endl;
    SS2out << "effN_mult_Lencomp " << var_adjust(4) << endl;
    SS2out << "effN_mult_Agecomp " << var_adjust(5) << endl;
    SS2out << "effN_mult_Len_at_age " << var_adjust(6) << endl;
    SS2out << "effN_mult_generalized_sizecomp " << var_adjust(7) << endl;

    SS2out << "MG_parms_Using_offset_approach_#:_" << MGparm_def << "  (1=none, 2= M, G, CV_G as offset from female_GP1, 3=like SS2 V1.x)" << endl;
  }

  // REPORT_KEYWORD 5 PARAMETERS
  if (pick_report_use(5) == "Y")
  {
    SS2out << endl
           << pick_report_name(5) << endl;
    SS2out << "Num Label Value Active_Cnt  Phase Min Max Init  Used  Status  Parm_StDev Gradient Pr_type Prior Pr_SD Pr_Like Value_again Value-1.96*SD Value+1.96*SD V_1%  V_10% V_20% V_30% V_40% V_50% V_60% V_70% V_80% V_90% V_99% P_val P_lowCI P_hiCI  P_1%  P_10% P_20% P_30% P_40% P_50% P_60% P_70% P_80% P_90% P_99%" << endl;

    NP = 0; // count of number of parameters
    active_count = 0;
    Nparm_on_bound = 0;
    int Activ;
    for (j = 1; j <= N_MGparm2; j++)
    {
      NP++;
      Activ = 0;
      if (active(MGparm(j)))
      {
        active_count++;
        Activ = 1;
      }
      Report_Parm(NP, active_count, Activ, MGparm(j), MGparm_LO(j), MGparm_HI(j), MGparm_RD(j), MGparm_use(j), MGparm_PR(j), MGparm_CV(j), MGparm_PRtype(j), MGparm_PH(j), MGparm_Like(j));
    }

    for (j = 1; j <= N_SRparm3; j++)
    {
      NP++;
      Activ = 0;
      if (active(SRparm(j)))
      {
        active_count++;
        Activ = 1;
      }
      Report_Parm(NP, active_count, Activ, SRparm(j), SRparm_LO(j), SRparm_HI(j), SRparm_RD(j), SRparm_use(j), SRparm_PR(j), SRparm_CV(j), SRparm_PRtype(j), SRparm_PH(j), SRparm_Like(j));
    }

    if (recdev_cycle > 0)
    {
      for (j = 1; j <= recdev_cycle; j++)
      {
        NP++;
        Activ = 0;
        if (active(recdev_cycle_parm(j)))
        {
          active_count++;
          Activ = 1;
        }
        Report_Parm(NP, active_count, Activ, recdev_cycle_parm(j), recdev_cycle_parm_RD(j, 1), recdev_cycle_parm_RD(j, 2), recdev_cycle_parm_RD(j, 3), recdev_cycle_use(j), recdev_cycle_parm_RD(j, 4), recdev_cycle_parm_RD(j, 5), recdev_cycle_parm_RD(j, 6), recdev_cycle_parm_RD(j, 7), recdev_cycle_Like(j));
      }
    }

    if (recdev_do_early > 0)
    {
      for (i = recdev_early_start; i <= recdev_early_end; i++)
      {
        NP++;
        SS2out << NP << " " << ParmLabel(NP) << " " << recdev(i);
        if (active(recdev_early))
        {
          active_count++;
          SS2out << " " << active_count << " " << recdev_early_PH << " " << recdev_LO << " " << recdev_HI << " " << recdev_RD(i) << " " << recdev_use(i) << " act " << CoVar(active_count, 1) << " " << parm_gradients(active_count);
        }
        else
        {
          SS2out << " _ _ _ _ _ _ NA _ _ ";
        }
        SS2out << " dev " << endl;
      }
    }

    if (do_recdev > 0)
    {
      for (i = recdev_start; i <= recdev_end; i++)
      {
        NP++;
        SS2out << NP << " " << ParmLabel(NP) << " " << recdev(i);
        if (active(recdev1) || active(recdev2))
        {
          active_count++;
          SS2out << " " << active_count << " " << recdev_PH << " " << recdev_LO << " " << recdev_HI << " " << recdev_RD(i) << " " << recdev_use(i) << " act " << CoVar(active_count, 1) << " " << parm_gradients(active_count);
        }
        else
        {
          SS2out << " _ _ _ _ _ _ NA _ _ ";
        }
        SS2out << " dev " << endl;
      }
    }

    if (Do_Forecast > 0 && do_recdev > 0)
    {
      for (i = recdev_end + 1; i <= YrMax; i++)
      {
        NP++;
        SS2out << NP << " " << ParmLabel(NP) << " " << Fcast_recruitments(i);
        if (active(Fcast_recruitments))
        {
          active_count++;
          SS2out << " " << active_count << " " << Fcast_recr_PH2 << " " << recdev_LO << " " << recdev_HI << " " << recdev_RD(i) << " " << recdev_use(i) << " act " << CoVar(active_count, 1) << " " << parm_gradients(active_count);
        }
        else
        {
          SS2out << "  _ _ _ _ _ _ NA _ _ ";
        }
        SS2out << " dev " << endl;
      }
    }

    if (Do_Impl_Error > 0)
    {
      for (i = endyr + 1; i <= YrMax; i++)
      {
        NP++;
        SS2out << NP << " " << ParmLabel(NP) << " " << Fcast_impl_error(i);
        if (Fcast_recr_PH2 > 0) //  intentionally using recdev phase
        {
          active_count++;
          SS2out << " " << active_count << " " << Fcast_recr_PH2 << " -1 1 0 0 act " << CoVar(active_count, 1) << " " << parm_gradients(active_count);
        }
        else
        {
          SS2out << "  _ _ _ _ _ _ NA _ _ ";
        }
        SS2out << " dev " << endl;
      }
    }
    for (j = 1; j <= N_init_F; j++)
    {
      NP++;
      Activ = 0;
      if (active(init_F(j)))
      {
        active_count++;
        Activ = 1;
      }
      Report_Parm(NP, active_count, Activ, init_F(j), init_F_LO(j), init_F_HI(j), init_F_RD(j), init_F_use(j), init_F_PR(j), init_F_CV(j), init_F_PRtype(j), init_F_PH(j), init_F_Like(j));
    }

    if (N_Fparm > 0)
    {
      for (i = 1; i <= N_Fparm; i++)
      {
        NP++;
        Activ = 0;
        SS2out << NP << " " << ParmLabel(NP) << " " << F_rate(i);
        if (active(F_rate(i)))
        {
          active_count++;
          Activ = 1;
          SS2out << " " << active_count << " " << Fparm_PH[i] << " 0.0 " << max_harvest_rate << " " << F_parm_intval(Fparm_loc[i](1)) << " " << Fparm_use(i) << " act " << CoVar(active_count, 1) << " " << parm_gradients(active_count);
        }
        else
        {
          SS2out << " _ _ _ _ _ _ NA _ _ ";
        }
        SS2out << " F " << endl;
      }
    }

    for (j = 1; j <= Q_Npar2; j++)
    {
      NP++;
      Activ = 0;
      if (active(Q_parm(j)))
      {
        active_count++;
        Activ = 1;
      }
      Report_Parm(NP, active_count, Activ, Q_parm(j), Q_parm_LO(j), Q_parm_HI(j), Q_parm_RD(j), Q_parm_use(j), Q_parm_PR(j), Q_parm_CV(j), Q_parm_PRtype(j), Q_parm_PH(j), Q_parm_Like(j));
    }

    for (j = 1; j <= N_selparm2; j++)
    {
      NP++;
      Activ = 0;
      if (active(selparm(j)))
      {
        active_count++;
        Activ = 1;
      }
      Report_Parm(NP, active_count, Activ, selparm(j), selparm_LO(j), selparm_HI(j), selparm_RD(j), selparm_use(j), selparm_PR(j), selparm_CV(j), selparm_PRtype(j), selparm_PH(j), selparm_Like(j));
    }

    if (Do_TG > 0)
    {
      k = 3 * N_TG + 2 * Nfleet1;
      for (j = 1; j <= k; j++)
      {
        NP++;
        Activ = 0;
        if (active(TG_parm(j)))
        {
          active_count++;
          Activ = 1;
        }
        Report_Parm(NP, active_count, Activ, TG_parm(j), TG_parm_LO(j), TG_parm_HI(j), TG_parm2(j, 3), TG_parm_use(j), TG_parm2(j, 4), TG_parm2(j, 5), TG_parm2(j, 6), TG_parm_PH(j), TG_parm_Like(j));
      }
    }

    if (N_parm_dev > 0)
    {
      for (i = 1; i <= N_parm_dev; i++)
        for (j = parm_dev_minyr(i); j <= parm_dev_maxyr(i); j++)
        {
          NP++;
          SS2out << NP << " " << ParmLabel(NP) << " " << parm_dev(i, j);
          if (parm_dev_PH(i) > 0)
          {
            active_count++;
            SS2out << " " << active_count << " " << parm_dev_PH(i) << " -10 10 " << parm_dev_RD(i, j) << " " << parm_dev_use(i, j);
            temp = (parm_dev(i, j) - (-10)) / (20);
            if (temp <= 0.0 || temp >= 1.0)
            {
              SS2out << " BOUND ";
              Nparm_on_bound++;
            }
            else if (temp < 0.01)
            {
              SS2out << " LO ";
              Nparm_on_bound++;
            }
            else if (temp >= 0.99)
            {
              SS2out << " HI ";
              Nparm_on_bound++;
            }
            else if (parm_dev(i, j) == parm_dev_use(i, j) && parm_dev_PH(i) > 0)
            {
              SS2out << " NO_MOVE ";
            }
            else
            {
              SS2out << " act ";
            }
            SS2out << CoVar(active_count, 1) << " " << parm_gradients(active_count) << " dev " << endl;
          }
          else
          {
            SS2out << " _ _ _ _ _ _ NA _ _ dev" << endl;
          }
        }
    }

    SS2out << "#" << endl
           << "Number_of_parameters: " << NP << endl;
    SS2out << "Active_count: " << active_count << endl;
    SS2out << "Number_of_active_parameters_on_or_within_1%_of_min-max_bound: " << Nparm_on_bound << endl;
  }

  // REPORT_KEYWORD 6 DERIVED_QUANTITIES
  if (pick_report_use(6) == "Y")
  {
    SS2out << endl
           << pick_report_name(6) << endl;
    SS2out << "SPR_std_report_basis: " << SPR_report_label << endl;
    SS2out << "F_std_report_basis: " << F_report_label << endl;
    SS2out << "B_ratio_denominator: " << depletion_basis_label << endl;
    NP = deriv_start;
    active_count = deriv_covar_start;
    SS2out << "Label Value  StdDev (Val-1.0)/Stddev  CumNorm" << endl;
    for (j = 1; j <= N_STD_Yr; j++)
    {
      NP++;
      SS2out << ParmLabel(NP) << " " << SSB_std(j);
      active_count++;
      SS2out << " " << CoVar(active_count, 1) << endl;
    }
    for (j = 1; j <= N_STD_Yr; j++)
    {
      NP++;
      SS2out << ParmLabel(NP) << " " << recr_std(j);
      active_count++;
      SS2out << " " << CoVar(active_count, 1) << endl;
    }
    for (j = 1; j <= N_STD_Yr_Ofish; j++)
    {
      NP++;
      SS2out << ParmLabel(NP) << " " << SPR_std(j);
      active_count++;
      SS2out << " " << CoVar(active_count, 1);
      if (CoVar(active_count, 1) > 0.0)
      {
        temp = value((SPR_std(j) - 1.0) / CoVar(active_count, 1));
        SS2out << " " << temp << " " << cumd_norm(temp);
      }
      SS2out << endl;
    }
    post_vecs << runnumber << " 0 " << obj_fun << " F/Fmsy_stdev ";
    for (j = 1; j <= N_STD_Yr_F; j++)
    {
      NP++;
      SS2out << ParmLabel(NP) << " " << F_std(j);
      active_count++;
      SS2out << " " << CoVar(active_count, 1);
      post_vecs << CoVar(active_count, 1) << " ";
      if (CoVar(active_count, 1) > 0.0)
      {
        temp = value((F_std(j) - 1.0) / CoVar(active_count, 1));
        SS2out << " " << temp << " " << cumd_norm(temp);
      }
      SS2out << endl;
    }
    post_vecs << endl;
    post_vecs << runnumber << " 0 " << obj_fun << " B/Bmsy_stdev ";

    for (j = 1; j <= N_STD_Yr_Dep; j++)
    {
      NP++;
      SS2out << ParmLabel(NP) << " " << depletion(j);
      active_count++;
      SS2out << " " << CoVar(active_count, 1);
      post_vecs << CoVar(active_count, 1) << " ";
      if (CoVar(active_count, 1) > 0.0)
      {
        temp = value((depletion(j) - 1.0) / CoVar(active_count, 1));
        SS2out << " " << temp << " " << cumd_norm(temp);
      }
      SS2out << endl;
    }
    post_vecs << endl;
    for (j = 1; j <= N_STD_Mgmt_Quant; j++)
    {
      NP++;
      active_count++;
      SS2out << ParmLabel(NP) << " " << Mgmt_quant(j);

      SS2out << " " << CoVar(active_count, 1) << endl;
    }

    for (j = 1; j <= Extra_Std_N; j++)
    {
      NP++;
      active_count++;
      SS2out << ParmLabel(NP) << " " << Extra_Std(j);
      SS2out << " " << CoVar(active_count, 1) << endl;
    }

    if (Svy_N_sdreport > 0)
    {
      k = 0;
      for (f = 1; f <= Nfleet; ++f)
      {
        if (Svy_sdreport(f) > 0)
        {
          for (j = 1; j <= Svy_N_fleet(f); j++)
          {
            active_count++;
            k++;
            SS2out << fleetname(f) << "_" << Svy_yr(f, j) << " ";
            SS2out << Svy_est(f, j) << " " << CoVar(active_count, 1) << " " << Svy_sdreport_est(k) << endl;
          }
        }
      }
    }
  }

  // REPORT_KEYWORD 7 MGPARM_BY_YEAR
  if (pick_report_use(7) == "Y")
  {
    k1 = YrMax;
    SS2out << endl
           << pick_report_name(7) << endl;
    SS2out << "Yr   Change? ";
    for (i = 1; i <= N_MGparm2; i++)
      SS2out << " " << ParmLabel(i);
    SS2out << endl;
    for (y = styr; y <= k1; y++)
      SS2out << y << " " << timevary_MG(y, 0) << " " << mgp_save(y) << endl;
    SS2out << endl;
  }

  // REPORT_KEYWORD 8 SELPARM_SIZE_BY_YEAR
  if (pick_report_use(8) == "Y")
  {
    k1 = YrMax;
    if (Fcast_timevary_Selex == 0)
    {
      SS2out << "forecast_selectivity_averaged_over_years:_" << Fcast_Sel_yr1 << "_to_" << Fcast_Sel_yr2 << endl;
    }
    else
    {
      SS2out << "forecast_selectivity_from_time-varying_parameters " << endl;
    }
    SS2out << endl
           << pick_report_name(8) << endl;
    SS2out << "Fleet Yr  Change?  Parameters" << endl;
    for (f = 1; f <= Nfleet; f++)
      for (y = styr; y <= k1; y++)
      {
        k = N_selparmvec(f);
        if (k > 0)
          SS2out << f << " " << y << " " << timevary_sel(y, f) << " " << save_sp_len(y, f)(1, k) << endl;
      }
  }

  // REPORT_KEYWORD 9 SELPARM_AGE_BY_YEAR
  if (pick_report_use(9) == "Y")
  {
    k1 = YrMax;
    SS2out << endl
           << pick_report_name(9) << endl;
    SS2out << "Fleet Yr  Change?  Parameters" << endl;
    for (f = Nfleet + 1; f <= 2 * Nfleet; f++)
      for (y = styr; y <= k1; y++)
      {
        k = N_selparmvec(f);
        if (k > 0)
          SS2out << f - Nfleet << " " << y << " " << timevary_sel(y, f) << " " << save_sp_len(y, f)(1, k) << endl;
      }
  }

  // REPORT_KEYWORD 10 RECRUITMENT_DISTRIBUTION
  if (pick_report_use(10) == "Y")
  {
    SS2out << endl
           << pick_report_name(10) << endl;
    SS2out << "Settle# settle_timing# G_pattern Area Settle_Month Seas Age Time_w/in_seas  recr_dist_F recr_dist_M" << endl;
    for (settle = 1; settle <= N_settle_assignments; settle++)
    {
      gp = settlement_pattern_rd(settle, 1); //  growth patterns
      p = settlement_pattern_rd(settle, 3); //  settlement area
      settle_time = settle_assignments_timing(settle);
      SS2out << settle << " " << settle_time << " " << gp << " " << p << " " << Settle_month(settle_time) << " " << Settle_seas(settle_time) << " " << Settle_age(settle_time) << " " << Settle_timing_seas(settle_time) << " " << recr_dist(styr, gp, settle_time, p);
      if (gender == 2) {SS2out << " " << recr_dist(styr, gp + N_GP, settle_time, p) << endl;} else {SS2out << " NA" << endl; }
    }
    SS2out << "#" << endl
           << "RECRUITMENT_DIST_Bmark" << endl
           << "Settle# settle_timing# G_pattern Area Settle_Month Seas Age Time_w/in_seas  recr_dist_F recr_dist_M" << endl;
    for (settle = 1; settle <= N_settle_assignments; settle++)
    {
      gp = settlement_pattern_rd(settle, 1); //  growth patterns
      p = settlement_pattern_rd(settle, 3); //  settlement area
      settle_time = settle_assignments_timing(settle);
      SS2out << settle << " " << settle_time << " " << gp << " " << p << " " << Settle_month(settle_time) << " " << Settle_seas(settle_time) << " " << Settle_age(settle_time) << " " << Settle_timing_seas(settle_time) << " " << recr_dist_unf(gp, settle_time, p) / (Bmark_Yr(8) - Bmark_Yr(7) + 1);
      if (gender == 2) {SS2out << " " << recr_dist_unf(gp + N_GP, settle_time, p) / (Bmark_Yr(8) - Bmark_Yr(7) + 1) << endl;} else {SS2out << " NA" << endl; }
    }
    SS2out << "#" << endl
           << "RECRUITMENT_DIST_endyr" << endl
           << "Settle# settle_timing# G_pattern Area Settle_Month Seas Age Time_w/in_seas recr_dist_F recr_dist_M" << endl;
    for (settle = 1; settle <= N_settle_assignments; settle++)
    {
      gp = settlement_pattern_rd(settle, 1); //  growth patterns
      p = settlement_pattern_rd(settle, 3); //  settlement area
      settle_time = settle_assignments_timing(settle);
      SS2out << settle << " " << settle_time << " " << gp << " " << p << " " << Settle_month(settle_time) << " " << Settle_seas(settle_time) << " " << Settle_age(settle_time) << " " << Settle_timing_seas(settle_time) << " " << recr_dist_endyr(gp, settle_time, p);
      if (gender == 2) {SS2out << " " << recr_dist(endyr, gp + N_GP, settle_time, p) << endl;} else {SS2out << " NA" << endl; }
  }

    SS2out << "#" << endl;
    SS2out << "RECRUITMENT_DIST_TIMESERIES" << endl;
    SS2out << "GP: ";
      for (gp = 1; gp <= N_GP; gp++)
        for (settle = 1; settle <= N_settle_timings; settle++)
          for (p = 1; p <= pop; p++)
          for (int sex = 1; sex <= gender; sex++)
            if (recr_dist_pattern(gp, settle, p) == 1) SS2out << gp << " ";
    SS2out << endl;
    SS2out << "settle_timing: ";
      for (gp = 1; gp <= N_GP; gp++)
        for (settle = 1; settle <= N_settle_timings; settle++)
          for (p = 1; p <= pop; p++)
          for (int sex = 1; sex <= gender; sex++)
            if (recr_dist_pattern(gp, settle, p) == 1) SS2out << settle << " ";
    SS2out << endl;
    SS2out << "area: ";
      for (gp = 1; gp <= N_GP; gp++)
        for (settle = 1; settle <= N_settle_timings; settle++)
          for (p = 1; p <= pop; p++)
          for (int sex = 1; sex <= gender; sex++)
            if (recr_dist_pattern(gp, settle, p) == 1) SS2out << p << " ";
    SS2out << endl;
    SS2out << "sex: ";
      for (gp = 1; gp <= N_GP; gp++)
        for (settle = 1; settle <= N_settle_timings; settle++)
          for (p = 1; p <= pop; p++)
          for (int sex = 1; sex <= gender; sex++)
            {if (recr_dist_pattern(gp, settle, p) == 1) SS2out << sex << " ";}
    SS2out << endl;

    SS2out << "Year recr_dist" << endl;
    for (y = styr; y <= YrMax; y++)
    {
      SS2out << y << " ";
      for (gp = 1; gp <= N_GP; gp++)
        for (settle = 1; settle <= N_settle_timings; settle++)
          for (p = 1; p <= pop; p++)
          for (int sex = 1; sex <= gender; sex++)
            if (recr_dist_pattern(gp, settle, p) == 1)
              {
              SS2out << " " << recr_dist(y, gp + (sex -1) * N_GP, settle, p);
              }
      SS2out << endl;
    }
  }

  // REPORT_KEYWORD 11 MORPH_INDEXING
  if (pick_report_use(11) == "Y")
  {
    SS2out << endl
           << pick_report_name(11) << endl;
    SS2out << "Index GP Sex BirthSeas Platoon Platoon_Dist Sex*GP Sex*GP*Settle BirthAge_Rel_Jan1" << endl;
    for (g = 1; g <= gmorph; g++)
    {
      SS2out << g << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << GP2(g) << " " << platoon_distr(GP2(g)) << " " << GP(g) << " " << GP3(g) << " " << azero_G(g) << endl;
    }
  }

  // REPORT_KEYWORD 12 SIZEFREQ_TRANSLATION
  //  3darray SzFreqTrans(1,SzFreq_Nmeth*nseas,1,nlength2,1,SzFreq_Nbins_seas_g);
  if (pick_report_use(12) == "Y" && SzFreq_Nmeth > 0)
  {
    SS2out << endl
           << pick_report_name(12) << endl;
    SS2out << "#_NOTE: rows_are_population_length_bins;_columns_are_recipient_size_bins_according_to_the_specified_method" << endl;
    for (SzFreqMethod = 1; SzFreqMethod <= SzFreq_Nmeth; SzFreqMethod++)
    {
      SS2out << SzFreqMethod << " gp seas len mid-len ";
      if (SzFreq_scale(SzFreqMethod) == 1)
      {
        SS2out << " mid-kg ";
      }
      else if (SzFreq_scale(SzFreqMethod) == 2)
      {
        SS2out << " mid-lbs ";
      }
      else if (SzFreq_scale(SzFreqMethod) == 3)
      {
        SS2out << " mid-cm ";
      }
      else
      {
        SS2out << " mid-inch ";
      }
      SS2out << SzFreq_bins1(SzFreqMethod);
      if (gender == 2)
        SS2out << SzFreq_bins1(SzFreqMethod);
      SS2out << endl
             << SzFreqMethod << " gp seas len mid-len metric " << SzFreq_bins(SzFreqMethod) << endl;
      ;
      for (gp = 1; gp <= N_GP; gp++)
        for (s = 1; s <= nseas; s++)
        {
          SzFreqMethod_seas = nseas * (SzFreqMethod - 1) + s; // index that combines sizefreqmethod and season and used in SzFreqTrans
          for (z = 1; z <= nlength2; z++)
          {
            SS2out << SzFreqMethod << " " << gp << " " << s << " " << len_bins2(z) << " " << len_bins_m2(z) << " ";
            if (SzFreq_scale(SzFreqMethod) == 1)
            {
              SS2out << wt_len2(s, gp, z) << " ";
            }
            else if (SzFreq_scale(SzFreqMethod) == 2)
            {
              SS2out << wt_len2(s, gp, z) / 0.4536 << " ";
            }
            else if (SzFreq_scale(SzFreqMethod) == 3)
            {
              SS2out << len_bins_m2(z) << " ";
            }
            else
            {
              SS2out << len_bins_m2(z) / 2.54 << " ";
            }
            for (j = 1; j <= gender * SzFreq_Nbins(SzFreqMethod); j++)
            {
              SS2out << SzFreqTrans(SzFreqMethod_seas, z, j) << " ";
              if (SzFreqTrans(SzFreqMethod_seas, z, j) < 0.0)
              {
                warnstream << "Bin widths narrower than pop len bins caused negative allocation in sizefreq method:";
                warnstream << " method, season, size, bin: " << SzFreqMethod << " " << s << " " << len_bins2(z) << " " << j;
                write_message (FATAL, 0); // EXIT!
              }
            }
            SS2out << endl;
          }
        }
    }
  }

  // REPORT_KEYWORD 13 MOVEMENT

  if (pick_report_use(13) == "Y" && do_migration > 0)
  {
    SS2out << endl
           << pick_report_name(13) << endl;
    SS2out << " Seas GP Source_area Dest_area minage maxage " << age_vector << endl;
    for (k = 1; k <= do_migr2; k++)
    {
      SS2out << move_def2(k) << " " << migrrate(endyr, k) << endl;
    }
  }

  // REPORT_KEYWORD 14 EXPLOITATION
  if (pick_report_use(14) == "Y")
  {
    SS2out << endl
           << pick_report_name(14) << endl;
    SS2out << "NOTE: Displays.various.annual.F.statistics.and.displays.apical.F.for.each.fleet.by.season" << endl;
    SS2out << "NOTE: F_Method:=" << F_Method;
    if (F_Method == 1)
    {
      SS2out << ";.Pope's_approx,.fleet.F.is.mid-season.exploitation.fraction ";
    }
    else
    {
      SS2out << ";.Continuous_F;.fleet.F.will.be.multiplied.by.season.duration.when.it.is.used.and.in.the.F_std.calculation";
    }
    SS2out << endl
           << "NOTE: Displayed.fleet-specific.F.values.are.the.F.for.ages.with.compound.age-length-sex.selectivity=1.0" << endl;
    SS2out << "NOTE: F_std_basis: " << F_report_label << endl;
    SS2out << "F_std averaged over N years: " << F_std_multi << endl;
    if (F_reporting >= 4)
    {
      SS2out << "NOTE: Annual_F.shown.here.is.done.by.the.Z-M.method.for.ages:." << F_reporting_ages(1) << "-" << F_reporting_ages(2) << endl;
    }
    else
    {
      SS2out << "NOTE: Annual_F.shown.here.is.done.by.the.Z-M.method.for.nages/2=" << nages / 2 << endl;
    }
    SS2out << "#" << endl;
    SS2out << "Yr Seas Seas_dur F_std annual_F annual_M ";
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        SS2out << " " << fleetname(f);
      }
    SS2out << endl;
    SS2out << "Catchunits: _ _ _ _ _ ";
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        if (catchunits(f) == 1)
        {
          SS2out << " Bio ";
        }
        else
        {
          SS2out << " Num ";
        }
      }
    SS2out << endl
           << "FleetType: _ _ _ _ _ ";
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        if (fleet_type(f) == 1)
        {
          SS2out << " Catch ";
        }
        else
        {
          SS2out << " Bycatch ";
        }
      }
    SS2out << endl
           << "FleetArea: _ _ _ _ _ ";
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        SS2out << " " << fleet_area(f);
      }
    SS2out << endl
           << "FleetID: _ _ _ _ _ ";
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        SS2out << " " << f;
      }
    SS2out << endl;
    if (N_init_F > 0)
    {
      for (s = 1; s <= nseas; s++)
      {
        SS2out << "INIT " << s << " " << seasdur(s) << " _  _  _ ";
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            if (init_F_loc(s, f) > 0)
            {
              SS2out << " " << init_F(init_F_loc(s, f));
            }
            else
            {
              SS2out << " _ ";
            }
          }
        SS2out << endl;
      }
    }

    for (y = styr; y <= YrMax; y++)
      for (s = 1; s <= nseas; s++)
      {
        t = styr + (y - styr) * nseas + s - 1;
        SS2out << y << " " << s << " " << seasdur(s);
        if (s == 1 && STD_Yr_Reverse_F(y) > 0)
        {
          SS2out << " " << F_std(STD_Yr_Reverse_F(y));
        }
        else
        {
          SS2out << " _ ";
        }
        SS2out << " " << annual_F(y)(2, 3);
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            SS2out << " " << Hrate(f, t);
          }
        SS2out << endl;
      }
  }

  // REPORT_KEYWORD 15 CATCH
  if (pick_report_use(15) == "Y")
  {
    SS2out << endl
           << pick_report_name(15) << endl;
    SS2out << "# where vuln_ is mid-season selected bio or numbers; sel_ is selected total catch; dead_ is catch without live discards; ret_ is retained catch" << endl;
    SS2out << "Fleet Fleet_Name Area Yr Seas Time Obs Exp Mult Exp*Mult se F  Like vuln_bio sel_bio dead_bio ret_bio vuln_num sel_num dead_num ret_num" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (fleet_type(f) <= 2)
      {
        for (y = styr - 1; y <= endyr; y++)
          for (s = 1; s <= nseas; s++)
          {
            t = styr + (y - styr) * nseas + s - 1;
            if (catchunits(f) == 1)
            {
              gg = 3;
            } //  biomass
            else
            {
              gg = 6;
            } //  numbers
            temp = float(y) + 0.01 * int(100. * (azero_seas(s) + seasdur_half(s)));
            SS2out << f << " " << fleetname(f) << " " << fleet_area(f) << " ";
            if (y < styr)
            {
              SS2out << "INIT ";
            }
            else
            {
              SS2out << y << " ";
            }
            SS2out << s << " " << temp << " " << catch_ret_obs(f, t) << " " << catch_fleet(t, f, gg) << " " << catch_mult(y, f) << " " << catch_mult(y, f) * catch_fleet(t, f, gg);
            SS2out << " " << catch_se(t, f) << " " << Hrate(f, t) << " ";
            if (fleet_type(f) == 1)
            {
              if (catch_ret_obs(f, t) > 0 && F_Method > 1)
              {
                SS2out << 0.5 * square((log(1.1 * catch_ret_obs(f, t)) - log(catch_fleet(t, f, gg) * catch_mult(y, f) + 0.1 * catch_ret_obs(f, t))) / catch_se(t, f));
              }
              else
              {
                SS2out << " NA";
              }
            }
            else
            {
              SS2out << "BYCATCH";
            }
            SS2out << " " << vuln_bio(t, f) << " " << catch_fleet(t, f)(1,3) << " " << vuln_num(t, f) << " " << catch_fleet(t, f)(4,6) << endl;
          }
      }
    }
  }
  int bio_t;
  dvector Bio_Comp(1, N_GP * gender);
  dvector Num_Comp(1, N_GP * gender);
  // REPORT_KEYWORD 16 TIME_SERIES
  //  Fleet Fleet_Name Area Yr Era Seas Subseas Month Time
  if (pick_report_use(16) == "Y")
  {
    SS2out << endl
           << pick_report_name(16);
    SS2out << "  BioSmry_age:_" << Smry_Age; // SS_Label_320
    if (F_Method == 1)
    {
      SS2out << "  Pope's_approx" << endl;
    }
    else
    {
      SS2out << "  Continuous_F" << endl;
    }
    SS2out << "Area Yr Era Seas Bio_all Bio_smry SpawnBio Recruit_0 ";
    for (gp = 1; gp <= N_GP; gp++)
      SS2out << " SpawnBio_GP:" << gp;
    if (Hermaphro_Option != 0)
    {
      for (gp = 1; gp <= N_GP; gp++)
        SS2out << " MaleSpawnBio_GP:" << gp;
    }
    for (gg = 1; gg <= gender; gg++)
      for (gp = 1; gp <= N_GP; gp++)
      {
        SS2out << " SmryBio_SX:" << gg << "_GP:" << gp;
      }

    for (gg = 1; gg <= gender; gg++)
    {
      for (gp = 1; gp <= N_GP; gp++)
      {
        SS2out << " SmryNum_SX:" << gg << "_GP:" << gp;
      }
    }
    SS2out << " mature_bio mature_num ";

    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
      {
        SS2out << " sel(B):_" << f << " dead(B):_" << f << " retain(B):_" << f << " sel(N):_" << f << " dead(N):_" << f << " retain(N):_" << f << " obs_cat:_" << f;
        if (F_Method == 1)
        {
          SS2out << " Hrate:_" << f;
        }
        else
        {
          SS2out << " F:_" << f;
        }
      }

    SS2out << " SSB_vir_LH ABC_buffer" << endl;
    for (p = 1; p <= pop; p++)
    {
      for (y = styr - 2; y <= YrMax; y++)
      {
        if (p == 1)
        {
          Smry_Table(y)(16, 17).initialize();
        }
        for (s = 1; s <= nseas; s++)
        {
          t = styr + (y - styr) * nseas + s - 1;
          bio_t = t;
          if (y <= styr)
          {
            bio_t = styr - 1 + s;
          }
          Bio_Comp.initialize();
          Num_Comp.initialize();
          totbio.initialize();
          smrybio.initialize();
          smrynum.initialize();
          SSB_vir_LH.initialize();
          smryage.initialize();
          //    Recr(p,y)=0;
          for (g = 1; g <= gmorph; g++)
            if (use_morph(g) > 0)
            {
              //     if(s==Bseas(g)) Recr(p,y)+=natage(t,p,g,0);
              gg = sx(g);
              temp = natage(t, p, g)(Smry_Age, nages) * Wt_Age_t(bio_t, 0, g)(Smry_Age, nages);
              Bio_Comp(GP(g)) += value(temp); //sums to accumulate across platoons and settlements
              Num_Comp(GP(g)) += value(sum(natage(t, p, g)(Smry_Age, nages))); //sums to accumulate across platoons and settlements
              totbio += natage(t, p, g) * Wt_Age_t(bio_t, 0, g);
              smrybio += temp;
              smrynum += sum(natage(t, p, g)(Smry_Age, nages));
              smryage += natage(t, p, g)(Smry_Age, nages) * r_ages(Smry_Age, nages);
              SSB_vir_LH += natage(t, p, g) * virg_fec(g);
              {
                for (f = 1; f <= Nfleet; f++)
                {
                  if (fleet_area(f) == p && y >= styr - 1 && fleet_type(f) <= 2)
                  {
                    Smry_Table(y, 16) += sum(catage(t, f, g));  // temporary storage spot
                    Smry_Table(y, 17) += catage(t, f, g) * r_ages;
                  }
                }
              }
            } //close gmorph loop
          Smry_Table(y, 17) /= ( Smry_Table(y, 16) + 1.0e-06 ); // mean age of catch
          Smry_Table(y, 16) = smryage / smrynum; //  mean age of summary numbers
          if (gender_rd == -1)
            SSB_vir_LH *= femfrac(1);
          SS2out << p << " " << y;
          if (y == styr - 2)
          {
            SS2out << " VIRG ";
          }
          else if (y == styr - 1)
          {
            SS2out << " INIT ";
          }
          else if (y <= endyr)
          {
            SS2out << " TIME ";
          }
          else
          {
            SS2out << " FORE ";
          }

          SS2out << s << " " << totbio << " " << smrybio << " ";
          if (s == spawn_seas)
          {
            temp = sum(SSB_pop_gp(y, p));
            if (Hermaphro_maleSSB > 0)
              temp += Hermaphro_maleSSB * sum(MaleSSB(y, p));
            SS2out << temp;
          }
          else
          {
            SS2out << " _ ";
          }
          SS2out << " " << Recr(p, t) << " ";
          if (s == spawn_seas)
          {
            SS2out << SSB_pop_gp(y, p);
            if (Hermaphro_Option != 0)
              SS2out << MaleSSB(y, p);
          }
          else
          {
            for (gp = 1; gp <= N_GP; gp++)
            {
              SS2out << " _ ";
            }
            if (Hermaphro_Option != 0)
            {
              for (gp = 1; gp <= N_GP; gp++)
              {
                SS2out << " _ ";
              }
            }
          }
          SS2out << " " << Bio_Comp << " " << Num_Comp;
          SS2out << " " << SSB_B_yr(y) << " " << SSB_N_yr(y);
          for (f = 1; f <= Nfleet; f++)
            if (fleet_type(f) <= 2)
            {
              if (fleet_area(f) == p && y >= styr - 1)
              {
                SS2out << " " << catch_fleet(t, f) << " ";
                if (y <= endyr)
                {
                  SS2out << catch_ret_obs(f, t) << " " << Hrate(f, t);
                }
                else
                {
                  SS2out << " _ " << Hrate(f, t);
                }
                //        if(y<=endyr) {Smry_Table(y,4)+=catch_fleet(t,f,1); Smry_Table(y,5)+=catch_fleet(t,f,2); Smry_Table(y,6)+=catch_fleet(t,f,3);}
              }
              else
              {
                SS2out << " 0 0 0 0 0 0 0 0 ";
              }
            }
          if (s == spawn_seas)
          {
            SS2out << " " << SSB_vir_LH;
          }
          else
          {
            SS2out << " _";
          }
          if (y <= endyr)
          {
            SS2out << " NA";
          }
          else
          {
            SS2out << " " << ABC_buffer(y);
          }
          SS2out << endl;
        }
      }
    }
  }
  // REPORT_KEYWORD 17 SPR_SERIES  (equilibrium_SPR_and_YPR_calculations_for_each_year)
  // 1=totbio, 2=smrybio, 3=smrynum, 4=enc_catch, 5=dead_catch, 6=ret_catch, 7=spbio, 8=recruit,
  // 9=equ_totbio, 10=equ_smrybio, 11=equ_SSB_virgin, 12=equ_S1, 13=Gentime, 14=YPR, 15=meanage_spawners, 16=meanage_smrynums, 17=meanage_catch

  if (pick_report_use(17) == "Y")
  {
    SS2out << endl
           << pick_report_name(17) << endl;
    SS2out << "#_NOTE: reports_per_recruit_quantities_using_current_year_biology;_using_same_equil_calc_routine_used_for_reference_points" << endl;
    SS2out << "#_NOTE: current_year_biology_is_current_at-age_biology_from_time_series;_not_recalc_biology_from_current_growth_parameters" << endl;
    SS2out << "#_NOTE: uses_R0= " << Recr_virgin << endl;
    SS2out << "#_NOTE: YPR_unit_is_Dead_Biomass" << endl;
    SS2out << "#_NOTE: gentime_is_mean_age_of_female_spawners_weighted_by_reproductive_value-at-age_(fec(g))" << endl;

    SS2out << "Yr Era Bio_all_eq Bio_Smry_eq SSB_unfished_eq SSBfished_eq SSBfished/R SPR  YPR GenTime" << endl;

    for (y = styr; y <= YrMax; y++)
    {
      if (y <= endyr)
      {
        SS2out << y << " TIME ";
      }
      else
      {
        SS2out << y << " FORE ";
      }
      SS2out << Smry_Table(y)(9, 12) << " " << (Smry_Table(y, 12) / Recr_virgin) << " " << Smry_Table(y, 12) / Smry_Table(y, 11) << " ";
      SS2out << (Smry_Table(y, 14) / Recr_virgin) << " " << Smry_Table(y, 13) << endl;
    } // end year loop
    // end SPR time series
  }

  if (pick_report_use(61) == "Y")  // ANNUAL_TIME_SERIES report:61
  {
    SS2out << endl
           << pick_report_name(61) << endl;
    SS2out << "#_NOTE: MnAgeSmry_is_numbers_weighted_meanage_at_and_above_smryage:_" << Smry_Age << endl;
    SS2out << "#_NOTE:_mean_age_of_catch_is_numbers-weighted_and_based_on_catage_which_is_the_dead_catch_and_comes_from:_sel_dead_num_=_sel_*_(retain_+_(1-retain)*discmort)" << endl;
    SS2out << "#_NOTE: Depletion_basis: " << depletion_basis << " # " << depletion_basis_label << endl;
    SS2out << "#_NOTE: F_std_report_basis: " << F_reporting << " # " << F_report_label << endl;
    SS2out << "#_NOTE: SPR_std_report_basis: " << SPR_reporting << " # " << SPR_report_label << endl;
    SS2out << "#_NOTE: tot_exploit:_is_dead_catch_B/bio_smry" << endl;
    SS2out << "#_NOTE: sum_fleet_F:_is_simple_sum_of_full_Fs_among_all_fleets_ignoring_seasonal_and_area_modifiers" << endl;
    SS2out << "#_NOTE: suffix:_an_emphasizes_that_quantity_is_annual_and_all_areas" << endl;

    SS2out << "year Era Bio_all_an Bio_Smry_an Num_Smry_an SSB recruits sel_catch_B_an dead_catch_B_an retain_catch_B_an sel_catch_N_an dead_catch_N_an retain_catch_N_an" <<
              " tot_exploit sum_fleet_F F=Z-M M mn_age_SSB mn_age_smry mn_age_catch SPR_std Depletion_std F_std" << endl;
  // 1=totbio, 2=smrybio, 3=smrynum, 4=enc_catch, 5=dead_catch, 6=ret_catch, 7=spbio, 8=recruit,
  // 9=equ_totbio, 10=equ_smrybio, 11=equ_SSB_virgin, 12=equ_S1, 13=Gentime, 14=YPR, 15=meanage_spawners, 16=meanage_smrynums, 17=meanage_catch
  
    for (y = styr; y <= YrMax; y++)
    {
      if (y <= endyr)
      {
        SS2out << y << " TIME ";
      }
      else
      {
        SS2out << y << " FORE ";
      }
      SS2out << Smry_Table(y)(1, 3) << " " << SSB_yr(y) << " " << exp_rec(y, 4) << " ";
      SS2out << annual_catch(y) << " " << Smry_Table(y, 5) / Smry_Table(y, 2) << " " << annual_F(y) <<  " " << Smry_Table(y, 15) / SSB_yr(y) <<  " " << Smry_Table(y, 16) << " " << Smry_Table(y, 17) << " ";  // 
  // gentime
      if (STD_Yr_Reverse_Ofish(y) > 0)
      {
        SS2out << SPR_std(STD_Yr_Reverse_Ofish(y)) << " ";
      }
      else
      {
        SS2out << " _ ";
      }
      if (STD_Yr_Reverse_Dep(y) > 0)
      {
        SS2out << depletion(STD_Yr_Reverse_Dep(y)) << " ";
      }
      else
      {
        SS2out << " _ ";
      }
      if (y >= styr && STD_Yr_Reverse_F(y) > 0)
      {
        SS2out << F_std(STD_Yr_Reverse_F(y));
      }
      else
      {
        SS2out << " _ ";
      }
      SS2out << endl;
    } // end year loop
      // end ANNUAL_TIME_SERIES
  }

  // REPORT_KEYWORD 18 Kobe_Plot
  if (pick_report_use(18) == "Y")
  {
    SS2out << endl
           << pick_report_name(18) << endl;
    if (F_std_basis != 2)
      SS2out << "F_report_basis_is_not_=2;_so_info_below_is_not_F/Fmsy" << endl;
    SS2out << "MSY_basis:_" << MSY_name << endl;
    SS2out << "Yr  B/Bmsy  F/Fmsy" << endl;
    for (y = styr; y <= YrMax; y++)
    {
      SS2out << y << " " << SSB_yr(y) / Bmsy << " ";
      if (y >= styr && STD_Yr_Reverse_F(y) > 0)
      {
        SS2out << " " << F_std(STD_Yr_Reverse_F(y));
      }
      else
      {
        SS2out << " _ ";
      }
      SS2out << endl;
    }
  }

  // ******************************************************************************
  k = Nfleet;
  if (k < 4)
    k = 4;
  // quantities to store summary statistics
  dvector rmse(1, k); //  used in the SSBio, Index, Lencomp and Agecomp reports
  dvector Hrmse(1, k);
  dvector Rrmse(1, k);
  dvector n_rmse(1, k);
  // following vectors used for index-related quantities
  dvector mean_CV(1, k);

  dvector mean_CV2(1, k);

  dvector mean_CV3(1, k);

  // vectors to store mean sample sizes for comp data
  dvector mean_Nsamp_in(1, k);
  dvector mean_Nsamp_adj(1, k);
  dvector mean_Nsamp_DM(1, k);
  //                                                            SS_Label_330

  // REPORT_KEYWORD 19 SPAWN_RECRUIT
  if (pick_report_use(19) == "Y")
  {

    rmse = 0.0;
    n_rmse = 0.0;
    double cross = 0.0;
    double Durbin = 0.0;
    double var = 0.0;

    for (y = recdev_first; y <= recdev_end; y++)
    {
      temp1 = recdev(y);
      if (y < recdev_start) // so in early period
      {
        rmse(3) += value(square(temp1));
        n_rmse(3) += 1.;
        rmse(4) += biasadj(y);
      }
      else
      {
        var += value(square(temp1));
        if (y > recdev_start) // so not first year
        {
          cross += value(temp1 * recdev(y - 1));
          Durbin += value(square(temp1 - recdev(y - 1)));
        }
        rmse(1) += value(square(temp1));
        n_rmse(1) += 1.;
        rmse(2) += biasadj(y);
      }
    }
    if (n_rmse(1) > 0. && rmse(1) > 0.)
      rmse(1) = sqrt(rmse(1) / n_rmse(1)); // rmse during main period
    if (n_rmse(1) > 0.)
      rmse(2) = rmse(2) / n_rmse(1); // mean biasadj during main period
    if (n_rmse(3) > 0. && rmse(3) > 0.)
      rmse(3) = sqrt(rmse(3) / n_rmse(3)); //rmse during early period
    if (n_rmse(3) > 0.)
      rmse(4) = rmse(4) / n_rmse(3); // mean biasadj during early period
    if (n_rmse(1) >= 2.)
    {
      cross /= (n_rmse(1) - 1.);
    }
    else
    {
      cross = 0.0;
    }
    Durbin /= (var + 1.0e-09);
    var /= (n_rmse(1) + 1.0e-09);

    dvariable steepness = SRparm(2);
    SS2out << endl
           << pick_report_name(19);
    SS2out << "  Function: " << SR_fxn << "  RecDev_method: " << do_recdev << "   sum_recdev: " << sum_recdev << endl
           << SRparm(1) << " Ln(R0) " << mfexp(SRparm(1)) << endl
           << steepness << " steepness" << endl
           << Bmsy / SSB_virgin << " Bmsy/Bzero ";
    if (SR_fxn == 8)
    {
      dvariable Shepherd_c;
      dvariable Shepherd_c2;
      dvariable Hupper;
      Shepherd_c = SRparm(3);
      Shepherd_c2 = pow(0.2, Shepherd_c);
      Hupper = 1.0 / (5.0 * Shepherd_c2);
      temp = 0.2 + (SRparm(2) - 0.2) / (0.8) * (Hupper - 0.2);
      SS2out << " Shepherd_c: " << Shepherd_c << " steepness_limit: " << Hupper << " Adjusted_steepness: " << temp;
    }
    else if (SR_fxn == 9)
    {
      SS2out << " Ricker_Power: " << SRparm(3);
    }

    SS2out << endl;
    SS2out << sigmaR << " sigmaR" << endl;
    SS2out << init_equ_steepness << "  # 0/1 to use steepness in initial equ recruitment calculation" << endl;

    SS2out << SRparm(N_SRparm2 - 1) << " init_eq:  see below" << endl
           << recdev_start << " " << recdev_end << " main_recdev:start_end" << endl
           << recdev_adj(1) << " " << recdev_adj(2, 5) << " breakpoints_for_bias_adjustment_ramp " << endl;

    temp = sigmaR * sigmaR; //  sigmaR^2
    SS2out << "ERA    N    RMSE  RMSE^2/sigmaR^2  mean_BiasAdj est_rho Durbin-Watson" << endl;
    SS2out << "main  " << n_rmse(1) << " " << rmse(1) << " " << square(rmse(1)) / temp << " " << rmse(2) << " " << cross / var << " " << Durbin;
    if (wrote_bigreport == 0) //  first time writing bigreport
    {
      if (rmse(1) < 0.5 * sigmaR && rmse(2) > (0.01 + 2.0 * square(rmse(1)) / temp))
      {
        warnstream << "Main recdev biasadj is >2 times ratio of rmse to sigmaR";
        SS2out << " # " << warnstream.str() ;
        write_message (WARN, 0);
      }
    }
    SS2out << endl;

    SS2out << "early " << n_rmse(3) << " " << rmse(3) << " " << square(rmse(3)) / temp << " " << rmse(4);
    if (wrote_bigreport == 0) //  first time writing bigreport
    {
      if (rmse(3) < 0.5 * sigmaR && rmse(4) > (0.01 + 2.0 * square(rmse(3)) / temp))
      {
        warnstream << "Early recdev biasadj is >2 times ratio of rmse to sigmaR";
        SS2out << " # " << warnstream.str();
        write_message (WARN, 0);
      }
    }
    SS2out << endl;

    SS2out << "Yr SpawnBio exp_recr with_regime bias_adjusted pred_recr dev biasadjuster era mature_bio mature_num raw_dev" << endl;
    SS2out << "S/Rcurve " << SSB_virgin << " " << Recr_virgin << endl;
    y = styr - 2;
    SS2out << "Virg " << SSB_yr(y) << " " << exp_rec(y) << " - " << 0.0 << " Virg " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " 0.0 " << endl;
    y = styr - 1;
    SS2out << "Init " << SSB_yr(y) << " " << exp_rec(y) << " - " << 0.0 << " Init " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " " << 0.0 << endl;

    if (recdev_first < styr)
    {
      for (y = recdev_first; y <= styr - 1; y++)
      {
        SS2out << y << " " << SSB_yr(styr - 1) << " " << exp_rec(styr - 1, 1) << " " << exp_rec(styr - 1, 2) << " " << exp_rec(styr - 1, 3) * mfexp(-biasadj(y) * half_sigmaRsq) << " " << exp_rec(styr - 1, 3) * mfexp(recdev(y) - biasadj(y) * half_sigmaRsq) << " "
               << recdev(y) << " " << biasadj(y) << " Init_age " << SSB_B_yr(styr - 1) << " " << SSB_N_yr(styr - 1) << " " << recdev(y) << endl; // newdev approach uses devs for initial agecomp directly
      }
    }
    for (y = styr; y <= YrMax; y++)
    {
      SS2out << y << " " << SSB_yr(y) << " " << exp_rec(y) << " ";
      if (recdev_do_early > 0 && y >= recdev_early_start && y <= recdev_early_end)
      {
        SS2out << log(exp_rec(y, 4) / exp_rec(y, 3)) << " " << biasadj(y) << " Early " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " " << recdev(y);
      }
      else if (y >= recdev_start && y <= recdev_end)
      {
        SS2out << log(exp_rec(y, 4) / exp_rec(y, 3)) << " " << biasadj(y) << " Main " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " " << recdev(y);
      }
      else if (Do_Forecast > 0 && y > recdev_end)
      {
        SS2out << log(exp_rec(y, 4) / exp_rec(y, 3)) << " " << biasadj(y);
        if (y <= endyr)
        {
          SS2out << " Late ";
        }
        else
        {
          SS2out << " Fore ";
        }
        SS2out << SSB_B_yr(y) << " " << SSB_N_yr(y) << " ";
        if (do_recdev > 0)
        {
          SS2out << Fcast_recruitments(y);
        }
        else
        {
          SS2out << " 0.0";
        }
      }
      else
      {
        SS2out << " _ _ Fixed";
      }
      SS2out << endl;
    }

    SS2out << endl << "#Expanded_Spawn_Recr_report" << endl << pick_report_name(19) << endl;
    SS2out << SR_fxn << " # SR_Function" << endl;
    SS2out << N_SRparm2 << " # N_SRparms" << endl;
    SS2out << "#" << endl << "#_SRparm  parm_label value phase TV_year" << endl;
    for (int j = 1; j <=N_SRparm2; j++)
    {
      SS2out << "# " << j << " " << ParmLabel(firstSRparm + j) << " " << SRparm(j) << " " << SRparm_PH(j);
      if (SRparm_timevary(j) > 0 && j <= 4 ) //  timevary SRparm exists
      {SS2out << " " << timevary_SRparm_first_yr;} else {SS2out << " -";}
       SS2out << endl;
    }
    SS2out << "#" << endl;
    if (SRparm_timevary(N_SRparm2 - 1) > 0) //  timevary regime exists
      {SS2out << " #_Regime_used_to_offset_from_SRR";}
    SS2out << timevary_bio_4SRR << " # timevary_bio_4SRR  #_Compatibility_flag_for_legacy_(0)_vs_improved_(1)_impact_of_timevary_biology_on_benchmark_SRR_calcs" << endl;
    if( timevary_MG_firstyr == YrMax)
    { SS2out << " #_No_timevary_MGparm" << endl; }
    else
    { SS2out << timevary_MG_firstyr << " #_first year_timevary_MGparm_(or_any_year_EWAA) " << endl; }

    SS2out << "#" << endl << "Quantities for MSY and other benchmark calculations " << endl
      << "Benchmark_index: 1 2 3 4 5 6 7 8 9 10" << endl
      << "Benchmark_label: beg_bio end_bio beg_selex end_selex beg_relF end_relF beg_recr_dist end_recr_dist beg_SRparm end_SRparm" << endl
      << "Benchmark_years: " << Bmark_Yr << endl;
    for ( int k = 1; k <=9; k+=2) 
    { if (Bmark_Yr(k+1) > Bmark_Yr(k))
      {SS2out << "#_NOTE:_using_range_of_years_can_reduce_standard_error_of_result;_do_this_only_when_timevarying_makes_necessary:  " << k << " " << Bmark_Yr(k) << " " << Bmark_Yr(k+1) << endl;}
    }
    SS2out << "SSBpR0_virgin: " << SSBpR_virgin << " #_uses_biology_from_start_year: " << styr <<endl;
    SS2out << "SSBpR_unfished_benchmark: " << SSBpR_bench << "  #_uses_biology_over_benchmark_year_range " << endl;

    switch (SR_fxn)
    {
      case 3: // Beverton-Holt with steepness
    {
      alpha = 4.0 * steepness / (SSBpR_virgin * (1. - steepness));
      beta = (5.0 * steepness - 1.0) / ((1. - steepness) * SSB_virgin);
      SS2out << "Ln(R0): " << SRparm(1) << endl << "R0: " << mfexp(SRparm(1)) << endl;
      SS2out << "steepness: " << steepness << endl;
      SS2out << "Ln(alpha)_derived: " << log(alpha) << " alpha " << alpha << endl;
      SS2out << "Ln(beta)_derived: " << log(beta) << " beta " << beta << endl;
      break;
    }
      case 10: // Beverton-Holt with alpha, beta
    {
      SS2out << "Ln(alpha): " << SRparm(3) << " alpha " << mfexp(SRparm(3)) << endl;
      SS2out << "Ln(beta): " << SRparm(4) << " beta " << mfexp(SRparm(4)) << endl;
      SS2out << "ln(R0)_derived: " << log( 1. / beta * (alpha - (1. / SSBpR_virgin))) << endl;  //  virgin R0
      SS2out << "steepness_derived: " << alpha * SSBpR_virgin / (4. + alpha * SSBpR_virgin) << endl;  // steepness virgin
      break;
    }
    case 8:
    {
      dvariable Shepherd_c;
      dvariable Shepherd_c2;
      dvariable Hupper;
      Shepherd_c = SRparm(3);
      Shepherd_c2 = pow(0.2, Shepherd_c);
      Hupper = 1.0 / (5.0 * Shepherd_c2);
      temp = 0.2 + (SRparm(2) - 0.2) / (0.8) * (Hupper - 0.2);
      SS2out << "Shepherd_c: " << Shepherd_c << endl << "Shepard_steepness_limit: " << Hupper << endl << "Shepard_adjusted_steepness: " << temp << endl;
      break;
    }
    default:
    {
      SS2out << "other_SRR " << endl;
      break;
    }
    }

    SS2out << "Bmsy/Bzero: "<< Bmsy / SSB_virgin  << " # using styr bio for Bzero" << endl;
    SS2out << "Bmsy/Bunf: "<< Bmsy / Mgmt_quant(1)  << " # using MSY's averaged bio for Bunf" << endl;

    SS2out << "#" << endl << "RecDev_method: " << do_recdev << endl << "sum_recdev: " << sum_recdev << endl << "recr_logL: " << recr_like << endl;
    SS2out << "main_recdev:start_end: " << recdev_start << " " << recdev_end << endl
           << "breakpoints_for_bias_adjustment_ramp: " <<recdev_adj(1,4) << endl << "max_bias_adj: " << recdev_adj(5) <<  endl;

    temp = sigmaR * sigmaR; //  sigmaR^2
    SS2out << "ERA    N    RMSE  RMSE^2/sigmaR^2  mean_BiasAdj est_rho Durbin-Watson" << endl;
    SS2out << "main  " << n_rmse(1) << " " << rmse(1) << " " << square(rmse(1)) / temp << " " << rmse(2) << " " << cross / var << " " << Durbin;
    if (wrote_bigreport == 0) //  first time writing bigreport
    {
      if (rmse(1) < 0.5 * sigmaR && rmse(2) > (0.01 + 2.0 * square(rmse(1)) / temp))
      {
        warnstream << "Main recdev biasadj is >2 times ratio of rmse to sigmaR";
        SS2out << " # " << warnstream.str() ;
        write_message (WARN, 0);
      }
    }
    SS2out << endl;

    SS2out << "early " << n_rmse(3) << " " << rmse(3) << " " << square(rmse(3)) / temp << " " << rmse(4);
    if (wrote_bigreport == 0) //  first time writing bigreport
    {
      if (rmse(3) < 0.5 * sigmaR && rmse(4) > (0.01 + 2.0 * square(rmse(3)) / temp))
      {
        warnstream << "Early recdev biasadj is >2 times ratio of rmse to sigmaR";
        SS2out << " # " << warnstream.str();
        write_message (WARN, 0);
      }
    }
    SS2out << endl  << "#" << endl << init_equ_steepness << "  # Initial_equilibrium:_0/1_to_use_spawner-recruitment_in_initial_equ_recruitment_calculation" << endl << "#" << endl;
    SS2out << "Yr SpawnBio exp_recr with_regime bias_adjusted pred_recr dev biasadjuster era mature_bio mature_num raw_dev SSBpR(yr) " << endl;

    y = styr - 2;
    SS2out << "Virg " << SSB_yr(y) << " " << exp_rec(y) << " _ " << 0.0 << " Virg " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " _ " << SSBpR_virgin << endl;
    y = styr - 1;
    SS2out << "Init " << SSB_yr(y) << " " << exp_rec(y) << " _ " << 0.0 << " Init " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " _ " << SSBpR_virgin << endl;

    if (recdev_first < styr)
    {
      for (y = recdev_first; y <= styr - 1; y++)
      {
        SS2out << y << " " << SSB_yr(styr - 1) << " " << exp_rec(styr - 1, 1) << " " << exp_rec(styr - 1, 2) << " " << exp_rec(styr - 1, 3) * mfexp(-biasadj(y) * half_sigmaRsq) << " " << exp_rec(styr - 1, 3) * mfexp(recdev(y) - biasadj(y) * half_sigmaRsq) << " "
               << recdev(y) << " " << biasadj(y) << " Init_age " << SSB_B_yr(styr - 1) << " " << SSB_N_yr(styr - 1) << " " << recdev(y) << endl; // newdev approach uses devs for initial agecomp directly
      }
    }
    for (y = styr; y <= YrMax; y++)
    {
      SS2out << y << " " << SSB_yr(y) << " " << exp_rec(y) << " ";
      if (recdev_do_early > 0 && y >= recdev_early_start && y <= recdev_early_end)
      {
        SS2out << log(exp_rec(y, 4) / exp_rec(y, 3)) << " " << biasadj(y) << " Early " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " " << recdev(y);
      }
      else if (y >= recdev_start && y <= recdev_end)
      {
        SS2out << log(exp_rec(y, 4) / exp_rec(y, 3)) << " " << biasadj(y) << " Main " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " " << recdev(y);
      }
      else if (Do_Forecast > 0 && y > recdev_end)
      {
        SS2out << log(exp_rec(y, 4) / exp_rec(y, 3)) << " " << biasadj(y);
        if (y <= endyr)
        {
          SS2out << " Late ";
        }
        else
        {
          SS2out << " Fore ";
        }
        SS2out << SSB_B_yr(y) << " " << SSB_N_yr(y) << " ";
        if (do_recdev > 0)
        {
          SS2out << Fcast_recruitments(y);
        }
        else
        {
          SS2out << " 0.0";
        }
      }
      else
      {
        SS2out << " _ _ Fixed  " << SSB_B_yr(y) << " " << SSB_N_yr(y) << " _ ";
      }
      SS2out << " " << Smry_Table(y, 11) / Recr_virgin << endl;
    }

    // REPORT_KEYWORD SPAWN_RECR_CURVE
    if (pick_report_use(20) == "Y")
    {
      {
      SRparm_work = SRparm_byyr(styr);
      y = styr;
      SS2out << endl
               << pick_report_name(20) << endl
               << "# using_virgin_SR_parameters:  " << SRparm_work << endl;
        SS2out << "SSB/SSB_virgin    SSB    Recruitment" << endl;
        for (f = 1; f <= 120; f++)
        {
          SSB_current = double(f) / 100. * SSB_virgin;
          temp = Spawn_Recr(SRparm_work, SSB_virgin, Recr_virgin, SSB_current);
          SS2out << SSB_current / SSB_virgin << " " << SSB_current << " " << temp << endl;
        }
        SS2out << endl
               << "SPAWN_RECR_CURVE report:20 Benchmark" << endl  //  revise this name per r4ss needs
               << "# using_benchmark_SR_parameters:  " << SRparm_bench << endl;
        SS2out << "SSB/SSB_benchmark    SSB    Recruitment" << endl;
        for (f = 1; f <= 120; f++)
        {
          SSB_current = double(f) / 100. * SSB0_4_SRR;
          temp = Spawn_Recr(SRparm_bench, SSB0_4_SRR, R0_4_SRR, SSB_current);
          SS2out << SSB_current / SSB0_4_SRR << " " << SSB_current << " " << temp << endl;
        }

      }
    }

    // REPORT_KEYWORD 22 INDEX_2 Survey Observations by Year
    if (pick_report_use(22) == "Y" && Svy_N > 0)
    {
      SS2out << endl
             << pick_report_name(22) << endl;
      SS2out << "NOTE: Calc_Q is Q_base with devs, so does not include power; eff_Q includes effect of Power" << endl;
      //  where show_time(t) contains:  yr, seas
      //  data_time(ALK,f) has real month; 2nd is timing within season; 3rd is year.fraction
      //  show_time2(ALK) has yr, seas, subseas
      rmse = 0.0;
      n_rmse = 0.0;
      mean_CV = 0.0;
      mean_CV2 = 0.0;
      mean_CV3 = 0.0;
      SS2out << "Fleet Fleet_name Area Yr Seas Subseas Month Time Vuln_bio Obs Exp Calc_Q Eff_Q SE SE_input Dev Like Like+log(s) SuprPer Use" << endl;
      for (f = 1; f <= Nfleet; f++)
      {
        in_superperiod = 0;
        for (i = 1; i <= Svy_N_fleet(f); i++)
        {
          t = Svy_time_t(f, i);
          ALK_time = Svy_ALK_time(f, i);
          SS2out << f << " " << fleetname(f) << " " << fleet_area(f) << " " << Show_Time2(ALK_time) << " " << data_time(ALK_time, f, 1) << " " << data_time(ALK_time, f, 3) << " " << Svy_selec_abund(f, i) << " " << Svy_obs(f, i) << " ";
          if (Svy_errtype(f) >= 0) // lognormal or T-dist
          {
            temp = mfexp(Svy_est(f, i));
            SS2out << temp << " " << Svy_q(f, i) << " " << temp / Svy_selec_abund(f, i) << " " << Svy_se_use(f, i) << " " << Svy_se(f, i);
            if (Svy_use(f, i) > 0)
            {
              SS2out << " " << Svy_obs_log(f, i) - Svy_est(f, i) << " ";
              SS2out << Svy_like_I(f, i) - log(Svy_se_use(f, i)) << " " << Svy_like_I(f,i) << " ";
              rmse(f) += value(square(Svy_obs_log(f, i) - Svy_est(f, i)));
              n_rmse(f) += 1.;
              mean_CV(f) += Svy_se_rd(f, i);
              mean_CV3(f) += Svy_se(f, i);
              mean_CV2(f) += value(Svy_se_use(f, i));
            }
            else
            {
              SS2out << " _ _ _ ";
            }
          }
          else // normal
          {
            SS2out << Svy_est(f, i) << " " << Svy_q(f, i) << " " << "NA" << " " << Svy_se_use(f, i) << " " << Svy_se(f, i);
            if (Svy_use(f, i) > 0)
            {
              SS2out << " " << Svy_obs(f, i) - Svy_est(f, i) << " ";
              SS2out << Svy_like_I(f, i) - log(Svy_se_use(f, i)) << " " << Svy_like_I(f,i) << " ";
              rmse(f) += value(square(Svy_obs(f, i) - Svy_est(f, i)));
              n_rmse(f) += 1.;
              mean_CV(f) += Svy_se_rd(f, i);
              mean_CV3(f) += Svy_se(f, i);
              mean_CV2(f) += value(Svy_se_use(f, i));
            }
            else
            {
              SS2out << " _ _ _ ";
            }
          }
          if (Svy_super(f, i) < 0 && in_superperiod == 0)
          {
            in_superperiod = 1;
            SS2out << " beg_SuprPer ";
          }
          else if (Svy_super(f, i) < 0 && in_superperiod == 1)
          {
            in_superperiod = 0;
            SS2out << " end_SuprPer ";
          }
          else if (in_superperiod == 1)
          {
            SS2out << " in_SuprPer ";
          }
          else
          {
            SS2out << " _ ";
          }
          SS2out << Svy_use(f, i);
          SS2out << endl;
        }
        if (n_rmse(f) > 0)
        {
          rmse(f) = sqrt((rmse(f) + 1.0e-9) / n_rmse(f));
          mean_CV(f) /= n_rmse(f);
          mean_CV3(f) /= n_rmse(f);
          mean_CV2(f) /= n_rmse(f);
        }
      }
    }

    // REPORT_KEYWORD 21 INDEX_1  Survey Fit Summary
    SS2out << endl
           << pick_report_name(21) << endl;
    SS2out << "Fleet Link Link+ ExtraStd BiasAdj Float   Qbase Num=0/Bio=1 Err_type"
           << " N Npos RMSE logL  mean_input_SE Input+VarAdj Input+VarAdj+extra VarAdj New_VarAdj penalty_mean_Qdev rmse_Qdev Offset Power fleetname" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (Svy_N_fleet(f) > 0)
      {
        SS2out << f << " " << Q_setup(f)
               << " " << Svy_q(f, 1) << " " << Svy_units(f) << " " << Svy_errtype(f)
               << " " << Svy_N_fleet(f) << " " << n_rmse(f) << " " << rmse(f)<< " " << surv_like(f)
               << " " << mean_CV(f) << " " << mean_CV3(f) << " " << mean_CV2(f) << " " << var_adjust(1, f)
               << " " << var_adjust(1, f) + rmse(f) - mean_CV(f)
               << " " << Q_dev_like(f, 1) << " " << Q_dev_like(f, 2) << " ";
        if (Q_setup(f, 1) >= 5)
        {SS2out << " " << Q_parm(Q_setup_parms(f, 1) + 1);}  // offset
        else
        {SS2out << " NA ";}
        if (Q_setup(f,1) == 3)
        {SS2out << " " << Q_parm(Q_setup_parms(f, 1) + 1) << " ";}  // power
        else
        if (Q_setup(f,1) == 6)
        {SS2out << " " << Q_parm(Q_setup_parms(f, 1) + 2) << " ";}  // power
        else
        {SS2out << " NA ";}
        SS2out << fleetname(f) << endl;
      }
    }
    if (depletion_fleet > 0) //  special code for depletion, so prepare to adjust phases and lambdas
    {
      f = depletion_fleet;
      SS2out << "#_survey: " << f << " " << fleetname(f) << " is a depletion fleet" << endl;
      if (depletion_type == 0)
        SS2out << "#_Q_setup(f,2)=0; add 1 to phases of all parms; only R0 active in new phase 1" << endl;
      if (depletion_type == 1)
        SS2out << "#_Q_setup(f,2)=1  only R0 active in phase 1; then exit;  useful for data-limited draws of other fixed parameter" << endl;
      if (depletion_type == 2)
        SS2out << "#_Q_setup(f,2)=2  no phase adjustments, can be used when profiling on fixed R0" << endl;
    }

    SS2out << "RMSE_Qdev_not_in_logL" << endl
           << "penalty_mean_Qdev_not_in_logL_in_randwalk_approach" << endl;

    // REPORT_KEYWORD 23 INDEX_3  Survey_Q_setup
    SS2out << endl
           << pick_report_name(23) << endl;
    SS2out << "#" << endl
           << "Fleet  Q_parm_assignments" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      SS2out << f << " " << Q_setup_parms(f, 1) << " _ " << Q_setup_parms(f, 2) << " _ " << Q_setup_parms(f)(3, 4) << " " << fleetname(f) << endl;
    }
  }

  // REPORT_KEYWORD 24 DISCARD_SPECIFICATION
  if (pick_report_use(24) == "Y" && nobs_disc > 0)
  {
    SS2out << endl
           << pick_report_name(24) << endl;
    SS2out << "Discard_units_options" << endl;
    SS2out << "1:  discard_in_biomass(mt)_or_numbers(1000s)_to_match_catchunits_of_fleet" << endl;
    SS2out << "2:  discard_as_fraction_of_total_catch(based_on_bio_or_num_depending_on_fleet_catchunits)" << endl;
    SS2out << "3:  discard_as_numbers(1000s)_regardless_of_fleet_catchunits" << endl;
    SS2out << "Discard_errtype_options" << endl;
    SS2out << ">1:  log(L)_based_on_T-distribution_with_specified_DF" << endl;
    SS2out << "0:  log(L)_based_on_normal_with_Std_in_as_CV" << endl;
    SS2out << "-1:  log(L)_based_on_normal_with_Std_in_as_stddev" << endl;
    SS2out << "-2:  log(L)_based_on_lognormal_with_Std_in_as_stddev_in_logspace" << endl;
    SS2out << "-3:  log(L)_based_on_trunc_normal_with_Std_in_as_CV" << endl;

    SS2out << "#_Fleet units errtype" << endl;
    if (Ndisc_fleets > 0)
    {
      for (int ff = 1; ff <= N_catchfleets(0); ff++)
      {
        f = fish_fleet_area(0, ff);
        if (disc_units(f) > 0)
          SS2out << f << " " << disc_units(f) << " " << disc_errtype(f) << " # " << fleetname(f) << endl;
      }
    }
    for (int ff = 1; ff <= N_pred; ff++)
    {
      f = predator(ff);
      SS2out << f << " " << disc_units(f) << " " << disc_errtype(f) << " # " << fleetname(f) << " is_M2_fleet" << endl;
    }

    // REPORT_KEYWORD 25 DISCARD_OUTPUT  Discard observations by year
    SS2out << endl
           << pick_report_name(25) << endl;
    SS2out << "Fleet Fleet_Name Area Yr Seas Subseas Month Time Obs Exp Std_in Std_use Dev Like Like+log(s) SuprPer Use Obs_cat Exp_cat catch_mult exp_cat*catch_mult F_rate" << endl;
    data_type = 2;
    if (nobs_disc > 0)
      for (f = 1; f <= Nfleet; f++)
        if (fleet_type(f) <= 2 || fleet_type(f) == 4)
        {
          for (i = 1; i <= disc_N_fleet(f); i++)
          {
            t = disc_time_t(f, i);
            y = Show_Time(t, 1);
            ALK_time = disc_time_ALK(f, i);
            if (catchunits(f) == 1)
            {
              gg = 3;
            } //  biomass
            else
            {
              gg = 6;
            } //  numbers
            SS2out << f << " " << fleetname(f) << " " << fleet_area(f) << " " << Show_Time2(ALK_time) << " " << data_time(ALK_time, f, 1) << " " << data_time(ALK_time, f, 3)
                   << " " << obs_disc(f, i) << " " << exp_disc(f, i) << " "
                   << " " << cv_disc(f, i) << " " << sd_disc(f, i);

            if (yr_disc_use(f, i) >= 0.0)
            {
              if (disc_errtype(f) >= 1) // T -distribution
              {
                temp = 0.5 * (disc_errtype(f) + 1.) * log((1. + square(obs_disc(f, i) - exp_disc(f, i)) / (disc_errtype(f) * square(sd_disc(f, i)))));
                SS2out << " " << obs_disc(f, i) - exp_disc(f, i) << " " << temp << " " << temp + sd_offset * log(sd_disc(f, i));
              }
              else if (disc_errtype(f) == 0) // normal error, with input CV
              {
                temp = 0.5 * square((obs_disc(f, i) - exp_disc(f, i)) / sd_disc(f, i));
                SS2out << " " << obs_disc(f, i) - exp_disc(f, i) << " " << temp << " " << temp + sd_offset * log(sd_disc(f, i));
              }
              else if (disc_errtype(f) == -1) // normal error with input se
              {
                temp = 0.5 * square((obs_disc(f, i) - exp_disc(f, i)) / sd_disc(f, i));
                SS2out << " " << obs_disc(f, i) - exp_disc(f, i) << " " << temp << " " << temp + sd_offset * log(sd_disc(f, i));
              }
              else if (disc_errtype(f) == -2) // lognormal  where input cv_disc must contain se in log space
              {
                temp = 0.5 * square(log(obs_disc(f, i) / exp_disc(f, i)) / sd_disc(f, i));
                SS2out << " " << log(obs_disc(f, i) / exp_disc(f, i)) << " " << temp << " " << temp + sd_offset * log(sd_disc(f, i));
              }
              else if (disc_errtype(f) == -3) // trunc normal error, with input CV
              {
                temp = 0.5 * square((obs_disc(f, i) - exp_disc(f, i)) / sd_disc(f, i)) - log(cumd_norm((1 - exp_disc(f, i)) / sd_disc(f, i)) - cumd_norm((0 - exp_disc(f, i)) / sd_disc(f, i)));
                SS2out << " " << obs_disc(f, i) - exp_disc(f, i) << " " << temp << " " << temp + sd_offset * log(sd_disc(f, i));
              }
            }
            else
            {
              SS2out << "  _  _  _  ";
            }
            if (yr_disc_super(f, i) < 0 && in_superperiod == 0)
            {
              in_superperiod = 1;
              SS2out << " beg_SuprPer ";
            }
            else if (yr_disc_super(f, i) < 0 && in_superperiod == 1)
            {
              in_superperiod = 0;
              SS2out << " end_SuprPer ";
            }
            else if (in_superperiod == 1)
            {
              SS2out << " in_SuprPer ";
            }
            else
            {
              SS2out << " _ ";
            }
            SS2out << yr_disc_use(f, i);
            SS2out << " " << catch_ret_obs(f, t) << " " << catch_fleet(t, f, gg) << " " << catch_mult(y, f) << " " << catch_mult(y, f) * catch_fleet(t, f, gg) << " " << Hrate(f, t);
            SS2out << endl;
          }
        }
  }

  // REPORT_KEYWORD 26 MEAN_BODY_WT_OUTPUT
  if (pick_report_use(26) == "Y" && nobs_mnwt > 0)
  {
    SS2out << endl
           << pick_report_name(26) << endl;
    SS2out << "log(L)_based_on_T_distribution_with_DF=_" << DF_bodywt << endl;
    SS2out << "Fleet Fleet_Name Area Yr  Seas Subseas Month Time Part Type Obs Exp CV Dev NeglogL Neg(logL+log(s)) Use" << endl;
    //  10 items are:  1yr, 2seas, 3fleet, 4part, 5type, 6obs, 7se, then three intermediate variance quantities
    for (i = 1; i <= nobs_mnwt; i++)
    {
      t = mnwtdata(1, i);
      f = abs(mnwtdata(3, i));
      ALK_time = mnwtdata(11, i);
      SS2out << mnwtdata(3, i) << " " << fleetname(f) << " " << fleet_area(f) << " " << Show_Time2(ALK_time) << " " << data_time(ALK_time, f, 1) << " " << data_time(ALK_time, f, 3) << " "
             << mnwtdata(4, i) << " " << mnwtdata(5, i) << " " << mnwtdata(6, i) << " " << exp_mnwt(i) << " " << mnwtdata(7, i);
      if (mnwtdata(3, i) > 0.)
      {
        SS2out << " " << mnwtdata(6, i) - exp_mnwt(i) << " " << 0.5 * (DF_bodywt + 1.) * log(1. + square(mnwtdata(6, i) - exp_mnwt(i)) / mnwtdata(9, i)) << " " << 0.5 * (DF_bodywt + 1.) * log(1. + square(mnwtdata(6, i) - exp_mnwt(i)) / mnwtdata(9, i)) + mnwtdata(10, i) << " " << 1;
      }
      else
      {
        SS2out << " NA NA NA -1";
      }
      SS2out << endl;
    }
  }

  dvar_vector more_comp_info(1, 20);
  dvariable cumdist;
  dvariable cumdist_save;
  double Nsamp_DM; // equals Nsamp_adj when not using Dirichlet-Multinomial or Tweedie likelihood
  double Nsamp_adj; // input sample size after input variance adjustment
  double Nsamp_in; // input sample size
  dvector minsamp(1, Nfleet);
  dvector maxsamp(1, Nfleet);

  // REPORT_KEYWORD 27 FIT_LEN_COMPS
  if (pick_report_use(27) == "Y" && Nobs_l_tot > 0)
  {
    SS2out << endl
           << pick_report_name(27) << endl;
    SS2out << "Fleet Fleet_Name Area Yr Seas Subseas Month Time Sexes Part SuprPer Use Nsamp_in Nsamp_adj Nsamp_DM effN Like Method DM_parm MV_T_parm ";
    SS2out << " All_obs_mean All_exp_mean All_delta All_exp_5% All_exp_95% All_DurWat";
    if (gender == 2)
      SS2out << " F_obs_mean F_exp_mean F_delta F_exp_5% F_exp_95% F_DurWat M_obs_mean M_exp_mean M_delta M_exp_5% M_exp_95% M_DurWat %F_obs %F_exp ";
    SS2out << endl;
    rmse = 0.0;
    n_rmse = 0.0;
    mean_Nsamp_in = 0.0;
    mean_Nsamp_adj = 0.0;
    mean_Nsamp_DM = 0.0;
    Hrmse = 0.0;
    Rrmse = 0.0;
    neff_l.initialize();
    in_superperiod = 0;
    data_type = 4;
    minsamp = 10000.;
    maxsamp = 0.;
    //mean_all_obs; 1
    //mean_all_exp; 2
    //mean_all_delta; 3
    //5%_all_exp; 4
    //95%_all_exp; 5
    //Durbin-Watson_all; 6
    //mean_F_obs; 7
    //mean_F_exp; 8
    //mean_F_delta; 9
    //5%_F_exp; 10
    //95%_F_exp; 11
    //Durbin-Watson_F; 12
    //mean_M_obs; 13
    //mean_M_exp; 14
    //mean_M_delta; 15
    //5%_M_exp; 16
    //95%_M_exp; 17
    //Durbin-Watson_M;  18
    //sexratio_obs; 19
    //sexratio_exp; 20

    for (f = 1; f <= Nfleet; f++)
      for (i = 1; i <= Nobs_l(f); i++)
      {
        t = Len_time_t(f, i);
        ALK_time = Len_time_ALK(f, i);
        more_comp_info.initialize();
        neff_l(f, i) = exp_l(f, i) * (1 - exp_l(f, i)) + 1.0e-06; // constant added for stability
        neff_l(f, i) /= (obs_l(f, i) - exp_l(f, i)) * (obs_l(f, i) - exp_l(f, i)) + 1.0e-06;
        // store sample sizes
        Nsamp_in = nsamp_l_read(f, i);
        Nsamp_adj = nsamp_l(f, i);
        dvector tempvec_l(1, exp_l(f, i).size());
        tempvec_l = value(exp_l(f, i));
        more_comp_info = process_comps(gender, gen_l(f, i), len_bins_dat2, len_bins_dat_m2, tails_l(f, i), obs_l(f, i), tempvec_l);
        Nsamp_DM = Nsamp_adj; // Will remain this if not used
        int parti = mkt_l(f, i);
        dirichlet_Parm = 0.0;  //  default gets reported if using multinomial
        double Tweedie_Parm = 0.0; //  default gets reported if not using MV Tweedie
        if (Comp_Err_L(parti, f) == 1) //  Dirichlet #1
        {
          dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_L2(parti, f),1))); //  Thorson's theta from eq 10
          // effN_DM = 1/(1+theta) + n*theta/(1+theta)
          Nsamp_DM = value(1. / (1. + dirichlet_Parm) + nsamp_l(f, i) * dirichlet_Parm / (1. + dirichlet_Parm));
        }
        else if (Comp_Err_L(parti, f) == 2) //  Dirichlet #2
        {
          dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_L2(parti, f),1))); //  Thorson's beta from eq 12
          // effN_DM = (n+n*beta)/(n+beta)
          Nsamp_DM = value((nsamp_l(f, i) + dirichlet_Parm * nsamp_l(f, i)) / (dirichlet_Parm + nsamp_l(f, i)));
        }
        else if (Comp_Err_L(parti, f) == 3) //  MV  Tweedie
        {
          // TBD
        }

        if (header_l(f, i, 3) > 0)
        {
          n_rmse(f) += 1.;
          rmse(f) += value(neff_l(f, i));
          mean_Nsamp_in(f) += Nsamp_in;
          mean_Nsamp_adj(f) += Nsamp_adj;
          mean_Nsamp_DM(f) += Nsamp_DM;
          Hrmse(f) += value(1. / neff_l(f, i));
          Rrmse(f) += value(neff_l(f, i) / Nsamp_adj);
          if (Nsamp_adj < minsamp(f))
            minsamp(f) = Nsamp_adj;
          if (Nsamp_adj > maxsamp(f))
            maxsamp(f) = Nsamp_adj;
        }

        //  SS2out<<"Fleet Fleet_Name Area Yr Month Seas Subseas Time Sexes Part SuprPer Use Nsamp_adj Nsamp_in Nsamp_DM effN Like";
        //      temp=abs(header_l_rd(f,i,2));
        //      if(temp>999) temp-=1000;
        SS2out << f << " " << fleetname(f) << " " << fleet_area(f) << " " << Show_Time2(ALK_time) << " " << data_time(ALK_time, f, 1) << " " << data_time(ALK_time, f, 3) << " " << gen_l(f, i) << " " << mkt_l(f, i);
        if (header_l(f, i, 2) < 0 && in_superperiod == 0)
        {
          SS2out << " start ";
          in_superperiod = 1;
        }
        else if (header_l(f, i, 2) < 0 && in_superperiod == 1)
        {
          SS2out << " end ";
          in_superperiod = 0;
        }
        else if (in_superperiod == 1)
        {
          SS2out << " in ";
        }
        else
        {
          SS2out << " _ ";
        }
        if (header_l(f, i, 3) < 0)
        {
          SS2out << " skip ";
        }
        else
        {
          SS2out << " _ ";
        }
        SS2out << Nsamp_in << " " << Nsamp_adj << " " << Nsamp_DM << " " << neff_l(f, i) << " " << length_like(f, i) << " ";
        SS2out << Comp_Err_L(parti, f) << " " << dirichlet_Parm << " " << Tweedie_Parm << " ";
        SS2out << more_comp_info(1, 6);
        if (gender == 2)
          SS2out << " " << more_comp_info(7, 20);
        SS2out << endl;
      } // end loops over observation i and fleet f

    //Fleet N Npos mean_effN mean(inputN*Adj) HarMean(effN) Mean(effN/inputN) MeaneffN/MeaninputN Var_Adj
    //long ago, Ian Stewart had the proto-r4ss add a column called "HarEffN/MeanInputN" which was the ratio of the columns "HarMean(effN)" column and the "mean(inputN*Adj)" and has been used as the multiplier on the adjustment factor in the status-quo NWFSC tuning approach.
    //My suggestion would be to remove the columns "Mean(effN/inputN)" and "MeaneffN/MeaninputN" if those are not recommended values for tuning (I don't get the impression that they are) and have SS3 internally produce the "HarEffN/MeanInputN" column so that it's available to all users.
    //It might also be good to add a keyword to the top of those lower tables which could simplify the logic of parsing them separately from the FIT_..._COMPS tables above them and therefore be more robust to changes in format.

    SS2out << "#" << endl
           << "Length_Comp_Fit_Summary" << endl
           << "Data_type Fleet Recommend_var_adj # N Npos min_Nsamp max_Nsamp mean_Nsamp_in mean_Nsamp_adj mean_Nsamp_DM err_method err_index par1 val1 par2 val2 mean_effN HarMean_effN Curr_Var_Adj Fleet_name" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (n_rmse(f) > 0)
      {
        // calculate summary statistics
        rmse(f) /= n_rmse(f);
        Hrmse(f) = n_rmse(f) / Hrmse(f);
        Rrmse(f) /= n_rmse(f);
        mean_Nsamp_in(f) /= n_rmse(f);
        mean_Nsamp_adj(f) /= n_rmse(f);
        mean_Nsamp_DM(f) /= n_rmse(f);
        // write values to file
        SS2out << "4 " << f << " ";
        if (Comp_Err_L(0, f) == 0)
        { // standard multinomial
          SS2out << Hrmse(f) / mean_Nsamp_adj(f) * var_adjust(4, f);
        }
        else
        { // Dirichlet-multinomial (Recommend_var_adj = 1)
          SS2out << "1";
        }
        SS2out << " # " << Nobs_l(f) << " " << n_rmse(f) << " " << minsamp(f) << " " << maxsamp(f) << " " << mean_Nsamp_in(f) << " " << mean_Nsamp_adj(f);

        switch (Comp_Err_L(0, f))
        {
          case 0:
          { // standard multinomial
            // placeholders for mean_Nsamp_DM and DM_theta (not used)
            SS2out << " NA 0 NA multinomial NA NA NA ";
            break;
          }
          case 1:   // Dirichlet-multinomial
          {
          }
          case 2:   // Dirichlet-multinomial
          {
            // mean_Nsamp_DM and DM_theta
            SS2out << " " << mean_Nsamp_DM(f) << " " << Comp_Err_L(0, f) << " " << Comp_Err_L2(0, f) << " " << ParmLabel(Comp_Err_parmloc(Comp_Err_L2(0, f),2)) << " " << mfexp(selparm(Comp_Err_parmloc(Comp_Err_L2(0, f),1))) << " NA "<< " NA ";
            break;
          }
          case 3:  //  MV Tweedie
          {
            SS2out << " NA 3 NA NA NA NA NA ";
            break;
          }
        }
        SS2out << rmse(f) << " " << Hrmse(f) << " " << var_adjust(4, f) << " " << fleetname(f) << endl;
      }
    }
  }

  // REPORT_KEYWORD 28 FIT_AGE_COMPS
  if (pick_report_use(28) == "Y" && Nobs_a_tot > 0)
  {
    SS2out << endl
           << pick_report_name(28) << endl;
    SS2out << "Fleet Fleet_Name Area Yr Seas Subseas Month Time Sexes Part Ageerr Lbin_lo Lbin_hi SuprPer Use Nsamp_in Nsamp_adj Nsamp_DM effN Like ";
    SS2out << " All_obs_mean All_exp_mean All_delta All_exp_5% All_exp_95% All_DurWat";
    if (gender == 2)
      SS2out << " F_obs_mean F_exp_mean F_delta F_exp_5% F_exp_95% F_DurWat M_obs_mean M_exp_mean M_delta M_exp_5% M_exp_95% M_DurWat %F_obs %F_exp ";
    SS2out << endl;
    rmse = 0.0;
    n_rmse = 0.0;
    mean_Nsamp_in = 0.0;
    mean_Nsamp_adj = 0.0;
    mean_Nsamp_DM = 0.0;
    Hrmse = 0.0;
    Rrmse = 0.0;
    minsamp = 10000.;
    maxsamp = 0.;
    for (f = 1; f <= Nfleet; f++)
      for (i = 1; i <= Nobs_a(f); i++)
      {
        t = Age_time_t(f, i);
        ALK_time = Age_time_ALK(f, i);
        more_comp_info.initialize();
        neff_a(f, i) = exp_a(f, i) * (1 - exp_a(f, i)) + 1.0e-06; // constant added for stability
        neff_a(f, i) /= (obs_a(f, i) - exp_a(f, i)) * (obs_a(f, i) - exp_a(f, i)) + 1.0e-06;
        // store sample sizes
        Nsamp_in = nsamp_a_read(f, i);
        Nsamp_adj = nsamp_a(f, i);
        dvector tempvec_a(1, exp_a(f, i).size());
        tempvec_a = value(exp_a(f, i));
        more_comp_info = process_comps(gender, gen_a(f, i), age_bins, age_bins_mean, tails_a(f, i), obs_a(f, i), tempvec_a);

        Nsamp_DM = Nsamp_adj; // Will stay at this val for multinomial
        if (Comp_Err_A(f) == 1) //  Dirichlet #1
        {
          dirichlet_Parm =mfexp(selparm(Comp_Err_parmloc(Comp_Err_A2(f),1))); //  Thorson's theta from eq 10
          // effN_DM = 1/(1+theta) + n*theta/(1+theta)
          Nsamp_DM = value(1. / (1. + dirichlet_Parm) + nsamp_a(f, i) * dirichlet_Parm / (1. + dirichlet_Parm));
        }
        else if (Comp_Err_A(f) == 2) //  Dirichlet #2
        {
          dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_A2(f),1))); //  Thorson's beta from eq 12
          // effN_DM = (n+n*beta)/(n+beta)
          Nsamp_DM = value((nsamp_a(f, i) + dirichlet_Parm * nsamp_a(f, i)) / (dirichlet_Parm + nsamp_a(f, i)));
        }

        if (header_a(f, i, 3) > 0)
        {
          n_rmse(f) += 1.;
          rmse(f) += value(neff_a(f, i));
          mean_Nsamp_in(f) += Nsamp_in;
          mean_Nsamp_adj(f) += Nsamp_adj;
          mean_Nsamp_DM(f) += Nsamp_DM;
          Hrmse(f) += value(1. / neff_a(f, i));
          Rrmse(f) += value(neff_a(f, i) / Nsamp_adj);
          if (Nsamp_adj < minsamp(f))
            minsamp(f) = Nsamp_adj;
          if (Nsamp_adj > maxsamp(f))
            maxsamp(f) = Nsamp_adj;
        }

        //  SS2out<<"Fleet Fleet_Name Area Yr  Seas Subseas Month Time Sexes Part Ageerr Lbin_lo Lbin_hi Nsamp_in Nsamp_adj Nsamp_DM effN Like SuprPer Use";
        temp = abs(header_a_rd(f, i, 2));
        if (temp > 999)
          temp -= 1000;
        SS2out << f << " " << fleetname(f) << " " << fleet_area(f) << Show_Time2(ALK_time) << " " << data_time(ALK_time, f, 1) << " " << data_time(ALK_time, f, 3) << " " << gen_a(f, i) << " " << mkt_a(f, i) << " " << ageerr_type_a(f, i) << " " << len_bins(Lbin_lo(f, i)) << " " << len_bins(Lbin_hi(f, i)) << " ";
        if (header_a(f, i, 2) < 0 && in_superperiod == 0)
        {
          SS2out << " start ";
          in_superperiod = 1;
        }
        else if (header_a(f, i, 2) < 0 && in_superperiod == 1)
        {
          SS2out << " end ";
          in_superperiod = 0;
        }
        else if (in_superperiod == 1)
        {
          SS2out << " in ";
        }
        else
        {
          SS2out << " _ ";
        }
        if (header_a(f, i, 3) < 0 || nsamp_a(f, i) < 0)
        {
          SS2out << " skip ";
        }
        else
        {
          SS2out << " _ ";
        }
        SS2out << Nsamp_in << " " << Nsamp_adj << " " << Nsamp_DM << " "
               << " " << neff_a(f, i) << " " << age_like(f, i) << " " << more_comp_info(1, 6);
        if (gender == 2)
          SS2out << " " << more_comp_info(7, 20);
        SS2out << endl;
      }

    SS2out << "#" << endl
           << "Age_Comp_Fit_Summary" << endl
           << "Data_type Fleet Recommend_var_adj # N Npos min_Nsamp max_Nsamp mean_Nsamp_in mean_Nsamp_adj mean_Nsamp_DM err_method err_index par1 val1 par2 val2 mean_effN HarMean_effN Curr_Var_Adj Fleet_name" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (n_rmse(f) > 0)
      {
        // calculate summary statistics
        rmse(f) /= n_rmse(f);
        Hrmse(f) = n_rmse(f) / Hrmse(f);
        Rrmse(f) /= n_rmse(f);
        mean_Nsamp_in(f) /= n_rmse(f);
        mean_Nsamp_adj(f) /= n_rmse(f);
        mean_Nsamp_DM(f) /= n_rmse(f);
        // write values to file
        SS2out << "5 " << f << " ";
        if (Comp_Err_A(f) == 0)
        { // standard multinomial
          SS2out << Hrmse(f) / mean_Nsamp_adj(f) * var_adjust(5, f);
        }
        else
        { // Dirichlet-multinomial (Recommend_var_adj = 1)
          SS2out << "1";
        }
        SS2out << " # " << Nobs_a(f) << " " << n_rmse(f) << " " << minsamp(f) << " " << maxsamp(f) << " " << mean_Nsamp_in(f) << " " << mean_Nsamp_adj(f);
        switch (Comp_Err_A(f))
        {
          case 0:
          { // standard multinomial
            // placeholders for mean_Nsamp_DM and DM_theta (not used)
            SS2out << " NA 0 NA multinomial NA NA NA ";
            break;
          }
          case 1:   // Dirichlet-multinomial
          {
          }
          case 2:   // Dirichlet-multinomial
          {
            // mean_Nsamp_DM and DM_theta
            SS2out << "  " << mean_Nsamp_DM(f) << " " << Comp_Err_A(f) << " " << Comp_Err_A2(f) << " " << ParmLabel(Comp_Err_parmloc(Comp_Err_A2(f),2)) << " " << mfexp(selparm(Comp_Err_parmloc(Comp_Err_A2(f),1))) << " NA "<< " NA ";
            break;
          }
          case 3:  //  MV Tweedie
          {
            SS2out << " NA 3 NA NA NA NA NA ";
            break;
          }
        }
        SS2out << rmse(f) << " " << Hrmse(f) << " " << var_adjust(5, f) << " " << fleetname(f) << endl;
      }
    }
  }

  // REPORT_KEYWORD 29 FIT_SIZE_COMPS
  if (pick_report_use(29) == "Y" && SzFreq_Nmeth > 0)
  {
    SS2out << endl
           << pick_report_name(29) << endl;

    SzFreq_effN.initialize();
    for (int sz_method = 1; sz_method <= SzFreq_Nmeth; sz_method++)
    {
      SS2out << "#Method: " << sz_method;
      SS2out << "  #Units: " << SzFreq_units_label(SzFreq_units(sz_method));
      SS2out << "  #Scale: " << SzFreq_scale_label(SzFreq_scale(sz_method));
      SS2out << "  #Add_to_comp: " << SzFreq_mincomp(sz_method) << "  #N_bins: " << SzFreq_Nbins(sz_method) << endl;
      SS2out << "Fleet Fleet_Name Area Yr Seas Subseas Month Time Sexes Part SuprPer Use Nsamp_in Nsamp_adj Nsamp_DM effN Like";
      SS2out << " All_obs_mean All_exp_mean All_delta All_exp_5% All_exp_95% All_DurWat";
      if (gender == 2)
        SS2out << " F_obs_mean F_exp_mean F_delta F_exp_5% F_exp_95% F_DurWat M_obs_mean M_exp_mean M_delta M_exp_5% M_exp_95% M_DurWat %F_obs %F_exp ";
      SS2out << endl;
      rmse = 0.0;
      n_rmse = 0.0;
      mean_Nsamp_in = 0.0;
      mean_Nsamp_adj = 0.0;
      mean_Nsamp_DM = 0.0;
      Hrmse = 0.0;
      Rrmse = 0.0;

      dvector sz_tails(1, 4);
      sz_tails(1) = 1;
      sz_tails(2) = SzFreq_Nbins(sz_method);
      sz_tails(3) = SzFreq_Nbins(sz_method) + 1;
      sz_tails(4) = 2 * SzFreq_Nbins(sz_method);
      for (f = 1; f <= Nfleet; f++)
      {
        in_superperiod = 0;
        for (iobs = 1; iobs <= SzFreq_totobs; iobs++)
        {
          more_comp_info.initialize();
          k = SzFreq_obs_hdr(iobs, 6);
          if (k == sz_method && abs(SzFreq_obs_hdr(iobs, 3)) == f)
          {
            if (SzFreq_obs_hdr(iobs, 1) >= styr) // year is positive, so use this obs
            {
              y = SzFreq_obs_hdr(iobs, 1);
              t = SzFreq_time_t(iobs);
              ALK_time = SzFreq_time_ALK(iobs);
              gg = SzFreq_obs_hdr(iobs, 4); // gender
              if (gender == 2 && (gg == 3 || gg == 2))
              {
                sz_tails(3) = SzFreq_Nbins(sz_method) + 1;
                sz_tails(4) = 2 * SzFreq_Nbins(sz_method);
              }
              else
              {
                sz_tails(3) = 1;
                sz_tails(4) = SzFreq_Nbins(sz_method);
              }
              p = SzFreq_obs_hdr(iobs, 5); // partition
              z1 = SzFreq_obs_hdr(iobs, 7);
              z2 = SzFreq_obs_hdr(iobs, 8);
              temp = 0.0;
              temp1 = 0.0;
              for (z = z1; z <= z2; z++)
              {
                SzFreq_effN(iobs) += value(SzFreq_exp(iobs, z) * (1.0 - SzFreq_exp(iobs, z)));
                temp += square(SzFreq_obs(iobs, z) - SzFreq_exp(iobs, z));
                temp1 += SzFreq_obs(iobs, z) * log(SzFreq_obs(iobs, z)) - SzFreq_obs(iobs, z) * log(SzFreq_exp(iobs, z));
              }
              SzFreq_effN(iobs) = (SzFreq_effN(iobs) + 1.0e-06) / value((temp + 1.0e-06));
              temp1 *= SzFreq_sampleN(iobs);
              dvector tempvec_l(1, SzFreq_exp(iobs).size());
              tempvec_l = value(SzFreq_exp(iobs));
              more_comp_info = process_comps(gender, gg, SzFreq_bins(sz_method), SzFreq_means(sz_method), sz_tails, SzFreq_obs(iobs), tempvec_l);
              Nsamp_DM = SzFreq_sampleN(iobs); // Will remain this if not used; there is no "adjusted" sample size for sizwfreq
              if (Comp_Err_Sz(sz_method) == 1) //  Dirichlet #1
              {
                dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(sz_method),1))); //  Thorson's theta from eq 10
                // effN_DM = 1/(1+theta) + n*theta/(1+theta)
                Nsamp_DM = value(1. / (1. + dirichlet_Parm) + SzFreq_sampleN(iobs) * dirichlet_Parm / (1. + dirichlet_Parm));
              }
              else if (Comp_Err_Sz(sz_method) == 2) //  Dirichlet #2
              {
                dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(sz_method),1))); //  Thorson's beta from eq 12
                // effN_DM = (n+n*beta)/(n+beta)
                Nsamp_DM = value((SzFreq_sampleN(iobs) + dirichlet_Parm * SzFreq_sampleN(iobs)) / (dirichlet_Parm + SzFreq_sampleN(iobs)));
              }
              if (SzFreq_obs_hdr(iobs, 3) > 0)  //  dheck for -fleet that is an ignored obs
              {
                n_rmse(f) += 1.;
                rmse(f) += SzFreq_effN(iobs);
                mean_Nsamp_in(f) += SzFreq_sampleN(iobs);
                mean_Nsamp_adj(f) += SzFreq_sampleN(iobs);
                if (SzFreq_sampleN(iobs) < minsamp(f))
                  minsamp(f) = SzFreq_sampleN(iobs);
                if (SzFreq_sampleN(iobs) > maxsamp(f))
                  maxsamp(f) = SzFreq_sampleN(iobs);
                Hrmse(f) += 1. / SzFreq_effN(iobs);
                Rrmse(f) += SzFreq_effN(iobs) / SzFreq_sampleN(iobs);
                mean_Nsamp_DM(f) += Nsamp_DM;
              }
              else
              {
                SzFreq_effN(iobs) = 0.;
              }
              temp = SzFreq_obs1(iobs, 3); //  use original input value because
              if (temp > 999)
                temp -= 1000.;
              SS2out << f << " " << fleetname(f) << " " << fleet_area(f) << " " << Show_Time2(ALK_time) << " " << data_time(ALK_time, f, 1) << " " << data_time(ALK_time, f, 3) << " " << gg << " " << p;
              if (SzFreq_obs_hdr(iobs, 2) < 0 && in_superperiod == 0)
              {
                SS2out << " start ";
                in_superperiod = 1;
              }
              else if (SzFreq_obs_hdr(iobs, 2) < 0 && in_superperiod == 1)
              {
                SS2out << " end ";
                in_superperiod = 0;
              }
              else if (in_superperiod == 1)
              {
                SS2out << " in ";
              }
              else
              {
                SS2out << " _ ";
              }
              if (SzFreq_obs_hdr(iobs, 3) < 0)
              {
                SS2out << " skip ";
              }
              else
              {
                SS2out << " _ ";
              }
              SS2out << " " << SzFreq_sampleN(iobs) << "  " << SzFreq_sampleN(iobs) << "  " << Nsamp_DM << " " << SzFreq_effN(iobs) << "  " << SzFreq_eachlike(iobs) << " " << more_comp_info(1, 6);
              if (gender == 2)
                SS2out << " " << more_comp_info(7, 20);
              SS2out << endl;
            } //  end finding observation that is being used
          } //  end observation matching selected method
        } //  end loop of observations
      } //  end fleet loop
      //      SS2out<<"Fleet N Npos mean_effN mean(inputN*Adj) HarMean(effN) Mean(effN/inputN) MeaneffN/MeaninputN Var_Adj"<<endl;
    SS2out << "#" << endl
           << "Size_Comp_Fit_Summary" << endl
           << "Data_type Fleet Recommend_var_adj # N Npos min_Nsamp max_Nsamp mean_Nsamp_in mean_Nsamp_adj mean_Nsamp_DM err_method err_index par1 val1 par2 val2 mean_effN HarMean_effN Curr_Var_Adj Fleet_name" << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      if (n_rmse(f) > 0)
      {
        // calculate summary statistics
        rmse(f) /= n_rmse(f);
        Hrmse(f) = n_rmse(f) / Hrmse(f);
        Rrmse(f) /= n_rmse(f);
        mean_Nsamp_in(f) /= n_rmse(f);
        mean_Nsamp_adj(f) /= n_rmse(f);
        mean_Nsamp_DM(f) /= n_rmse(f);
        // write values to file
        SS2out << "6 " << f << " ";
        if (Comp_Err_Sz(sz_method) == 0)
        { // standard multinomial
          SS2out << Hrmse(f) / mean_Nsamp_adj(f) * var_adjust(6, f);
        }
        else
        { // Dirichlet-multinomial (Recommend_var_adj = 1)
          SS2out << "1";
        }
        SS2out << " # " << n_rmse(f) << " " << n_rmse(f) << " " << minsamp(f) << " " << maxsamp(f) << " " << mean_Nsamp_in(f) << " " << mean_Nsamp_adj(f);

        switch (Comp_Err_Sz(sz_method))
        {
          case 0:
          { // standard multinomial
            // placeholders for mean_Nsamp_DM and DM_theta (not used)
            SS2out << " NA 0 NA multinomial NA NA NA ";
            break;
          }
          case 1:   // Dirichlet-multinomial
          {
          }
          case 2:   // Dirichlet-multinomial
          {
            // mean_Nsamp_DM and DM_theta
            SS2out << " " << mean_Nsamp_DM(f) << " " << Comp_Err_Sz(sz_method) << " " << Comp_Err_Sz2(sz_method) << " " << ParmLabel(Comp_Err_parmloc(Comp_Err_Sz2(sz_method),2)) << " " << mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(sz_method),1))) << " NA "<< " NA ";
            break;
          }
          case 3:  //  MV Tweedie
          {
            SS2out << " NA 3 NA NA NA NA NA ";
            break;
          }
        }
        SS2out << rmse(f) << " " << Hrmse(f) << " " << var_adjust(4, f) << " " << fleetname(f) << endl;
      }
    }
    } //  end loop of methods
  } // end have sizecomp

  // REPORT_KEYWORD 30 OVERALL_COMPS  average composition for all observations
  if (pick_report_use(30) == "Y")
  {
    SS2out << endl
           << pick_report_name(30) << endl;
    SS2out << "area seas Fleet N_obs len_bins " << len_bins_dat << endl;

    for (f = 1; f <= Nfleet; f++)
    {
      for (k = 1; k <= 4; k++)
      {
        dvector templen(1, nlen_bin);
        templen.initialize();
        for (s = 1; s <= nseas; s++)
        {
          templen += obs_l_all(k, s, f);
        }
        obs_l_all(k, 0, f) = templen / (float(nseas));
      }
    }
    int kseas = 1;
    if (nseas > 1)
      kseas = 0;
    for (f = 1; f <= Nfleet; f++)
      for (s = kseas; s <= nseas; s++)
      {
        if (Nobs_l(f) > 0)
        {
          SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_l(f) << " freq " << obs_l_all(1, s, f) << endl;
          SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_l(f) << " cum  " << obs_l_all(2, s, f) << endl;
          if (gender == 2)
          {
            SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_l(f) << " female  " << obs_l_all(2, s, f) << endl;
            SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_l(f) << " male  " << obs_l_all(2, s, f) << endl;
          }
        }
      }

    SS2out << "area seas Fleet N_obs age_bins ";
    if (n_abins > 1)
    {
      SS2out << age_bins(1, n_abins) << endl;
      for (f = 1; f <= Nfleet; f++)
        for (s = kseas; s <= nseas; s++)
        {
          if (Nobs_a(f) > 0)
          {
            SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_a(f) << " freq " << obs_a_all(1, s, f) << endl;
            SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_a(f) << " cum  " << obs_a_all(2, s, f) << endl;
            if (gender == 2)
            {
              SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_a(f) << " female  " << obs_a_all(2, s, f) << endl;
              SS2out << fleet_area(f) << " " << s << " " << f << " " << Nobs_a(f) << " male  " << obs_a_all(2, s, f) << endl;
            }
          }
        }
    }
    else
    {
      SS2out << "No_age_bins_defined" << endl;
    }
  }

  // REPORT_KEYWORD 31 LEN_SELEX
  if (pick_report_use(31) == "Y")
  {
    SS2out << endl
           << pick_report_name(31) << endl;
    SS2out << "Lsel_is_length_selectivity" << endl; // SS_Label_370
    SS2out << "RET_is_retention" << endl; // SS_Label_390
    SS2out << "MORT_is_discard_mortality" << endl; // SS_Label_390
    SS2out << "KEEP_is_sel*retain" << endl; // SS_Label_370
    SS2out << "DEAD_is_sel*(retain+(1-retain)*discmort)"; // SS_Label_370
    SS2out << "; Year_styr-3_(" << styr - 3 << ")_stores_average_used_for_benchmark" << endl;
    SS2out << "Factor Fleet Yr Sex Label " << len_bins_m << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      k = styr - 3;
      j = YrMax;
      for (y = k; y <= j; y++)
        for (gg = 1; gg <= gender; gg++)
          if (y == styr - 3 || y == endyr || y == YrMax || (y >= styr && (timevary_sel(y, f) > 0 || timevary_sel(y + 1, f) > 0)))
          {
            SS2out << "Lsel " << f << " " << y << " " << gg << " " << y << "_" << f << "_Lsel";
            for (z = 1; z <= nlength; z++)
            {
              SS2out << " " << sel_l(y, f, gg, z);
            }
            SS2out << endl;
          }
    }

    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
        for (y = styr - 3; y <= YrMax; y++)
          for (gg = 1; gg <= gender; gg++)
            if (y == styr - 3 || y == endyr || y == YrMax || (y >= styr && (timevary_sel(y, f) > 0 || timevary_sel(y + 1, f) > 0)))
            {
              //    if(y>=styr && y<=endyr)
              //    {
              SS2out << "Ret " << f << " " << y << " " << gg << " " << y << "_" << f << "_Ret";
              if (gg == 1)
              {
                for (z = 1; z <= nlength; z++)
                {
                  SS2out << " " << retain(y, f, z);
                }
              }
              else
              {
                for (z = nlength1; z <= nlength2; z++)
                {
                  SS2out << " " << retain(y, f, z);
                }
              }
              SS2out << endl;
              SS2out << "Mort " << f << " " << y << " " << gg << " " << y << "_" << f << "_Mort";
              if (gg == 1)
              {
                for (z = 1; z <= nlength; z++)
                {
                  SS2out << " " << discmort(y, f, z);
                }
              }
              else
              {
                for (z = nlength1; z <= nlength2; z++)
                {
                  SS2out << " " << discmort(y, f, z);
                }
              }
              SS2out << endl;
              //    }
              SS2out << "Keep " << f << " " << y << " " << gg << " " << y << "_" << f << "_Keep";
              for (z = 1; z <= nlength; z++)
              {
                SS2out << " " << sel_l_r(y, f, gg, z);
              }
              SS2out << endl;
              SS2out << "Dead " << f << " " << y << " " << gg << " " << y << "_" << f << "_Dead";
              for (z = 1; z <= nlength; z++)
              {
                SS2out << " " << discmort2(y, f, gg, z);
              }
              SS2out << endl;
            }
  }

  // REPORT_KEYWORD 32 AGE_SELEX
  if (pick_report_use(32) == "Y")
  {
    dmatrix selmax(1,Nfleet,1,3);  //  max selectivity for each fleet and year, season
    SS2out << endl
           << pick_report_name(32) << endl;
    SS2out << "Asel_is_age_selectivity_alone" << endl;
    SS2out << "Asel2_is_Asel*(selL*size_at_age(ALK)); Q and F parameters may appear higher than expected because Asel2 may have max < 1.0; " << endl;
    SS2out << "Aret_is_age_retention" << endl;
    SS2out << "COMBINED_ALK*selL*selA*wtlen*ret*discmort_in_makefishsel_yr: " << makefishsel_yr << " With_MeanSel_From: " << Fcast_Sel_yr1 << " - " << Fcast_Sel_yr2; // SS_Label_380
    SS2out << "; Year_styr-3_(" << styr - 3 << ")_stores_average_used_for_benchmark" << endl;

    SS2out << "Factor Fleet Yr Seas Sex Morph Label ";
    for (a = 0; a <= nages; a++)
    {
      SS2out << " " << a;
    }
    SS2out << endl;
    for (f = 1; f <= Nfleet; f++)
    {
      k = styr - 3;
      j = YrMax;
      for (y = k; y <= j; y++)
        for (gg = 1; gg <= gender; gg++)
          if (y == styr - 3 || y == endyr || y == YrMax || (y >= styr && (timevary_sel(y, f + Nfleet) > 0 || timevary_sel(y + 1, f + Nfleet) > 0)))
          {
            SS2out << "Asel " << f << " " << y << " 1 " << gg << " 1 " << y << "_" << f << "Asel " << sel_a(y, f, gg) << endl;
          }
    }
    for (f = 1; f <= Nfleet; f++)
    {
      if (seltype(f + Nfleet, 2) != 0) // using age retention
      {
        for (y = styr - 3; y <= YrMax; y++)
          for (gg = 1; gg <= gender; gg++)
            if (y == styr - 3 || y == endyr || y == YrMax || (y >= styr && (timevary_sel(y, f + Nfleet) > 0 || timevary_sel(y + 1, f + Nfleet) > 0)))
            {
              SS2out << "Aret " << f << " " << y << " 1 " << gg << " 1 " << y << "_" << f << "Aret " << retain_a(y, f, gg) << endl;
              SS2out << "Amort " << f << " " << y << " 1 " << gg << " 1 " << y << "_" << f << "Amort " << discmort_a(y, f, gg) << endl;
            }
      }
    }

    if (Do_Forecast > 0)
    {
      k = YrMax;
    }
    else
    {
      k = endyr;
    }

    selmax = 100.0;  //  set to big number

    for (y = styr - 3; y <= k; y++)
      for (s = 1; s <= nseas; s++)
      {
        t = styr + (y - styr) * nseas + s - 1;
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0 && (y == styr - 3 || y >= styr))
          {
            if (s == spawn_seas && (sx(g) == 1 || Hermaphro_Option != 0))
              SS2out << "Fecund "
                     << " NA "
                     << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_"
                     << "Fecund" << Wt_Age_t(t, -2, g) << endl;
            for (f = 1; f <= Nfleet; f++)
            {
              SS2out << "Asel2 " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_Asel2" << save_sel_num(t, f, g) << endl;
              temp = max(save_sel_num(t, f, g));
              if (temp < selmax(f, 3) && y >= styr) 
                {selmax(f, 3) = value(temp); 
                 selmax(f, 1) = float(y);
                 selmax(f, 2) = float(s);}  //  save y.s

              if (fleet_type(f) <= 2)
                SS2out << "F " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_F" << Hrate(f, t) * save_sel_num(t, f, g) << endl;
              SS2out << "bodywt " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_bodywt" << Wt_Age_t(t, f, g) << endl;
            }
          }
      }
    y = makefishsel_yr;
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
            for (s = 1; s <= nseas; s++)
            {
              SS2out << "sel*wt " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_sel*wt" << sel_bio(s, f, g) << endl;
              SS2out << "sel*ret*wt " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_sel*ret*wt" << sel_ret_bio(s, f, g) << endl;
              SS2out << "sel_nums " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_sel_nums" << sel_num(s, f, g) << endl;
              SS2out << "sel*ret_nums " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_sel*ret_nums" << sel_ret_num(s, f, g) << endl;
              SS2out << "dead_nums " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_dead_nums" << sel_dead_num(s, f, g) << endl;
              SS2out << "dead*wt " << f << " " << y << " " << s << " " << sx(g) << " " << g << " " << y << "_" << f << "_dead*wt" << sel_dead_bio(s, f, g) << endl;
            }
    SS2out << "#" << endl << "maximum_ASEL2" << endl << "Fleet fleet_name year seas max" << endl;
    for (f = 1; f <=Nfleet; f++)
    {SS2out << f << " " << fleetname(f) << selmax(f) << endl;}
  }

  // REPORT_KEYWORD 33 ENVIRONMENTAL_DATA
  if (pick_report_use(33) == "Y" && N_envvar > 0)
  {
    SS2out << endl
           << pick_report_name(33) << endl;
    SS2out << "#_Begins.in.startyr-1.which.for.model.generated.columns.shows.the.base.value.to.which.other.years.are.scaled" << endl;
    SS2out << "#_Ninput.vectors " << N_envvar << endl;
    SS2out << "#_statistics.for.each.inout.env.vector.where.mc.is.to.meancenter.and.Zscore.also.divides.by.stdev" << endl;
    SS2out << "Index N minyr maxyr mean stdev mc Zscore" << endl;
    for (k = 1; k <= N_envvar; k++)
    {
      SS2out << k << " " << env_data_N(k) << " " << env_data_minyr(k) << " " << env_data_maxyr(k) << " " << env_data_mean(k) << " " << env_data_stdev(k) << " " << env_data_do_mean(k) << " " << env_data_do_stdev(k) << endl;
    }

    SS2out << endl
           << "Yr rel_smrynum rel_smrybio exp(recdev) rel_SSB null ";
    for (i = 1; i <= N_envvar; i++)
      SS2out << " env:_" << i;
    SS2out << endl;
    for (y = styr - 1; y <= YrMax; y++)
    {
      SS2out << y << " " << env_data(y) << endl;
    }
    SS2out << endl;
  }

  // REPORT_KEYWORD 34 TAG_Recapture
  if (pick_report_use(34) == "Y" && Do_TG > 0)
  {
    SS2out << endl
           << pick_report_name(34) << endl;
    SS2out << TG_mixperiod << " First period to use recaptures in likelihood" << endl;
    SS2out << TG_maxperiods << " Accumulation period" << endl;

    SS2out << " Tag_release_info" << endl;
    SS2out << "TAG Area Yr Seas Time Sex Age Nrelease Init_Loss Chron_Loss" << endl;
    ;
    for (TG = 1; TG <= N_TG; TG++)
    {
      SS2out << TG << " " << TG_release(TG)(2, 8) << " " << TG_save(TG)(1, 2) << endl;
    }
    SS2out << "Tags_Alive ";
    k = max(TG_endtime);
    for (t = 0; t <= k; t++)
      SS2out << t << " ";
    SS2out << endl;
    for (TG = 1; TG <= N_TG; TG++)
    {
      SS2out << TG << " " << TG_save(TG)(3, 3 + TG_endtime(TG)) << endl;
    }
    SS2out << "Total_recaptures ";
    for (t = 0; t <= k; t++)
      SS2out << t << " ";
    SS2out << endl;
    for (TG = 1; TG <= N_TG; TG++)
    {
      SS2out << TG << " ";
      for (TG_t = 0; TG_t <= TG_endtime(TG); TG_t++)
        SS2out << TG_recap_exp(TG, TG_t, 0) << " ";
      SS2out << endl;
    }

    SS2out << endl
           << "Reporting_Rates_by_Fishery" << endl
           << "Fleet Init_Reporting Report_Decay" << endl;
    for (f = 1; f <= Nfleet; f++)
      SS2out << f << " " << TG_report(f) << " " << TG_rep_decay(f) << endl;
    SS2out << "See_composition_data_output_for_tag_recapture_details" << endl;
  }

  // ************************                     SS_Label_400
  // REPORT_KEYWORD 35 NUMBERS_AT_AGE
  if (pick_report_use(35) == "Y")
  {
    SS2out << endl
           << pick_report_name(35) << endl;
    SS2out << "Area Bio_Pattern Sex BirthSeas Settlement Platoon Morph Yr Seas Time Beg/Mid Era" << age_vector << endl;
    for (p = 1; p <= pop; p++)
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (y = styr - 2; y <= YrMax; y++)
            for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              temp = double(y) + azero_seas(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " B";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopAge(t, p, g) << endl;
              temp = double(y) + azero_seas(s) + seasdur_half(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " M";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopAge(t, p + pop, g) << endl;
            }
        }
  }

  // REPORT_KEYWORD 36 BIOMASS_AT_AGE
  if (pick_report_use(36) == "Y")
  {
    SS2out << endl
           << pick_report_name(36) << endl;
    SS2out << "Area Bio_Pattern Sex BirthSeas Settlement Platoon Morph Yr Seas Time Beg/Mid Era" << age_vector << endl;
    for (p = 1; p <= pop; p++)
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (y = styr - 2; y <= YrMax; y++)
            for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              temp = double(y) + azero_seas(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " B";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopBio(t, p, g) << endl;
              temp = double(y) + azero_seas(s) + seasdur_half(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " M";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopBio(t, p + pop, g) << endl;
            }
        }
  }

  // REPORT_KEYWORD 37 NUMBERS_AT_LENGTH
  if (pick_report_use(37) == "Y")
  {
    SS2out << endl
           << pick_report_name(37) << endl;
    SS2out << "Area Bio_Pattern Sex BirthSeas Settlement Platoon Morph Yr Seas Time Beg/Mid Era " << len_bins << endl;
    for (p = 1; p <= pop; p++)
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (y = styr; y <= YrMax; y++)
            for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              temp = double(y) + azero_seas(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " B ";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopLen(t, p, g) << endl;
              temp = double(y) + azero_seas(s) + seasdur_half(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " M ";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopLen(t, p + pop, g) << endl;
            }
        }
  }

  // REPORT_KEYWORD 38 BIOMASS_AT_LENGTH
  if (pick_report_use(38) == "Y")
  {
    SS2out << endl
           << pick_report_name(38) << endl;
    SS2out << "Area Bio_Pattern Sex BirthSeas Settlement Platoon Morph Yr Seas Time Beg/Mid Era " << len_bins << endl;
    for (p = 1; p <= pop; p++)
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (y = styr; y <= YrMax; y++)
            for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              temp = double(y) + azero_seas(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " B ";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopWt(t, p, g) << endl;
              temp = double(y) + azero_seas(s) + seasdur_half(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " M ";
              if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out << Save_PopWt(t, p + pop, g) << endl;
            }
        }
  }

  // REPORT_KEYWORD 39 F_AT_AGE
  if (pick_report_use(39) == "Y")
  {
    SS2out << endl
           << pick_report_name(39) << endl;
    SS2out << "Area Fleet Sex Morph Yr Seas Era" << age_vector << endl;
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2)
        for (g = 1; g <= gmorph; g++)
        {
          if (use_morph(g) > 0)
          {
            for (y = styr - 1; y <= YrMax; y++)
              for (s = 1; s <= nseas; s++)
              {
                t = styr + (y - styr) * nseas + s - 1;
                SS2out << fleet_area(f) << " " << f << " " << sx(g) << " " << g << " " << y << " " << s;
                if (y == styr - 1)
                {
                  SS2out << " INIT ";
                }
                else if (y <= endyr)
                {
                  SS2out << " TIME ";
                }
                else
                {
                  SS2out << " FORE ";
                }
                SS2out << Hrate(f, t) * save_sel_num(t, f, g) << endl;
              }
          }
        }
  }

  // REPORT_KEYWORD 40 CATCH_AT_AGE
  if (pick_report_use(40) == "Y")
  {
    SS2out << endl
           << pick_report_name(40) << endl;
    SS2out << "#_NOTE: catage is based on: sel_dead_num = sel * (retain + (1-retain)*discmort)" << endl;
    SS2out << "Area Fleet Sex  XX XX Type Morph Yr Seas XX Era" << age_vector << endl;
    for (f = 1; f <= Nfleet; f++)
      if (fleet_type(f) <= 2 || fleet_type(f) == 4)
        for (g = 1; g <= gmorph; g++)
        {
          if (use_morph(g) > 0)
          {
            for (y = styr - 1; y <= YrMax; y++)
              for (s = 1; s <= nseas; s++)
              {
                t = styr + (y - styr) * nseas + s - 1;
                SS2out << fleet_area(f) << " " << f << " " << sx(g) << " XX XX dead " << g << " " << y << " " << s;
                if (y == styr - 1)
                {
                  SS2out << " XX INIT ";
                }
                else if (y <= endyr)
                {
                  SS2out << " XX TIME ";
                }
                else
                {
                  SS2out << " XX FORE ";
                }
                SS2out << catage(t, f, g) << endl;
              }
          }
        }
  }

  // REPORT_KEYWORD 41 DISCARD_AT_AGE
  if (pick_report_use(41) == "Y")
  {
    SS2out << endl
           << pick_report_name(41) << endl;
    SS2out << "Area Fleet Sex  XX XX Type Morph Yr Seas XX Era" << age_vector << endl;
    for (f = 1; f <= Nfleet; f++)
      //     if((fleet_type(f)<=2 && Do_Retain(f)>0) || fleet_type(f)==4)
      if ((fleet_type(f) <= 2 && Do_Retain(f) > 0))
        for (g = 1; g <= gmorph; g++)
        {
          if (use_morph(g) > 0)
          {
            for (y = styr - 1; y <= YrMax; y++)
              for (s = 1; s <= nseas; s++)
              {
                t = styr + (y - styr) * nseas + s - 1;
                SS2out << fleet_area(f) << " " << f << " " << sx(g) << " XX XX dead " << g << " " << y << " " << s;
                if (y == styr - 1)
                {
                  SS2out << " XX INIT ";
                }
                else if (y <= endyr)
                {
                  SS2out << " XX TIME ";
                }
                else
                {
                  SS2out << " XX FORE ";
                }
                SS2out << catage(t, f, g) << endl;
                SS2out << fleet_area(f) << " " << f << " " << sx(g) << " XX XX sel " << g << " " << y << " " << s;
                if (y == styr - 1)
                {
                  SS2out << " XX INIT ";
                }
                else if (y <= endyr)
                {
                  SS2out << " XX TIME ";
                }
                else
                {
                  SS2out << " XX FORE ";
                }
                SS2out << disc_age(t, disc_fleet_list(f), g) << endl;

                SS2out << fleet_area(f) << " " << f << " " << sx(g) << " XX XX ret " << g << " " << y << " " << s;
                if (y == styr - 1)
                {
                  SS2out << " XX INIT ";
                }
                else if (y <= endyr)
                {
                  SS2out << " XX TIME ";
                }
                else
                {
                  SS2out << " XX FORE ";
                }
                SS2out << disc_age(t, disc_fleet_list(f) + N_retain_fleets, g) << endl;

                SS2out << fleet_area(f) << " " << f << " " << sx(g) << " XX XX disc " << g << " " << y << " " << s;
                if (y == styr - 1)
                {
                  SS2out << " XX INIT ";
                }
                else if (y <= endyr)
                {
                  SS2out << " XX TIME ";
                }
                else
                {
                  SS2out << " XX FORE ";
                }
                SS2out << disc_age(t, disc_fleet_list(f), g) - disc_age(t, disc_fleet_list(f) + N_retain_fleets, g) << endl;
              }
          }
        }
  }

  // REPORT_KEYWORD 42 BIOLOGY
  if (pick_report_use(42) == "Y")
  {
    SS2out << endl
           << pick_report_name(42) << endl;
    SS2out << sum(use_morph) << " " << nlength << " " << nages << " " << nseas << " N_Used_morphs;_lengths;_ages;_season;_by_season_in_endyr" << endl;
    if (gender == 2)
    {
      SS2out << "GP Bin Len_lo Len_mean Wt_F Mat Mat*Fec Wt_M Fec";
    }
    else
    {
      SS2out << "GP Bin Len_lo Len_mean Wt_F Mat Mat*Fec Fec";
    }
    if(Maturity_Option == 4 || Maturity_Option == 5) {
      SS2out << " // [Mat, Mat*Fec, and Fec reported as 0.5 because maturity option directly reads age_fecundity]";
    }
    SS2out << endl;
    for (gp = 1; gp <= N_GP; gp++)
      for (z = 1; z <= nlength; z++)
      {
        SS2out << gp << " " << z << " " << len_bins(z) << " " << len_bins_m(z) << " " << wt_len(1, gp, z) << " " << mat_len(gp, z) << " " << mat_fec_len(gp, z);
        if (gender == 2)
        {
          SS2out << " " << wt_len(1, N_GP + gp, z);
        }
        SS2out << " " << fec_len(gp, z) << endl;
      }
  }

  // REPORT_KEYWORD 43 NATURAL_MORTALITY
  if (pick_report_use(43) == "Y")
  {
    SS2out << endl
           << pick_report_name(43) << endl;
    SS2out << "Method: " << natM_type << endl;
    int hide_M1 = 1;
    if(N_pred > 0)
    {
      SS2out<< "area 0 shows M1 only, numbered areas have M1+M2"<<endl;
      hide_M1 = 0;
    }
    SS2out << "Area Bio_Pattern Sex BirthSeas Settlement Platoon Morph Yr Seas Time Beg/Mid Era" << age_vector << endl;
    for (p = hide_M1; p <= pop; p++)
    for (gp = 1; gp <= N_GP * gender; gp++)
    {
      g = g_Start(gp); //  base platoon
      for (settle = 1; settle <= N_settle_timings; settle++)
      {
        g += N_platoon;
        int gpi = GP3(g); // GP*gender*settlement
        for (y = styr - 3; y <= YrMax; y++)
        for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              temp = double(y) + azero_seas(s);
              SS2out << p << " " << GP4(g) << " " << sx(g) << " " << Bseas(g) << " " << settle_g(g) << " " << GP2(g) << " " << g << " " << y << " " << s << " " << temp << " B";
              if (y == styr - 3)
              {
                SS2out << " BENCH ";
              }
              else if (y == styr - 2)
              {
                SS2out << " VIRG ";
              }
              else if (y == styr - 1)
              {
                SS2out << " INIT ";
              }
              else if (y <= endyr)
              {
                SS2out << " TIME ";
              }
              else
              {
                SS2out << " FORE ";
              }
              SS2out<<natM(t,p,gpi)<<endl;
            }
          }
        }

    if (N_predparms > 0)
    {
      SS2out << endl
             << "Predator_(M2); Values_are_apical_M2; total_M-at-age_(M1+M2)_reported_in_table_No_fishery_for_Z=M " << endl
             << "Yr Era seas ";
      for (f1 = 1; f1 <= N_pred; f1++)
      {
        f = predator(f1);
        SS2out << fleetname(f) << "_M2 comsume_Bio consume_Num";
      }
      SS2out << endl;
      for (y = styr - 2; y <= YrMax; y++)
      {
        for (s = 1; s <= nseas; s++)
        {
          t = styr + (y - styr) * nseas + s - 1;
          SS2out << y;
          if (y == styr - 2)
          {
            SS2out << " VIRG ";
          }
          else if (y == styr - 1)
          {
            SS2out << " INIT ";
          }
          else if (y <= endyr)
          {
            SS2out << " TIME ";
          }
          else
          {
            SS2out << " FORE ";
          }
          SS2out << s << " ";
          for (f1 = 1; f1 <= N_pred; f1++)
          {
            SS2out << pred_M2(f1, t) << " " << catch_fleet(t, predator(f1), 1) << " " << catch_fleet(t, predator(f1), 4) << " ";
          }
          SS2out << endl;
        }
      }
    }
  }
  // REPORT_KEYWORD 44 AGE_SPECIFIC_K
  if (pick_report_use(44) == "Y" && Grow_type >= 3 && Grow_type <= 6)
  {
    SS2out << endl
           << pick_report_name(44) << endl;
    SS2out << "Bio_Pattern Sex " << age_vector << endl;
    g = 0;
    for (gg = 1; gg <= gender; gg++)
      for (gp = 1; gp <= N_GP; gp++)
      {
        g++;
        SS2out << gp << " " << gg << " " << -VBK(g) << endl;
      }
  }

  // REPORT_KEYWORD 45 GROWTH_PARAMETERS_derived
  if (pick_report_use(45) == "Y")
  {
    SS2out << endl
           << pick_report_name(45) << endl;
    SS2out << " Count Yr Sex Platoon A1 A2 L_a_A1 L_a_A2 K A_a_L0 Linf CVmin CVmax natM_amin natM_max M_age0 M_nages"
           << " WtLen1 WtLen2 Mat1 Mat2 Fec1 Fec2" << endl;
    for (g = 1; g <= save_gparm_print; g++)
    {
      SS2out << save_G_parm(g)(1, 2) << " " << sx(save_G_parm(g, 3)) << " " << save_G_parm(g)(3, 22) << endl;
    }
  }
  // REPORT_KEYWORD 46 SEASONAL_BIOLOGY
  if (pick_report_use(46) == "Y" && MGparm_doseas > 0)
  {
    SS2out << endl
           << pick_report_name(46) << endl;
    SS2out << "Seas F_wtlen1 F_wtlen2 F_mat1 F_mat2 F_fec1 F_fec2 M_wtlen1 M_wtlen2 L_a_A1 VBK" << endl;
    for (s = 1; s <= nseas; s++)
    {
      SS2out << s << " " << save_seas_parm(s) << endl;
    }
  }

  //    restore_AgeLength_Key to endyr, otherwise it will have ALK from end of forecast
  //   NOT SURE why this code is here
  if (timevary_MG(endyr, 2) > 0 || timevary_MG(endyr, 3) > 0 || WTage_rd > 0)
  {
    y = endyr;
    t_base = styr + (y - styr) * nseas - 1;
    for (s = 1; s <= nseas; s++)
    {
      t = t_base + s;
      bio_t = styr + (endyr - styr) * nseas + s - 1;
      subseas = 1;
      ALK_idx = (s - 1) * N_subseas + subseas;
      get_growth3(styr, t, s, subseas);
      Make_AgeLength_Key(s, subseas); //  for begin season
      subseas = mid_subseas;
      ALK_idx = (s - 1) * N_subseas + subseas;
      get_growth3(styr, t, s, subseas);
      Make_AgeLength_Key(s, subseas); //  for midseason
      if (s == spawn_seas)
      {
        subseas = spawn_subseas;
        ALK_idx = (s - 1) * N_subseas + subseas;
        if (spawn_subseas != 1 && spawn_subseas != mid_subseas)
        {
          get_growth3(styr, t, s, subseas);
          Make_AgeLength_Key(s, subseas); //  spawn subseas
        }
        get_mat_fec();
      }
    }
  }

  dvariable Herma_Cum;
  // REPORT_KEYWORD 47 Biology_at_age_by_morph
  if (pick_report_use(47) == "Y")
  {
    SS2out << endl
           << pick_report_name(47) << endl;
    SS2out << "in_endyr_with_";
    switch (CV_depvar)
    {
      case 0:
      {
        SS2out << "CV=f(LAA)";
        break;
      }
      case 1:
      {
        SS2out << "CV=F(A)";
        break;
      }
      case 2:
      {
        SS2out << "SD=F(LAA)";
        break;
      }
      case 3:
      {
        SS2out << "SD=F(A)";
        break;
      }
      case 4:
      {
        SS2out << "logSD=f(A)";
        break;
      }
    }

    SS2out << endl;
    SS2out << "Seas Morph Bio_Pattern Sex Settlement Platoon int_Age Real_Age Age_Beg Age_Mid M Len_Beg Len_Mid SD_Beg SD_Mid Wt_Beg Wt_Mid Len_Mat Age_Mat Mat*Fecund Mat_F_wtatage Mat_F_Natage";
    if (Hermaphro_Option != 0)
    {
      SS2out << " Herma_Trans ";
    }
    if (gender == 2)
    {
      for (p = 1; p <=pop; p++)
        SS2out << " sex_ratio_area:_" << p ;
    }
    for (f = 1; f <= Nfleet; f++)
      SS2out << " Len:_" << f << " SelWt:_" << f << " RetWt:_" << f;
    SS2out << endl;
    for (s = 1; s <= nseas; s++)
    {
      t = styr + (endyr - styr) * nseas + s - 1;
      ALK_idx = (s - 1) * N_subseas + 1; // for first subseas of season
      ALK_idx_mid = (s - 1) * N_subseas + mid_subseas; // for midsubseas of the season
      for (g = 1; g <= gmorph; g++)
        if (use_morph(g) > 0)
        {
          for (a = 0; a <= nages; a++)
          {
            SS2out << s << " " << g << " " << GP4(g) << " " << sx(g) << " " << settle_g(g) << " " << GP2(g) << " " << a << " " << real_age(g, ALK_idx, a) << " " << calen_age(g, ALK_idx, a) << " " << calen_age(g, ALK_idx_mid, a);
            SS2out << " " << natM(t, 1, GP3(g), a) << " " << Ave_Size(t, 1, g, a) << " " << Ave_Size(t, mid_subseas, g, a) << " "
                   << Sd_Size_within(ALK_idx, g, a) << " " << Sd_Size_within(ALK_idx_mid, g, a) << " "
                   << Wt_Age_beg(s, g, a) << " " << Wt_Age_mid(s, g, a) << " " << ALK(ALK_idx, g, a) * mat_len(GP4(g)) << " ";
            if (Maturity_Option <= 2)
            {
              SS2out << mat_age(GP4(g), a);
            }
            else if (sx(g) == 1 && Maturity_Option < 5)
            {
              SS2out << Age_Maturity(GP4(g), a);
            }
            else
            {
              SS2out << -1.;
            }
            SS2out << " " << fec(g, a) << " " << make_mature_bio(g, a) << " " << make_mature_numbers(g, a);
            if (Hermaphro_Option == 1)
            {
              if (sx(g) == 1)
              {
                SS2out << " " << Hermaphro_val(GP4(g), a) << " ";
              }
              else
              {
                SS2out << " NA ";
              }
            }
            else if (Hermaphro_Option == -1)
            {
              if (sx(g) == 2)
              {
                SS2out << " " << Hermaphro_val(GP4(g), a) << " ";
              }
              else
              {
                SS2out << " NA ";
              }
            }
            //  write sex ratio in endyr for each area using natage
            //  small constant added to denominator so that morph-area combos with no fish will display a value of 0.0, rather than "nan"
            //  because natage is used, the reported sex ratio values will be responsive to hermaphroditism, and to sex-specific mortality
            if (gender == 2)
            {
              if (sx(g) == 1)
              {
                for (p = 1; p <= pop; p++)
                  SS2out << " " << natage(t, p, g, a) / (natage(t, p, g, a) + natage(t, p, g + gmorph / 2, a) + 1.0e-07) << " ";
              }
              else
              {
                for (p = 1; p <= pop; p++)
                  SS2out << " " << natage(t, p, g, a) / (natage(t, p, g, a) + natage(t, p, g - gmorph / 2, a) + 1.0e-07) << " ";
              }
            }
            if (WTage_rd == 0)
            {
              for (f = 1; f <= Nfleet; f++)
                SS2out << " " << ALK(ALK_idx_mid, g, a) * elem_prod(sel_l(endyr, f, sx(g)), len_bins_m) / (ALK(ALK_idx_mid, g, a) * sel_l(endyr, f, sx(g))) << " " << ALK(ALK_idx_mid, g, a) * elem_prod(sel_l(endyr, f, sx(g)), wt_len(s, GP(g))) / (ALK(ALK_idx_mid, g, a) * sel_l(endyr, f, sx(g))) << " " << ALK(ALK_idx_mid, g, a) * elem_prod(sel_l_r(endyr, f, sx(g)), wt_len(s, GP(g))) / (ALK(ALK_idx_mid, g, a) * sel_l_r(endyr, f, sx(g)));
            }
            else
            {
              for (f = 1; f <= Nfleet; f++)
                SS2out << " " << ALK(ALK_idx_mid, g, a) * elem_prod(sel_l(endyr, f, sx(g)), len_bins_m) / (ALK(ALK_idx_mid, g, a) * sel_l(endyr, f, sx(g))) << " " << Wt_Age_t(t, f, g, a) << " " << Wt_Age_t(t, f, g, a);
            }
            SS2out << endl;
          }
        }
    }
  }

  // REPORT_KEYWORD 48 MEAN_BODY_WT by year
  if (pick_report_use(48) == "Y")
  {
    SS2out << endl
           << pick_report_name(48) << endl;
    if (WTage_rd > 0)
      SS2out << " as read from wtatage.ss";
    SS2out << "#_NOTE: yr=_" << styr - 3 << "_stores_values_for_benchmark" << endl;
    SS2out << "Morph Yr Seas" << age_vector << endl;
    for (g = 1; g <= gmorph; g++)
      if (use_morph(g) > 0)
      {
        for (y = styr - 3; y <= YrMax; y++)
        {
          yz = y;
          if (yz > endyr + 2)
            yz = endyr + 2;
          //    if(y==styr-3 || y==styr || timevary_MG(yz,2)>0 || timevary_MG(yz,3)>0 || WTage_rd>0)  // if growth or wtlen parms have changed
          for (s = 1; s <= nseas; s++)
          {
            t = styr + (y - styr) * nseas + s - 1;
            SS2out << g << " " << y << " " << s << " " << Wt_Age_t(t, 0, g) << endl;
          }
        }
      }
  }

  // REPORT_KEYWORD 49 MEAN_SIZE_TIMESERIES  body length
  if (pick_report_use(49) == "Y")
  {
    SS2out << endl
           << pick_report_name(49) << endl;
    SS2out << "Morph Yr Seas SubSeas" << age_vector << endl;
    for (g = 1; g <= gmorph; g++)
      if (use_morph(g) > 0)
      {
        for (y = styr - 3; y <= YrMax; y++)
        {
          yz = y;
          if (yz > endyr + 2)
            yz = endyr + 2;
          //        if(y==styr-3 || y==styr ||  timevary_MG(yz,2)>0)
          {
            for (s = 1; s <= nseas; s++)
            {
              t = styr + (y - styr) * nseas + s - 1;
              for (i = 1; i <= N_subseas; i++)
              {
                SS2out << g << " " << y << " " << s << " " << i << " " << Ave_Size(t, i, g) << endl;
              }
            }
          }
        }
      }
    s = 1;
    for (i = 1; i <= gender; i++)
    {
      SS2out << "#" << endl
             << "mean_size_Jan_1_for_sex: " << i << "#NOTE: combines_all_settlements_areas_GP_and_platoons" << endl;
      SS2out << "Sex Yr Seas Beg " << age_vector << endl;
      for (y = styr; y <= YrMax; y++)
      {
        yz = y;
        if (yz > endyr + 2)
          yz = endyr + 2;
        if (y <= styr || timevary_MG(yz, 2) > 0 || N_platoon > 1)
        {
          t = styr + (y - styr) * nseas + s - 1;
          SS2out << i << " " << y << " " << s << " " << 0;
          for (a = 0; a <= nages; a++)
          {
            temp = 0.0;
            temp1 = 0.0;
            for (g = 1; g <= gmorph; g++)
            {
              if (sx(g) == i && use_morph(g) > 0)
              {
                for (p = 1; p <= pop; p++)
                {
                  temp += natage(t, p, g, a);
                  temp1 += Ave_Size(t, 1, g, a) * natage(t, p, g, a);
                } // end loop of areas
              } //  end need to use this gender/platoon
            } //  end loop of all platoons
            if (temp > 0.0)
            {
              SS2out << " " << temp1 / temp;
            }
            else
            {
              SS2out << " __";
            }
          } //  end loop of ages
          SS2out << endl;
        } // end need to report this year
      } // end year loop
    } // end gender loop
  } //   end do report detail

  // REPORT_KEYWORD 50 AGE_LENGTH_KEY
  if (pick_report_use(50) == "Y")
  {
    SS2out << endl
           << pick_report_name(50) << endl;
    if (Grow_logN == 1)
      SS2out << " #Lognormal ";
    SS2out << "#" << endl; // SS_Label_460
    SS2out << " sdratio " << platoon_sd_ratio << endl;
    SS2out << " sdwithin " << sd_within_platoon << endl;
    SS2out << " sdbetween " << sd_between_platoon << endl;
    for (s = 1; s <= nseas; s++)
      for (subseas = 1; subseas <= N_subseas; subseas++)
        for (g = 1; g <= gmorph; g++)
          if (use_morph(g) > 0)
          {
            t = styr + (endyr - styr) * nseas + s - 1;
            ALK_idx = (s - 1) * N_subseas + subseas;
            SS2out << "#" << endl
                   << " Seas: " << s << " Sub_Seas: " << subseas << "   Morph: " << g << endl;
            SS2out << "Age:";
            for (a = 0; a <= nages; a++)
              SS2out << " " << a;
            SS2out << endl;
            for (z = nlength; z >= 1; z--)
            {
              SS2out << len_bins2(z) << " ";
              for (a = 0; a <= nages; a++)
                SS2out << ALK(ALK_idx, g, a, z) << " ";
              SS2out << endl;
            }
            SS2out << "mean " << Ave_Size(t, subseas, g) << endl;
            SS2out << "sdsize " << Sd_Size_within(ALK_idx, g) << endl;
          }
  }

  // REPORT_KEYWORD 51 AGE_AGE_KEY
  if (pick_report_use(51) == "Y" && N_ageerr > 0)
  {
    SS2out << endl
           << pick_report_name(51) << endl;
    for (k = 1; k <= N_ageerr + store_agekey_add; k++)
    {
      SS2out << "KEY: " << k << endl
             << "mean " << age_err(k, 1) << endl
             << "SD " << age_err(k, 2) << endl;
      for (b = n_abins; b >= 1; b--)
      {
        SS2out << age_bins(b) << " ";
        for (a = 0; a <= nages; a++)
          SS2out << age_age(k, b, a) << " ";
        SS2out << endl;
      }
      if (gender == 2)
      {
        L2 = n_abins;
        A2 = nages + 1;
        for (b = n_abins; b >= 1; b--)
        {
          SS2out << age_bins(b) << " ";
          for (a = 0; a <= nages; a++)
            SS2out << age_age(k, b + L2, a + A2) << " ";
          SS2out << endl;
        }
      }
    }
  }

  // REPORT_KEYWORD 52 COMPOSITION_DATABASE
  /* SS_Label_xxx report the composition database to CompReport.sso */
  int last_t;
  if (pick_report_use(52) == "Y")
  {
    SS_compout << endl
               << "Size_Bins_pop;_(Pop_len_mid_used_for_calc_of_selex_and_bio_quantities)" << endl;
    SS_compout << "Pop_Bin: ";
    for (j = 1; j <= nlength; j++)
      SS_compout << " " << j;
    SS_compout << endl
               << "Length: " << len_bins << endl;
    SS_compout << "Len_mid: " << len_bins_m << endl;
    SS_compout << "Size_Bins_dat;_(Data_len_mid_for_reporting_only)" << endl;
    SS_compout << "Data_Bin: ";
    for (j = 1; j <= nlen_bin; j++)
      SS_compout << " " << j;
    SS_compout << endl
               << "Length: " << len_bins_dat << endl;
    SS_compout << "Len_mid: " << len_bins_dat_m << endl;

    SS_compout << "Combine_males_with_females_thru_sizedata_bin " << CombGender_L << endl;
    //  SS_compout<<"Size:"<<len_bins_dat(CombGender_L)<<endl;
    SS_compout << "Combine_males_with_females_thru_Age_Data_bin: " << CombGender_A << endl;
    //  SS_compout<<"Age: "<<age_bins(CombGender_A)<<endl;
    SS_compout << endl
               << "Method_for_Lbin_definition_for_agecomp_data: " << Lbin_method << endl;

    SS_compout << "For_Sizefreq;_Lbin_Lo_is_units(bio_or_numbers);_Lbin_hi_is_scale(kg,_lb,_cm,_in),_Ageerr_is_method" << endl;
    SS_compout << "For_mean_size_at_age,_the_sign_of_ageerror_indicates_length(positive),_or_weight(negative)" << endl;
    SS_compout << "For_mean_size_at_age,_the_std_dev_of_size_at_age_is_stored_in_LbinLo_ans_LbinHi_is_ignored" << endl;
    SS_compout << "subseas_is_derived_from_month_and_the_number_of_subseasons_per_season,_which_is: " << N_subseas << endl;
    SS_compout << "Time_is_fraction_of_year_based_on_subseas,_not_directly_on_month" << endl;
    SS_compout << "If_observations_with_same_or_different_month_value_are_assigned_to_the_same_subseas,_then_repli(cate)_counter_is_incremented" << endl;
    SS_compout << "For_Tag_output,_Rep_contains_Tag_Group,_Bin_is_fleet_for_TAG1_and_Bin_is_Year.Seas_for_TAG2" << endl;
    SS_compout << "Column_Super?_indicates_super-periods;_column_used_indicates_inclusion_in_logL" << endl;

    SS_compout << endl
               << "Composition_Database" << endl; // SS_Label_480

    SS_compout << "Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part Ageerr Sex Lbin_lo Lbin_hi Bin Obs Exp Pearson Nsamp_adj Nsamp_in effN Like Cum_obs Cum_exp SuprPer Used?" << endl;
    int repli;
    int N_out;
    int z_lo = 1;
    int z_hi = 1;
    int nbins = 0;
    double ocomp = 0.0;
    double ecomp = 0.0;
    N_out = 0;
    double show_logL = 0.0;
    double show_Pearson = 0.0;
    double nsamp = 0.0;

    for (f = 1; f <= Nfleet; f++)
    {

      /* SS_Label_xxx  output lengthcomp to CompReport.sso */
      {
        data_type = 4; // for length comp
        in_superperiod = 0;
        repli = 0;
        last_t = -999;
        for (i = 1; i <= Nobs_l(f); i++) // loop obs in this type/time
        {
          N_out++;
          t = Len_time_t(f, i);
          ALK_time = Len_time_ALK(f, i);
          temp2 = 0.0;
          temp1 = 0.0;
          real_month = abs(header_l_rd(f, i, 2));
          if (real_month > 999)
            real_month -= 1000.;

          if (ALK_time == last_t)
          {
            repli++;
          }
          else
          {
            repli = 1;
            last_t = ALK_time;
          }
          in_superperiod = determine_speriod(in_superperiod, anystring, header_l(f, i, 2), header_l(f, i, 3));

//        count bins
          nbins = 0;
          for (gg = 1; gg <= gender ; gg ++)
          {
            if (gen_l(f, i) != 2 && gg == 1)
            {
              z_lo = tails_l(f, i, 1);
              z_hi = tails_l(f, i, 2);
              nbins += z_hi - z_lo + 1;
            }
            else if (gen_l(f, i) >= 2 && gg == 2) // do males
            {
              z_lo = tails_l(f, i, 3);
              z_hi = tails_l(f, i, 4);
              nbins += z_hi - z_lo + 1;
            }
          }

          int gender2 = gender;
          if (gen_l(f, i) == 0) gender2 = 1;
          for (gg = 1; gg <= gender2 ; gg ++)
          {
            if (gen_l(f, i) != 2 && gg == 1)
            {
              s_off = 1;
              z_lo = tails_l(f, i, 1);
              z_hi = tails_l(f, i, 2);
            }
            else if (gen_l(f, i) >= 2 && gg == 2) // do males
            {
              s_off = 2;
              z_lo = tails_l(f, i, 3);
              z_hi = tails_l(f, i, 4);
            }
            // temp = gammln(dirichlet_Parm) - gammln(nsamp_l(f, i) + dirichlet_Parm);
            nsamp = fabs(nsamp_l(f, i));
            for (z = z_lo; z <= z_hi; z++)
            {
              ocomp = obs_l(f, i, z); 
              ecomp = value( exp_l(f, i, z) ); 
              // Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part Ageerr Sex Lbin_lo Lbin_hi Bin Obs Exp
              SS_compout << header_l(f, i, 1) << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gen_l(f, i) << " LEN " << mkt_l(f, i) << " 0 " << s_off << " " << 1 << " " << 1 << " " << len_bins_dat2(z) << " " << ocomp << " " << ecomp << " ";
              // Pearson Nsamp_adj Nsamp_in effN Like
              temp2 += ocomp;
              temp1 += ecomp;
              if (nsamp > 0 && header_l(f, i, 3) > 0 && (ecomp != 0.0 && ecomp != 1.0) && nbins > 0 ) // check for values to include
              {
                  int parti = mkt_l(f, i);
                  if (Comp_Err_L(parti,f) == 0)
                  {
                    show_Pearson = (ocomp - ecomp) / sqrt(ecomp * (1.0 - ecomp) / nsamp ); // Pearson for multinomial
                    show_logL = ocomp * log( (ocomp + 1.0e-12) / ( ecomp + 1.0e-12) ) * nsamp;  //  logL
                  }
                  if (Comp_Err_L(parti, f) == 1 || Comp_Err_L(parti, f) == 2)
                  {
                    dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_L2(parti, f),1)));
                    if (Comp_Err_L(parti, f) == 1 )
                      { dirichlet_Parm *= nsamp; }
                    show_Pearson = value((ocomp - ecomp) / sqrt(ecomp * (1.0 - ecomp) / nsamp * (nsamp + dirichlet_Parm) / (1. + dirichlet_Parm))); // Pearson for Dirichlet-multinomial using negative-exponential parameterization
                    show_logL =  -offset_l(f,i) / nbins
                     - value( gammln(nsamp * ocomp + dirichlet_Parm * ecomp) - gammln(dirichlet_Parm * ecomp))
                     - value( ( gammln(dirichlet_Parm) - gammln(nsamp + dirichlet_Parm))) / nbins;
                  }
                  if (Comp_Err_L(parti, f) == 3 )  //  MV Tweedie
                  {
                  }
                  SS_compout << show_Pearson << " " << nsamp << " " << nsamp_l_read(f, i) << " " << neff_l(f, i) << " " << show_logL;
              }
              else // sample size zero or skip
              {
                SS_compout << " NA " << " " << nsamp << " " << nsamp_l_read(f, i) << " NA NA "; // placeholder
              }
              // Cum_obs Cum_exp SuprPer Used?
              SS_compout << " " << temp2 << " " << temp1 << " " << anystring <<endl;
            }
            // single row representing info from previous bin-specific rows
            SS_compout << header_l(f, i, 1) << " " << header_l(f, i, 2) << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gen_l(f, i) << " LEN "
                       << mkt_l(f, i) << " 0 " << s_off << " " << 1 << " " << 1 << endl;
          }
        }
      }

      /* SS_Label_xxx  output agecomp to CompReport.sso */
      {
        data_type = 5; // for age comp
        in_superperiod = 0;
        repli = 0;
        last_t = -999;
        for (i = 1; i <= Nobs_a(f); i++) // loop obs in this type/time
        {
          N_out++;
          t = Age_time_t(f, i);
          ALK_time = Age_time_ALK(f, i);
          temp2 = 0.0;
          temp1 = 0.0;
          real_month = abs(header_a_rd(f, i, 2));
          if (real_month > 999)
            real_month -= 1000.;

          if (ALK_time == last_t)
          {
            repli++;
          }
          else
          {
            repli = 1;
            last_t = ALK_time;
          }
          in_superperiod = determine_speriod(in_superperiod, anystring, header_a(f, i, 2), header_a(f, i, 3));

//        count bins
          nbins = 0;
          for (gg = 1; gg <= gender ; gg ++)
          {
            if (gen_a(f, i) != 2 && gg == 1)
            {
              z_lo = tails_a(f, i, 1);
              z_hi = tails_a(f, i, 2);
              nbins += z_hi - z_lo + 1;
            }
            else if (gen_a(f, i) >= 2 && gg == 2) // do males
            {
              z_lo = tails_a(f, i, 3);
              z_hi = tails_a(f, i, 4);
              nbins += z_hi - z_lo + 1;
            }
          }

          int gender2 = gender;
          if (gen_a(f, i) == 0) gender2 = 1;
          for (gg = 1; gg <= gender2 ; gg ++)
          {
            if (gen_a(f, i) != 2 && gg == 1)
            {
              s_off = 1;
              z_lo = tails_a(f, i, 1);
              z_hi = tails_a(f, i, 2);
            }
            else if (gen_a(f, i) >= 2 && gg == 2) // do males
            {
              s_off = 2;
              z_lo = tails_a(f, i, 3);
              z_hi = tails_a(f, i, 4);
            }
            // temp = gammln(dirichlet_Parm) - gammln(nsamp_l(f, i) + dirichlet_Parm);
            nsamp = fabs(nsamp_a(f, i));
            for (z = z_lo; z <= z_hi; z++)
            {
              ocomp = obs_a(f, i, z); 
              ecomp = value( exp_a(f, i, z) ); 
              // Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part Ageerr Sex Lbin_lo Lbin_hi Bin Obs Exp
              SS_compout << header_a(f, i, 1) << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gen_a(f, i) << " AGE " << mkt_a(f, i) << " " << ageerr_type_a(f, i)
                         << " " << s_off << " " << len_bins(Lbin_lo(f, i)) << " " << len_bins(Lbin_hi(f, i)) << " " << age_bins(z) << " " << ocomp << " " << ecomp << " ";
              // Pearson Nsamp_adj Nsamp_in effN Like
              temp2 += ocomp;
              temp1 += ecomp;

              if (nsamp > 0 && header_a(f, i, 3) > 0 && (ecomp != 0.0 && ecomp != 1.0) && nbins > 0 ) // check for values to include
              {
                if (Comp_Err_A(f) == 0)
                {
                  show_Pearson = (ocomp - ecomp) / sqrt(ecomp * (1.0 - ecomp) / nsamp ); // Pearson for multinomial
                  show_logL = ocomp * log( (ocomp + 1.0e-12) / ( ecomp + 1.0e-12) ) * nsamp;  //  logL
                }
                if (Comp_Err_A(f) == 1 || Comp_Err_A(f) == 2)
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_A2(f),1)));
                  if (Comp_Err_A(f) == 1 )
                    { dirichlet_Parm *= nsamp; }
                  show_Pearson = value((ocomp - ecomp) / sqrt(ecomp * (1.0 - ecomp) / nsamp * (nsamp + dirichlet_Parm) / (1. + dirichlet_Parm))); // Pearson for Dirichlet-multinomial using negative-exponential parameterization
                  show_logL =  -offset_a(f,i) / nbins
                   - value( gammln(nsamp * ocomp + dirichlet_Parm * ecomp) - gammln(dirichlet_Parm * ecomp))
                   - value( ( gammln(dirichlet_Parm) - gammln(nsamp + dirichlet_Parm))) / nbins;
                }
                if (Comp_Err_A(f) == 3 )  //  MV Tweedie
                {
                }
                SS_compout << show_Pearson << " " << nsamp << " " << nsamp_a_read(f, i) << " " << neff_a(f, i) << " " << show_logL;
              }
              else // sample size zero or skip
              {
                SS_compout << " NA " << " " << nsamp << " " << nsamp_a_read(f, i) << " NA NA "; // placeholder
              }
              // Cum_obs Cum_exp SuprPer Used?
              SS_compout << " " << temp2 << " " << temp1 << " " << anystring <<endl;
            }
            // single row representing info from previous bin-specific rows
            SS_compout << header_a(f, i, 1) << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gen_a(f, i) << " AGE "
                       << mkt_a(f, i) << " " << ageerr_type_a(f, i) << " " << s_off << " " << 1 << " " << nlength << endl;
          }
        }
      } //end have agecomp data

      /* SS_Label_xxx  output size-age to CompReport.sso */
      {
        data_type = 7; // for mean size-at-age
        in_superperiod = 0;
        repli = 0;
        last_t = -999;
        for (i = 1; i <= Nobs_ms(f); i++)
        {
          N_out++;
          t = msz_time_t(f, i);
          ALK_time = msz_time_ALK(f, i);
          temp2 = 0.0;
          temp1 = 0.0;
          real_month = abs(header_ms_rd(f, i, 2));
          if (real_month > 999)
            real_month -= 1000.;
          if (ALK_time == last_t)
          {
            repli++;
          }
          else
          {
            repli = 1;
            last_t = ALK_time;
          }
          in_superperiod = determine_speriod(in_superperiod, anystring, header_ms(f, i, 2), header_ms(f, i, 3));

          for (z = 1; z <= n_abins2; z++)
          {
            if (z <= n_abins)
              s_off = 1;
            else
              s_off = 2;
            t1 = obs_ms_n(f, i, z);
            //  where:  obs_ms_n(f,i,z)=sqrt(var_adjust(6,f)*obs_ms_n(f,i,z));
            if (ageerr_type_ms(f, i) > 0)
            {
              anystring2 = " L@A ";
            }
            else
            {
              anystring2 = " W@A ";
            }
            if (t1 > 0.)
              t1 = square(t1);
            SS_compout << header_ms(f, i, 1) << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gen_ms(f, i) << anystring2 << mkt_ms(f, i) << " " << ageerr_type_ms(f, i) << " " << s_off << " " << exp_ms_sq(f, i, z) << " " << nlen_bin << " " << age_bins(z) << " " << obs_ms(f, i, z) << " " << exp_ms(f, i, z) << " ";
            if (obs_ms(f, i, z) > 0. && t1 > 0. && header_ms(f, i, 3) > 0)
            {
              SS_compout << (obs_ms(f, i, z) - exp_ms(f, i, z)) / (exp_ms_sq(f, i, z) / obs_ms_n(f, i, z)) << " "; // Pearson
              SS_compout << t1 << " "; // sample size
              SS_compout << "NA "; // placeholder for input sample size
              //SS_compout<<obs_ms_n_read(f,i)<<" "; // input sample size (was a big vector)
              SS_compout << square(1.0 / ((obs_ms(f, i, z) - exp_ms(f, i, z)) / exp_ms_sq(f, i, z))) << " "; // effective sample size
              SS_compout << 0.5 * square((obs_ms(f, i, z) - exp_ms(f, i, z)) / (exp_ms_sq(f, i, z) / obs_ms_n(f, i, z))) + sd_offset * log(exp_ms_sq(f, i, z) / obs_ms_n(f, i, z)); //  -logL
            }
            else
            {
              SS_compout << " NA " << t1 << " NA NA ";
            }
            SS_compout << " NA NA " << anystring << endl;
            if (z == n_abins || z == n_abins2)
              SS_compout << header_ms(f, i, 1) << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gen_ms(f, i) << anystring2 << mkt_ms(f, i) << " " << ageerr_type_ms(f, i) << " " << s_off << " " << 1 << " " << nlen_bin << endl;
          }
        } //end have data
      }
    } // end fleet

    if (SzFreq_Nmeth > 0) //  have some sizefreq data
    {
      repli = 0;
      in_superperiod = 0;
      last_t = -999;
      for (iobs = 1; iobs <= SzFreq_totobs; iobs++)
      {
        y = SzFreq_obs_hdr(iobs, 1);
        if (y >= styr) // flag for obs that are used
        {
          N_out++;
          temp2 = 0.0;
          temp1 = 0.0;
          real_month = abs(SzFreq_obs1(iobs, 3)); //  month
          if (real_month > 999)
            real_month -= 1000.;
          f = abs(SzFreq_obs_hdr(iobs, 3));
          gg = SzFreq_obs_hdr(iobs, 4); // gender
          int Sz_method = SzFreq_obs1(iobs, 1);  //  sizecomp method
          int logL_method = Comp_Err_Sz(Sz_method);

          in_superperiod = determine_speriod(in_superperiod, anystring, SzFreq_obs_hdr(iobs, 2), SzFreq_obs_hdr(iobs, 3));

          p = SzFreq_obs_hdr(iobs, 5); // partition
          z_lo = SzFreq_obs_hdr(iobs, 7);
          z_hi = SzFreq_obs_hdr(iobs, 8);
          nbins = z_hi - z_lo +1;
          t = SzFreq_time_t(iobs);
          ALK_time = SzFreq_time_ALK(iobs);
          nsamp = SzFreq_sampleN(iobs);
          temp2 = 0.0;
          temp1 = 0.0;
          if (ALK_time == last_t)
          {
            repli++;
          }
          else
          {
            repli = 1;
            last_t = ALK_time;
          }
          for (z = z_lo; z <= z_hi; z++)
          {
            ocomp = SzFreq_obs(iobs, z); 
            ecomp = value( SzFreq_exp(iobs, z));
            if (z > SzFreq_Nbins(Sz_method))
            {s_off = 2;}
            else
            {s_off = 1;}
            // Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part Ageerr Sex Lbin_lo Lbin_hi Bin Obs Exp
            SS_compout << SzFreq_obs_hdr(iobs, 1) << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gg << " SIZE " << p << " " << Sz_method;
            SS_compout << " " << s_off << " " << SzFreq_units(Sz_method) << " " << SzFreq_scale(Sz_method) << " ";
            if (s_off == 1)
            {
              SS_compout << SzFreq_bins1(Sz_method, z);
            }
            else
            {
              SS_compout << SzFreq_bins1(Sz_method, z - SzFreq_Nbins(Sz_method));
            }
            SS_compout << " " << ocomp << " " << ecomp << " ";
            temp2 += ocomp;
            temp1 += ecomp;

            // Pearson Nsamp_adj Nsamp_in effN Like
            if (nsamp > 0 && SzFreq_obs_hdr(iobs, 3) && (ecomp != 0.0 && ecomp != 1.0) && nbins > 0 ) // check for values to include
            {
                if (logL_method == 0)
                {
                  show_Pearson = (ocomp - ecomp) / sqrt(ecomp * (1.0 - ecomp) / nsamp ); // Pearson for multinomial
                  show_logL = ocomp * log( (ocomp + 1.0e-12) / ( ecomp + 1.0e-12) ) * nsamp;  //  logL
                }
                if (logL_method == 1 || logL_method == 2)
                {
                  dirichlet_Parm = mfexp(selparm(Comp_Err_parmloc(Comp_Err_Sz2(Sz_method),1)));
                  if (logL_method == 1 )
                    { dirichlet_Parm *= nsamp; }
                  show_Pearson = value((ocomp - ecomp) / sqrt(ecomp * (1.0 - ecomp) / nsamp * (nsamp + dirichlet_Parm) / (1. + dirichlet_Parm))); // Pearson for Dirichlet-multinomial using negative-exponential parameterization
                  show_logL =  -SzFreq_each_offset(iobs) / nbins
                   - value( gammln(nsamp * ocomp + dirichlet_Parm * ecomp) - gammln(dirichlet_Parm * ecomp))
                   - value( ( gammln(dirichlet_Parm) - gammln(nsamp + dirichlet_Parm))) / nbins;
                }
                if (logL_method == 3 )  //  MV Tweedie
                {
                }
                SS_compout << show_Pearson << " " << nsamp << " " << SzFreq_sampleN(iobs) << " " << SzFreq_effN(iobs) << " " << show_logL;
            }
            else // sample size zero or skip
            {
              SS_compout << " NA " << " " << nsamp << " " << SzFreq_sampleN(iobs) << " NA NA "; // placeholder
            }
            // Cum_obs Cum_exp SuprPer Used?
            SS_compout << " " << temp2 << " " << temp1 << " " << anystring <<endl;
          }

 /*
          for (z = z1; z <= z2; z++)
          {
            s_off = 1;
            // The following columns printed by the section:
            // Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part
            // Ageerr Sex Lbin_lo Lbin_hi Bin Obs Exp
            SS_compout << SzFreq_obs_hdr(iobs, 1) << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gg << " SIZE " << p << " " << k;
            if (z > SzFreq_Nbins(k))
              s_off = 2;
            SS_compout << " " << s_off << " " << SzFreq_units(k) << " " << SzFreq_scale(k) << " ";
            if (s_off == 1)
            {
              SS_compout << SzFreq_bins1(k, z);
            }
            else
            {
              SS_compout << SzFreq_bins1(k, z - SzFreq_Nbins(k));
            }
            SS_compout << " " << SzFreq_obs(iobs, z) << " " << SzFreq_exp(iobs, z) << " ";
            temp2 += SzFreq_obs(iobs, z);
            temp1 += SzFreq_exp(iobs, z);
            // next add Pearson column
            if (SzFreq_obs_hdr(iobs, 3) > 0)
            {
              if (SzFreq_exp(iobs, z) != 0.0 && SzFreq_exp(iobs, z) != 1.0)
              {
                SS_compout << (SzFreq_obs(iobs, z) - SzFreq_exp(iobs, z)) / sqrt(SzFreq_exp(iobs, z) * (1. - SzFreq_exp(iobs, z)) / SzFreq_sampleN(iobs));
              }
              else
              {
                SS_compout << " NA ";
              }
              // next add the following columns:
              // Nsamp_adj, Nsamp_in (temporarily "NA"), effN
              SS_compout << " " << SzFreq_sampleN(iobs) << " NA " << SzFreq_effN(iobs) << " ";
              // next add Like column
              if (SzFreq_obs(iobs, z) != 0.0 && SzFreq_exp(iobs, z) != 0.0)
              {
                SS_compout << " " << SzFreq_obs(iobs, z) * log(SzFreq_obs(iobs, z) / SzFreq_exp(iobs, z)) * SzFreq_sampleN(iobs);
              }
              else
              {
                SS_compout << " NA ";
              }
            }
            else // sample size zero or skip
            {
              SS_compout << " NA "; // placeholder for Pearson
              SS_compout << " " << SzFreq_sampleN(iobs) << " NA"; // Nsamp_adj and Nsamp_in (NA for now)
              SS_compout << " NA NA "; // placeholder for effN and Like
            }
            // next add the following columns:
            // Cum_obs Cum_exp SuprPer Used?
            SS_compout << " " << temp2 << " " << temp1 << " " << anystring << endl;
            // single row representing info from previous bin-specific rows
            if (z == z2 || z == SzFreq_Nbins(k))
              SS_compout << SzFreq_obs_hdr(iobs, 1) << " " << SzFreq_obs_hdr(iobs, 2) << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " " << repli << " " << gg << " SIZE " << p << " " << k << " " << s_off << " " << 1 << " " << 2 << endl;
          }
  */
        }
      }
    }

    // Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part Ageerr Sex Lbin_lo Lbin_hi Bin Obs Exp Pearson N effN Like Cum_obs Cum_exp SuprPer Used?
    if (Do_Morphcomp > 0)
    {
      for (iobs = 1; iobs <= Morphcomp_nobs; iobs++)
      {
        N_out++;
        y = Morphcomp_obs(iobs, 1);
        real_month = Morphcomp_obs(iobs, 2);
        ALK_time = Morphcomp_obs(iobs, 5 + 1 + Morphcomp_nmorph);
        f = Morphcomp_obs(iobs, 3);
        k = 5 + Morphcomp_nmorph;
        for (z = 6; z <= k; z++)
        {
          SS_compout << y << " " << real_month << " " << Show_Time2(ALK_time)(2, 3) << " " << data_time(ALK_time, f, 3) << " " << f << " " << fleet_area(f) << " 1  1 "
                     << " GP% ";
          SS_compout << " 0 0 0 0 0 " << z - 5 << " " << Morphcomp_obs(iobs, z) << " " << Morphcomp_exp(iobs, z) << " NA " << Morphcomp_obs(iobs, 5) << " NA NA NA NA _ _ " << endl;
        }
      }
    }

    if (Do_TG > 0)
    {
      for (TG = 1; TG <= N_TG; TG++)
      {
        y = TG_release(TG, 3);
        s = TG_release(TG, 4);
        for (TG_t = 0; TG_t <= TG_endtime(TG); TG_t++)
        {
          N_out++;
          t = styr + (y - styr) * nseas + s - 1;
          temp1 = s - 1.;
          //          temp=float(y)+temp1/float(nseas);
          temp = float(y) + 0.01 * int(100. * (azero_seas(s) + seasdur_half(s)));
          // Fill in columns for: Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part Ageerr Sex Lbin_lo Lbin_hi Bin
          SS_compout << y << " NA " << s << " NA " << temp << " NA " << TG_release(TG, 2) << " " << TG << " " << TG_release(TG, 6) << " TAG2 NA NA NA NA NA " <<
              // TAG2 values (total recaptures)
              // Fill in columns for: Obs Exp Pearson Nsamp_adj Nsamp_in effN Like Cum_obs Cum_exp SuprPer Used?
              TG_t << " " << TG_recap_obs(TG, TG_t, 0) << " " << TG_recap_exp(TG, TG_t, 0) << " NA NA NA NA NA NA NA NA ";
          if (TG_t >= TG_mixperiod && TG_use(TG) >= TG_min_recap)
          {
            SS_compout << "_" << endl;
          }
          else
          {
            SS_compout << " skip" << endl;
          }
          // TAG1 values (proportions for each fleet) associated with the above TAG2 output
          if (Nfleet > 1)
            for (f = 1; f <= Nfleet; f++)
            {
              // Fill in columns for: Yr Month Seas Subseas Time Fleet Area Repl. Sexes Kind Part Ageerr Sex Lbin_lo Lbin_hi
              SS_compout << y << " NA " << s << " NA " << temp << " " << f << " " << fleet_area(f) << " " << TG << " " << TG_release(TG, 6) << " TAG1 NA NA NA NA NA " <<
                  // Fill in columns for:: Bin Obs Exp Pearson Nsamp_adj Nsamp_in
                  f << " " << TG_recap_obs(TG, TG_t, f) << " " << TG_recap_exp(TG, TG_t, f) << " NA " << TG_recap_obs(TG, TG_t, 0) << " NA "
                         << " NA NA NA NA NA "; // NA values are for: effN Like Cum_obs Cum_exp SuprPer
              // Fill in Used? column
              if (TG_t >= TG_mixperiod && TG_use(TG) >= TG_min_recap)
              {
                SS_compout << "_" << endl;
              }
              else
              {
                SS_compout << " skip" << endl;
              }
            }
          s++;
          if (s > nseas)
          {
            s = 1;
            y++;
          }
        }
      }
    }

    if (N_out == 0)
      SS_compout << styr << " -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1" << endl;
    SS_compout << styr << " -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1" << endl
               << " End_comp_data" << endl;
  }

  // REPORT_KEYWORD 53 SELEX_database
  if (pick_report_use(53) == "Y")
  {
    SS2out << endl
           << pick_report_name(53) << endl;
    SS2out << "Fleet Yr Kind Sex Bin Selex" << endl;
    for (f = 1; f <= Nfleet; f++)
      for (y = styr - 3; y <= endyr; y++)
      {
        if (y == styr - 3 || y == endyr || (timevary_sel(y, f) > 0 || timevary_sel(y + 1, f) > 0))
        {
          for (gg = 1; gg <= gender; gg++)
          {
            for (z = 1; z <= nlength; z++)
            {
              SS2out << f << " " << y << " L " << gg << " " << len_bins(z) << " " << sel_l(y, f, gg, z) << endl;
            }
            if (seltype(f, 2) != 0)
            {
              if (gg == 1)
              {
                for (z = 1; z <= nlength; z++)
                {
                  SS2out << f << " " << y << " D " << gg << " " << len_bins(z) << " " << retain(y, f, z) << endl;
                }
              }
              else
              {
                for (z = 1; z <= nlength; z++)
                {
                  SS2out << f << " " << y << " D " << gg << " " << len_bins(z) << " " << retain(y, f, z + nlength) << endl;
                }
              }
            }
            if (seltype(f, 2) == 2)
            {
              if (gg == 1)
              {
                for (z = 1; z <= nlength; z++)
                {
                  SS2out << f << " " << y << " DM " << gg << " " << len_bins(z) << " " << discmort(y, f, z) << endl;
                }
              }
              else
              {
                for (z = 1; z <= nlength; z++)
                {
                  SS2out << f << " " << y << " DM " << gg << " " << len_bins(z) << " " << discmort(y, f, z + nlength) << endl;
                }
              }
            }
          }
        }
        if (timevary_sel(y, f + Nfleet) > 0)
        {
          for (gg = 1; gg <= gender; gg++)
            for (a = 0; a <= nages; a++)
            {
              SS2out << f << " " << y << " A " << gg << " " << a << " " << sel_a(y, f, gg, a) << endl;
            }
        }
      }
    SS2out << " end selex output " << endl;
  } // end do report detail
  wrote_bigreport++;
  //  SS2out.close();
  //  SS_compout.close();
  return;
  } //  end write_bigoutput

FUNCTION void SPR_profile()
  {
  // REPORT_KEYWORD 54 SPR/YPR_Profile
  int SPRloop;
  int bio_t_base;
  dvariable Fmult2 = maxpossF;
  dvariable Fcrash = Fmult2;
  dvariable Fmultchanger0 = Fmult2 / 39.;
  dvariable Fmultchanger1;
  dvariable Fmultchanger2;
  dvariable Btgt_prof;
  dvariable Btgt_prof_rec;
  dvariable SPR_last;
  dvariable SPR_trial;
  dvariable YPR_last;

  SS2out << endl
         << pick_report_name(54) << endl;
  y = styr - 3;
  yz = y;
  bio_yr = y;
  eq_yr = y;
  t_base = y + (y - styr) * nseas - 1;
  bio_t_base = styr + (bio_yr - styr) * nseas - 1;

  //  SPAWN-RECR:  call make_fecundity for benchmark bio for SPR loop

  for (s = 1; s <= nseas; s++)
  {
    t = styr - 3 * nseas + s - 1;
    Wt_Age_beg(s) = Wt_Age_t(t, 0); //  used for smrybio
    Wt_Age_mid(s) = Wt_Age_t(t, -1);  //  used in global MSY
    if (s == spawn_seas)
    {
      fec = Wt_Age_t(t, -2);
      SS2out << " repro_output for SPR/YPR: " << fec(1) << endl;}
  }
//  do not recalculate here so force using values from benchmark
  SS2out << "unfished values for SRR: SSB " << SSB0_4_SRR << " R " << R0_4_SRR << " SSBpR " << "  SSBpR: " << SSB0_4_SRR / R0_4_SRR << endl;
  SS2out << "SPRloop Iter Bycatch Fmult F_std SSBpR YpR_dead YpR_dead*Recr YpR_ret*Recr Revenue Cost Profit SSB Recruits SSB/Bzero Tot_Catch ";
  for (f = 1; f <= Nfleet; f++)
  {
    if (fleet_type(f) <= 2)
      SS2out << " " << fleetname(f) << "(" << f << ")Dead";
  }
  for (f = 1; f <= Nfleet; f++)
  {
    if (fleet_type(f) <= 2)
      SS2out << " " << fleetname(f) << "(" << f << ")Ret";
  }
  for (f = 1; f <= Nfleet; f++)
  {
    if (fleet_type(f) <= 2)
      SS2out << " " << fleetname(f) << "(" << f << ")Age";
  }
  for (p = 1; p <= pop; p++)
    for (gp = 1; gp <= N_GP; gp++)
    {
      SS2out << " SSB_Area:" << p << "_GP:" << gp;
    }
  SS2out << endl;
  equ_Recr = 1.0;
  Fishon = 0;
  int SPRloop1_end;
  if (Do_Benchmark == 3)
  {
    SPRloop1_end = 8;
  }
  else
  {
    SPRloop1_end = 7;
  }
  int SPRloops;
  SSBpR_Calc(equ_Recr);
  if (N_bycatch == 0)
  {
    k = 0;
  }
  else
  {
    k = 1;
  }
  for (int with_BYC = 0; with_BYC <= k; with_BYC++)
    for (int SPRloop1 = -1; SPRloop1 <= SPRloop1_end; SPRloop1++)
    {
      Fmultchanger1 = value(pow(0.0001 / Fcrash, 0.025));
      Fmultchanger2 = value(Fcrash / 39.);
      SPRloops = 40;
      switch (SPRloop1)
      {
        case -1:
        {
          SPRloops = 1;
          Fmult2 = 0.0;
          break;
        }
        case 0:
        {
          SPRloops = 40;
          Fmult2 = maxpossF;
          break;
        }
        case 1:
        {
          SPRloops = 40;
          Fmult2 = Fcrash;
          break;
        }
        case 3:
        {
          Fmult2 = 1;
          SPRloops = 1;
          break;
        }
        case 4:
        {
          Fmult2 = SPR_Fmult;
          SPRloops = 1;
          break;
        }
        case 5:
        {
          Fmult2 = Btgt_Fmult;
          SPRloops = 1;
          break;
        }
        case 6:
        {
          Fmult2 = MSY_Fmult;
          SPRloops = 1;
          break;
        }
        case 8:
        {
          Fmult2 = Btgt_Fmult2;
          SPRloops = 1;
          break;
        }
        case 7:
        {
          Fmult2 = MSY_Fmult;
          SPRloops = 40;
          SPR_trial = value(SSB_equil / SSB_virgin);
          SPR_last = SPR_trial * 2.;
          YPR_last = -1.;
          break;
        }
      }
      for (SPRloop = 1; SPRloop <= SPRloops; SPRloop++)
      {
        if (SPRloop1 == 7 && SPRloop > 1)
        {
          if (F_Method > 1)
          {
            Fmult2 *= 1.05;
          }
          else
          {
            Fmult2 = Fmult2 + (1.0 - Fmult2) * 0.05;
          }
          if (SPR_trial <= 0.001)
            SPRloop = 1001;
          SPR_last = SPR_trial;
          YPR_last = YPR_dead;
        }

        for (f = 1; f <= Nfleet; f++)
          for (s = 1; s <= nseas; s++)
          {
            t = bio_t_base + s;
            if (fleet_type(f) == 1 || (fleet_type(f) == 2 && bycatch_setup(f, 3) == 1))
            {
              if (SPRloop1 != 3)
              {
                Hrate(f, t) = Fmult2 * Bmark_RelF_Use(s, f);
              }
              else
              {
                a = styr + (endyr - styr) * nseas + s - 1;
                Hrate(f, t) = Hrate(f, a);
              }
            }
            else if (fleet_type(f) == 2 && bycatch_setup(f, 3) > 1)
            {
              Hrate(f, t) = double(with_BYC) * bycatch_F(f, s);
            }
            else
            {
              Hrate(f, t) = 0.0;
            }
          }
        Fishon = 1;

        SSBpR_Calc(equ_Recr);
        //  SPAWN-RECR:   calc equil spawn-recr in the SPR loop
        SSBpR_temp = SSB_equil;
        Equ_SpawnRecr_Result = Equil_Spawn_Recr_Fxn(SRparm_bench , SSB0_4_SRR, R0_4_SRR, SSBpR_temp); //  returns 2 element vector containing equilibrium biomass and recruitment at this SPR
        Btgt_prof = Equ_SpawnRecr_Result(1);
        Btgt_prof_rec = Equ_SpawnRecr_Result(2);
        if (Btgt_prof < 0.001 || Btgt_prof_rec < 0.001)
        {
          Btgt_prof_rec = 0.0;
          Btgt_prof = 0.;
          if (SPRloop1 == 0)
            Fcrash = Fmult2;
        }
        SS2out << SPRloop1 << " " << SPRloop << " " << with_BYC << " " << Fmult2 << " " << equ_F_std << " " << SSB_equil / (SSB0_4_SRR / R0_4_SRR) << " " << YPR_dead << " "
               << YPR_dead * Btgt_prof_rec << " " << YPR_ret * Btgt_prof_rec << " " << (PricePerF * YPR_val_vec) * Btgt_prof_rec
               << " " << Cost << " " << (PricePerF * YPR_val_vec) * Btgt_prof_rec - Cost << " " << Btgt_prof << " " << Btgt_prof_rec << " " << Btgt_prof / SSB0_4_SRR
               << " " << value(sum(equ_catch_fleet(2)) * Btgt_prof_rec);
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            temp = 0.0;
            for (s = 1; s <= nseas; s++)
            {
              temp += equ_catch_fleet(2, s, f);
            }
            SS2out << " " << temp * Btgt_prof_rec;
          }
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            temp = 0.0;
            for (s = 1; s <= nseas; s++)
            {
              temp += equ_catch_fleet(3, s, f);
            }
            SS2out << " " << temp * Btgt_prof_rec;
          }
        //  report mean age of CATCH of non-bycatch fleets
        for (f = 1; f <= Nfleet; f++)
          if (fleet_type(f) <= 2)
          {
            temp = 0.0;
            temp2 = 0;
            for (s = 1; s <= nseas; s++)
              for (g = 1; g <= gmorph; g++)
                if (use_morph(g) > 0)
                {
                  temp += equ_catage(s, f, g) * r_ages;
                  temp2 += sum(equ_catage(s, f, g));
                }
            if (temp2 > 0.0)
            {
              SS2out << " " << temp / temp2;
            }
            else
              SS2out << " NA";
          }

        for (p = 1; p <= pop; p++)
          for (gp = 1; gp <= N_GP; gp++)
          {
            SS2out << " " << SSB_equil_pop_gp(p, gp) * Btgt_prof_rec;
          }
        SS2out << endl;
        if (SPRloop1 == 0)
        {
          Fmult2 -= Fmultchanger0;
          if (Fmult2 < 0.0)
            Fmult2 = 1.0e-6;
        }
        else if (SPRloop1 == 1)
        {
          Fmult2 *= Fmultchanger1;
        }
        else if (SPRloop1 == 2)
        {
          Fmult2 += Fmultchanger2;
        }
      }
    }

  SS2out << "Finish SPR/YPR profile" << endl;
  SS2out << "#Profile 0 is descending additively from max possible F:  " << maxpossF << endl;
  SS2out << "#Profile 1 is descending multiplicatively half of max possible F" << endl;
  SS2out << "#Profile 2 is additive back to Fcrash: " << Fcrash << endl;
  SS2out << "#value 3 uses endyr F, which has different fleet allocation than benchmark" << endl;
  SS2out << "#value 4 is Fspr: " << SPR_Fmult << endl;
  SS2out << "#value 5 is Fbtgt: " << Btgt_Fmult << endl;
  SS2out << "#value 6 is Fmsy: " << MSY_Fmult << endl;
  if (Do_Benchmark == 3)
    SS2out << "#value 8 is F_Blimit: " << Btgt_Fmult2 << endl;
  SS2out << "#Profile 7 increases from Fmsy to Fcrash" << endl;
  SS2out << "#_NOTE: meanage_of_catch_is_for_total_catch_of_fleet_type==1_or_bycatch_fleets_with_scaled_Hrate" << endl;
  // end SPR/YPR_Profile
  return;
  }

FUNCTION void Global_MSY()
  {
  // REPORT_KEYWORD 55 GLOBAL_MSY
  //  GLOBAL_MSY with knife-edge age selection, then slot-age selection
  SS2out << endl
         << pick_report_name(55) << endl;
  y = styr - 3; //  stores the averaged biology and selectivity, etc. from benchmark
  yz = y;
  bio_yr = y;
  eq_yr = y;
  t_base = y + (y - styr) * nseas - 1;

  for (int MSY_loop = 0; MSY_loop <= 2; MSY_loop++)
  {
    if (MSY_loop == 0)
    {
      SS2out << "#" << endl
             << "ACTUAL_SELECTIVITY_MSY with MSY units as: " << MSY_name << endl;
    }
    else if (MSY_loop == 1)
    {
      SS2out << "#" << endl
             << "KNIFE_AGE_SELECTIVITY_MSY " << endl;
    }
    else
    {
      SS2out << "#" << endl
             << "SLOT_AGE_SELECTIVITY_MSY " << endl;
    }
    SS2out << "------  SPR  SPR SPR SPR SPR SPR SPR SPR SPR # BTGT BTGT BTGT BTGT BTGT BTGT BTGT BTGT   BTGT  BTGT # "
           << "   MSY MSY MSY MSY MSY MSY MSY MSY MSY MSY MSY" << endl
           << "Age SPR  Fmult Fstd   Exploit Recruit SSB Y_dead Y_ret VBIO # SPR   B/B0  Fmult Fstd    Exploit Recruit SSB  Y_dead Y_ret VBIO "
           << " # SPR   B/B0  Fmult Fstd  Exploit Recruit SSB  Y_MSY Y_dead Y_ret VBIO " << endl;

    if (MSY_loop > 0)
    {
      for (int SPRloop1 = 1; SPRloop1 <= nages - 1; SPRloop1++)
      {
        sel_bio.initialize();
        sel_ret_bio.initialize();
        sel_num.initialize();
        sel_ret_num.initialize();
        sel_dead_num.initialize();
        sel_dead_bio.initialize();
        SS2out << SPRloop1 << " ";
        for (s = 1; s <= nseas; s++)
        {
          t = styr - 3 * nseas + s - 1;
          for (g = 1; g <= gmorph; g++)
            if (use_morph(g) > 0)
            {
              for (f = 1; f <= Nfleet; f++)
              {
                if (MSY_loop == 1)
                {
                  sel_bio(s, f, g)(SPRloop1, nages) = Wt_Age_mid(s, g)(SPRloop1, nages); // selected * wt
                  sel_ret_bio(s, f, g)(SPRloop1, nages) = Wt_Age_mid(s, g)(SPRloop1, nages); // selected * retained * wt
                  sel_num(s, f, g)(SPRloop1, nages) = 1.00; // selected numbers
                  sel_ret_num(s, f, g)(SPRloop1, nages) = 1.00; // selected * retained numbers
                  sel_dead_num(s, f, g)(SPRloop1, nages) = 1.00; // sel * (retain + (1-retain)*discmort)
                  sel_dead_bio(s, f, g)(SPRloop1, nages) = Wt_Age_mid(s, g)(SPRloop1, nages); // sel * (retain + (1-retain)*discmort) * wt
                }
                else
                {
                  sel_bio(s, f, g, SPRloop1) = Wt_Age_mid(s, g, SPRloop1); // selected * wt
                  sel_ret_bio(s, f, g, SPRloop1) = Wt_Age_mid(s, g, SPRloop1); // selected * retained * wt
                  sel_num(s, f, g, SPRloop1) = 1.00; // selected numbers
                  sel_ret_num(s, f, g, SPRloop1) = 1.00; // selected * retained numbers
                  sel_dead_num(s, f, g, SPRloop1) = 1.00; // sel * (retain + (1-retain)*discmort)
                  sel_dead_bio(s, f, g, SPRloop1) = Wt_Age_mid(s, g, SPRloop1); // sel * (retain + (1-retain)*discmort) * wt
                }
              }
            }
        }
        show_MSY = 2; //  invokes just brief output in benchmark
        did_MSY = 0;
        Get_Benchmarks(show_MSY);
        did_MSY = 0;
      }
    }
    else
    {
      SS2out << "Actual ";
      show_MSY = 2; //  invokes just brief output in benchmark
      did_MSY = 0;
//    report5 << 0 << " y: " << y << " updated_Repro_output global_1: " << fec(1) << endl;
      Get_Benchmarks(show_MSY);
//    report5 << 0 << " y: " << y << " updated_Repro_output global_2: " << fec(1) << endl;
      did_MSY = 0;
    }
  }
  SS2out << endl;
  return;
  }

//  note that FUNCTION write_Bzero_output() is found in file SS_write.tpl
FUNCTION dvector process_comps(const int sexes, const int sex, dvector& bins, dvector& means, const dvector& tails,
    dvector& obs, dvector& exp)
  {
  dvector more_comp_info(1, 20);
  double cumdist;
  double cumdist_save;
  double temp, temp1, temp2;
  int z;
  more_comp_info.initialize();
  //  sexes is 1 or 2 for numbers of sexes in model
  //  sex is 0, 1, 2, 3 for range of sexes used in this sample
  int nbins = bins.indexmax() / sexes; // find number of bins
  // do both sexes  tails(4) has been set to tails(2) if males not in this sample
  if ((sex == 3 && sexes == 2) || sex == 0 || sexes == 1)
  {
    more_comp_info(1) = obs(tails(1), tails(4)) * means(tails(1), tails(4));
    more_comp_info(2) = exp(tails(1), tails(4)) * means(tails(1), tails(4));
    more_comp_info(3) = more_comp_info(1) - more_comp_info(2);
    //  calc tails of distribution and Durbin-Watson for autocorrelation
    temp1 = 0.0;
    temp2 = 0.0;
    cumdist_save = 0.0;
    cumdist = 0.0;
    for (z = 1; z <= nbins; z++)
    {
      cumdist += exp(z);
      if (sexes == 2)
        cumdist += exp(z + nbins); // add males and females
      if (cumdist >= 0.05 && cumdist_save < 0.05) //  found bin for 5%
      {
        if (z == 1)
        {
          more_comp_info(4) = bins(z);
        } //  set to lower edge
        else
        {
          more_comp_info(4) = bins(z) + (bins(min(z + 1, nbins)) - bins(z)) * (0.05 - cumdist_save) / (cumdist - cumdist_save);
        }
      }
      if (cumdist >= 0.95 && cumdist_save < 0.95) //  found bin for 95%
      {
        more_comp_info(5) = bins(z) + (bins(min(z + 1, nbins)) - bins(z)) * (0.95 - cumdist_save) / (cumdist - cumdist_save);
      }
      cumdist_save = cumdist;

      temp = obs(z) - exp(z); //  obs-exp
      if (z > tails(1))
      {
        more_comp_info(6) += square(temp2 - temp);
        temp1 += square(temp);
      }
      temp2 = temp;
    }

    if (sex == 3 && sexes == 2) // do sex ratio
    {
      more_comp_info(19) = sum(obs(tails(1), tails(2))); //  sum obs female fractions =  %female
      more_comp_info(20) = sum(exp(tails(1), tails(2))); //  sum exp female fractions =  %female
      for (z = tails(3); z <= tails(4); z++)
      {
        temp = obs(z) - exp(z); //  obs-exp
        if (z > tails(3))
        {
          more_comp_info(6) += square(temp2 - temp);
          temp1 += square(temp);
        }
        temp2 = temp;
      }
    }
    more_comp_info(6) = (more_comp_info(6) / temp1) - 2.0;
  }

  if (sex == 1 || (sex == 3 && sexes == 2)) //  need females
  {
    //  where means() holds midpoints of the data length bins
    more_comp_info(7) = (obs(tails(1), tails(2)) * means(tails(1), tails(2))) / sum(obs(tails(1), tails(2)));
    more_comp_info(8) = (exp(tails(1), tails(2)) * means(tails(1), tails(2))) / sum(exp(tails(1), tails(2)));
    more_comp_info(9) = more_comp_info(7) - more_comp_info(8);
    //  calc tails of distribution and Durbin-Watson for autocorrelation
    temp1 = 0.0;
    temp2 = 0.0;
    cumdist_save = 0.0;
    cumdist = 0.0;
    for (z = tails(1); z <= tails(2); z++)
    {
      cumdist += exp(z);
      if (cumdist >= 0.05 * more_comp_info(20) && cumdist_save < 0.05 * more_comp_info(20)) //  found bin for 5%
      {
        if (z == 1)
        {
          more_comp_info(10) = bins(z);
        } //  set to lower edge
        else
        {
          more_comp_info(10) = bins(z) + (bins(min(z + 1, nlen_bin)) - bins(z)) * (0.05 * more_comp_info(20) - cumdist_save) / (cumdist - cumdist_save);
        }
      }
      if (cumdist >= 0.95 * more_comp_info(20) && cumdist_save < 0.95 * more_comp_info(20)) //  found bin for 95%
      {
        more_comp_info(11) = bins(z) + (bins(min(z + 1, nlen_bin)) - bins(z)) * (0.95 * more_comp_info(20) - cumdist_save) / (cumdist - cumdist_save);
      }
      cumdist_save = cumdist;

      temp = obs(z) - exp(z); //  obs-exp
      if (z > tails(1))
      {
        more_comp_info(12) += square(temp2 - temp);
        temp1 += square(temp);
      }
      temp2 = temp; //  save current delta
    }
    more_comp_info(12) = (more_comp_info(12) / temp1) - 2.0;
  }
  if (sex >= 2 && sexes == 2) // need males
  {
    more_comp_info(13) = (obs(tails(3), tails(4)) * means(tails(3), tails(4))) / sum(obs(tails(3), tails(4)));
    more_comp_info(14) = (exp(tails(3), tails(4)) * means(tails(3), tails(4))) / sum(exp(tails(3), tails(4)));
    more_comp_info(15) = more_comp_info(13) - more_comp_info(14);
    //  calc tails of distribution and Durbin-Watson for autocorrelation
    temp1 = 0.0;
    temp2 = 0.;
    cumdist_save = 0.0;
    cumdist = 0.0;
    //  where (1-more_comp_info(20)) is the total of male fractions
    for (z = tails(3); z <= tails(4); z++)
    {
      cumdist += exp(z);
      if (cumdist >= 0.05 * (1.0 - more_comp_info(20)) && cumdist_save < 0.05 * (1.0 - more_comp_info(20))) //  found bin for 5%
      {
        if (z == nbins + 1)
        {
          more_comp_info(16) = bins(z);
        } //  set to lower edge
        else
        {
          more_comp_info(16) = bins(z) + (bins(min(z + 1, 2 * nbins)) - bins(z)) * (0.05 * more_comp_info(20) - cumdist_save) / (cumdist - cumdist_save);
        }
      }
      if (cumdist >= 0.95 * (1.0 - more_comp_info(20)) && cumdist_save < 0.95 * (1.0 - more_comp_info(20))) //  found bin for 95%
      {
        more_comp_info(17) = bins(z) + (bins(min(z + 1, 2 * nbins)) - bins(z)) * (0.95 * (1.0 - more_comp_info(20)) - cumdist_save) / (cumdist - cumdist_save);
      }
      cumdist_save = cumdist;

      temp = obs(z) - exp(z); //  obs-exp
      if (z > tails(3))
      {
        more_comp_info(18) += square(temp2 - temp);
        temp1 += square(temp);
      }
      temp2 = temp; //  save current delta
    }
    more_comp_info(18) = (more_comp_info(18) / temp1) - 2.0;
  }

  return more_comp_info;
  }

FUNCTION int determine_speriod(int s_period, adstring a_string, dvariable var2, dvariable var3)
  {
  if (var2 < 0 && s_period == 0)
  {
    s_period = 1;
    a_string = "Sup";
  }
  else if (var2 < 0 && s_period > 0)
  {
    s_period = 0;
    a_string = "Sup";
  }
  else if (s_period > 0)
  {
    s_period++;
    a_string = "Sup";
  }
  else
  {
    a_string = "_";
  }
  if (var3 < 0)
  {
    a_string += " skip";
  }
  else
  {
    a_string += " _";
  }
  return s_period;
  }
// SS_Label_file  #20. **SS_ALK.tpl**
// SS_Label_file  # * <u>Make_AgeLength_Key()</u>  // calculates age-length key for a particular season and subseason; uses calc_ALK or calc_ALK_log
// SS_Label_file  # * <u>calc_ALK_range()</u>  //  allows for condensing range of lengths for each age, but no longer used
// SS_Label_file  # * <u>calc_ALK()</u>      //  calculates normal distribution of length-at-age
// SS_Label_file  # * <u>calc_ALK_log()</u>  //  for lognormal distribution of length-at-age
// SS_Label_file  #

FUNCTION void Make_AgeLength_Key(const int s, const int subseas)
  {
  //********************************************************************
  /*  SS_Label_FUNCTION 31 Make_AgeLength_Key */
  //  this is called for each subseason of each year
  //  checks to see if a re-calc of the ALK is needed for that time step
  //  if it is, then it loops through all possible biological entities "g" (sex, growth pattern, settlement event, platoon)
  //  then it retrieves the previously calculated and stored mean size-at-age from Ave_Size(t,subseas,gstart)
  //  moves these mean sizes into a _W working vector
  //  then it calls calc_ALK to make and store the age-length key for that subseason for each biological entity

  int gstart = 0;
  dvariable dvar_platoon_ratio = platoon_sd_ratio;
  dvariable dvar_between_platoon = sd_between_platoon;
  dvariable dvar_within_platoon = sd_within_platoon;
  dvar_vector use_Ave_Size_W(0, nages);
  dvar_vector use_SD_Size(0, nages);
  imatrix ALK_range_use(0, nages, 1, 2);
  ALK_idx = (s - 1) * N_subseas + subseas;
  if (ALK_subseas_update(ALK_idx) == 1) //  so need to calculate
  {
    ALK_subseas_update(ALK_idx) = 0; //  reset to 0 to indicate update has been done
    gp = 0;
    // calculate the between and within stdev ratio
	// when sd_ratio_rd is > 0, values are constant and calculations are already done.
    if (sd_ratio_rd < 0)
    {
      dvar_platoon_ratio = MGparm(sd_ratio_param_ptr);
      dvar_between_platoon = sqrt(1. / (1. + dvar_platoon_ratio * dvar_platoon_ratio));
      dvar_within_platoon = dvar_platoon_ratio * dvar_between_platoon;
      platoon_sd_ratio = value(dvar_platoon_ratio);
      sd_between_platoon = value(dvar_between_platoon);
      sd_within_platoon = value(dvar_within_platoon);
    }

    for (int sex = 1; sex <= gender; sex++)
      for (GPat = 1; GPat <= N_GP; GPat++)
      {
        gp = gp + 1;
        gstart = g_Start(gp); //  base platoon
        for (settle = 1; settle <= N_settle_timings; settle++)
        {
          gstart += N_platoon;
          if (recr_dist_pattern(GPat, settle, 0) > 0)
          {

            //  update the sd_within and sb_between here.  Used to be in growth2 function
            //  SS_Label_Info_16.5.2  #do calculations related to std.dev. of size-at-age
            //  SS_Label_Info_16.5.3 #if (y=styr), calc CV_G(gp,s,a) by interpolation on age or LAA
            //  doing this just at y=styr prevents the CV from changing as time-vary growth updates over time
            g = gstart;
            if (CV_const(gp) > 0 && y == styr)
            {
              for (a = 0; a <= nages; a++)
              {
                if (real_age(g, ALK_idx, a) < AFIX)
                {
                  CV_G(gp, ALK_idx, a) = CVLmin(gp);
                }
                else if (real_age(g, ALK_idx, a) >= AFIX2_forCV)
                {
                  CV_G(gp, ALK_idx, a) = CVLmax(gp);
                }
                else if (CV_depvar_a == 0)
                {
                  CV_G(gp, ALK_idx, a) = CVLmin(gp) + (Ave_Size(t, subseas, g, a) - Lmin(gp)) * CV_delta(gp);
                }
                else
                {
                  CV_G(gp, ALK_idx, a) = CVLmin(gp) + (real_age(g, ALK_idx, a) - AFIX) * CV_delta(gp);
                }
              } // end age loop
            }
            else
            {
              //  already set constant to CVLmi
            }
            //  SS_Label_Info_16.5.4  #calc stddev of size-at-age from CV_G(gp,s,a) and Ave_Size(t,g,a)
            if (CV_depvar_b == 0)
            {
              Sd_Size_within(ALK_idx, g) = SD_add_to_LAA + elem_prod(CV_G(gp, ALK_idx), Ave_Size(t, subseas, g));
            }
            else
            {
              Sd_Size_within(ALK_idx, g) = SD_add_to_LAA + CV_G(gp, ALK_idx);
            }
            //  SS_Label_Info_16.3.5  #if platoons being used, calc the stddev between platoons
            if (N_platoon > 1)
            {
              Sd_Size_between(ALK_idx, g) = Sd_Size_within(ALK_idx, g) * dvar_between_platoon;
              Sd_Size_within(ALK_idx, g) *= dvar_within_platoon;
            }

            if (docheckup == 1)
            {
              echoinput << "with lingrow; subseas: " << subseas << " sex: " << sx(g) << " gp: " << GP4(g) << " g: " << g << endl;
              echoinput << "size " << Ave_Size(t, subseas, g)(0, min(6, nages)) << " @nages " << Ave_Size(t, subseas, g, nages) << endl;
              if (CV_depvar_b == 0)
                echoinput << "CV   " << CV_G(gp, ALK_idx)(0, min(6, nages)) << " @nages " << CV_G(gp, ALK_idx, nages) << endl;
              echoinput << "sd   " << Sd_Size_within(ALK_idx, g)(0, min(6, nages)) << " @nages " << Sd_Size_within(ALK_idx, g, nages) << endl;
            }

            //  end sd_within updating

            for (gp2 = 1; gp2 <= N_platoon; gp2++) // loop the platoons
            {
              g = gstart + ishadow(gp2);

              use_Ave_Size_W = Ave_Size(t, subseas, gstart);
              use_SD_Size = Sd_Size_within(ALK_idx, gstart);
              if (N_platoon > 1)
              {
                use_Ave_Size_W += shadow(gp2) * Sd_Size_between(ALK_idx, gstart);
                Ave_Size(t, subseas, g) = use_Ave_Size_W; // only needed for reporting because use_Ave_Size_W used for calcs
                Sd_Size_within(ALK_idx, g) = use_SD_Size; //  ditto; also same sd is used for all platoons
              }

              if (Grow_logN == 0)
              {
                ALK(ALK_idx, g) = calc_ALK(len_bins, use_Ave_Size_W, use_SD_Size);
              }
              else
              {
                ALK(ALK_idx, g) = calc_ALK_log(log_len_bins, use_Ave_Size_W, use_SD_Size);
              }
            } // end platoon loop
          }
        } // end settle loop
      } // end growth pattern&gender loop
  }
  } //  end Make_AgeLength_Key

FUNCTION imatrix calc_ALK_range(const dvector& len_bins, const dvar_vector& mean_len_at_age, const dvar_vector& sd_len_at_age,
    const double ALK_tolerance)
  {
  // SS_Label_FUNCTION_31.2 # calc_ALK_range finds the range for the distribution of length for each age
  int a, z = 0; // declare indices
  int nlength = len_bins.indexmax(); // find number of lengths
  int nages = mean_len_at_age.indexmax(); // find number of ages
  imatrix ALK_range(0, nages, 1, 2); // stores minimum and maximum
  dvariable len_dev;
  double ALK_tolerance_2;
  ALK_tolerance_2 = 1.0 - ALK_tolerance;
  for (a = 0; a <= nages; a++)
  {
    if (ALK_tolerance == 0.00)
    {
      ALK_range(a, 1) = 1;
      ALK_range(a, 2) = nlength;
    }
    else
    {
      z = 1;
      temp = 0.0;
      while (temp < ALK_tolerance && z < nlength)
      {
        len_dev = (len_bins(z) - mean_len_at_age(a)) / (sd_len_at_age(a));
        temp = cumd_norm(len_dev);
        z++;
      }
      ALK_range(a, 1) = z;
      temp = 0.0;
      while (temp < ALK_tolerance_2 && z < nlength)
      {
        len_dev = (len_bins(z) - mean_len_at_age(a)) / (sd_len_at_age(a));
        temp = cumd_norm(len_dev);
        z++;
      } // end length loop
      ALK_range(a, 2) = min(z, nlength);
    }
  } // end age loop
  return (ALK_range);
  }

// the function calc_ALK is called by Make_AgeLength_Key to calculate the distribution of length for each age
FUNCTION dvar_matrix calc_ALK(const dvector& len_bins, const dvar_vector& mean_len_at_age, const dvar_vector& sd_len_at_age)
  {
  // the function calc_ALK is called by Make_AgeLength_Key to calculate the distribution of length for each age
  RETURN_ARRAYS_INCREMENT();
  // SS_Label_FUNCTION_31.2 #Calculate the ALK
  int a, z; // declare indices
  int nlength = len_bins.indexmax(); // find number of lengths
  int nages = mean_len_at_age.indexmax(); // find number of ages
  dvar_matrix ALK_w(0, nages, 1, nlength); // create matrix to return with length vectors for each age
  dvar_vector AL(1, nlength + 1); // create temporary vector
  dvariable len_dev;
  //  ALK_count++;
  ALK_w.initialize();
  for (a = 0; a <= nages; a++)
  {
    AL.initialize();
    for (z = 1; z <= nlength; z++)
    {
      len_dev = (len_bins(z) - mean_len_at_age(a)) / (sd_len_at_age(a));
      AL(z) = cumd_norm(len_dev);
    }
    AL(nlength + 1, nlength + 1) = 1.0;
    ALK_w(a) = first_difference(AL);
    ALK_w(a, 1) += AL(1); //  because first bin is from cumulative calc
  } // end age loop

  RETURN_ARRAYS_DECREMENT();
  return (ALK_w);
  }

FUNCTION dvar_matrix calc_ALK_log(const dvector& len_bins, const dvar_vector& mean_len_at_age, const dvar_vector& sd_len_at_age)
  {
  RETURN_ARRAYS_INCREMENT();
  //SS_Label_FUNCTION_31.3 #Calculate the ALK with lognormal error, called when Grow_logN==1
  int a, z; // declare indices
  int nlength = len_bins.indexmax(); // find number of lengths
  int nages = mean_len_at_age.indexmax(); // find number of ages
  dvar_matrix ALK_w(0, nages, 1, nlength); // create matrix to return with length vectors for each age
  dvar_vector AL(1, nlength + 1); // create temporary vector
  dvariable len_dev;
  dvariable temp;

  AL(1) = 0.0;
  AL(nlength + 1) = 1.0; //  terminal values that are not recalculated

  for (a = 0; a <= nages; a++)
  {
    temp = log(mean_len_at_age(a)) - 0.5 * sd_len_at_age(a) * sd_len_at_age(a);
    for (z = 2; z <= nlength; z++)
    {
      len_dev = (len_bins(z) - temp) / (sd_len_at_age(a));
      AL(z) = cumd_norm(len_dev);
    } // end length loop
    ALK_w(a) = first_difference(AL);
  } // end age loop
  RETURN_ARRAYS_DECREMENT();
  return (ALK_w);
  }

// SS_Label_file  #21. **SS_timevaryparm.tpl**
// SS_Label_file  # * <u>make_timevaryparm()</u>  // makes parameters a function of input environmental data time series
// SS_Label_file  # * <u>make_densitydependent_parm()</u>  // for the current year, changes a parameter value as a function of summary bio or recruitment at beginning of this year
// SS_Label_file  #

//*********************************************************************
 /*  SS_Label_Function_14 #make_timevaryparm():  create trend and block time series */
FUNCTION void make_timevaryparm()
  {
  dvariable baseparm;
  baseparm_min = -999.;  //  fill array with default
  baseparm_max = 999;  //  fill array with default
  dvariable endtrend;
  dvariable infl_year;
  dvariable slope;
  dvariable norm_styr;
  //  note:  need to implement the approach that keeps within bounds of base parameter

  int timevary_parm_cnt_all;
  timevary_parm_cnt_all = 0;
  if (do_once == 1)
    echoinput << endl
              << "**********************" << endl
              << "number of parameters with timevary:  " << timevary_cnt << endl;

  for (int tvary = 1; tvary <= timevary_cnt; tvary++)
  {
    ivector timevary_setup(1, 14);
    timevary_setup(1, 14) = timevary_def[tvary](1, 14);
    if (do_once == 1)
      echoinput << "timevary #: " << tvary << endl
                << "setup:  " << timevary_setup << endl;
    //  what type of parameter is being affected?  get the baseparm and its bounds
    switch (timevary_setup(1)) //  parameter type
    {
      case 1: // MG
      {
        baseparm = MGparm(timevary_setup(2)); //  index of base parm
        baseparm_min(tvary) = MGparm_LO(timevary_setup(2));
        baseparm_max(tvary) = MGparm_HI(timevary_setup(2));
        if (do_once == 1)
          echoinput << "base MGparm " << baseparm << endl;
        for (j = timevary_setup(3); j < timevary_def[tvary + 1](3); j++)
        {
          timevary_parm_cnt_all++;
          timevary_parm(timevary_parm_cnt_all) = MGparm(N_MGparm + j);
          if (do_once == 1)
            echoinput << j << " timevary_parm: " << timevary_parm(timevary_parm_cnt_all) << endl;
        }
        parm_timevary(tvary) = baseparm; //  fill timeseries with base parameter, just in case
        break;
      }
      case 2: // SR
      {
        baseparm = SRparm(timevary_setup(2)); //  index of base parm
        baseparm_min(tvary) = SRparm_LO(timevary_setup(2));
        baseparm_max(tvary) = SRparm_HI(timevary_setup(2));
        if (do_once == 1)
          echoinput << "base SRparm " << baseparm << endl;
        for (j = timevary_setup(3); j < timevary_def[tvary + 1](3); j++)
        {
          timevary_parm_cnt_all++;
          timevary_parm(timevary_parm_cnt_all) = SRparm(N_SRparm(SR_fxn) + 3 + j - timevary_SRparm_first + 1);
          if (do_once == 1)
            echoinput << j << " timevary_parm: " << timevary_parm(timevary_parm_cnt_all) << endl;
        }
        parm_timevary(tvary) = baseparm; //  fill timeseries with base parameter, just in case
        break;
      }
      case 3: // Q
      {
        baseparm = Q_parm(timevary_setup(2)); //  index of base parm
        baseparm_min(tvary) = Q_parm_LO(timevary_setup(2));
        baseparm_max(tvary) = Q_parm_HI(timevary_setup(2));
        if (do_once == 1)
          echoinput << "base Qparm " << baseparm << endl;
        for (j = timevary_setup(3); j < timevary_def[tvary + 1](3); j++)
        {
          timevary_parm_cnt_all++;
          timevary_parm(timevary_parm_cnt_all) = Q_parm(Q_Npar + j - timevary_parm_start_Q + 1);
          if (do_once == 1)
            echoinput << j << " timevary_parm: " << timevary_parm(timevary_parm_cnt_all) << endl;
        }
        parm_timevary(tvary) = baseparm; //  fill timeseries with base parameter, just in case
        break;
      }
      case 5: // selex
      {
        baseparm = selparm(timevary_setup(2)); //  index of base parm
        baseparm_min(tvary) = selparm_LO(timevary_setup(2));
        baseparm_max(tvary) = selparm_HI(timevary_setup(2));
        if (do_once == 1)
          echoinput << "base selparm " << baseparm << endl;
        for (j = timevary_setup(3); j < timevary_def[tvary + 1](3); j++)
        {
          timevary_parm_cnt_all++;
          timevary_parm(timevary_parm_cnt_all) = selparm(N_selparm + j - timevary_parm_start_sel + 1);
          if (do_once == 1)
            echoinput << j << " timevary_parm: " << timevary_parm(timevary_parm_cnt_all) << endl;
        }
        parm_timevary(tvary) = baseparm; //  fill timeseries with base parameter, just in case
        break;
      }
    }

    timevary_parm_cnt = timevary_setup(3); //  first  parameter used to create timevary effect on baseparm
    if (timevary_setup(4) > 0) //  block
    {
      if (do_once == 1)
        echoinput << "block pattern " << z << endl;
      z = timevary_setup(4); // specified block pattern
      g = 1;
      temp = baseparm;
      for (a = 1; a <= Nblk(z); a++)
      {
        switch (timevary_setup(5))
        {
          case 0:
          {
            temp = baseparm * mfexp(timevary_parm(timevary_parm_cnt));
            timevary_parm_cnt++;
            break;
          }
          case 1:
          {
            temp = baseparm + timevary_parm(timevary_parm_cnt);
            timevary_parm_cnt++;
            break;
          }
          case 2:
          {
            temp = timevary_parm(timevary_parm_cnt); //  direct assignment of block value
            timevary_parm_cnt++;
            break;
          }
          case 3:
          {
            temp += timevary_parm(timevary_parm_cnt); //  block as offset from previous block
            timevary_parm_cnt++;
            break;
          }
        }

        for (int y1 = Block_Design(z, g); y1 <= Block_Design(z, g + 1); y1++) // loop years for this block
        {
          parm_timevary(tvary, y1) = temp;
        }
        g += 2;
      }
      //        timevary_parm_cnt--;    // back out last increment
    } // end uses blocks

    else if (timevary_setup(4) < 0) //  trend
    {
      // timevary_parm(timevary_parm_cnt+0) = offset for the trend at endyr; 3 options available below
      // timevary_parm(timevary_parm_cnt+1) = inflection year; 2 options available
      // timevary_parm(timevary_parm_cnt+2) = stddev of normal at inflection year
      //  calc endyr value,
      if (do_once == 1)
        echoinput << "logistic trend over time " << endl;
      if (timevary_setup(4) == -1) // use logistic transform to keep with bounds of the base parameter
      {
        endtrend = log((baseparm_max(tvary) - baseparm_min(tvary) + 0.0000002) / (baseparm - baseparm_min(tvary) + 0.0000001) - 1.) / (-2.); // transform the base parameter
        endtrend += timevary_parm(timevary_parm_cnt); //  add the offset  Note that offset value is in the transform space
        endtrend = baseparm_min(tvary) + (baseparm_max(tvary) - baseparm_min(tvary)) / (1. + mfexp(-2. * endtrend)); // backtransform
        infl_year = log(0.5) / (-2.); // transform the base parameter
        infl_year += timevary_parm(timevary_parm_cnt + 1); //  add the offset  Note that offset value is in the transform space
        infl_year = r_years(styr) + (r_years(endyr) - r_years(styr)) / (1. + mfexp(-2. * infl_year)); // backtransform
      }
      else if (timevary_setup(4) == -2) // set ending value directly
      {
        endtrend = timevary_parm(timevary_parm_cnt);
        infl_year = timevary_parm(timevary_parm_cnt + 1);
      }
      else if (timevary_setup(4) == -3) // use parm as fraction of way between bounds
      {
        endtrend = baseparm_min(tvary) + (baseparm_max(tvary) - baseparm_min(tvary)) * timevary_parm(timevary_parm_cnt);
        infl_year = r_years(styr) + (r_years(endyr) - r_years(styr)) * timevary_parm(timevary_parm_cnt + 1);
      }
      slope = timevary_parm(timevary_parm_cnt + 2);
      timevary_parm_cnt += 3;

      norm_styr = cumd_norm((r_years(styr) - infl_year) / slope);
      temp = (endtrend - baseparm) / (cumd_norm((r_years(endyr) - infl_year) / slope) - norm_styr); //  delta in cum_norm between styr and endyr

      for (int y1 = styr; y1 <= YrMax; y1++)
      {
        if (y1 <= endyr)
        {
          parm_timevary(tvary, y1) = baseparm + temp * (cumd_norm((r_years(y1) - infl_year) / slope) - norm_styr);
        }
        else
        {
          parm_timevary(tvary, y1) = parm_timevary(tvary, endyr);
        }
      }
      parm_timevary(tvary, styr - 1) = baseparm;
    }

    if (timevary_setup(7) > 0) //  env link (negative value indicates density-dependence which is calculated year-by-year in different function)
    {
      if (do_once == 1)
        echoinput << "env_link to env_variable: " << timevary_setup(7) << "  using link_type " << timevary_setup(6) << endl;
      switch (int(timevary_setup(6)))
      {
        case 1: //  exponential  env link
        {
          for (int y1 = styr - 1; y1 <= YrMax; y1++)
          {
            parm_timevary(tvary, y1) *= mfexp(timevary_parm(timevary_parm_cnt) * (env_data(y1, timevary_setup(7))));
          }
          timevary_parm_cnt++;
          break;
        }
        case 2: //  linear  env link
        {
          for (int y1 = styr - 1; y1 <= YrMax; y1++)
          {
            parm_timevary(tvary, y1) += timevary_parm(timevary_parm_cnt) * env_data(y1, timevary_setup(7));
          }
          timevary_parm_cnt++;
          break;
        }
        case 3: //  result constrained by baseparm_min-max; input values are unit normal
        {
          dvariable temp;
          double p_range = baseparm_max(tvary) - baseparm_min(tvary);

          for (int y1 = env_data_minyr(timevary_setup(7)); y1 <= env_data_maxyr(timevary_setup(7)); y1++)
          {
            temp = log((parm_timevary(tvary, y1) - baseparm_min(tvary) + 1.0e-7) / (baseparm_max(tvary) - parm_timevary(tvary, y1) + 1.0e-7));
            temp += timevary_parm(timevary_parm_cnt) * env_data(y1, timevary_setup(7));
            parm_timevary(tvary, y1) = baseparm_min(tvary) + p_range / (1.0 + exp(-temp));
          }
          timevary_parm_cnt++;
          break;
        }
        case 4: //  logistic env link
        {
          // first parm is offset; second is slope
          for (int y1 = styr - 1; y1 <= YrMax; y1++)
          {
            parm_timevary(tvary, y1) *= 2.00000 / (1.00000 + mfexp(-timevary_parm(timevary_parm_cnt + 1) * (env_data(y1, timevary_setup(7)) - timevary_parm(timevary_parm_cnt))));
          }
          timevary_parm_cnt += 2;
          break;
        }
      }
    }
    //  SS_Label_Info_14.3 #Create parm dev randwalks if needed
    if (timevary_setup(8) > 0) //  devs
    {
      k = timevary_setup(8); //  dev used
      if (do_once == 1)
        echoinput << "dev vector #: " << k << endl;
      parm_dev_stddev(k) = timevary_parm(timevary_parm_cnt);
      parm_dev_rho(k) = timevary_parm(timevary_parm_cnt + 1);
      int picker = timevary_setup(9);  //  selects the method for creating time-vary parameter from dev vector

      switch (picker)
      {
        case 1:
        {
          for (j = timevary_setup(10); j <= timevary_setup(11); j++)
          {
            parm_timevary(tvary, j) *= mfexp(parm_dev(k, j) * parm_dev_stddev(k));
          }
          break;
        }
        case 2:
        {
          for (j = timevary_setup(10); j <= timevary_setup(11); j++)
          {
            parm_timevary(tvary, j) += parm_dev(k, j) * parm_dev_stddev(k);
          }
          break;
        }
        case 3:
        {
          parm_dev_rwalk(k, timevary_setup(10)) = parm_dev(k, timevary_setup(10)) * parm_dev_stddev(k);
          parm_timevary(tvary, timevary_setup(10)) += parm_dev_rwalk(k, timevary_setup(10));
          for (j = timevary_setup(10) + 1; j <= timevary_setup(11); j++)
          {
            parm_dev_rwalk(k, j) = parm_dev_rwalk(k, j - 1) + parm_dev(k, j) * parm_dev_stddev(k);
            parm_timevary(tvary, j) += parm_dev_rwalk(k, j);
          }
          break;
        }
        case 4: // mean reverting random walk
        {
          parm_dev_rwalk(k, timevary_setup(10)) = parm_dev(k, timevary_setup(10)) * parm_dev_stddev(k); //  1st yr dev
          parm_timevary(tvary, timevary_setup(10)) += parm_dev_rwalk(k, timevary_setup(10)); //  add dev to current value
          for (j = timevary_setup(10) + 1; j <= timevary_setup(11); j++)
          {
            //    =(1-rho)*mean + rho*prevval + dev   //  where mean = 0.0
            parm_dev_rwalk(k, j) = parm_dev_rho(k) * parm_dev_rwalk(k, j - 1) + parm_dev(k, j) * parm_dev_stddev(k); //  update MRRW using annual dev
            parm_timevary(tvary, j) += parm_dev_rwalk(k, j); //  add dev to current value of annual parameter, which may previously be adjusted by block or env
          }
          break;
        }
        case 6: // mean reverting random walk with penalty to keep rmse near 1.0
        {
          parm_dev_rwalk(k, timevary_setup(10)) = parm_dev(k, timevary_setup(10)) * parm_dev_stddev(k); //  1st yr dev
          parm_timevary(tvary, timevary_setup(10)) += parm_dev_rwalk(k, timevary_setup(10)); //  add dev to current value
          for (j = timevary_setup(10) + 1; j <= timevary_setup(11); j++)
          {
            //    =(1-rho)*mean + rho*prevval + dev   //  where mean = 0.0
            parm_dev_rwalk(k, j) = parm_dev_rho(k) * parm_dev_rwalk(k, j - 1) + parm_dev(k, j) * parm_dev_stddev(k); //  update MRRW using annual dev
            parm_timevary(tvary, j) += parm_dev_rwalk(k, j); //  add dev to current value of annual parameter, which may previously be adjusted by block or env
          }
          break;
        }
        case 5: // mean reverting random walk constrained by base parameter's min-max:
        {
          //          NOTE:  if the stddev parameter is greater than 1.8, the distribution of adjusted parameters will become U-shaped
          dvariable temp;
          double p_range = baseparm_max(tvary) - baseparm_min(tvary);
          int j = timevary_setup(10);
          parm_dev_rwalk(k, j) = parm_dev(k, j) * parm_dev_stddev(k); //  1st yr dev
          //            p_base=(parm_timevary(tvary,j)-baseparm_min(tvary))/(baseparm_max(tvary)-baseparm_min(tvary));  //  convert parm to (0,1) scale
          //            temp=log(p_base/(1.-p_base)) + parm_dev_rwalk(k,j);  //  convert to logit and add dev; so dev must be in units of the logit
          temp = log((parm_timevary(tvary, j) - baseparm_min(tvary) + 1.0e-7) / (baseparm_max(tvary) - parm_timevary(tvary, j) + 1.0e-7));
          parm_timevary(tvary, j) = baseparm_min(tvary) + p_range / (1.0 + exp(-temp - parm_dev_rwalk(k, j)));
          for (j = timevary_setup(10) + 1; j <= timevary_setup(11); j++)
          {
            //    =(1-rho)*mean + rho*prevval + dev   //  where mean = 0.0
            parm_dev_rwalk(k, j) = parm_dev_rho(k) * parm_dev_rwalk(k, j - 1) + parm_dev(k, j) * parm_dev_stddev(k); //  update MRRW using annual dev
            temp = log((parm_timevary(tvary, j) - baseparm_min(tvary) + 1.0e-7) / (baseparm_max(tvary) - parm_timevary(tvary, j) + 1.0e-7));
            parm_timevary(tvary, j) = baseparm_min(tvary) + p_range / (1.0 + exp(-temp - parm_dev_rwalk(k, j)));
          }
          break;
        }
      }
      if (timevary_setup(14) == 1) //  continue_last
      {
        for (j = timevary_setup(11) + 1; j <= YrMax; j++)
          parm_timevary(tvary, j) = parm_timevary(tvary, timevary_setup(11));
      }
    }
    if (do_once == 1)
      echoinput << "result by year: " << parm_timevary(tvary) << endl;
  }
  } //  end timevary_parm setup for all years

FUNCTION void make_densitydependent_parm(int const y1)
  {

  for (int tvary = 1; tvary <= timevary_cnt; tvary++)
  {
    ivector timevary_setup(1, 13);
    timevary_setup(1, 13) = timevary_def[tvary](1, 13);
    if (timevary_setup(7) < 0) //  density-dependent
    {
      int env_var = timevary_setup(7);
      timevary_parm_cnt = timevary_setup(3); //  link parameter index
      if (do_once == 1)
        echoinput << y1 << "  density-dependent to env_variable: " << env_var << "  using link_type "
         << timevary_setup(6) << "  env: " << env_data(y1, env_var) << "  parm: " << timevary_parm(timevary_parm_cnt) << endl;
      switch (int(timevary_setup(6)))
      {
        case 1: //  exponential  env link
        {
          parm_timevary(tvary, y1) *= mfexp(timevary_parm(timevary_parm_cnt) * env_data(y1, env_var));
          break;
        }
        case 2: //  linear  env link
        {
          parm_timevary(tvary, y1) += timevary_parm(timevary_parm_cnt) * env_data(y1, env_var);
          break;
        }
        case 3: //  result constrained by baseparm_min-max; input values are unit normal
        {
          dvariable temp;
          double p_range = baseparm_max(tvary) - baseparm_min(tvary);
          temp = log((parm_timevary(tvary, y1) - baseparm_min(tvary) + 1.0e-7) / (baseparm_max(tvary) - parm_timevary(tvary, y1) + 1.0e-7));
          temp += timevary_parm(timevary_parm_cnt) * env_data(y1, env_var);
          parm_timevary(tvary, y1) = baseparm_min(tvary) + p_range / (1.0 + exp(-temp));
          break;
        }
        case 4: //  logistic env link
        {
          // first parm is offset ; second is slope
          parm_timevary(tvary, y1) = 2.00000 / (1.00000 + mfexp(-timevary_parm(timevary_parm_cnt + 1) * (env_data(y1, env_var) - timevary_parm(timevary_parm_cnt))));
          break;
        }
      }
    }
  }
  }

// SS_Label_file  #22. **SS_tagrecap.tpl**
// SS_Label_file  # * <u>Tag_Recapture()</u>  //  calculates expected values for number of tags returned by each fleet(and area), in each time step, for each tag release group
// SS_Label_file  #

FUNCTION void Tag_Recapture()
  {
  //  SS_Label_Info_24.15 #do tag mortality, movement and recapture  revise 7/10/2019
  dvariable TG_init_loss;
  dvariable TG_chron_loss;
  TG_recap_exp.initialize();

  //  get reporting rates by fleet that will be used for all Tag Groups
  for (f = 1; f <= Nfleet1; f++)
  {
    j = 3 * N_TG + f;
    if (TG_parm_PH(j) == -1000.)
    {
      TG_report(f) = TG_report(f - 1);
    } //  do nothing keep same value
    else
    {
      if (TG_parm_PH(j) > -1000.)
      {
        k = j;
      }
      else
      {
        k = -1000 - TG_parm_PH(j);
      }
      TG_report(f) = mfexp(TG_parm(k)) / (1. + mfexp(TG_parm(k)));
    }
    j += Nfleet1;
    if (TG_parm_PH(j) == -1000.)
    {
      TG_rep_decay(f) = TG_rep_decay(f - 1);
    } //  do nothing keep same value
    else
    {
      if (TG_parm_PH(j) > -1000.)
      {
        k = j;
      }
      else
      {
        k = -1000 - TG_parm_PH(j);
      }
      TG_rep_decay(f) = TG_parm(k);
    }
  }
  for (TG = 1; TG <= N_TG; TG++)
  {
    firstseas = int(TG_release(TG, 4)); // release season
    t = int(TG_release(TG, 5)); // release t index calculated in data section from year and season of release
    p = int(TG_release(TG, 2)); // release area
    gg = int(TG_release(TG, 6)); // gender (1=fem; 2=male; 0=both
    a1 = int(TG_release(TG, 7)); // age at release

    TG_alive.initialize();
    if (gg == 0)
    {
      for (g = 1; g <= gmorph; g++)
      {
        TG_alive(p, g) = natage(t, p, g, a1);
      } //  gets both genders
    }
    else
    {
      for (g = 1; g <= gmorph; g++)
      {
        if (sx(g) == gg)
        {
          TG_alive(p, g) = natage(t, p, g, a1);
        } //  only does the selected gender
      }
    }
    if (TG_parm_PH(TG) == -1000.)
    {
    } //  do nothing keep same TG_init_loss
    else
    {
      if (TG_parm_PH(TG) > -1000.)
      {
        k = TG;
      }
      else
      {
        k = -1000 - TG_parm_PH(TG);
      }
      TG_init_loss = mfexp(TG_parm(k)) / (1. + mfexp(TG_parm(k)));
    }

    //  get chronic loss parameter
    j = TG + N_TG;
    if (TG_parm_PH(j) == -1000.)
    {
    } //  do nothing keep same value
    else
    {
      if (TG_parm_PH(j) > -1000.)
      {
        k = j;
      }
      else
      {
        k = -1000 - TG_parm_PH(j) + N_TG;
      }
      TG_chron_loss = mfexp(TG_parm(k)) / (1. + mfexp(TG_parm(k)));
    }
    TG_alive /= sum(TG_alive); // proportions across morphs at age a1 in release area p at time of release t
    TG_alive *= TG_release(TG, 8); //  number released as distributed across morphs
    TG_alive *= (1. - TG_init_loss); // initial mortality
    if (save_for_report > 0)
    {
      TG_save(TG, 1) = value(TG_init_loss);
      TG_save(TG, 2) = value(TG_chron_loss);
    }
    TG_t = 0;
    for (y = TG_release(TG, 3); y <= endyr; y++)
    {
      for (s = firstseas; s <= nseas; s++)
      {
        if (save_for_report > 0 && TG_t <= TG_endtime(TG))
        {
          TG_save(TG, 3 + TG_t) = value(sum(TG_alive));
        } //  OK to do simple sum because only selected morphs are populated

        for (p = 1; p <= pop; p++)
        {
          for (g = 1; g <= gmorph; g++)
            if (TG_use_morph(TG, g) > 0)
            {
              for (f = 1; f <= Nfleet; f++)
                if (fleet_area(f) == p)
                {
                  // calculate recaptures by fleet
                  // NOTE:  Sel_for_tag(t,f,g,a1) = sel_ret_num(s,f,g,a1)*Hrate(f,t)
                  if (F_Method == 1)
                  {
                    TG_recap_exp(TG, TG_t, f) += TG_alive(p, g) // tags recaptured
                        * mfexp(-(natM(t, p, GP3(g), a1) + TG_chron_loss) * seasdur_half(s)) * Sel_for_tag(t, f, g, a1) * TG_report(f) * mfexp(TG_t * TG_rep_decay(f));
                  }
                  else // use for method 2 and 3
                  {
                    TG_recap_exp(TG, TG_t, f) += TG_alive(p, g) * Sel_for_tag(t, f, g, a1) / (Z_rate(t, p, g, a1) + TG_chron_loss) * (1. - mfexp(-seasdur(s) * (Z_rate(t, p, g, a1) + TG_chron_loss))) * TG_report(f) * mfexp(TG_t * TG_rep_decay(f));
                  }

                  if (docheckup == 1)
                    echoinput << " TG_" << TG << " y_" << y << " s_" << s << " area_" << p << " g_" << g << " GP3_" << GP3(g) << " f_" << f << " a1_" << a1 << " Sel_" << Sel_for_tag(t, f, g, a1) << " TG_alive_" << TG_alive(p, g) << " TG_obs_" << TG_recap_obs(TG, TG_t, f) << " TG_exp_" << TG_recap_exp(TG, TG_t, f) << endl;
                } // end fleet loop for recaptures
              TG_alive(p, g) *= mfexp(-seasdur(s) * (Z_rate(t, p, g, a1) + TG_chron_loss));
            } // end morph loop
        } // end area loop

        if (Hermaphro_Option != 0)
        {
          if (Hermaphro_seas == -1 || Hermaphro_seas == s)
          {
            k = gmorph / 2;
            for (p = 1; p <= pop; p++) //   area
              for (g = 1; g <= k; g++) //  loop females
                if (use_morph(g) > 0)
                {
                  if (Hermaphro_Option == 1)
                  {
                    TG_alive(p, g + k) += TG_alive(p, g) * Hermaphro_val(GP4(g), a1); // increment males with females
                    TG_alive(p, g) *= (1. - Hermaphro_val(GP4(g), a1)); // decrement females
                  }
                  else if (Hermaphro_Option == -1)
                  {
                    TG_alive(p, g) += TG_alive(p, g + k) * Hermaphro_val(GP4(g + k), a1); // increment females with males
                    TG_alive(p, g + k) *= (1. - Hermaphro_val(GP4(g + k), a1)); // decrement males
                  }
                }
          }
        }

        if (do_migration > 0) //  movement between areas of tags
        {
          TG_alive_temp = TG_alive;
          TG_alive = 0.0;
          for (g = 1; g <= gmorph; g++)
            if (use_morph(g) > 0)
            {
              for (p = 1; p <= pop; p++) //   source population
                for (p2 = 1; p2 <= pop; p2++) //  destination population
                {
                  k = move_pattern(s, GP4(g), p, p2);
                  if (k > 0)
                    TG_alive(p2, g) += TG_alive_temp(p, g) * migrrate(y, k, a1);
                }
            }
          if (docheckup == 1)
            echoinput << " Tag_alive after survival and movement " << endl
                      << TG_alive << endl;
        }
        t++; //  increment seasonal time counter
        if (TG_t < TG_endtime(TG))
          TG_t++;
        if (s == nseas && a1 < nages)
          a1++;
      } // end seasons
      firstseas = 1; // so start with season 1 in year following the tag release
    } // end years
  } //  end loop of tag groups
  } // end having tag groups

